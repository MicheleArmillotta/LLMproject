[
  {
    "function_name": "virVBoxSnapshotConfHardDiskPtrByLocation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "1528-1540",
    "snippet": "virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskPtrByLocation(virVBoxSnapshotConfMachinePtr machine,\n                                         const char *location)\n{\n    int it = 0;\n    virVBoxSnapshotConfHardDiskPtr disk = NULL;\n    for (it = 0; it < machine->mediaRegistry->ndisks; it++) {\n        disk = virVBoxSnapshotConfHardDiskByLocation(machine->mediaRegistry->disks[it], location);\n        if (disk != NULL)\n            break;\n    }\n    return disk;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfHardDiskByLocation",
          "args": [
            "machine->mediaRegistry->disks[it]",
            "location"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfHardDiskByLocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "310-324",
          "snippet": "static virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskByLocation(virVBoxSnapshotConfHardDiskPtr disk,\n                                      const char *parentLocation)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr ret = NULL;\n    if (STREQ(disk->location, parentLocation))\n        return disk;\n    for (i = 0; i < disk->nchildren; i++) {\n        ret = virVBoxSnapshotConfHardDiskByLocation(disk->children[i], parentLocation);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskByLocation(virVBoxSnapshotConfHardDiskPtr disk,\n                                      const char *parentLocation)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr ret = NULL;\n    if (STREQ(disk->location, parentLocation))\n        return disk;\n    for (i = 0; i < disk->nchildren; i++) {\n        ret = virVBoxSnapshotConfHardDiskByLocation(disk->children[i], parentLocation);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvirVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskPtrByLocation(virVBoxSnapshotConfMachinePtr machine,\n                                         const char *location)\n{\n    int it = 0;\n    virVBoxSnapshotConfHardDiskPtr disk = NULL;\n    for (it = 0; it < machine->mediaRegistry->ndisks; it++) {\n        disk = virVBoxSnapshotConfHardDiskByLocation(machine->mediaRegistry->disks[it], location);\n        if (disk != NULL)\n            break;\n    }\n    return disk;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfDiskIsInMediaRegistry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "1483-1523",
    "snippet": "int\nvirVBoxSnapshotConfDiskIsInMediaRegistry(virVBoxSnapshotConfMachinePtr machine,\n                                         const char *location)\n{\n    int ret = -1;\n    size_t i = 0;\n    size_t j = 0;\n    size_t tempSize = 0;\n    size_t diskSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *tempList = NULL;\n    virVBoxSnapshotConfHardDiskPtr *diskList = NULL;\n\n    if (VIR_ALLOC_N(diskList, 0) < 0)\n        return -1;\n\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        tempSize = virVBoxSnapshotConfAllChildren(machine->mediaRegistry->disks[i], &tempList);\n        if (VIR_EXPAND_N(diskList, diskSize, tempSize) < 0)\n            goto cleanup;\n\n        for (j = 0; j < tempSize; j++)\n            diskList[diskSize - tempSize + j] = tempList[j];\n\n        VIR_FREE(tempList);\n    }\n\n    for (i = 0; i < diskSize; i++) {\n        if (STREQ(diskList[i]->location, location)) {\n            ret = 1;\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(diskList);\n    VIR_FREE(tempList);\n\n    return ret;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tempList"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "diskList"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "diskList[i]->location",
            "location"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tempList"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "diskList",
            "diskSize",
            "tempSize"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfAllChildren",
          "args": [
            "machine->mediaRegistry->disks[i]",
            "&tempList"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfAllChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "461-497",
          "snippet": "static size_t\nvirVBoxSnapshotConfAllChildren(virVBoxSnapshotConfHardDiskPtr disk,\n                               virVBoxSnapshotConfHardDiskPtr **list)\n{\n    size_t returnSize = 0;\n    size_t tempSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *ret = NULL;\n    virVBoxSnapshotConfHardDiskPtr *tempList = NULL;\n    size_t i = 0;\n    size_t j = 0;\n\n    if (VIR_ALLOC_N(ret, 0) < 0)\n        return 0;\n\n    for (i = 0; i < disk->nchildren; i++) {\n        tempSize = virVBoxSnapshotConfAllChildren(disk->children[i], &tempList);\n        if (VIR_EXPAND_N(ret, returnSize, tempSize) < 0)\n            goto error;\n\n        for (j = 0; j < tempSize; j++)\n            ret[returnSize - tempSize + j] = tempList[j];\n\n        VIR_FREE(tempList);\n    }\n\n    if (VIR_EXPAND_N(ret, returnSize, 1) < 0)\n        goto error;\n\n    ret[returnSize - 1] = disk;\n    *list = ret;\n    return returnSize;\n\n error:\n    VIR_FREE(tempList);\n    VIR_FREE(ret);\n    return 0;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic size_t\nvirVBoxSnapshotConfAllChildren(virVBoxSnapshotConfHardDiskPtr disk,\n                               virVBoxSnapshotConfHardDiskPtr **list)\n{\n    size_t returnSize = 0;\n    size_t tempSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *ret = NULL;\n    virVBoxSnapshotConfHardDiskPtr *tempList = NULL;\n    size_t i = 0;\n    size_t j = 0;\n\n    if (VIR_ALLOC_N(ret, 0) < 0)\n        return 0;\n\n    for (i = 0; i < disk->nchildren; i++) {\n        tempSize = virVBoxSnapshotConfAllChildren(disk->children[i], &tempList);\n        if (VIR_EXPAND_N(ret, returnSize, tempSize) < 0)\n            goto error;\n\n        for (j = 0; j < tempSize; j++)\n            ret[returnSize - tempSize + j] = tempList[j];\n\n        VIR_FREE(tempList);\n    }\n\n    if (VIR_EXPAND_N(ret, returnSize, 1) < 0)\n        goto error;\n\n    ret[returnSize - 1] = disk;\n    *list = ret;\n    return returnSize;\n\n error:\n    VIR_FREE(tempList);\n    VIR_FREE(ret);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "diskList",
            "0"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfDiskIsInMediaRegistry(virVBoxSnapshotConfMachinePtr machine,\n                                         const char *location)\n{\n    int ret = -1;\n    size_t i = 0;\n    size_t j = 0;\n    size_t tempSize = 0;\n    size_t diskSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *tempList = NULL;\n    virVBoxSnapshotConfHardDiskPtr *diskList = NULL;\n\n    if (VIR_ALLOC_N(diskList, 0) < 0)\n        return -1;\n\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        tempSize = virVBoxSnapshotConfAllChildren(machine->mediaRegistry->disks[i], &tempList);\n        if (VIR_EXPAND_N(diskList, diskSize, tempSize) < 0)\n            goto cleanup;\n\n        for (j = 0; j < tempSize; j++)\n            diskList[diskSize - tempSize + j] = tempList[j];\n\n        VIR_FREE(tempList);\n    }\n\n    for (i = 0; i < diskSize; i++) {\n        if (STREQ(diskList[i]->location, location)) {\n            ret = 1;\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(diskList);\n    VIR_FREE(tempList);\n\n    return ret;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfRemoveFakeDisks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "1432-1475",
    "snippet": "int\nvirVBoxSnapshotConfRemoveFakeDisks(virVBoxSnapshotConfMachinePtr machine)\n{\n    int ret = -1;\n    size_t i = 0;\n    size_t j = 0;\n    size_t tempSize = 0;\n    size_t diskSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *tempList = NULL;\n    virVBoxSnapshotConfHardDiskPtr *diskList = NULL;\n\n    if (VIR_ALLOC_N(diskList, 0) < 0)\n        return -1;\n\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        tempSize = virVBoxSnapshotConfAllChildren(machine->mediaRegistry->disks[i], &tempList);\n        if (VIR_EXPAND_N(diskList, diskSize, tempSize) < 0)\n            goto cleanup;\n\n        for (j = 0; j < tempSize; j++)\n            diskList[diskSize - tempSize + j] = tempList[j];\n\n        VIR_FREE(tempList);\n    }\n\n    for (i = 0; i < diskSize; i++) {\n        if (strstr(diskList[i]->location, \"fake\") != NULL) {\n            if (virVBoxSnapshotConfRemoveHardDisk(machine->mediaRegistry, diskList[i]->uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to remove hard disk %s from media registry\"),\n                               diskList[i]->location);\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(diskList);\n    VIR_FREE(tempList);\n\n    return ret;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tempList"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "diskList"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to remove hard disk %s from media registry\")",
            "diskList[i]->location"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to remove hard disk %s from media registry\""
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfRemoveHardDisk",
          "args": [
            "machine->mediaRegistry",
            "diskList[i]->uuid"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfRemoveHardDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "912-961",
          "snippet": "int\nvirVBoxSnapshotConfRemoveHardDisk(virVBoxSnapshotConfMediaRegistryPtr mediaRegistry,\n                                  const char *uuid)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    virVBoxSnapshotConfHardDiskPtr parentHardDisk = NULL;\n    if (mediaRegistry == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Media registry is null\"));\n        return -1;\n    }\n    if (uuid == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Uuid is null\"));\n        return -1;\n    }\n\n    for (i = 0; i < mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskById(mediaRegistry->disks[i], uuid);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find the hard disk with uuid %s\"), uuid);\n        return -1;\n    }\n    if (hardDisk->parent == NULL) {\n        /* it means that the hard disk is in 'root' */\n        for (i = 0; i < mediaRegistry->ndisks; i++) {\n            if (hardDisk == mediaRegistry->disks[i])\n                break;\n        }\n        if (VIR_DELETE_ELEMENT(mediaRegistry->disks, i, mediaRegistry->ndisks) < 0)\n            return -1;\n\n        return 0;\n    }\n\n    parentHardDisk = hardDisk->parent;\n    i = 0;\n    while (i < parentHardDisk->nchildren && parentHardDisk->children[i] != hardDisk)\n        ++i;\n    hardDisk->parent = NULL;\n    if (VIR_DELETE_ELEMENT(parentHardDisk->children, i, parentHardDisk->nchildren) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfRemoveHardDisk(virVBoxSnapshotConfMediaRegistryPtr mediaRegistry,\n                                  const char *uuid)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    virVBoxSnapshotConfHardDiskPtr parentHardDisk = NULL;\n    if (mediaRegistry == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Media registry is null\"));\n        return -1;\n    }\n    if (uuid == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Uuid is null\"));\n        return -1;\n    }\n\n    for (i = 0; i < mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskById(mediaRegistry->disks[i], uuid);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find the hard disk with uuid %s\"), uuid);\n        return -1;\n    }\n    if (hardDisk->parent == NULL) {\n        /* it means that the hard disk is in 'root' */\n        for (i = 0; i < mediaRegistry->ndisks; i++) {\n            if (hardDisk == mediaRegistry->disks[i])\n                break;\n        }\n        if (VIR_DELETE_ELEMENT(mediaRegistry->disks, i, mediaRegistry->ndisks) < 0)\n            return -1;\n\n        return 0;\n    }\n\n    parentHardDisk = hardDisk->parent;\n    i = 0;\n    while (i < parentHardDisk->nchildren && parentHardDisk->children[i] != hardDisk)\n        ++i;\n    hardDisk->parent = NULL;\n    if (VIR_DELETE_ELEMENT(parentHardDisk->children, i, parentHardDisk->nchildren) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "diskList[i]->location",
            "\"fake\""
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tempList"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "diskList",
            "diskSize",
            "tempSize"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfAllChildren",
          "args": [
            "machine->mediaRegistry->disks[i]",
            "&tempList"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfAllChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "461-497",
          "snippet": "static size_t\nvirVBoxSnapshotConfAllChildren(virVBoxSnapshotConfHardDiskPtr disk,\n                               virVBoxSnapshotConfHardDiskPtr **list)\n{\n    size_t returnSize = 0;\n    size_t tempSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *ret = NULL;\n    virVBoxSnapshotConfHardDiskPtr *tempList = NULL;\n    size_t i = 0;\n    size_t j = 0;\n\n    if (VIR_ALLOC_N(ret, 0) < 0)\n        return 0;\n\n    for (i = 0; i < disk->nchildren; i++) {\n        tempSize = virVBoxSnapshotConfAllChildren(disk->children[i], &tempList);\n        if (VIR_EXPAND_N(ret, returnSize, tempSize) < 0)\n            goto error;\n\n        for (j = 0; j < tempSize; j++)\n            ret[returnSize - tempSize + j] = tempList[j];\n\n        VIR_FREE(tempList);\n    }\n\n    if (VIR_EXPAND_N(ret, returnSize, 1) < 0)\n        goto error;\n\n    ret[returnSize - 1] = disk;\n    *list = ret;\n    return returnSize;\n\n error:\n    VIR_FREE(tempList);\n    VIR_FREE(ret);\n    return 0;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic size_t\nvirVBoxSnapshotConfAllChildren(virVBoxSnapshotConfHardDiskPtr disk,\n                               virVBoxSnapshotConfHardDiskPtr **list)\n{\n    size_t returnSize = 0;\n    size_t tempSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *ret = NULL;\n    virVBoxSnapshotConfHardDiskPtr *tempList = NULL;\n    size_t i = 0;\n    size_t j = 0;\n\n    if (VIR_ALLOC_N(ret, 0) < 0)\n        return 0;\n\n    for (i = 0; i < disk->nchildren; i++) {\n        tempSize = virVBoxSnapshotConfAllChildren(disk->children[i], &tempList);\n        if (VIR_EXPAND_N(ret, returnSize, tempSize) < 0)\n            goto error;\n\n        for (j = 0; j < tempSize; j++)\n            ret[returnSize - tempSize + j] = tempList[j];\n\n        VIR_FREE(tempList);\n    }\n\n    if (VIR_EXPAND_N(ret, returnSize, 1) < 0)\n        goto error;\n\n    ret[returnSize - 1] = disk;\n    *list = ret;\n    return returnSize;\n\n error:\n    VIR_FREE(tempList);\n    VIR_FREE(ret);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "diskList",
            "0"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfRemoveFakeDisks(virVBoxSnapshotConfMachinePtr machine)\n{\n    int ret = -1;\n    size_t i = 0;\n    size_t j = 0;\n    size_t tempSize = 0;\n    size_t diskSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *tempList = NULL;\n    virVBoxSnapshotConfHardDiskPtr *diskList = NULL;\n\n    if (VIR_ALLOC_N(diskList, 0) < 0)\n        return -1;\n\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        tempSize = virVBoxSnapshotConfAllChildren(machine->mediaRegistry->disks[i], &tempList);\n        if (VIR_EXPAND_N(diskList, diskSize, tempSize) < 0)\n            goto cleanup;\n\n        for (j = 0; j < tempSize; j++)\n            diskList[diskSize - tempSize + j] = tempList[j];\n\n        VIR_FREE(tempList);\n    }\n\n    for (i = 0; i < diskSize; i++) {\n        if (strstr(diskList[i]->location, \"fake\") != NULL) {\n            if (virVBoxSnapshotConfRemoveHardDisk(machine->mediaRegistry, diskList[i]->uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to remove hard disk %s from media registry\"),\n                               diskList[i]->location);\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(diskList);\n    VIR_FREE(tempList);\n\n    return ret;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfDiskListToOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "1395-1425",
    "snippet": "size_t\nvirVBoxSnapshotConfDiskListToOpen(virVBoxSnapshotConfMachinePtr machine,\n                                  virVBoxSnapshotConfHardDiskPtr **hardDiskToOpen,\n                                  const char *location)\n{\n    size_t i = 0;\n    size_t returnSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *ret = NULL;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskByLocation(machine->mediaRegistry->disks[i], location);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL)\n        return 0;\n    if (VIR_ALLOC_N(ret, 1) < 0)\n        return 0;\n\n    returnSize = 1;\n    ret[returnSize - 1] = hardDisk;\n\n    while (hardDisk->parent != NULL) {\n        if (VIR_EXPAND_N(ret, returnSize, 1) < 0)\n            return 0;\n        ret[returnSize - 1] = hardDisk->parent;\n        hardDisk = hardDisk->parent;\n    }\n    *hardDiskToOpen = ret;\n    return returnSize;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "ret",
            "returnSize",
            "1"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "ret",
            "1"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfHardDiskByLocation",
          "args": [
            "machine->mediaRegistry->disks[i]",
            "location"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfHardDiskByLocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "310-324",
          "snippet": "static virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskByLocation(virVBoxSnapshotConfHardDiskPtr disk,\n                                      const char *parentLocation)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr ret = NULL;\n    if (STREQ(disk->location, parentLocation))\n        return disk;\n    for (i = 0; i < disk->nchildren; i++) {\n        ret = virVBoxSnapshotConfHardDiskByLocation(disk->children[i], parentLocation);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskByLocation(virVBoxSnapshotConfHardDiskPtr disk,\n                                      const char *parentLocation)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr ret = NULL;\n    if (STREQ(disk->location, parentLocation))\n        return disk;\n    for (i = 0; i < disk->nchildren; i++) {\n        ret = virVBoxSnapshotConfHardDiskByLocation(disk->children[i], parentLocation);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nsize_t\nvirVBoxSnapshotConfDiskListToOpen(virVBoxSnapshotConfMachinePtr machine,\n                                  virVBoxSnapshotConfHardDiskPtr **hardDiskToOpen,\n                                  const char *location)\n{\n    size_t i = 0;\n    size_t returnSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *ret = NULL;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskByLocation(machine->mediaRegistry->disks[i], location);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL)\n        return 0;\n    if (VIR_ALLOC_N(ret, 1) < 0)\n        return 0;\n\n    returnSize = 1;\n    ret[returnSize - 1] = hardDisk;\n\n    while (hardDisk->parent != NULL) {\n        if (VIR_EXPAND_N(ret, returnSize, 1) < 0)\n            return 0;\n        ret[returnSize - 1] = hardDisk->parent;\n        hardDisk = hardDisk->parent;\n    }\n    *hardDiskToOpen = ret;\n    return returnSize;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfHardDiskUuidByLocation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "1374-1388",
    "snippet": "const char *\nvirVBoxSnapshotConfHardDiskUuidByLocation(virVBoxSnapshotConfMachinePtr machine,\n                                          const char *location)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskByLocation(machine->mediaRegistry->disks[i], location);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL)\n        return NULL;\n    return hardDisk->uuid;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfHardDiskByLocation",
          "args": [
            "machine->mediaRegistry->disks[i]",
            "location"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfHardDiskByLocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "310-324",
          "snippet": "static virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskByLocation(virVBoxSnapshotConfHardDiskPtr disk,\n                                      const char *parentLocation)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr ret = NULL;\n    if (STREQ(disk->location, parentLocation))\n        return disk;\n    for (i = 0; i < disk->nchildren; i++) {\n        ret = virVBoxSnapshotConfHardDiskByLocation(disk->children[i], parentLocation);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskByLocation(virVBoxSnapshotConfHardDiskPtr disk,\n                                      const char *parentLocation)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr ret = NULL;\n    if (STREQ(disk->location, parentLocation))\n        return disk;\n    for (i = 0; i < disk->nchildren; i++) {\n        ret = virVBoxSnapshotConfHardDiskByLocation(disk->children[i], parentLocation);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nconst char *\nvirVBoxSnapshotConfHardDiskUuidByLocation(virVBoxSnapshotConfMachinePtr machine,\n                                          const char *location)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskByLocation(machine->mediaRegistry->disks[i], location);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL)\n        return NULL;\n    return hardDisk->uuid;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfGetRODisksPathsFromLibvirtXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "1314-1368",
    "snippet": "int\nvirVBoxSnapshotConfGetRODisksPathsFromLibvirtXML(const char *filePath,\n                                                 char ***roDisksPath)\n{\n    int result = -1;\n    size_t i = 0;\n    char **ret = NULL;\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr xPathContext = NULL;\n    xmlNodePtr *nodes = NULL;\n    int nodeSize = 0;\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"filePath is null\"));\n        goto cleanup;\n    }\n    xml = virXMLParse(filePath, NULL, NULL);\n    if (xml == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to parse the xml\"));\n        goto cleanup;\n    }\n\n    if (!(xPathContext = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    xPathContext->node = xmlDocGetRootElement(xml);\n    if ((nodeSize = virXPathNodeSet(\"/domainsnapshot/domain/devices/disk\",\n                                    xPathContext,\n                                    &nodes)) < 0)\n        goto cleanup;\n    if (VIR_ALLOC_N(ret, nodeSize) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nodeSize; i++) {\n        xmlNodePtr node = nodes[i];\n        xPathContext->node = node;\n        xmlNodePtr sourceNode = virXPathNode(\"./source\", xPathContext);\n        if (sourceNode)\n            ret[i] = virXMLPropString(sourceNode, \"file\");\n    }\n    result = 0;\n\n cleanup:\n    xmlFreeDoc(xml);\n    xmlXPathFreeContext(xPathContext);\n    if (result < 0) {\n        virStringListFree(ret);\n        nodeSize = -1;\n    } else {\n        *roDisksPath = ret;\n    }\n    VIR_FREE(nodes);\n    return nodeSize;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "ret"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "xPathContext"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "xml"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "sourceNode",
            "\"file\""
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./source\"",
            "xPathContext"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "ret",
            "nodeSize"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"/domainsnapshot/domain/devices/disk\"",
            "xPathContext",
            "&nodes"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlDocGetRootElement",
          "args": [
            "xml"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLXPathContextNew",
          "args": [
            "xml"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLXPathContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "48-59",
          "snippet": "xmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Unable to parse the xml\")"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to parse the xml\""
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLParse",
          "args": [
            "filePath",
            "NULL",
            "NULL"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"filePath is null\")"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfGetRODisksPathsFromLibvirtXML(const char *filePath,\n                                                 char ***roDisksPath)\n{\n    int result = -1;\n    size_t i = 0;\n    char **ret = NULL;\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr xPathContext = NULL;\n    xmlNodePtr *nodes = NULL;\n    int nodeSize = 0;\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"filePath is null\"));\n        goto cleanup;\n    }\n    xml = virXMLParse(filePath, NULL, NULL);\n    if (xml == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to parse the xml\"));\n        goto cleanup;\n    }\n\n    if (!(xPathContext = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    xPathContext->node = xmlDocGetRootElement(xml);\n    if ((nodeSize = virXPathNodeSet(\"/domainsnapshot/domain/devices/disk\",\n                                    xPathContext,\n                                    &nodes)) < 0)\n        goto cleanup;\n    if (VIR_ALLOC_N(ret, nodeSize) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nodeSize; i++) {\n        xmlNodePtr node = nodes[i];\n        xPathContext->node = node;\n        xmlNodePtr sourceNode = virXPathNode(\"./source\", xPathContext);\n        if (sourceNode)\n            ret[i] = virXMLPropString(sourceNode, \"file\");\n    }\n    result = 0;\n\n cleanup:\n    xmlFreeDoc(xml);\n    xmlXPathFreeContext(xPathContext);\n    if (result < 0) {\n        virStringListFree(ret);\n        nodeSize = -1;\n    } else {\n        *roDisksPath = ret;\n    }\n    VIR_FREE(nodes);\n    return nodeSize;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfGetRWDisksPathsFromLibvirtXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "1252-1307",
    "snippet": "int\nvirVBoxSnapshotConfGetRWDisksPathsFromLibvirtXML(const char *filePath,\n                                                 char ***rwDisksPath)\n{\n    int result = -1;\n    size_t i = 0;\n    char **ret = NULL;\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr xPathContext = NULL;\n    xmlNodePtr *nodes = NULL;\n    int nodeSize = 0;\n    *rwDisksPath = NULL;\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"filePath is null\"));\n        goto cleanup;\n    }\n    xml = virXMLParse(filePath, NULL, NULL);\n    if (xml == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to parse the xml\"));\n        goto cleanup;\n    }\n\n    if (!(xPathContext = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    xPathContext->node = xmlDocGetRootElement(xml);\n    if ((nodeSize = virXPathNodeSet(\"/domainsnapshot/disks/disk\",\n                                    xPathContext, &nodes)) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC_N(ret, nodeSize) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nodeSize; i++) {\n        xmlNodePtr node = nodes[i];\n        xPathContext->node = node;\n        xmlNodePtr sourceNode = virXPathNode(\"./source\", xPathContext);\n        if (sourceNode)\n            ret[i] = virXMLPropString(sourceNode, \"file\");\n    }\n    result = 0;\n\n cleanup:\n    xmlFreeDoc(xml);\n    xmlXPathFreeContext(xPathContext);\n    if (result < 0) {\n        virStringListFree(ret);\n        nodeSize = -1;\n    } else {\n        *rwDisksPath = ret;\n    }\n    VIR_FREE(nodes);\n    return nodeSize;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "ret"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "xPathContext"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "xml"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "sourceNode",
            "\"file\""
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./source\"",
            "xPathContext"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "ret",
            "nodeSize"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"/domainsnapshot/disks/disk\"",
            "xPathContext",
            "&nodes"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlDocGetRootElement",
          "args": [
            "xml"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLXPathContextNew",
          "args": [
            "xml"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLXPathContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "48-59",
          "snippet": "xmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Unable to parse the xml\")"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to parse the xml\""
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLParse",
          "args": [
            "filePath",
            "NULL",
            "NULL"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"filePath is null\")"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfGetRWDisksPathsFromLibvirtXML(const char *filePath,\n                                                 char ***rwDisksPath)\n{\n    int result = -1;\n    size_t i = 0;\n    char **ret = NULL;\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr xPathContext = NULL;\n    xmlNodePtr *nodes = NULL;\n    int nodeSize = 0;\n    *rwDisksPath = NULL;\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"filePath is null\"));\n        goto cleanup;\n    }\n    xml = virXMLParse(filePath, NULL, NULL);\n    if (xml == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to parse the xml\"));\n        goto cleanup;\n    }\n\n    if (!(xPathContext = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    xPathContext->node = xmlDocGetRootElement(xml);\n    if ((nodeSize = virXPathNodeSet(\"/domainsnapshot/disks/disk\",\n                                    xPathContext, &nodes)) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC_N(ret, nodeSize) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nodeSize; i++) {\n        xmlNodePtr node = nodes[i];\n        xPathContext->node = node;\n        xmlNodePtr sourceNode = virXPathNode(\"./source\", xPathContext);\n        if (sourceNode)\n            ret[i] = virXMLPropString(sourceNode, \"file\");\n    }\n    result = 0;\n\n cleanup:\n    xmlFreeDoc(xml);\n    xmlXPathFreeContext(xPathContext);\n    if (result < 0) {\n        virStringListFree(ret);\n        nodeSize = -1;\n    } else {\n        *rwDisksPath = ret;\n    }\n    VIR_FREE(nodes);\n    return nodeSize;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfIsCurrentSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "1223-1245",
    "snippet": "int\nvirVBoxSnapshotConfIsCurrentSnapshot(virVBoxSnapshotConfMachinePtr machine,\n                                     const char *snapshotName)\n{\n    virVBoxSnapshotConfSnapshotPtr snapshot = NULL;\n    if (machine == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Machine is null\"));\n        return 0;\n    }\n    if (snapshotName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"snapshotName is null\"));\n        return 0;\n    }\n    snapshot = virVBoxSnapshotConfSnapshotByName(machine->snapshot, snapshotName);\n    if (snapshot == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Unable to find the snapshot %s\"), snapshotName);\n        return 0;\n    }\n    return STREQ(snapshot->uuid, machine->currentSnapshot);\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "snapshot->uuid",
            "machine->currentSnapshot"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN_SNAPSHOT",
            "_(\"Unable to find the snapshot %s\")",
            "snapshotName"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to find the snapshot %s\""
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfSnapshotByName",
          "args": [
            "machine->snapshot",
            "snapshotName"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfSnapshotByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "278-292",
          "snippet": "virVBoxSnapshotConfSnapshotPtr\nvirVBoxSnapshotConfSnapshotByName(virVBoxSnapshotConfSnapshotPtr snapshot,\n                                  const char *snapshotName)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfSnapshotPtr ret = NULL;\n    if (STREQ(snapshot->name, snapshotName))\n        return snapshot;\n    for (i = 0; i < snapshot->nchildren; i++) {\n        ret = virVBoxSnapshotConfSnapshotByName(snapshot->children[i], snapshotName);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvirVBoxSnapshotConfSnapshotPtr\nvirVBoxSnapshotConfSnapshotByName(virVBoxSnapshotConfSnapshotPtr snapshot,\n                                  const char *snapshotName)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfSnapshotPtr ret = NULL;\n    if (STREQ(snapshot->name, snapshotName))\n        return snapshot;\n    for (i = 0; i < snapshot->nchildren; i++) {\n        ret = virVBoxSnapshotConfSnapshotByName(snapshot->children[i], snapshotName);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"snapshotName is null\")"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Machine is null\")"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfIsCurrentSnapshot(virVBoxSnapshotConfMachinePtr machine,\n                                     const char *snapshotName)\n{\n    virVBoxSnapshotConfSnapshotPtr snapshot = NULL;\n    if (machine == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Machine is null\"));\n        return 0;\n    }\n    if (snapshotName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"snapshotName is null\"));\n        return 0;\n    }\n    snapshot = virVBoxSnapshotConfSnapshotByName(machine->snapshot, snapshotName);\n    if (snapshot == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Unable to find the snapshot %s\"), snapshotName);\n        return 0;\n    }\n    return STREQ(snapshot->uuid, machine->currentSnapshot);\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfSaveVboxFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "968-1217",
    "snippet": "int\nvirVBoxSnapshotConfSaveVboxFile(virVBoxSnapshotConfMachinePtr machine,\n                                const char *filePath)\n{\n    int ret = -1;\n    size_t i = 0;\n    xmlDocPtr xml = NULL;\n    xmlNodePtr mediaRegistryNode = NULL;\n    xmlNodePtr snapshotNode = NULL;\n    xmlNodePtr machineNode = NULL;\n    xmlNodePtr hardDisksNode = NULL;\n    xmlNodePtr cur = NULL;\n    xmlParserErrors parseError = XML_ERR_OK;\n    char *currentSnapshot = NULL;\n    char *timeStamp = NULL;\n\n    char **firstRegex = NULL;\n    int firstRegexResult = 0;\n    char **secondRegex = NULL;\n    int secondRegexResult = 0;\n\n    if (machine == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Machine is null\"));\n        goto cleanup;\n    }\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Filepath is null\"));\n        goto cleanup;\n    }\n    xml = xmlNewDoc(BAD_CAST \"1.0\");\n    if (!xml) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    cur = xmlNewNode(NULL, BAD_CAST \"VirtualBox\");\n    if (!cur) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (!xmlNewProp(cur, BAD_CAST \"version\", BAD_CAST \"1.12-linux\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (xmlNewProp(cur,\n                   BAD_CAST \"xmlns\",\n                   BAD_CAST \"http://www.innotek.de/VirtualBox-settings\") == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n\n    xmlDocSetRootElement(xml, cur);\n\n    cur = xmlNewDocComment(xml,\n                           BAD_CAST \"WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE\\n\"\n                           \"OVERWRITTEN AND LOST.\\n\"\n                           \"Changes to this xml configuration should be made using Virtualbox\\n\"\n                           \"or other application using the libvirt API\");\n    if (!cur) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (!xmlAddPrevSibling(xmlDocGetRootElement(xml), cur)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlAddPrevSibling\"));\n        goto cleanup;\n    }\n\n    machineNode = xmlNewNode(NULL, BAD_CAST \"Machine\");\n    if (!machineNode) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (!xmlNewProp(machineNode, BAD_CAST \"uuid\", BAD_CAST machine->uuid)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"name\", BAD_CAST machine->name)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n\n    if (machine->currentSnapshot != NULL) {\n        currentSnapshot = g_strdup_printf(\"{%s}\", machine->currentSnapshot);\n        if (!xmlNewProp(machineNode, BAD_CAST \"currentSnapshot\", BAD_CAST currentSnapshot)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Error in xmlNewProp\"));\n            goto cleanup;\n        }\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"snapshotFolder\", BAD_CAST machine->snapshotFolder)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"currentStateModified\",\n               BAD_CAST(machine->currentStateModified == 0 ? \"false\" : \"true\"))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"OSType\", BAD_CAST \"Other\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n\n    firstRegexResult = virStringSearch(machine->lastStateChange,\n                                       \"([0-9]{4}-[0-9]{2}-[0-9]{2})\",\n                                       1,\n                                       &firstRegex);\n    secondRegexResult = virStringSearch(machine->lastStateChange,\n                                        \"([0-9]{2}:[0-9]{2}:[0-9]{2})\",\n                                        1,\n                                        &secondRegex);\n    if (firstRegexResult < 1)\n        goto cleanup;\n    if (secondRegexResult < 1)\n        goto cleanup;\n\n    timeStamp = g_strdup_printf(\"%sT%sZ\", firstRegex[0], secondRegex[0]);\n    if (!xmlNewProp(machineNode, BAD_CAST \"lastStateChange\", BAD_CAST timeStamp)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    xmlAddChild(xmlDocGetRootElement(xml), machineNode);\n\n    mediaRegistryNode = xmlNewNode(NULL, BAD_CAST \"MediaRegistry\");\n    if (!mediaRegistryNode) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    xmlAddChild(machineNode, mediaRegistryNode);\n    for (i = 0; i < machine->mediaRegistry->notherMedia; i++) {\n        parseError = xmlParseInNodeContext(mediaRegistryNode,\n                              machine->mediaRegistry->otherMedia[i],\n                              (int)strlen(machine->mediaRegistry->otherMedia[i]),\n                              0,\n                              &cur);\n        if (parseError != XML_ERR_OK) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Unable to add media registry other media\"));\n            goto cleanup;\n        }\n        xmlAddChild(mediaRegistryNode, cur);\n    }\n    hardDisksNode = xmlNewNode(NULL, BAD_CAST \"HardDisks\");\n    if (!hardDisksNode) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        xmlNodePtr child = virVBoxSnapshotConfCreateHardDiskNode(machine->mediaRegistry->disks[i]);\n        if (child != NULL)\n            xmlAddChild(hardDisksNode, child);\n    }\n    xmlAddChild(mediaRegistryNode, hardDisksNode);\n\n    parseError = xmlParseInNodeContext(machineNode,\n                                       machine->hardware,\n                                       (int)strlen(machine->hardware),\n                                       0,\n                                       &cur);\n    if (parseError != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add hardware machine\"));\n        goto cleanup;\n    }\n    xmlAddChild(machineNode, cur);\n\n    if (machine->extraData != NULL) {\n        parseError = xmlParseInNodeContext(xmlDocGetRootElement(xml),\n                                           machine->extraData,\n                                           (int)strlen(machine->extraData),\n                                           0,\n                                           &cur);\n        if (parseError != XML_ERR_OK) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Unable to add extra data\"));\n            goto cleanup;\n        }\n        xmlAddChild(machineNode, cur);\n    }\n\n    parseError = xmlParseInNodeContext(machineNode,\n                                       machine->storageController,\n                                       (int)strlen(machine->storageController),\n                                       0,\n                                       &cur);\n    if (parseError != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add storage controller\"));\n        goto cleanup;\n    }\n    xmlAddChild(machineNode, cur);\n\n    if (machine->snapshot != NULL) {\n        snapshotNode = xmlNewNode(NULL, BAD_CAST \"Snapshot\");\n        xmlAddChild(machineNode, snapshotNode);\n        if (virVBoxSnapshotConfSerializeSnapshot(snapshotNode, machine->snapshot) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Failed to serialize snapshot\"));\n            goto cleanup;\n        }\n    }\n\n    if (xmlSaveFormatFileEnc(filePath, xml, \"ISO-8859-1\", 1) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to save the xml\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(currentSnapshot);\n    VIR_FREE(timeStamp);\n\n    xmlUnlinkNode(hardDisksNode);\n    xmlFreeNode(hardDisksNode);\n\n    xmlUnlinkNode(mediaRegistryNode);\n    xmlFreeNode(mediaRegistryNode);\n\n    xmlUnlinkNode(snapshotNode);\n    xmlFreeNode(snapshotNode);\n\n    xmlUnlinkNode(cur);\n    xmlFreeNode(cur);\n\n    xmlUnlinkNode(machineNode);\n    xmlFreeNode(machineNode);\n\n    xmlFreeDoc(xml);\n\n    virStringListFree(firstRegex);\n    virStringListFree(secondRegex);\n    return ret;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "secondRegex"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "xml"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeNode",
          "args": [
            "machineNode"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlUnlinkNode",
          "args": [
            "machineNode"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeNode",
          "args": [
            "cur"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlUnlinkNode",
          "args": [
            "cur"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeNode",
          "args": [
            "snapshotNode"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlUnlinkNode",
          "args": [
            "snapshotNode"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeNode",
          "args": [
            "mediaRegistryNode"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlUnlinkNode",
          "args": [
            "mediaRegistryNode"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeNode",
          "args": [
            "hardDisksNode"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlUnlinkNode",
          "args": [
            "hardDisksNode"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "timeStamp"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "currentSnapshot"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Unable to save the xml\")"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to save the xml\""
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlSaveFormatFileEnc",
          "args": [
            "filePath",
            "xml",
            "\"ISO-8859-1\"",
            "1"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Failed to serialize snapshot\")"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfSerializeSnapshot",
          "args": [
            "snapshotNode",
            "machine->snapshot"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfSerializeSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "361-459",
          "snippet": "static int\nvirVBoxSnapshotConfSerializeSnapshot(xmlNodePtr node,\n                                     virVBoxSnapshotConfSnapshotPtr snapshot)\n{\n    int result = -1;\n    size_t i = 0;\n    xmlNodePtr descriptionNode = NULL;\n    xmlNodePtr snapshotsNode = NULL;\n    xmlNodePtr hardwareNode = NULL;\n    xmlNodePtr storageControllerNode = NULL;\n    xmlParserErrors parseError = XML_ERR_OK;\n    char *uuid = NULL;\n    char *timeStamp = NULL;\n\n    char **firstRegex = NULL;\n    int firstRegexResult = 0;\n    char **secondRegex = NULL;\n    int secondRegexResult = 0;\n\n    uuid = g_strdup_printf(\"{%s}\", snapshot->uuid);\n\n    if (xmlNewProp(node, BAD_CAST \"uuid\", BAD_CAST uuid) == NULL)\n        goto cleanup;\n    if (xmlNewProp(node, BAD_CAST \"name\", BAD_CAST snapshot->name) == NULL)\n        goto cleanup;\n\n    /* We change the date format from \"yyyy-MM-dd hh:mm:ss.msec+timeZone\"\n     * to \"yyyy-MM-ddThh:mm:ssZ\" */\n    firstRegexResult = virStringSearch(snapshot->timeStamp,\n                                       \"([0-9]{4}-[0-9]{2}-[0-9]{2})\",\n                                       1,\n                                       &firstRegex);\n    secondRegexResult = virStringSearch(snapshot->timeStamp,\n                                        \"([0-9]{2}:[0-9]{2}:[0-9]{2})\",\n                                        1,\n                                        &secondRegex);\n    if (firstRegexResult < 1)\n        goto cleanup;\n    if (secondRegexResult < 1)\n        goto cleanup;\n    timeStamp = g_strdup_printf(\"%sT%sZ\", firstRegex[0], secondRegex[0]);\n\n    if (xmlNewProp(node, BAD_CAST \"timeStamp\", BAD_CAST timeStamp) == NULL)\n        goto cleanup;\n\n    /* node description */\n    if (snapshot->description != NULL) {\n        descriptionNode = xmlNewNode(NULL, BAD_CAST \"Description\");\n        xmlNodeSetContent(descriptionNode, BAD_CAST snapshot->description);\n        xmlAddChild(node, descriptionNode);\n    }\n    /* hardware */\n    parseError = xmlParseInNodeContext(node,\n                                       snapshot->hardware,\n                                       (int)strlen(snapshot->hardware),\n                                       0,\n                                       &hardwareNode);\n    if (parseError != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add the snapshot hardware\"));\n        goto cleanup;\n    }\n    xmlAddChild(node, hardwareNode);\n\n    /* storageController */\n    if (xmlParseInNodeContext(node, snapshot->storageController,\n                              (int)strlen(snapshot->storageController),\n                              0,\n                              &storageControllerNode) != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add the snapshot storageController\"));\n        goto cleanup;\n    }\n    xmlAddChild(node, storageControllerNode);\n\n    if (snapshot->nchildren > 0) {\n        snapshotsNode = xmlNewNode(NULL, BAD_CAST \"Snapshots\");\n        xmlAddChild(node, snapshotsNode);\n        for (i = 0; i < snapshot->nchildren; i++) {\n            xmlNodePtr child = xmlNewNode(NULL, BAD_CAST \"Snapshot\");\n            xmlAddChild(snapshotsNode, child);\n            if (virVBoxSnapshotConfSerializeSnapshot(child, snapshot->children[i]) < 0)\n                goto cleanup;\n        }\n    }\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        xmlFreeNode(descriptionNode);\n        xmlUnlinkNode(snapshotsNode);\n        xmlFreeNode(snapshotsNode);\n    }\n    virStringListFree(firstRegex);\n    virStringListFree(secondRegex);\n    VIR_FREE(uuid);\n    VIR_FREE(timeStamp);\n    return result;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic int\nvirVBoxSnapshotConfSerializeSnapshot(xmlNodePtr node,\n                                     virVBoxSnapshotConfSnapshotPtr snapshot)\n{\n    int result = -1;\n    size_t i = 0;\n    xmlNodePtr descriptionNode = NULL;\n    xmlNodePtr snapshotsNode = NULL;\n    xmlNodePtr hardwareNode = NULL;\n    xmlNodePtr storageControllerNode = NULL;\n    xmlParserErrors parseError = XML_ERR_OK;\n    char *uuid = NULL;\n    char *timeStamp = NULL;\n\n    char **firstRegex = NULL;\n    int firstRegexResult = 0;\n    char **secondRegex = NULL;\n    int secondRegexResult = 0;\n\n    uuid = g_strdup_printf(\"{%s}\", snapshot->uuid);\n\n    if (xmlNewProp(node, BAD_CAST \"uuid\", BAD_CAST uuid) == NULL)\n        goto cleanup;\n    if (xmlNewProp(node, BAD_CAST \"name\", BAD_CAST snapshot->name) == NULL)\n        goto cleanup;\n\n    /* We change the date format from \"yyyy-MM-dd hh:mm:ss.msec+timeZone\"\n     * to \"yyyy-MM-ddThh:mm:ssZ\" */\n    firstRegexResult = virStringSearch(snapshot->timeStamp,\n                                       \"([0-9]{4}-[0-9]{2}-[0-9]{2})\",\n                                       1,\n                                       &firstRegex);\n    secondRegexResult = virStringSearch(snapshot->timeStamp,\n                                        \"([0-9]{2}:[0-9]{2}:[0-9]{2})\",\n                                        1,\n                                        &secondRegex);\n    if (firstRegexResult < 1)\n        goto cleanup;\n    if (secondRegexResult < 1)\n        goto cleanup;\n    timeStamp = g_strdup_printf(\"%sT%sZ\", firstRegex[0], secondRegex[0]);\n\n    if (xmlNewProp(node, BAD_CAST \"timeStamp\", BAD_CAST timeStamp) == NULL)\n        goto cleanup;\n\n    /* node description */\n    if (snapshot->description != NULL) {\n        descriptionNode = xmlNewNode(NULL, BAD_CAST \"Description\");\n        xmlNodeSetContent(descriptionNode, BAD_CAST snapshot->description);\n        xmlAddChild(node, descriptionNode);\n    }\n    /* hardware */\n    parseError = xmlParseInNodeContext(node,\n                                       snapshot->hardware,\n                                       (int)strlen(snapshot->hardware),\n                                       0,\n                                       &hardwareNode);\n    if (parseError != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add the snapshot hardware\"));\n        goto cleanup;\n    }\n    xmlAddChild(node, hardwareNode);\n\n    /* storageController */\n    if (xmlParseInNodeContext(node, snapshot->storageController,\n                              (int)strlen(snapshot->storageController),\n                              0,\n                              &storageControllerNode) != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add the snapshot storageController\"));\n        goto cleanup;\n    }\n    xmlAddChild(node, storageControllerNode);\n\n    if (snapshot->nchildren > 0) {\n        snapshotsNode = xmlNewNode(NULL, BAD_CAST \"Snapshots\");\n        xmlAddChild(node, snapshotsNode);\n        for (i = 0; i < snapshot->nchildren; i++) {\n            xmlNodePtr child = xmlNewNode(NULL, BAD_CAST \"Snapshot\");\n            xmlAddChild(snapshotsNode, child);\n            if (virVBoxSnapshotConfSerializeSnapshot(child, snapshot->children[i]) < 0)\n                goto cleanup;\n        }\n    }\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        xmlFreeNode(descriptionNode);\n        xmlUnlinkNode(snapshotsNode);\n        xmlFreeNode(snapshotsNode);\n    }\n    virStringListFree(firstRegex);\n    virStringListFree(secondRegex);\n    VIR_FREE(uuid);\n    VIR_FREE(timeStamp);\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlAddChild",
          "args": [
            "machineNode",
            "snapshotNode"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewNode",
          "args": [
            "NULL",
            "BAD_CAST \"Snapshot\""
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlAddChild",
          "args": [
            "machineNode",
            "cur"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Unable to add storage controller\")"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlParseInNodeContext",
          "args": [
            "machineNode",
            "machine->storageController",
            "(int)strlen(machine->storageController)",
            "0",
            "&cur"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "machine->storageController"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlAddChild",
          "args": [
            "machineNode",
            "cur"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Unable to add extra data\")"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlParseInNodeContext",
          "args": [
            "xmlDocGetRootElement(xml)",
            "machine->extraData",
            "(int)strlen(machine->extraData)",
            "0",
            "&cur"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "machine->extraData"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlDocGetRootElement",
          "args": [
            "xml"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlAddChild",
          "args": [
            "machineNode",
            "cur"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Unable to add hardware machine\")"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlParseInNodeContext",
          "args": [
            "machineNode",
            "machine->hardware",
            "(int)strlen(machine->hardware)",
            "0",
            "&cur"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "machine->hardware"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlAddChild",
          "args": [
            "mediaRegistryNode",
            "hardDisksNode"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlAddChild",
          "args": [
            "hardDisksNode",
            "child"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfCreateHardDiskNode",
          "args": [
            "machine->mediaRegistry->disks[i]"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfCreateHardDiskNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "326-359",
          "snippet": "static xmlNodePtr\nvirVBoxSnapshotConfCreateHardDiskNode(virVBoxSnapshotConfHardDiskPtr hardDisk)\n{\n    int result = -1;\n    size_t i = 0;\n    char *uuid = NULL;\n    xmlNodePtr ret = xmlNewNode(NULL, BAD_CAST \"HardDisk\");\n    uuid = g_strdup_printf(\"{%s}\", hardDisk->uuid);\n\n    if (xmlNewProp(ret, BAD_CAST \"uuid\", BAD_CAST uuid) == NULL)\n        goto cleanup;\n    if (xmlNewProp(ret, BAD_CAST \"location\", BAD_CAST hardDisk->location) == NULL)\n        goto cleanup;\n    if (xmlNewProp(ret, BAD_CAST \"format\", BAD_CAST hardDisk->format) == NULL)\n        goto cleanup;\n    if (hardDisk->type != NULL && xmlNewProp(ret, BAD_CAST \"type\", BAD_CAST hardDisk->type) == NULL)\n        goto cleanup;\n\n    for (i = 0; i < hardDisk->nchildren; i++) {\n        xmlNodePtr child = virVBoxSnapshotConfCreateHardDiskNode(hardDisk->children[i]);\n        if (child != NULL)\n            xmlAddChild(ret, child);\n    }\n\n    result = 0;\n cleanup:\n    if (result < 0) {\n        xmlUnlinkNode(ret);\n        xmlFreeNode(ret);\n        ret = NULL;\n    }\n    VIR_FREE(uuid);\n    return ret;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic xmlNodePtr\nvirVBoxSnapshotConfCreateHardDiskNode(virVBoxSnapshotConfHardDiskPtr hardDisk)\n{\n    int result = -1;\n    size_t i = 0;\n    char *uuid = NULL;\n    xmlNodePtr ret = xmlNewNode(NULL, BAD_CAST \"HardDisk\");\n    uuid = g_strdup_printf(\"{%s}\", hardDisk->uuid);\n\n    if (xmlNewProp(ret, BAD_CAST \"uuid\", BAD_CAST uuid) == NULL)\n        goto cleanup;\n    if (xmlNewProp(ret, BAD_CAST \"location\", BAD_CAST hardDisk->location) == NULL)\n        goto cleanup;\n    if (xmlNewProp(ret, BAD_CAST \"format\", BAD_CAST hardDisk->format) == NULL)\n        goto cleanup;\n    if (hardDisk->type != NULL && xmlNewProp(ret, BAD_CAST \"type\", BAD_CAST hardDisk->type) == NULL)\n        goto cleanup;\n\n    for (i = 0; i < hardDisk->nchildren; i++) {\n        xmlNodePtr child = virVBoxSnapshotConfCreateHardDiskNode(hardDisk->children[i]);\n        if (child != NULL)\n            xmlAddChild(ret, child);\n    }\n\n    result = 0;\n cleanup:\n    if (result < 0) {\n        xmlUnlinkNode(ret);\n        xmlFreeNode(ret);\n        ret = NULL;\n    }\n    VIR_FREE(uuid);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewNode",
          "args": [
            "NULL",
            "BAD_CAST \"HardDisks\""
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlAddChild",
          "args": [
            "mediaRegistryNode",
            "cur"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Unable to add media registry other media\")"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlParseInNodeContext",
          "args": [
            "mediaRegistryNode",
            "machine->mediaRegistry->otherMedia[i]",
            "(int)strlen(machine->mediaRegistry->otherMedia[i])",
            "0",
            "&cur"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "machine->mediaRegistry->otherMedia[i]"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlAddChild",
          "args": [
            "machineNode",
            "mediaRegistryNode"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewNode",
          "args": [
            "NULL",
            "BAD_CAST \"MediaRegistry\""
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlAddChild",
          "args": [
            "xmlDocGetRootElement(xml)",
            "machineNode"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlDocGetRootElement",
          "args": [
            "xml"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Error in xmlNewProp\")"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewProp",
          "args": [
            "machineNode",
            "BAD_CAST \"lastStateChange\"",
            "BAD_CASTtimeStamp"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%sT%sZ\"",
            "firstRegex[0]",
            "secondRegex[0]"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringSearch",
          "args": [
            "machine->lastStateChange",
            "\"([0-9]{2}:[0-9]{2}:[0-9]{2})\"",
            "1",
            "&secondRegex"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "965-1029",
          "snippet": "ssize_t\nvirStringSearch(const char *str,\n                const char *regexp,\n                size_t max_matches,\n                char ***matches)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    size_t nmatches = 0;\n    ssize_t ret = -1;\n\n    *matches = NULL;\n\n    VIR_DEBUG(\"search '%s' for '%s'\", str, regexp);\n\n    regex = g_regex_new(regexp, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (g_regex_get_capture_count(regex) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Regular expression '%s' must have exactly 1 match group, not %d\"),\n                       regexp, g_regex_get_capture_count(regex));\n        goto cleanup;\n    }\n\n    /* '*matches' must always be NULL terminated in every iteration\n     * of the loop, so start by allocating 1 element\n     */\n    if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n        goto cleanup;\n\n    while ((nmatches - 1) < max_matches) {\n        g_autoptr(GMatchInfo) info = NULL;\n        char *match;\n        int endpos;\n\n        if (!g_regex_match(regex, str, 0, &info))\n            break;\n\n        if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n            goto cleanup;\n\n        match = g_match_info_fetch(info, 1);\n\n        VIR_DEBUG(\"Got '%s'\", match);\n\n        (*matches)[nmatches-2] = match;\n\n        g_match_info_fetch_pos(info, 1, NULL, &endpos);\n        str += endpos;\n    }\n\n    ret = nmatches - 1; /* don't count the trailing null */\n\n cleanup:\n    if (ret < 0) {\n        virStringListFree(*matches);\n        *matches = NULL;\n    }\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nssize_t\nvirStringSearch(const char *str,\n                const char *regexp,\n                size_t max_matches,\n                char ***matches)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    size_t nmatches = 0;\n    ssize_t ret = -1;\n\n    *matches = NULL;\n\n    VIR_DEBUG(\"search '%s' for '%s'\", str, regexp);\n\n    regex = g_regex_new(regexp, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (g_regex_get_capture_count(regex) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Regular expression '%s' must have exactly 1 match group, not %d\"),\n                       regexp, g_regex_get_capture_count(regex));\n        goto cleanup;\n    }\n\n    /* '*matches' must always be NULL terminated in every iteration\n     * of the loop, so start by allocating 1 element\n     */\n    if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n        goto cleanup;\n\n    while ((nmatches - 1) < max_matches) {\n        g_autoptr(GMatchInfo) info = NULL;\n        char *match;\n        int endpos;\n\n        if (!g_regex_match(regex, str, 0, &info))\n            break;\n\n        if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n            goto cleanup;\n\n        match = g_match_info_fetch(info, 1);\n\n        VIR_DEBUG(\"Got '%s'\", match);\n\n        (*matches)[nmatches-2] = match;\n\n        g_match_info_fetch_pos(info, 1, NULL, &endpos);\n        str += endpos;\n    }\n\n    ret = nmatches - 1; /* don't count the trailing null */\n\n cleanup:\n    if (ret < 0) {\n        virStringListFree(*matches);\n        *matches = NULL;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Error in xmlNewProp\")"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewProp",
          "args": [
            "machineNode",
            "BAD_CAST \"OSType\"",
            "BAD_CAST \"Other\""
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Error in xmlNewProp\")"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewProp",
          "args": [
            "machineNode",
            "BAD_CAST \"currentStateModified\"",
            "BAD_CAST(machine->currentStateModified == 0 ? \"false\" : \"true\")"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BAD_CAST",
          "args": [
            "machine->currentStateModified == 0 ? \"false\" : \"true\""
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Error in xmlNewProp\")"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewProp",
          "args": [
            "machineNode",
            "BAD_CAST \"snapshotFolder\"",
            "BAD_CAST machine->snapshotFolder"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Error in xmlNewProp\")"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewProp",
          "args": [
            "machineNode",
            "BAD_CAST \"currentSnapshot\"",
            "BAD_CASTcurrentSnapshot"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Error in xmlNewProp\")"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewProp",
          "args": [
            "machineNode",
            "BAD_CAST \"name\"",
            "BAD_CAST machine->name"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Error in xmlNewProp\")"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewProp",
          "args": [
            "machineNode",
            "BAD_CAST \"uuid\"",
            "BAD_CAST machine->uuid"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewNode",
          "args": [
            "NULL",
            "BAD_CAST \"Machine\""
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Error in xmlAddPrevSibling\")"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlAddPrevSibling",
          "args": [
            "xmlDocGetRootElement(xml)",
            "cur"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlDocGetRootElement",
          "args": [
            "xml"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewDocComment",
          "args": [
            "xml",
            "BAD_CAST \"WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE\\n\"\n                           \"OVERWRITTEN AND LOST.\\n\"\n                           \"Changes to this xml configuration should be made using Virtualbox\\n\"\n                           \"or other application using the libvirt API\""
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlDocSetRootElement",
          "args": [
            "xml",
            "cur"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Error in xmlNewProp\")"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewProp",
          "args": [
            "cur",
            "BAD_CAST \"xmlns\"",
            "BAD_CAST \"http://www.innotek.de/VirtualBox-settings\""
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Error in xmlNewProp\")"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewProp",
          "args": [
            "cur",
            "BAD_CAST \"version\"",
            "BAD_CAST \"1.12-linux\""
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewNode",
          "args": [
            "NULL",
            "BAD_CAST \"VirtualBox\""
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewDoc",
          "args": [
            "BAD_CAST \"1.0\""
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Filepath is null\")"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Machine is null\")"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfSaveVboxFile(virVBoxSnapshotConfMachinePtr machine,\n                                const char *filePath)\n{\n    int ret = -1;\n    size_t i = 0;\n    xmlDocPtr xml = NULL;\n    xmlNodePtr mediaRegistryNode = NULL;\n    xmlNodePtr snapshotNode = NULL;\n    xmlNodePtr machineNode = NULL;\n    xmlNodePtr hardDisksNode = NULL;\n    xmlNodePtr cur = NULL;\n    xmlParserErrors parseError = XML_ERR_OK;\n    char *currentSnapshot = NULL;\n    char *timeStamp = NULL;\n\n    char **firstRegex = NULL;\n    int firstRegexResult = 0;\n    char **secondRegex = NULL;\n    int secondRegexResult = 0;\n\n    if (machine == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Machine is null\"));\n        goto cleanup;\n    }\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Filepath is null\"));\n        goto cleanup;\n    }\n    xml = xmlNewDoc(BAD_CAST \"1.0\");\n    if (!xml) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    cur = xmlNewNode(NULL, BAD_CAST \"VirtualBox\");\n    if (!cur) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (!xmlNewProp(cur, BAD_CAST \"version\", BAD_CAST \"1.12-linux\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (xmlNewProp(cur,\n                   BAD_CAST \"xmlns\",\n                   BAD_CAST \"http://www.innotek.de/VirtualBox-settings\") == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n\n    xmlDocSetRootElement(xml, cur);\n\n    cur = xmlNewDocComment(xml,\n                           BAD_CAST \"WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE\\n\"\n                           \"OVERWRITTEN AND LOST.\\n\"\n                           \"Changes to this xml configuration should be made using Virtualbox\\n\"\n                           \"or other application using the libvirt API\");\n    if (!cur) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (!xmlAddPrevSibling(xmlDocGetRootElement(xml), cur)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlAddPrevSibling\"));\n        goto cleanup;\n    }\n\n    machineNode = xmlNewNode(NULL, BAD_CAST \"Machine\");\n    if (!machineNode) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (!xmlNewProp(machineNode, BAD_CAST \"uuid\", BAD_CAST machine->uuid)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"name\", BAD_CAST machine->name)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n\n    if (machine->currentSnapshot != NULL) {\n        currentSnapshot = g_strdup_printf(\"{%s}\", machine->currentSnapshot);\n        if (!xmlNewProp(machineNode, BAD_CAST \"currentSnapshot\", BAD_CAST currentSnapshot)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Error in xmlNewProp\"));\n            goto cleanup;\n        }\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"snapshotFolder\", BAD_CAST machine->snapshotFolder)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"currentStateModified\",\n               BAD_CAST(machine->currentStateModified == 0 ? \"false\" : \"true\"))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"OSType\", BAD_CAST \"Other\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n\n    firstRegexResult = virStringSearch(machine->lastStateChange,\n                                       \"([0-9]{4}-[0-9]{2}-[0-9]{2})\",\n                                       1,\n                                       &firstRegex);\n    secondRegexResult = virStringSearch(machine->lastStateChange,\n                                        \"([0-9]{2}:[0-9]{2}:[0-9]{2})\",\n                                        1,\n                                        &secondRegex);\n    if (firstRegexResult < 1)\n        goto cleanup;\n    if (secondRegexResult < 1)\n        goto cleanup;\n\n    timeStamp = g_strdup_printf(\"%sT%sZ\", firstRegex[0], secondRegex[0]);\n    if (!xmlNewProp(machineNode, BAD_CAST \"lastStateChange\", BAD_CAST timeStamp)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    xmlAddChild(xmlDocGetRootElement(xml), machineNode);\n\n    mediaRegistryNode = xmlNewNode(NULL, BAD_CAST \"MediaRegistry\");\n    if (!mediaRegistryNode) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    xmlAddChild(machineNode, mediaRegistryNode);\n    for (i = 0; i < machine->mediaRegistry->notherMedia; i++) {\n        parseError = xmlParseInNodeContext(mediaRegistryNode,\n                              machine->mediaRegistry->otherMedia[i],\n                              (int)strlen(machine->mediaRegistry->otherMedia[i]),\n                              0,\n                              &cur);\n        if (parseError != XML_ERR_OK) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Unable to add media registry other media\"));\n            goto cleanup;\n        }\n        xmlAddChild(mediaRegistryNode, cur);\n    }\n    hardDisksNode = xmlNewNode(NULL, BAD_CAST \"HardDisks\");\n    if (!hardDisksNode) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        xmlNodePtr child = virVBoxSnapshotConfCreateHardDiskNode(machine->mediaRegistry->disks[i]);\n        if (child != NULL)\n            xmlAddChild(hardDisksNode, child);\n    }\n    xmlAddChild(mediaRegistryNode, hardDisksNode);\n\n    parseError = xmlParseInNodeContext(machineNode,\n                                       machine->hardware,\n                                       (int)strlen(machine->hardware),\n                                       0,\n                                       &cur);\n    if (parseError != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add hardware machine\"));\n        goto cleanup;\n    }\n    xmlAddChild(machineNode, cur);\n\n    if (machine->extraData != NULL) {\n        parseError = xmlParseInNodeContext(xmlDocGetRootElement(xml),\n                                           machine->extraData,\n                                           (int)strlen(machine->extraData),\n                                           0,\n                                           &cur);\n        if (parseError != XML_ERR_OK) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Unable to add extra data\"));\n            goto cleanup;\n        }\n        xmlAddChild(machineNode, cur);\n    }\n\n    parseError = xmlParseInNodeContext(machineNode,\n                                       machine->storageController,\n                                       (int)strlen(machine->storageController),\n                                       0,\n                                       &cur);\n    if (parseError != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add storage controller\"));\n        goto cleanup;\n    }\n    xmlAddChild(machineNode, cur);\n\n    if (machine->snapshot != NULL) {\n        snapshotNode = xmlNewNode(NULL, BAD_CAST \"Snapshot\");\n        xmlAddChild(machineNode, snapshotNode);\n        if (virVBoxSnapshotConfSerializeSnapshot(snapshotNode, machine->snapshot) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Failed to serialize snapshot\"));\n            goto cleanup;\n        }\n    }\n\n    if (xmlSaveFormatFileEnc(filePath, xml, \"ISO-8859-1\", 1) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to save the xml\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(currentSnapshot);\n    VIR_FREE(timeStamp);\n\n    xmlUnlinkNode(hardDisksNode);\n    xmlFreeNode(hardDisksNode);\n\n    xmlUnlinkNode(mediaRegistryNode);\n    xmlFreeNode(mediaRegistryNode);\n\n    xmlUnlinkNode(snapshotNode);\n    xmlFreeNode(snapshotNode);\n\n    xmlUnlinkNode(cur);\n    xmlFreeNode(cur);\n\n    xmlUnlinkNode(machineNode);\n    xmlFreeNode(machineNode);\n\n    xmlFreeDoc(xml);\n\n    virStringListFree(firstRegex);\n    virStringListFree(secondRegex);\n    return ret;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfRemoveHardDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "912-961",
    "snippet": "int\nvirVBoxSnapshotConfRemoveHardDisk(virVBoxSnapshotConfMediaRegistryPtr mediaRegistry,\n                                  const char *uuid)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    virVBoxSnapshotConfHardDiskPtr parentHardDisk = NULL;\n    if (mediaRegistry == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Media registry is null\"));\n        return -1;\n    }\n    if (uuid == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Uuid is null\"));\n        return -1;\n    }\n\n    for (i = 0; i < mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskById(mediaRegistry->disks[i], uuid);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find the hard disk with uuid %s\"), uuid);\n        return -1;\n    }\n    if (hardDisk->parent == NULL) {\n        /* it means that the hard disk is in 'root' */\n        for (i = 0; i < mediaRegistry->ndisks; i++) {\n            if (hardDisk == mediaRegistry->disks[i])\n                break;\n        }\n        if (VIR_DELETE_ELEMENT(mediaRegistry->disks, i, mediaRegistry->ndisks) < 0)\n            return -1;\n\n        return 0;\n    }\n\n    parentHardDisk = hardDisk->parent;\n    i = 0;\n    while (i < parentHardDisk->nchildren && parentHardDisk->children[i] != hardDisk)\n        ++i;\n    hardDisk->parent = NULL;\n    if (VIR_DELETE_ELEMENT(parentHardDisk->children, i, parentHardDisk->nchildren) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "parentHardDisk->children",
            "i",
            "parentHardDisk->nchildren"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "mediaRegistry->disks",
            "i",
            "mediaRegistry->ndisks"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to find the hard disk with uuid %s\")",
            "uuid"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to find the hard disk with uuid %s\""
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfHardDiskById",
          "args": [
            "mediaRegistry->disks[i]",
            "uuid"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfHardDiskById",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "294-308",
          "snippet": "static virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskById(virVBoxSnapshotConfHardDiskPtr disk,\n                                const char *parentHardDiskId)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr ret = NULL;\n    if (STREQ(disk->uuid, parentHardDiskId))\n        return disk;\n    for (i = 0; i < disk->nchildren; i++) {\n        ret = virVBoxSnapshotConfHardDiskById(disk->children[i], parentHardDiskId);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskById(virVBoxSnapshotConfHardDiskPtr disk,\n                                const char *parentHardDiskId)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr ret = NULL;\n    if (STREQ(disk->uuid, parentHardDiskId))\n        return disk;\n    for (i = 0; i < disk->nchildren; i++) {\n        ret = virVBoxSnapshotConfHardDiskById(disk->children[i], parentHardDiskId);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Uuid is null\")"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Media registry is null\")"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfRemoveHardDisk(virVBoxSnapshotConfMediaRegistryPtr mediaRegistry,\n                                  const char *uuid)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    virVBoxSnapshotConfHardDiskPtr parentHardDisk = NULL;\n    if (mediaRegistry == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Media registry is null\"));\n        return -1;\n    }\n    if (uuid == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Uuid is null\"));\n        return -1;\n    }\n\n    for (i = 0; i < mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskById(mediaRegistry->disks[i], uuid);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find the hard disk with uuid %s\"), uuid);\n        return -1;\n    }\n    if (hardDisk->parent == NULL) {\n        /* it means that the hard disk is in 'root' */\n        for (i = 0; i < mediaRegistry->ndisks; i++) {\n            if (hardDisk == mediaRegistry->disks[i])\n                break;\n        }\n        if (VIR_DELETE_ELEMENT(mediaRegistry->disks, i, mediaRegistry->ndisks) < 0)\n            return -1;\n\n        return 0;\n    }\n\n    parentHardDisk = hardDisk->parent;\n    i = 0;\n    while (i < parentHardDisk->nchildren && parentHardDisk->children[i] != hardDisk)\n        ++i;\n    hardDisk->parent = NULL;\n    if (VIR_DELETE_ELEMENT(parentHardDisk->children, i, parentHardDisk->nchildren) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfRemoveSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "849-904",
    "snippet": "int\nvirVBoxSnapshotConfRemoveSnapshot(virVBoxSnapshotConfMachinePtr machine,\n                                  const char *snapshotName)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfSnapshotPtr snapshot = NULL;\n    virVBoxSnapshotConfSnapshotPtr parentSnapshot = NULL;\n    if (machine == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"machine is null\"));\n        return -1;\n    }\n    if (snapshotName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"snapshotName is null\"));\n        return -1;\n    }\n    if (machine->snapshot == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"the machine has no snapshot\"));\n        return -1;\n    }\n    snapshot = virVBoxSnapshotConfSnapshotByName(machine->snapshot, snapshotName);\n    if (snapshot == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find the snapshot with name %s\"), snapshotName);\n        return -1;\n    }\n    if (snapshot->nchildren > 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"This snapshot has children, \"\n                         \"please delete theses snapshots before\"));\n        return -1;\n    }\n\n    if (snapshot->parent == NULL) {\n        if (machine->snapshot != snapshot) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"You are trying to remove a snapshot which does not exists\"));\n            return -1;\n        }\n        machine->snapshot = NULL;\n        virVBoxSnapshotConfSnapshotFree(snapshot);\n\n        return 0;\n    }\n    parentSnapshot = snapshot->parent;\n\n    snapshot->parent = NULL;\n    while (i < parentSnapshot->nchildren && parentSnapshot->children[i] != snapshot)\n        ++i;\n    if (VIR_DELETE_ELEMENT(parentSnapshot->children, i, parentSnapshot->nchildren) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "parentSnapshot->children",
            "i",
            "parentSnapshot->nchildren"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfSnapshotFree",
          "args": [
            "snapshot"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfSnapshotFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "535-553",
          "snippet": "void\nvirVBoxSnapshotConfSnapshotFree(virVBoxSnapshotConfSnapshotPtr snapshot)\n{\n    size_t i = 0;\n\n    if (!snapshot)\n        return;\n\n    VIR_FREE(snapshot->uuid);\n    VIR_FREE(snapshot->name);\n    VIR_FREE(snapshot->timeStamp);\n    VIR_FREE(snapshot->description);\n    VIR_FREE(snapshot->hardware);\n    VIR_FREE(snapshot->storageController);\n    for (i = 0; i < snapshot->nchildren; i++)\n        virVBoxSnapshotConfSnapshotFree(snapshot->children[i]);\n    VIR_FREE(snapshot->children);\n    VIR_FREE(snapshot);\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvoid\nvirVBoxSnapshotConfSnapshotFree(virVBoxSnapshotConfSnapshotPtr snapshot)\n{\n    size_t i = 0;\n\n    if (!snapshot)\n        return;\n\n    VIR_FREE(snapshot->uuid);\n    VIR_FREE(snapshot->name);\n    VIR_FREE(snapshot->timeStamp);\n    VIR_FREE(snapshot->description);\n    VIR_FREE(snapshot->hardware);\n    VIR_FREE(snapshot->storageController);\n    for (i = 0; i < snapshot->nchildren; i++)\n        virVBoxSnapshotConfSnapshotFree(snapshot->children[i]);\n    VIR_FREE(snapshot->children);\n    VIR_FREE(snapshot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"You are trying to remove a snapshot which does not exists\")"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"You are trying to remove a snapshot which does not exists\""
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"This snapshot has children, \"\n                         \"please delete theses snapshots before\")"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to find the snapshot with name %s\")",
            "snapshotName"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfSnapshotByName",
          "args": [
            "machine->snapshot",
            "snapshotName"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfSnapshotByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "278-292",
          "snippet": "virVBoxSnapshotConfSnapshotPtr\nvirVBoxSnapshotConfSnapshotByName(virVBoxSnapshotConfSnapshotPtr snapshot,\n                                  const char *snapshotName)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfSnapshotPtr ret = NULL;\n    if (STREQ(snapshot->name, snapshotName))\n        return snapshot;\n    for (i = 0; i < snapshot->nchildren; i++) {\n        ret = virVBoxSnapshotConfSnapshotByName(snapshot->children[i], snapshotName);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvirVBoxSnapshotConfSnapshotPtr\nvirVBoxSnapshotConfSnapshotByName(virVBoxSnapshotConfSnapshotPtr snapshot,\n                                  const char *snapshotName)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfSnapshotPtr ret = NULL;\n    if (STREQ(snapshot->name, snapshotName))\n        return snapshot;\n    for (i = 0; i < snapshot->nchildren; i++) {\n        ret = virVBoxSnapshotConfSnapshotByName(snapshot->children[i], snapshotName);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"the machine has no snapshot\")"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"snapshotName is null\")"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"machine is null\")"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfRemoveSnapshot(virVBoxSnapshotConfMachinePtr machine,\n                                  const char *snapshotName)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfSnapshotPtr snapshot = NULL;\n    virVBoxSnapshotConfSnapshotPtr parentSnapshot = NULL;\n    if (machine == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"machine is null\"));\n        return -1;\n    }\n    if (snapshotName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"snapshotName is null\"));\n        return -1;\n    }\n    if (machine->snapshot == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"the machine has no snapshot\"));\n        return -1;\n    }\n    snapshot = virVBoxSnapshotConfSnapshotByName(machine->snapshot, snapshotName);\n    if (snapshot == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find the snapshot with name %s\"), snapshotName);\n        return -1;\n    }\n    if (snapshot->nchildren > 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"This snapshot has children, \"\n                         \"please delete theses snapshots before\"));\n        return -1;\n    }\n\n    if (snapshot->parent == NULL) {\n        if (machine->snapshot != snapshot) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"You are trying to remove a snapshot which does not exists\"));\n            return -1;\n        }\n        machine->snapshot = NULL;\n        virVBoxSnapshotConfSnapshotFree(snapshot);\n\n        return 0;\n    }\n    parentSnapshot = snapshot->parent;\n\n    snapshot->parent = NULL;\n    while (i < parentSnapshot->nchildren && parentSnapshot->children[i] != snapshot)\n        ++i;\n    if (VIR_DELETE_ELEMENT(parentSnapshot->children, i, parentSnapshot->nchildren) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfAddHardDiskToMediaRegistry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "804-841",
    "snippet": "int\nvirVBoxSnapshotConfAddHardDiskToMediaRegistry(virVBoxSnapshotConfHardDiskPtr hardDisk,\n                                              virVBoxSnapshotConfMediaRegistryPtr mediaRegistry,\n                                              const char *parentHardDiskId)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr parentDisk = NULL;\n    if (hardDisk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Hard disk is null\"));\n        return -1;\n    }\n    if (mediaRegistry == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Media Registry is null\"));\n        return -1;\n    }\n\n    for (i = 0; i < mediaRegistry->ndisks; i++) {\n        parentDisk = virVBoxSnapshotConfHardDiskById(mediaRegistry->disks[i], parentHardDiskId);\n        if (parentDisk != NULL)\n            break;\n    }\n    if (parentDisk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get the parent disk\"));\n        return -1;\n    }\n    /* Hard disk found */\n    if (VIR_EXPAND_N(parentDisk->children, parentDisk->nchildren, 1) < 0)\n        return -1;\n\n    parentDisk->children[parentDisk->nchildren - 1] = hardDisk;\n    if (hardDisk->parent == NULL)\n        hardDisk->parent = parentDisk;\n\n    return 0;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "parentDisk->children",
            "parentDisk->nchildren",
            "1"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to get the parent disk\")"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to get the parent disk\""
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfHardDiskById",
          "args": [
            "mediaRegistry->disks[i]",
            "parentHardDiskId"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfHardDiskById",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "294-308",
          "snippet": "static virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskById(virVBoxSnapshotConfHardDiskPtr disk,\n                                const char *parentHardDiskId)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr ret = NULL;\n    if (STREQ(disk->uuid, parentHardDiskId))\n        return disk;\n    for (i = 0; i < disk->nchildren; i++) {\n        ret = virVBoxSnapshotConfHardDiskById(disk->children[i], parentHardDiskId);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskById(virVBoxSnapshotConfHardDiskPtr disk,\n                                const char *parentHardDiskId)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr ret = NULL;\n    if (STREQ(disk->uuid, parentHardDiskId))\n        return disk;\n    for (i = 0; i < disk->nchildren; i++) {\n        ret = virVBoxSnapshotConfHardDiskById(disk->children[i], parentHardDiskId);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Media Registry is null\")"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Hard disk is null\")"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfAddHardDiskToMediaRegistry(virVBoxSnapshotConfHardDiskPtr hardDisk,\n                                              virVBoxSnapshotConfMediaRegistryPtr mediaRegistry,\n                                              const char *parentHardDiskId)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr parentDisk = NULL;\n    if (hardDisk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Hard disk is null\"));\n        return -1;\n    }\n    if (mediaRegistry == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Media Registry is null\"));\n        return -1;\n    }\n\n    for (i = 0; i < mediaRegistry->ndisks; i++) {\n        parentDisk = virVBoxSnapshotConfHardDiskById(mediaRegistry->disks[i], parentHardDiskId);\n        if (parentDisk != NULL)\n            break;\n    }\n    if (parentDisk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get the parent disk\"));\n        return -1;\n    }\n    /* Hard disk found */\n    if (VIR_EXPAND_N(parentDisk->children, parentDisk->nchildren, 1) < 0)\n        return -1;\n\n    parentDisk->children[parentDisk->nchildren - 1] = hardDisk;\n    if (hardDisk->parent == NULL)\n        hardDisk->parent = parentDisk;\n\n    return 0;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfAddSnapshotToXmlMachine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "748-796",
    "snippet": "int\nvirVBoxSnapshotConfAddSnapshotToXmlMachine(virVBoxSnapshotConfSnapshotPtr snapshot,\n                                           virVBoxSnapshotConfMachinePtr machine,\n                                           const char *snapshotParentName)\n{\n    virVBoxSnapshotConfSnapshotPtr parentSnapshot = NULL;\n\n    if (snapshot == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Snapshot is Null\"));\n        return -1;\n    }\n    if (machine == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Machine is Null\"));\n        return -1;\n    }\n\n    /* If parent is NULL and the machine has no snapshot yet,\n     * it means that the added snapshot is the first snapshot */\n    if (snapshotParentName == NULL) {\n        if (machine->snapshot != NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to add this snapshot, there is already a snapshot \"\n                             \"linked to the machine\"));\n            return -1;\n        }\n        machine->snapshot = snapshot;\n        return 0;\n    } else {\n        if (machine->snapshot == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"The machine has no snapshot and it should have it\"));\n            return -1;\n        }\n        parentSnapshot = virVBoxSnapshotConfSnapshotByName(machine->snapshot, snapshotParentName);\n        if (parentSnapshot == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to find the snapshot %s\"), snapshotParentName);\n            return -1;\n        }\n        if (VIR_EXPAND_N(parentSnapshot->children, parentSnapshot->nchildren, 1) < 0)\n            return -1;\n\n        parentSnapshot->children[parentSnapshot->nchildren - 1] = snapshot;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "parentSnapshot->children",
            "parentSnapshot->nchildren",
            "1"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to find the snapshot %s\")",
            "snapshotParentName"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to find the snapshot %s\""
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfSnapshotByName",
          "args": [
            "machine->snapshot",
            "snapshotParentName"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfSnapshotByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "278-292",
          "snippet": "virVBoxSnapshotConfSnapshotPtr\nvirVBoxSnapshotConfSnapshotByName(virVBoxSnapshotConfSnapshotPtr snapshot,\n                                  const char *snapshotName)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfSnapshotPtr ret = NULL;\n    if (STREQ(snapshot->name, snapshotName))\n        return snapshot;\n    for (i = 0; i < snapshot->nchildren; i++) {\n        ret = virVBoxSnapshotConfSnapshotByName(snapshot->children[i], snapshotName);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvirVBoxSnapshotConfSnapshotPtr\nvirVBoxSnapshotConfSnapshotByName(virVBoxSnapshotConfSnapshotPtr snapshot,\n                                  const char *snapshotName)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfSnapshotPtr ret = NULL;\n    if (STREQ(snapshot->name, snapshotName))\n        return snapshot;\n    for (i = 0; i < snapshot->nchildren; i++) {\n        ret = virVBoxSnapshotConfSnapshotByName(snapshot->children[i], snapshotName);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"The machine has no snapshot and it should have it\")"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to add this snapshot, there is already a snapshot \"\n                             \"linked to the machine\")"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Machine is Null\")"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Snapshot is Null\")"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfAddSnapshotToXmlMachine(virVBoxSnapshotConfSnapshotPtr snapshot,\n                                           virVBoxSnapshotConfMachinePtr machine,\n                                           const char *snapshotParentName)\n{\n    virVBoxSnapshotConfSnapshotPtr parentSnapshot = NULL;\n\n    if (snapshot == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Snapshot is Null\"));\n        return -1;\n    }\n    if (machine == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Machine is Null\"));\n        return -1;\n    }\n\n    /* If parent is NULL and the machine has no snapshot yet,\n     * it means that the added snapshot is the first snapshot */\n    if (snapshotParentName == NULL) {\n        if (machine->snapshot != NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to add this snapshot, there is already a snapshot \"\n                             \"linked to the machine\"));\n            return -1;\n        }\n        machine->snapshot = snapshot;\n        return 0;\n    } else {\n        if (machine->snapshot == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"The machine has no snapshot and it should have it\"));\n            return -1;\n        }\n        parentSnapshot = virVBoxSnapshotConfSnapshotByName(machine->snapshot, snapshotParentName);\n        if (parentSnapshot == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to find the snapshot %s\"), snapshotParentName);\n            return -1;\n        }\n        if (VIR_EXPAND_N(parentSnapshot->children, parentSnapshot->nchildren, 1) < 0)\n            return -1;\n\n        parentSnapshot->children[parentSnapshot->nchildren - 1] = snapshot;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfLoadVboxFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "580-739",
    "snippet": "virVBoxSnapshotConfMachinePtr\nvirVBoxSnapshotConfLoadVboxFile(const char *filePath,\n                                const char *machineLocation)\n{\n    int ret = -1;\n    virVBoxSnapshotConfMachinePtr machineDescription = NULL;\n    xmlDocPtr xml = NULL;\n    xmlNodePtr machineNode = NULL;\n    xmlNodePtr cur = NULL;\n    xmlXPathContextPtr xPathContext = NULL;\n    char *currentStateModifiedString = NULL;\n\n    char **searchResultTab = NULL;\n    ssize_t searchResultSize = 0;\n    char *currentSnapshotAttribute = NULL;\n\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Filepath is Null\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC(machineDescription) < 0)\n        goto cleanup;\n\n    xml = virXMLParse(filePath, NULL, NULL);\n    if (xml == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to parse the xml\"));\n        goto cleanup;\n    }\n    if (!(xPathContext = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    if (xmlXPathRegisterNs(xPathContext,\n                           BAD_CAST \"vbox\",\n                           BAD_CAST \"http://www.innotek.de/VirtualBox-settings\") < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Failed to register xml namespace \"\n                         \"'http://www.innotek.de/VirtualBox-settings'\"));\n        goto cleanup;\n    }\n\n    /* Retrieve MachineNode */\n    cur = xmlDocGetRootElement(xml);\n    xPathContext->node = cur;\n    machineNode = virXPathNode(\"./vbox:Machine\", xPathContext);\n    if (machineNode == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <VirtualBox> <Machine> node\"));\n        goto cleanup;\n    }\n\n    machineDescription->uuid = virXMLPropString(machineNode, \"uuid\");\n    if (machineDescription->uuid == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'uuid' attribute\"));\n        goto cleanup;\n    }\n    machineDescription->name = virXMLPropString(machineNode, \"name\");\n    if (machineDescription->name == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'name' attribute\"));\n        goto cleanup;\n    }\n\n    currentSnapshotAttribute = virXMLPropString(machineNode, \"currentSnapshot\");\n    if (currentSnapshotAttribute != NULL) {\n        /* we use virStringSearch because the uuid is between brackets */\n        searchResultSize = virStringSearch(currentSnapshotAttribute,\n                                           VBOX_UUID_REGEX,\n                                           1,\n                                           &searchResultTab);\n        if (searchResultSize != 1) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Cannot parse <Machine> 'currentSnapshot' attribute\"));\n            goto cleanup;\n        }\n        machineDescription->currentSnapshot = g_strdup(searchResultTab[0]);\n    }\n\n    machineDescription->snapshotFolder = virXMLPropString(machineNode, \"snapshotFolder\");\n    if (machineDescription->snapshotFolder == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'snapshotFolder' attribute\"));\n        goto cleanup;\n    }\n\n    currentStateModifiedString = virXMLPropString(machineNode, \"currentStateModified\");\n    if (currentStateModifiedString != NULL && STREQ(currentStateModifiedString, \"true\")) {\n        machineDescription->currentStateModified = 1;\n    } else {\n        machineDescription->currentStateModified = 0;\n    }\n    machineDescription->lastStateChange = virXMLPropString(machineNode, \"lastStateChange\");\n    if (machineDescription->lastStateChange == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'lastStateChange' attribute\"));\n        goto cleanup;\n    }\n\n    xPathContext->node = machineNode;\n    cur = virXPathNode(\"./vbox:Hardware\", xPathContext);\n    if (cur == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> <Hardware> node\"));\n        goto cleanup;\n    }\n    machineDescription->hardware = virXMLNodeToString(xml, cur);\n\n    cur = virXPathNode(\"./vbox:ExtraData\", xPathContext);\n    if (cur)\n        machineDescription->extraData = virXMLNodeToString(xml, cur);\n\n    cur = virXPathNode(\"./vbox:StorageControllers\", xPathContext);\n    if (cur == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> <StorageControllers> node\"));\n        goto cleanup;\n    }\n    machineDescription->storageController = virXMLNodeToString(xml, cur);\n\n    /* retrieve mediaRegistry */\n    cur = virXPathNode(\"./vbox:MediaRegistry\", xPathContext);\n    if (cur == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> <MediaRegistry> node\"));\n        goto cleanup;\n    }\n    machineDescription->mediaRegistry = virVBoxSnapshotConfRetrieveMediaRegistry(cur, xPathContext, machineLocation);\n    if (machineDescription->mediaRegistry == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to create media registry\"));\n        goto cleanup;\n    }\n\n    /* retrieve snapshot */\n    xPathContext->node = machineNode;\n    cur = virXPathNode(\"./vbox:Snapshot\", xPathContext);\n    if (cur != NULL) {\n        machineDescription->snapshot = virVBoxSnapshotConfRetrieveSnapshot(cur, xPathContext);\n        if (!machineDescription->snapshot)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    xmlXPathFreeContext(xPathContext);\n    xmlFreeDoc(xml);\n\n    VIR_FREE(currentStateModifiedString);\n    VIR_FREE(currentSnapshotAttribute);\n    virStringListFree(searchResultTab);\n    if (ret < 0) {\n        virVBoxSnapshotConfMachineFree(machineDescription);\n        machineDescription = NULL;\n    }\n    return machineDescription;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfMachineFree",
          "args": [
            "machineDescription"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfMachineFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "555-572",
          "snippet": "void\nvirVBoxSnapshotConfMachineFree(virVBoxSnapshotConfMachinePtr machine)\n{\n    if (!machine)\n        return;\n\n    VIR_FREE(machine->uuid);\n    VIR_FREE(machine->name);\n    VIR_FREE(machine->currentSnapshot);\n    VIR_FREE(machine->snapshotFolder);\n    VIR_FREE(machine->lastStateChange);\n    virVBoxSnapshotConfMediaRegistryFree(machine->mediaRegistry);\n    VIR_FREE(machine->hardware);\n    VIR_FREE(machine->extraData);\n    virVBoxSnapshotConfSnapshotFree(machine->snapshot);\n    VIR_FREE(machine->storageController);\n    VIR_FREE(machine);\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvoid\nvirVBoxSnapshotConfMachineFree(virVBoxSnapshotConfMachinePtr machine)\n{\n    if (!machine)\n        return;\n\n    VIR_FREE(machine->uuid);\n    VIR_FREE(machine->name);\n    VIR_FREE(machine->currentSnapshot);\n    VIR_FREE(machine->snapshotFolder);\n    VIR_FREE(machine->lastStateChange);\n    virVBoxSnapshotConfMediaRegistryFree(machine->mediaRegistry);\n    VIR_FREE(machine->hardware);\n    VIR_FREE(machine->extraData);\n    virVBoxSnapshotConfSnapshotFree(machine->snapshot);\n    VIR_FREE(machine->storageController);\n    VIR_FREE(machine);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "searchResultTab"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "currentSnapshotAttribute"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "currentStateModifiedString"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "xml"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "xPathContext"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfRetrieveSnapshot",
          "args": [
            "cur",
            "xPathContext"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfRetrieveSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "176-276",
          "snippet": "static virVBoxSnapshotConfSnapshotPtr\nvirVBoxSnapshotConfRetrieveSnapshot(xmlNodePtr snapshotNode,\n                                    xmlXPathContextPtr xPathContext)\n{\n    virVBoxSnapshotConfSnapshotPtr snapshot = NULL;\n    xmlNodePtr hardwareNode = NULL;\n    xmlNodePtr descriptionNode = NULL;\n    xmlNodePtr storageControllerNode = NULL;\n    xmlNodePtr snapshotsNode = NULL;\n    xmlNodePtr *nodes = NULL;\n    char *uuid = NULL;\n    char **searchTabResult = NULL;\n    int resultSize = 0;\n    size_t i = 0;\n    int result = -1;\n    int n = 0;\n\n    if (VIR_ALLOC(snapshot) < 0)\n        goto cleanup;\n\n    uuid = virXMLPropString(snapshotNode, \"uuid\");\n    /* we use virStringSearch because the uuid is between brackets */\n    resultSize = virStringSearch(uuid,\n                                 VBOX_UUID_REGEX,\n                                 1,\n                                 &searchTabResult);\n    if (resultSize != 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> 'uuid' attribute\"));\n        goto cleanup;\n    }\n    snapshot->uuid = g_strdup(searchTabResult[0]);\n\n    snapshot->name = virXMLPropString(snapshotNode, \"name\");\n    if (snapshot->name == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> 'name' attribute\"));\n        goto cleanup;\n    }\n    snapshot->timeStamp = virXMLPropString(snapshotNode, \"timeStamp\");\n    if (snapshot->timeStamp == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> 'timeStamp' attribute\"));\n        goto cleanup;\n    }\n\n    xPathContext->node = snapshotNode;\n    descriptionNode = virXPathNode(\"./vbox:Description\", xPathContext);\n    if (descriptionNode != NULL)\n        snapshot->description = virXMLNodeToString(descriptionNode->doc, descriptionNode);\n\n    hardwareNode = virXPathNode(\"./vbox:Hardware\", xPathContext);\n    if (hardwareNode == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> <Hardware> node\"));\n        goto cleanup;\n    }\n    snapshot->hardware = virXMLNodeToString(snapshotNode->doc, hardwareNode);\n\n    storageControllerNode = virXPathNode(\"./vbox:StorageControllers\", xPathContext);\n    if (storageControllerNode == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> <StorageControllers> node\"));\n        goto cleanup;\n    }\n    snapshot->storageController = virXMLNodeToString(snapshotNode->doc,\n                                                     storageControllerNode);\n\n    snapshotsNode = virXPathNode(\"./vbox:Snapshots\", xPathContext);\n\n    if (snapshotsNode != NULL) {\n        xPathContext->node = snapshotsNode;\n        n = virXPathNodeSet(\"./vbox:Snapshot\", xPathContext, &nodes);\n        if (n < 0)\n            goto cleanup;\n        if (n && VIR_ALLOC_N(snapshot->children, n) < 0)\n            goto cleanup;\n        snapshot->nchildren = n;\n        for (i = 0; i < snapshot->nchildren; i++) {\n            snapshot->children[i] = virVBoxSnapshotConfRetrieveSnapshot(nodes[i], xPathContext);\n            if (snapshot->children[i] == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Cannot create a vboxSnapshotXmlSnapshotPtr\"));\n                goto cleanup;\n            }\n            snapshot->children[i]->parent = snapshot;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virVBoxSnapshotConfSnapshotFree(snapshot);\n        snapshot = NULL;\n    }\n    VIR_FREE(nodes);\n    VIR_FREE(uuid);\n    virStringListFree(searchTabResult);\n    return snapshot;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic virVBoxSnapshotConfSnapshotPtr\nvirVBoxSnapshotConfRetrieveSnapshot(xmlNodePtr snapshotNode,\n                                    xmlXPathContextPtr xPathContext)\n{\n    virVBoxSnapshotConfSnapshotPtr snapshot = NULL;\n    xmlNodePtr hardwareNode = NULL;\n    xmlNodePtr descriptionNode = NULL;\n    xmlNodePtr storageControllerNode = NULL;\n    xmlNodePtr snapshotsNode = NULL;\n    xmlNodePtr *nodes = NULL;\n    char *uuid = NULL;\n    char **searchTabResult = NULL;\n    int resultSize = 0;\n    size_t i = 0;\n    int result = -1;\n    int n = 0;\n\n    if (VIR_ALLOC(snapshot) < 0)\n        goto cleanup;\n\n    uuid = virXMLPropString(snapshotNode, \"uuid\");\n    /* we use virStringSearch because the uuid is between brackets */\n    resultSize = virStringSearch(uuid,\n                                 VBOX_UUID_REGEX,\n                                 1,\n                                 &searchTabResult);\n    if (resultSize != 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> 'uuid' attribute\"));\n        goto cleanup;\n    }\n    snapshot->uuid = g_strdup(searchTabResult[0]);\n\n    snapshot->name = virXMLPropString(snapshotNode, \"name\");\n    if (snapshot->name == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> 'name' attribute\"));\n        goto cleanup;\n    }\n    snapshot->timeStamp = virXMLPropString(snapshotNode, \"timeStamp\");\n    if (snapshot->timeStamp == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> 'timeStamp' attribute\"));\n        goto cleanup;\n    }\n\n    xPathContext->node = snapshotNode;\n    descriptionNode = virXPathNode(\"./vbox:Description\", xPathContext);\n    if (descriptionNode != NULL)\n        snapshot->description = virXMLNodeToString(descriptionNode->doc, descriptionNode);\n\n    hardwareNode = virXPathNode(\"./vbox:Hardware\", xPathContext);\n    if (hardwareNode == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> <Hardware> node\"));\n        goto cleanup;\n    }\n    snapshot->hardware = virXMLNodeToString(snapshotNode->doc, hardwareNode);\n\n    storageControllerNode = virXPathNode(\"./vbox:StorageControllers\", xPathContext);\n    if (storageControllerNode == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> <StorageControllers> node\"));\n        goto cleanup;\n    }\n    snapshot->storageController = virXMLNodeToString(snapshotNode->doc,\n                                                     storageControllerNode);\n\n    snapshotsNode = virXPathNode(\"./vbox:Snapshots\", xPathContext);\n\n    if (snapshotsNode != NULL) {\n        xPathContext->node = snapshotsNode;\n        n = virXPathNodeSet(\"./vbox:Snapshot\", xPathContext, &nodes);\n        if (n < 0)\n            goto cleanup;\n        if (n && VIR_ALLOC_N(snapshot->children, n) < 0)\n            goto cleanup;\n        snapshot->nchildren = n;\n        for (i = 0; i < snapshot->nchildren; i++) {\n            snapshot->children[i] = virVBoxSnapshotConfRetrieveSnapshot(nodes[i], xPathContext);\n            if (snapshot->children[i] == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Cannot create a vboxSnapshotXmlSnapshotPtr\"));\n                goto cleanup;\n            }\n            snapshot->children[i]->parent = snapshot;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virVBoxSnapshotConfSnapshotFree(snapshot);\n        snapshot = NULL;\n    }\n    VIR_FREE(nodes);\n    VIR_FREE(uuid);\n    virStringListFree(searchTabResult);\n    return snapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./vbox:Snapshot\"",
            "xPathContext"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Unable to create media registry\")"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to create media registry\""
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfRetrieveMediaRegistry",
          "args": [
            "cur",
            "xPathContext",
            "machineLocation"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfRetrieveMediaRegistry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "114-174",
          "snippet": "static virVBoxSnapshotConfMediaRegistryPtr\nvirVBoxSnapshotConfRetrieveMediaRegistry(xmlNodePtr mediaRegistryNode,\n                                         xmlXPathContextPtr xPathContext,\n                                         const char *machineLocation)\n{\n    virVBoxSnapshotConfMediaRegistryPtr mediaRegistry = NULL;\n    xmlNodePtr hardDisksNode = NULL;\n    xmlNodePtr *nodes = NULL;\n    size_t i = 0;\n    int result = -1;\n    int n = 0;\n\n    if (VIR_ALLOC(mediaRegistry) < 0)\n        goto cleanup;\n\n    xPathContext->node = mediaRegistryNode;\n    hardDisksNode = virXPathNode(\"./vbox:HardDisks\", xPathContext);\n\n    xPathContext->node = hardDisksNode;\n    n = virXPathNodeSet(\"./vbox:HardDisk\", xPathContext, &nodes);\n    if (n < 0)\n        goto cleanup;\n    if (n && VIR_ALLOC_N(mediaRegistry->disks, n) < 0)\n        goto cleanup;\n    mediaRegistry->ndisks = n;\n    for (i = 0; i < mediaRegistry->ndisks; i++) {\n        mediaRegistry->disks[i] = virVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr(nodes[i],\n                                                                   xPathContext,\n                                                                   machineLocation);\n        if (mediaRegistry->disks[i] == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot create a vboxSnapshotXmlHardDisk\"));\n            goto cleanup;\n        }\n    }\n    n = 0;\n    VIR_FREE(nodes);\n\n    xPathContext->node = mediaRegistryNode;\n    n = virXPathNodeSet(\"./*[not(self::vbox:HardDisks)]\",\n                                                 xPathContext, &nodes);\n    if (n < 0)\n        goto cleanup;\n    if (n && VIR_ALLOC_N(mediaRegistry->otherMedia, n) < 0)\n        goto cleanup;\n    mediaRegistry->notherMedia = n;\n    for (i = 0; i < mediaRegistry->notherMedia; i++) {\n        mediaRegistry->otherMedia[i] = virXMLNodeToString(mediaRegistryNode->doc,\n                                                          nodes[i]);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virVBoxSnapshotConfMediaRegistryFree(mediaRegistry);\n        mediaRegistry = NULL;\n    }\n    VIR_FREE(nodes);\n    return mediaRegistry;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic virVBoxSnapshotConfMediaRegistryPtr\nvirVBoxSnapshotConfRetrieveMediaRegistry(xmlNodePtr mediaRegistryNode,\n                                         xmlXPathContextPtr xPathContext,\n                                         const char *machineLocation)\n{\n    virVBoxSnapshotConfMediaRegistryPtr mediaRegistry = NULL;\n    xmlNodePtr hardDisksNode = NULL;\n    xmlNodePtr *nodes = NULL;\n    size_t i = 0;\n    int result = -1;\n    int n = 0;\n\n    if (VIR_ALLOC(mediaRegistry) < 0)\n        goto cleanup;\n\n    xPathContext->node = mediaRegistryNode;\n    hardDisksNode = virXPathNode(\"./vbox:HardDisks\", xPathContext);\n\n    xPathContext->node = hardDisksNode;\n    n = virXPathNodeSet(\"./vbox:HardDisk\", xPathContext, &nodes);\n    if (n < 0)\n        goto cleanup;\n    if (n && VIR_ALLOC_N(mediaRegistry->disks, n) < 0)\n        goto cleanup;\n    mediaRegistry->ndisks = n;\n    for (i = 0; i < mediaRegistry->ndisks; i++) {\n        mediaRegistry->disks[i] = virVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr(nodes[i],\n                                                                   xPathContext,\n                                                                   machineLocation);\n        if (mediaRegistry->disks[i] == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot create a vboxSnapshotXmlHardDisk\"));\n            goto cleanup;\n        }\n    }\n    n = 0;\n    VIR_FREE(nodes);\n\n    xPathContext->node = mediaRegistryNode;\n    n = virXPathNodeSet(\"./*[not(self::vbox:HardDisks)]\",\n                                                 xPathContext, &nodes);\n    if (n < 0)\n        goto cleanup;\n    if (n && VIR_ALLOC_N(mediaRegistry->otherMedia, n) < 0)\n        goto cleanup;\n    mediaRegistry->notherMedia = n;\n    for (i = 0; i < mediaRegistry->notherMedia; i++) {\n        mediaRegistry->otherMedia[i] = virXMLNodeToString(mediaRegistryNode->doc,\n                                                          nodes[i]);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virVBoxSnapshotConfMediaRegistryFree(mediaRegistry);\n        mediaRegistry = NULL;\n    }\n    VIR_FREE(nodes);\n    return mediaRegistry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Cannot parse <Machine> <MediaRegistry> node\")"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLNodeToString",
          "args": [
            "xml",
            "cur"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "979-1003",
          "snippet": "char *\nvirXMLNodeToString(xmlDocPtr doc,\n                   xmlNodePtr node)\n{\n    xmlBufferPtr xmlbuf = NULL;\n    char *ret = NULL;\n\n    if (!(xmlbuf = xmlBufferCreate())) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    if (xmlNodeDump(xmlbuf, doc, node, 0, 1) == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to convert the XML node tree\"));\n        goto cleanup;\n    }\n\n    ret = g_strdup((const char *)xmlBufferContent(xmlbuf));\n\n cleanup:\n    xmlBufferFree(xmlbuf);\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLNodeToString(xmlDocPtr doc,\n                   xmlNodePtr node)\n{\n    xmlBufferPtr xmlbuf = NULL;\n    char *ret = NULL;\n\n    if (!(xmlbuf = xmlBufferCreate())) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    if (xmlNodeDump(xmlbuf, doc, node, 0, 1) == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to convert the XML node tree\"));\n        goto cleanup;\n    }\n\n    ret = g_strdup((const char *)xmlBufferContent(xmlbuf));\n\n cleanup:\n    xmlBufferFree(xmlbuf);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Cannot parse <Machine> <StorageControllers> node\")"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Cannot parse <Machine> <Hardware> node\")"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Cannot parse <Machine> 'lastStateChange' attribute\")"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "machineNode",
            "\"lastStateChange\""
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "currentStateModifiedString",
            "\"true\""
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Cannot parse <Machine> 'snapshotFolder' attribute\")"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "searchResultTab[0]"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Cannot parse <Machine> 'currentSnapshot' attribute\")"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSearch",
          "args": [
            "currentSnapshotAttribute",
            "VBOX_UUID_REGEX",
            "1",
            "&searchResultTab"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "965-1029",
          "snippet": "ssize_t\nvirStringSearch(const char *str,\n                const char *regexp,\n                size_t max_matches,\n                char ***matches)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    size_t nmatches = 0;\n    ssize_t ret = -1;\n\n    *matches = NULL;\n\n    VIR_DEBUG(\"search '%s' for '%s'\", str, regexp);\n\n    regex = g_regex_new(regexp, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (g_regex_get_capture_count(regex) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Regular expression '%s' must have exactly 1 match group, not %d\"),\n                       regexp, g_regex_get_capture_count(regex));\n        goto cleanup;\n    }\n\n    /* '*matches' must always be NULL terminated in every iteration\n     * of the loop, so start by allocating 1 element\n     */\n    if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n        goto cleanup;\n\n    while ((nmatches - 1) < max_matches) {\n        g_autoptr(GMatchInfo) info = NULL;\n        char *match;\n        int endpos;\n\n        if (!g_regex_match(regex, str, 0, &info))\n            break;\n\n        if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n            goto cleanup;\n\n        match = g_match_info_fetch(info, 1);\n\n        VIR_DEBUG(\"Got '%s'\", match);\n\n        (*matches)[nmatches-2] = match;\n\n        g_match_info_fetch_pos(info, 1, NULL, &endpos);\n        str += endpos;\n    }\n\n    ret = nmatches - 1; /* don't count the trailing null */\n\n cleanup:\n    if (ret < 0) {\n        virStringListFree(*matches);\n        *matches = NULL;\n    }\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nssize_t\nvirStringSearch(const char *str,\n                const char *regexp,\n                size_t max_matches,\n                char ***matches)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    size_t nmatches = 0;\n    ssize_t ret = -1;\n\n    *matches = NULL;\n\n    VIR_DEBUG(\"search '%s' for '%s'\", str, regexp);\n\n    regex = g_regex_new(regexp, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (g_regex_get_capture_count(regex) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Regular expression '%s' must have exactly 1 match group, not %d\"),\n                       regexp, g_regex_get_capture_count(regex));\n        goto cleanup;\n    }\n\n    /* '*matches' must always be NULL terminated in every iteration\n     * of the loop, so start by allocating 1 element\n     */\n    if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n        goto cleanup;\n\n    while ((nmatches - 1) < max_matches) {\n        g_autoptr(GMatchInfo) info = NULL;\n        char *match;\n        int endpos;\n\n        if (!g_regex_match(regex, str, 0, &info))\n            break;\n\n        if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n            goto cleanup;\n\n        match = g_match_info_fetch(info, 1);\n\n        VIR_DEBUG(\"Got '%s'\", match);\n\n        (*matches)[nmatches-2] = match;\n\n        g_match_info_fetch_pos(info, 1, NULL, &endpos);\n        str += endpos;\n    }\n\n    ret = nmatches - 1; /* don't count the trailing null */\n\n cleanup:\n    if (ret < 0) {\n        virStringListFree(*matches);\n        *matches = NULL;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Cannot parse <Machine> 'name' attribute\")"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Cannot parse <Machine> 'uuid' attribute\")"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Cannot parse <VirtualBox> <Machine> node\")"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlDocGetRootElement",
          "args": [
            "xml"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Failed to register xml namespace \"\n                         \"'http://www.innotek.de/VirtualBox-settings'\")"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathRegisterNs",
          "args": [
            "xPathContext",
            "BAD_CAST \"vbox\"",
            "BAD_CAST \"http://www.innotek.de/VirtualBox-settings\""
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLXPathContextNew",
          "args": [
            "xml"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLXPathContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "48-59",
          "snippet": "xmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Unable to parse the xml\")"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLParse",
          "args": [
            "filePath",
            "NULL",
            "NULL"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "machineDescription"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Filepath is Null\")"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvirVBoxSnapshotConfMachinePtr\nvirVBoxSnapshotConfLoadVboxFile(const char *filePath,\n                                const char *machineLocation)\n{\n    int ret = -1;\n    virVBoxSnapshotConfMachinePtr machineDescription = NULL;\n    xmlDocPtr xml = NULL;\n    xmlNodePtr machineNode = NULL;\n    xmlNodePtr cur = NULL;\n    xmlXPathContextPtr xPathContext = NULL;\n    char *currentStateModifiedString = NULL;\n\n    char **searchResultTab = NULL;\n    ssize_t searchResultSize = 0;\n    char *currentSnapshotAttribute = NULL;\n\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Filepath is Null\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC(machineDescription) < 0)\n        goto cleanup;\n\n    xml = virXMLParse(filePath, NULL, NULL);\n    if (xml == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to parse the xml\"));\n        goto cleanup;\n    }\n    if (!(xPathContext = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    if (xmlXPathRegisterNs(xPathContext,\n                           BAD_CAST \"vbox\",\n                           BAD_CAST \"http://www.innotek.de/VirtualBox-settings\") < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Failed to register xml namespace \"\n                         \"'http://www.innotek.de/VirtualBox-settings'\"));\n        goto cleanup;\n    }\n\n    /* Retrieve MachineNode */\n    cur = xmlDocGetRootElement(xml);\n    xPathContext->node = cur;\n    machineNode = virXPathNode(\"./vbox:Machine\", xPathContext);\n    if (machineNode == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <VirtualBox> <Machine> node\"));\n        goto cleanup;\n    }\n\n    machineDescription->uuid = virXMLPropString(machineNode, \"uuid\");\n    if (machineDescription->uuid == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'uuid' attribute\"));\n        goto cleanup;\n    }\n    machineDescription->name = virXMLPropString(machineNode, \"name\");\n    if (machineDescription->name == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'name' attribute\"));\n        goto cleanup;\n    }\n\n    currentSnapshotAttribute = virXMLPropString(machineNode, \"currentSnapshot\");\n    if (currentSnapshotAttribute != NULL) {\n        /* we use virStringSearch because the uuid is between brackets */\n        searchResultSize = virStringSearch(currentSnapshotAttribute,\n                                           VBOX_UUID_REGEX,\n                                           1,\n                                           &searchResultTab);\n        if (searchResultSize != 1) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Cannot parse <Machine> 'currentSnapshot' attribute\"));\n            goto cleanup;\n        }\n        machineDescription->currentSnapshot = g_strdup(searchResultTab[0]);\n    }\n\n    machineDescription->snapshotFolder = virXMLPropString(machineNode, \"snapshotFolder\");\n    if (machineDescription->snapshotFolder == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'snapshotFolder' attribute\"));\n        goto cleanup;\n    }\n\n    currentStateModifiedString = virXMLPropString(machineNode, \"currentStateModified\");\n    if (currentStateModifiedString != NULL && STREQ(currentStateModifiedString, \"true\")) {\n        machineDescription->currentStateModified = 1;\n    } else {\n        machineDescription->currentStateModified = 0;\n    }\n    machineDescription->lastStateChange = virXMLPropString(machineNode, \"lastStateChange\");\n    if (machineDescription->lastStateChange == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'lastStateChange' attribute\"));\n        goto cleanup;\n    }\n\n    xPathContext->node = machineNode;\n    cur = virXPathNode(\"./vbox:Hardware\", xPathContext);\n    if (cur == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> <Hardware> node\"));\n        goto cleanup;\n    }\n    machineDescription->hardware = virXMLNodeToString(xml, cur);\n\n    cur = virXPathNode(\"./vbox:ExtraData\", xPathContext);\n    if (cur)\n        machineDescription->extraData = virXMLNodeToString(xml, cur);\n\n    cur = virXPathNode(\"./vbox:StorageControllers\", xPathContext);\n    if (cur == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> <StorageControllers> node\"));\n        goto cleanup;\n    }\n    machineDescription->storageController = virXMLNodeToString(xml, cur);\n\n    /* retrieve mediaRegistry */\n    cur = virXPathNode(\"./vbox:MediaRegistry\", xPathContext);\n    if (cur == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> <MediaRegistry> node\"));\n        goto cleanup;\n    }\n    machineDescription->mediaRegistry = virVBoxSnapshotConfRetrieveMediaRegistry(cur, xPathContext, machineLocation);\n    if (machineDescription->mediaRegistry == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to create media registry\"));\n        goto cleanup;\n    }\n\n    /* retrieve snapshot */\n    xPathContext->node = machineNode;\n    cur = virXPathNode(\"./vbox:Snapshot\", xPathContext);\n    if (cur != NULL) {\n        machineDescription->snapshot = virVBoxSnapshotConfRetrieveSnapshot(cur, xPathContext);\n        if (!machineDescription->snapshot)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    xmlXPathFreeContext(xPathContext);\n    xmlFreeDoc(xml);\n\n    VIR_FREE(currentStateModifiedString);\n    VIR_FREE(currentSnapshotAttribute);\n    virStringListFree(searchResultTab);\n    if (ret < 0) {\n        virVBoxSnapshotConfMachineFree(machineDescription);\n        machineDescription = NULL;\n    }\n    return machineDescription;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfMachineFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "555-572",
    "snippet": "void\nvirVBoxSnapshotConfMachineFree(virVBoxSnapshotConfMachinePtr machine)\n{\n    if (!machine)\n        return;\n\n    VIR_FREE(machine->uuid);\n    VIR_FREE(machine->name);\n    VIR_FREE(machine->currentSnapshot);\n    VIR_FREE(machine->snapshotFolder);\n    VIR_FREE(machine->lastStateChange);\n    virVBoxSnapshotConfMediaRegistryFree(machine->mediaRegistry);\n    VIR_FREE(machine->hardware);\n    VIR_FREE(machine->extraData);\n    virVBoxSnapshotConfSnapshotFree(machine->snapshot);\n    VIR_FREE(machine->storageController);\n    VIR_FREE(machine);\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machine"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machine->storageController"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfSnapshotFree",
          "args": [
            "machine->snapshot"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfSnapshotFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "535-553",
          "snippet": "void\nvirVBoxSnapshotConfSnapshotFree(virVBoxSnapshotConfSnapshotPtr snapshot)\n{\n    size_t i = 0;\n\n    if (!snapshot)\n        return;\n\n    VIR_FREE(snapshot->uuid);\n    VIR_FREE(snapshot->name);\n    VIR_FREE(snapshot->timeStamp);\n    VIR_FREE(snapshot->description);\n    VIR_FREE(snapshot->hardware);\n    VIR_FREE(snapshot->storageController);\n    for (i = 0; i < snapshot->nchildren; i++)\n        virVBoxSnapshotConfSnapshotFree(snapshot->children[i]);\n    VIR_FREE(snapshot->children);\n    VIR_FREE(snapshot);\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvoid\nvirVBoxSnapshotConfSnapshotFree(virVBoxSnapshotConfSnapshotPtr snapshot)\n{\n    size_t i = 0;\n\n    if (!snapshot)\n        return;\n\n    VIR_FREE(snapshot->uuid);\n    VIR_FREE(snapshot->name);\n    VIR_FREE(snapshot->timeStamp);\n    VIR_FREE(snapshot->description);\n    VIR_FREE(snapshot->hardware);\n    VIR_FREE(snapshot->storageController);\n    for (i = 0; i < snapshot->nchildren; i++)\n        virVBoxSnapshotConfSnapshotFree(snapshot->children[i]);\n    VIR_FREE(snapshot->children);\n    VIR_FREE(snapshot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machine->extraData"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machine->hardware"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfMediaRegistryFree",
          "args": [
            "machine->mediaRegistry"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfMediaRegistryFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "518-533",
          "snippet": "void\nvirVBoxSnapshotConfMediaRegistryFree(virVBoxSnapshotConfMediaRegistryPtr mediaRegistry)\n{\n    size_t i = 0;\n\n    if (!mediaRegistry)\n        return;\n\n    for (i = 0; i < mediaRegistry->ndisks; i++)\n        virVboxSnapshotConfHardDiskFree(mediaRegistry->disks[i]);\n    VIR_FREE(mediaRegistry->disks);\n    for (i = 0; i < mediaRegistry->notherMedia; i++)\n        VIR_FREE(mediaRegistry->otherMedia[i]);\n    VIR_FREE(mediaRegistry->otherMedia);\n    VIR_FREE(mediaRegistry);\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvoid\nvirVBoxSnapshotConfMediaRegistryFree(virVBoxSnapshotConfMediaRegistryPtr mediaRegistry)\n{\n    size_t i = 0;\n\n    if (!mediaRegistry)\n        return;\n\n    for (i = 0; i < mediaRegistry->ndisks; i++)\n        virVboxSnapshotConfHardDiskFree(mediaRegistry->disks[i]);\n    VIR_FREE(mediaRegistry->disks);\n    for (i = 0; i < mediaRegistry->notherMedia; i++)\n        VIR_FREE(mediaRegistry->otherMedia[i]);\n    VIR_FREE(mediaRegistry->otherMedia);\n    VIR_FREE(mediaRegistry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machine->lastStateChange"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machine->snapshotFolder"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machine->currentSnapshot"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machine->name"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machine->uuid"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvoid\nvirVBoxSnapshotConfMachineFree(virVBoxSnapshotConfMachinePtr machine)\n{\n    if (!machine)\n        return;\n\n    VIR_FREE(machine->uuid);\n    VIR_FREE(machine->name);\n    VIR_FREE(machine->currentSnapshot);\n    VIR_FREE(machine->snapshotFolder);\n    VIR_FREE(machine->lastStateChange);\n    virVBoxSnapshotConfMediaRegistryFree(machine->mediaRegistry);\n    VIR_FREE(machine->hardware);\n    VIR_FREE(machine->extraData);\n    virVBoxSnapshotConfSnapshotFree(machine->snapshot);\n    VIR_FREE(machine->storageController);\n    VIR_FREE(machine);\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfSnapshotFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "535-553",
    "snippet": "void\nvirVBoxSnapshotConfSnapshotFree(virVBoxSnapshotConfSnapshotPtr snapshot)\n{\n    size_t i = 0;\n\n    if (!snapshot)\n        return;\n\n    VIR_FREE(snapshot->uuid);\n    VIR_FREE(snapshot->name);\n    VIR_FREE(snapshot->timeStamp);\n    VIR_FREE(snapshot->description);\n    VIR_FREE(snapshot->hardware);\n    VIR_FREE(snapshot->storageController);\n    for (i = 0; i < snapshot->nchildren; i++)\n        virVBoxSnapshotConfSnapshotFree(snapshot->children[i]);\n    VIR_FREE(snapshot->children);\n    VIR_FREE(snapshot);\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshot"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshot->children"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfSnapshotFree",
          "args": [
            "snapshot->children[i]"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfSnapshotFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "535-553",
          "snippet": "void\nvirVBoxSnapshotConfSnapshotFree(virVBoxSnapshotConfSnapshotPtr snapshot)\n{\n    size_t i = 0;\n\n    if (!snapshot)\n        return;\n\n    VIR_FREE(snapshot->uuid);\n    VIR_FREE(snapshot->name);\n    VIR_FREE(snapshot->timeStamp);\n    VIR_FREE(snapshot->description);\n    VIR_FREE(snapshot->hardware);\n    VIR_FREE(snapshot->storageController);\n    for (i = 0; i < snapshot->nchildren; i++)\n        virVBoxSnapshotConfSnapshotFree(snapshot->children[i]);\n    VIR_FREE(snapshot->children);\n    VIR_FREE(snapshot);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshot->storageController"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshot->hardware"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshot->description"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshot->timeStamp"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshot->name"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshot->uuid"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvoid\nvirVBoxSnapshotConfSnapshotFree(virVBoxSnapshotConfSnapshotPtr snapshot)\n{\n    size_t i = 0;\n\n    if (!snapshot)\n        return;\n\n    VIR_FREE(snapshot->uuid);\n    VIR_FREE(snapshot->name);\n    VIR_FREE(snapshot->timeStamp);\n    VIR_FREE(snapshot->description);\n    VIR_FREE(snapshot->hardware);\n    VIR_FREE(snapshot->storageController);\n    for (i = 0; i < snapshot->nchildren; i++)\n        virVBoxSnapshotConfSnapshotFree(snapshot->children[i]);\n    VIR_FREE(snapshot->children);\n    VIR_FREE(snapshot);\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfMediaRegistryFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "518-533",
    "snippet": "void\nvirVBoxSnapshotConfMediaRegistryFree(virVBoxSnapshotConfMediaRegistryPtr mediaRegistry)\n{\n    size_t i = 0;\n\n    if (!mediaRegistry)\n        return;\n\n    for (i = 0; i < mediaRegistry->ndisks; i++)\n        virVboxSnapshotConfHardDiskFree(mediaRegistry->disks[i]);\n    VIR_FREE(mediaRegistry->disks);\n    for (i = 0; i < mediaRegistry->notherMedia; i++)\n        VIR_FREE(mediaRegistry->otherMedia[i]);\n    VIR_FREE(mediaRegistry->otherMedia);\n    VIR_FREE(mediaRegistry);\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mediaRegistry"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mediaRegistry->otherMedia"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mediaRegistry->otherMedia[i]"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mediaRegistry->disks"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVboxSnapshotConfHardDiskFree",
          "args": [
            "mediaRegistry->disks[i]"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "virVboxSnapshotConfHardDiskFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "499-515",
          "snippet": "void\nvirVboxSnapshotConfHardDiskFree(virVBoxSnapshotConfHardDiskPtr disk)\n{\n    size_t i = 0;\n\n    if (!disk)\n        return;\n\n    VIR_FREE(disk->uuid);\n    VIR_FREE(disk->location);\n    VIR_FREE(disk->format);\n    VIR_FREE(disk->type);\n    for (i = 0; i < disk->nchildren; i++)\n        virVboxSnapshotConfHardDiskFree(disk->children[i]);\n    VIR_FREE(disk->children);\n    VIR_FREE(disk);\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvoid\nvirVboxSnapshotConfHardDiskFree(virVBoxSnapshotConfHardDiskPtr disk)\n{\n    size_t i = 0;\n\n    if (!disk)\n        return;\n\n    VIR_FREE(disk->uuid);\n    VIR_FREE(disk->location);\n    VIR_FREE(disk->format);\n    VIR_FREE(disk->type);\n    for (i = 0; i < disk->nchildren; i++)\n        virVboxSnapshotConfHardDiskFree(disk->children[i]);\n    VIR_FREE(disk->children);\n    VIR_FREE(disk);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvoid\nvirVBoxSnapshotConfMediaRegistryFree(virVBoxSnapshotConfMediaRegistryPtr mediaRegistry)\n{\n    size_t i = 0;\n\n    if (!mediaRegistry)\n        return;\n\n    for (i = 0; i < mediaRegistry->ndisks; i++)\n        virVboxSnapshotConfHardDiskFree(mediaRegistry->disks[i]);\n    VIR_FREE(mediaRegistry->disks);\n    for (i = 0; i < mediaRegistry->notherMedia; i++)\n        VIR_FREE(mediaRegistry->otherMedia[i]);\n    VIR_FREE(mediaRegistry->otherMedia);\n    VIR_FREE(mediaRegistry);\n}"
  },
  {
    "function_name": "virVboxSnapshotConfHardDiskFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "499-515",
    "snippet": "void\nvirVboxSnapshotConfHardDiskFree(virVBoxSnapshotConfHardDiskPtr disk)\n{\n    size_t i = 0;\n\n    if (!disk)\n        return;\n\n    VIR_FREE(disk->uuid);\n    VIR_FREE(disk->location);\n    VIR_FREE(disk->format);\n    VIR_FREE(disk->type);\n    for (i = 0; i < disk->nchildren; i++)\n        virVboxSnapshotConfHardDiskFree(disk->children[i]);\n    VIR_FREE(disk->children);\n    VIR_FREE(disk);\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "disk"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "disk->children"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVboxSnapshotConfHardDiskFree",
          "args": [
            "disk->children[i]"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "virVboxSnapshotConfHardDiskFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "499-515",
          "snippet": "void\nvirVboxSnapshotConfHardDiskFree(virVBoxSnapshotConfHardDiskPtr disk)\n{\n    size_t i = 0;\n\n    if (!disk)\n        return;\n\n    VIR_FREE(disk->uuid);\n    VIR_FREE(disk->location);\n    VIR_FREE(disk->format);\n    VIR_FREE(disk->type);\n    for (i = 0; i < disk->nchildren; i++)\n        virVboxSnapshotConfHardDiskFree(disk->children[i]);\n    VIR_FREE(disk->children);\n    VIR_FREE(disk);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "disk->type"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "disk->format"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "disk->location"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "disk->uuid"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvoid\nvirVboxSnapshotConfHardDiskFree(virVBoxSnapshotConfHardDiskPtr disk)\n{\n    size_t i = 0;\n\n    if (!disk)\n        return;\n\n    VIR_FREE(disk->uuid);\n    VIR_FREE(disk->location);\n    VIR_FREE(disk->format);\n    VIR_FREE(disk->type);\n    for (i = 0; i < disk->nchildren; i++)\n        virVboxSnapshotConfHardDiskFree(disk->children[i]);\n    VIR_FREE(disk->children);\n    VIR_FREE(disk);\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfAllChildren",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "461-497",
    "snippet": "static size_t\nvirVBoxSnapshotConfAllChildren(virVBoxSnapshotConfHardDiskPtr disk,\n                               virVBoxSnapshotConfHardDiskPtr **list)\n{\n    size_t returnSize = 0;\n    size_t tempSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *ret = NULL;\n    virVBoxSnapshotConfHardDiskPtr *tempList = NULL;\n    size_t i = 0;\n    size_t j = 0;\n\n    if (VIR_ALLOC_N(ret, 0) < 0)\n        return 0;\n\n    for (i = 0; i < disk->nchildren; i++) {\n        tempSize = virVBoxSnapshotConfAllChildren(disk->children[i], &tempList);\n        if (VIR_EXPAND_N(ret, returnSize, tempSize) < 0)\n            goto error;\n\n        for (j = 0; j < tempSize; j++)\n            ret[returnSize - tempSize + j] = tempList[j];\n\n        VIR_FREE(tempList);\n    }\n\n    if (VIR_EXPAND_N(ret, returnSize, 1) < 0)\n        goto error;\n\n    ret[returnSize - 1] = disk;\n    *list = ret;\n    return returnSize;\n\n error:\n    VIR_FREE(tempList);\n    VIR_FREE(ret);\n    return 0;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ret"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tempList"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "ret",
            "returnSize",
            "1"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tempList"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "ret",
            "returnSize",
            "tempSize"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfAllChildren",
          "args": [
            "disk->children[i]",
            "&tempList"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfAllChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "461-497",
          "snippet": "static size_t\nvirVBoxSnapshotConfAllChildren(virVBoxSnapshotConfHardDiskPtr disk,\n                               virVBoxSnapshotConfHardDiskPtr **list)\n{\n    size_t returnSize = 0;\n    size_t tempSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *ret = NULL;\n    virVBoxSnapshotConfHardDiskPtr *tempList = NULL;\n    size_t i = 0;\n    size_t j = 0;\n\n    if (VIR_ALLOC_N(ret, 0) < 0)\n        return 0;\n\n    for (i = 0; i < disk->nchildren; i++) {\n        tempSize = virVBoxSnapshotConfAllChildren(disk->children[i], &tempList);\n        if (VIR_EXPAND_N(ret, returnSize, tempSize) < 0)\n            goto error;\n\n        for (j = 0; j < tempSize; j++)\n            ret[returnSize - tempSize + j] = tempList[j];\n\n        VIR_FREE(tempList);\n    }\n\n    if (VIR_EXPAND_N(ret, returnSize, 1) < 0)\n        goto error;\n\n    ret[returnSize - 1] = disk;\n    *list = ret;\n    return returnSize;\n\n error:\n    VIR_FREE(tempList);\n    VIR_FREE(ret);\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "ret",
            "0"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic size_t\nvirVBoxSnapshotConfAllChildren(virVBoxSnapshotConfHardDiskPtr disk,\n                               virVBoxSnapshotConfHardDiskPtr **list)\n{\n    size_t returnSize = 0;\n    size_t tempSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *ret = NULL;\n    virVBoxSnapshotConfHardDiskPtr *tempList = NULL;\n    size_t i = 0;\n    size_t j = 0;\n\n    if (VIR_ALLOC_N(ret, 0) < 0)\n        return 0;\n\n    for (i = 0; i < disk->nchildren; i++) {\n        tempSize = virVBoxSnapshotConfAllChildren(disk->children[i], &tempList);\n        if (VIR_EXPAND_N(ret, returnSize, tempSize) < 0)\n            goto error;\n\n        for (j = 0; j < tempSize; j++)\n            ret[returnSize - tempSize + j] = tempList[j];\n\n        VIR_FREE(tempList);\n    }\n\n    if (VIR_EXPAND_N(ret, returnSize, 1) < 0)\n        goto error;\n\n    ret[returnSize - 1] = disk;\n    *list = ret;\n    return returnSize;\n\n error:\n    VIR_FREE(tempList);\n    VIR_FREE(ret);\n    return 0;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfSerializeSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "361-459",
    "snippet": "static int\nvirVBoxSnapshotConfSerializeSnapshot(xmlNodePtr node,\n                                     virVBoxSnapshotConfSnapshotPtr snapshot)\n{\n    int result = -1;\n    size_t i = 0;\n    xmlNodePtr descriptionNode = NULL;\n    xmlNodePtr snapshotsNode = NULL;\n    xmlNodePtr hardwareNode = NULL;\n    xmlNodePtr storageControllerNode = NULL;\n    xmlParserErrors parseError = XML_ERR_OK;\n    char *uuid = NULL;\n    char *timeStamp = NULL;\n\n    char **firstRegex = NULL;\n    int firstRegexResult = 0;\n    char **secondRegex = NULL;\n    int secondRegexResult = 0;\n\n    uuid = g_strdup_printf(\"{%s}\", snapshot->uuid);\n\n    if (xmlNewProp(node, BAD_CAST \"uuid\", BAD_CAST uuid) == NULL)\n        goto cleanup;\n    if (xmlNewProp(node, BAD_CAST \"name\", BAD_CAST snapshot->name) == NULL)\n        goto cleanup;\n\n    /* We change the date format from \"yyyy-MM-dd hh:mm:ss.msec+timeZone\"\n     * to \"yyyy-MM-ddThh:mm:ssZ\" */\n    firstRegexResult = virStringSearch(snapshot->timeStamp,\n                                       \"([0-9]{4}-[0-9]{2}-[0-9]{2})\",\n                                       1,\n                                       &firstRegex);\n    secondRegexResult = virStringSearch(snapshot->timeStamp,\n                                        \"([0-9]{2}:[0-9]{2}:[0-9]{2})\",\n                                        1,\n                                        &secondRegex);\n    if (firstRegexResult < 1)\n        goto cleanup;\n    if (secondRegexResult < 1)\n        goto cleanup;\n    timeStamp = g_strdup_printf(\"%sT%sZ\", firstRegex[0], secondRegex[0]);\n\n    if (xmlNewProp(node, BAD_CAST \"timeStamp\", BAD_CAST timeStamp) == NULL)\n        goto cleanup;\n\n    /* node description */\n    if (snapshot->description != NULL) {\n        descriptionNode = xmlNewNode(NULL, BAD_CAST \"Description\");\n        xmlNodeSetContent(descriptionNode, BAD_CAST snapshot->description);\n        xmlAddChild(node, descriptionNode);\n    }\n    /* hardware */\n    parseError = xmlParseInNodeContext(node,\n                                       snapshot->hardware,\n                                       (int)strlen(snapshot->hardware),\n                                       0,\n                                       &hardwareNode);\n    if (parseError != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add the snapshot hardware\"));\n        goto cleanup;\n    }\n    xmlAddChild(node, hardwareNode);\n\n    /* storageController */\n    if (xmlParseInNodeContext(node, snapshot->storageController,\n                              (int)strlen(snapshot->storageController),\n                              0,\n                              &storageControllerNode) != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add the snapshot storageController\"));\n        goto cleanup;\n    }\n    xmlAddChild(node, storageControllerNode);\n\n    if (snapshot->nchildren > 0) {\n        snapshotsNode = xmlNewNode(NULL, BAD_CAST \"Snapshots\");\n        xmlAddChild(node, snapshotsNode);\n        for (i = 0; i < snapshot->nchildren; i++) {\n            xmlNodePtr child = xmlNewNode(NULL, BAD_CAST \"Snapshot\");\n            xmlAddChild(snapshotsNode, child);\n            if (virVBoxSnapshotConfSerializeSnapshot(child, snapshot->children[i]) < 0)\n                goto cleanup;\n        }\n    }\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        xmlFreeNode(descriptionNode);\n        xmlUnlinkNode(snapshotsNode);\n        xmlFreeNode(snapshotsNode);\n    }\n    virStringListFree(firstRegex);\n    virStringListFree(secondRegex);\n    VIR_FREE(uuid);\n    VIR_FREE(timeStamp);\n    return result;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "timeStamp"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "secondRegex"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlFreeNode",
          "args": [
            "snapshotsNode"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlUnlinkNode",
          "args": [
            "snapshotsNode"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeNode",
          "args": [
            "descriptionNode"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfSerializeSnapshot",
          "args": [
            "child",
            "snapshot->children[i]"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfSerializeSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "361-459",
          "snippet": "static int\nvirVBoxSnapshotConfSerializeSnapshot(xmlNodePtr node,\n                                     virVBoxSnapshotConfSnapshotPtr snapshot)\n{\n    int result = -1;\n    size_t i = 0;\n    xmlNodePtr descriptionNode = NULL;\n    xmlNodePtr snapshotsNode = NULL;\n    xmlNodePtr hardwareNode = NULL;\n    xmlNodePtr storageControllerNode = NULL;\n    xmlParserErrors parseError = XML_ERR_OK;\n    char *uuid = NULL;\n    char *timeStamp = NULL;\n\n    char **firstRegex = NULL;\n    int firstRegexResult = 0;\n    char **secondRegex = NULL;\n    int secondRegexResult = 0;\n\n    uuid = g_strdup_printf(\"{%s}\", snapshot->uuid);\n\n    if (xmlNewProp(node, BAD_CAST \"uuid\", BAD_CAST uuid) == NULL)\n        goto cleanup;\n    if (xmlNewProp(node, BAD_CAST \"name\", BAD_CAST snapshot->name) == NULL)\n        goto cleanup;\n\n    /* We change the date format from \"yyyy-MM-dd hh:mm:ss.msec+timeZone\"\n     * to \"yyyy-MM-ddThh:mm:ssZ\" */\n    firstRegexResult = virStringSearch(snapshot->timeStamp,\n                                       \"([0-9]{4}-[0-9]{2}-[0-9]{2})\",\n                                       1,\n                                       &firstRegex);\n    secondRegexResult = virStringSearch(snapshot->timeStamp,\n                                        \"([0-9]{2}:[0-9]{2}:[0-9]{2})\",\n                                        1,\n                                        &secondRegex);\n    if (firstRegexResult < 1)\n        goto cleanup;\n    if (secondRegexResult < 1)\n        goto cleanup;\n    timeStamp = g_strdup_printf(\"%sT%sZ\", firstRegex[0], secondRegex[0]);\n\n    if (xmlNewProp(node, BAD_CAST \"timeStamp\", BAD_CAST timeStamp) == NULL)\n        goto cleanup;\n\n    /* node description */\n    if (snapshot->description != NULL) {\n        descriptionNode = xmlNewNode(NULL, BAD_CAST \"Description\");\n        xmlNodeSetContent(descriptionNode, BAD_CAST snapshot->description);\n        xmlAddChild(node, descriptionNode);\n    }\n    /* hardware */\n    parseError = xmlParseInNodeContext(node,\n                                       snapshot->hardware,\n                                       (int)strlen(snapshot->hardware),\n                                       0,\n                                       &hardwareNode);\n    if (parseError != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add the snapshot hardware\"));\n        goto cleanup;\n    }\n    xmlAddChild(node, hardwareNode);\n\n    /* storageController */\n    if (xmlParseInNodeContext(node, snapshot->storageController,\n                              (int)strlen(snapshot->storageController),\n                              0,\n                              &storageControllerNode) != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add the snapshot storageController\"));\n        goto cleanup;\n    }\n    xmlAddChild(node, storageControllerNode);\n\n    if (snapshot->nchildren > 0) {\n        snapshotsNode = xmlNewNode(NULL, BAD_CAST \"Snapshots\");\n        xmlAddChild(node, snapshotsNode);\n        for (i = 0; i < snapshot->nchildren; i++) {\n            xmlNodePtr child = xmlNewNode(NULL, BAD_CAST \"Snapshot\");\n            xmlAddChild(snapshotsNode, child);\n            if (virVBoxSnapshotConfSerializeSnapshot(child, snapshot->children[i]) < 0)\n                goto cleanup;\n        }\n    }\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        xmlFreeNode(descriptionNode);\n        xmlUnlinkNode(snapshotsNode);\n        xmlFreeNode(snapshotsNode);\n    }\n    virStringListFree(firstRegex);\n    virStringListFree(secondRegex);\n    VIR_FREE(uuid);\n    VIR_FREE(timeStamp);\n    return result;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "xmlAddChild",
          "args": [
            "snapshotsNode",
            "child"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewNode",
          "args": [
            "NULL",
            "BAD_CAST \"Snapshot\""
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlAddChild",
          "args": [
            "node",
            "snapshotsNode"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewNode",
          "args": [
            "NULL",
            "BAD_CAST \"Snapshots\""
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlAddChild",
          "args": [
            "node",
            "storageControllerNode"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Unable to add the snapshot storageController\")"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to add the snapshot storageController\""
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlParseInNodeContext",
          "args": [
            "node",
            "snapshot->storageController",
            "(int)strlen(snapshot->storageController)",
            "0",
            "&storageControllerNode"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "snapshot->storageController"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlAddChild",
          "args": [
            "node",
            "hardwareNode"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Unable to add the snapshot hardware\")"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlParseInNodeContext",
          "args": [
            "node",
            "snapshot->hardware",
            "(int)strlen(snapshot->hardware)",
            "0",
            "&hardwareNode"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "snapshot->hardware"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlAddChild",
          "args": [
            "node",
            "descriptionNode"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNodeSetContent",
          "args": [
            "descriptionNode",
            "BAD_CASTsnapshot->description"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewNode",
          "args": [
            "NULL",
            "BAD_CAST \"Description\""
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewProp",
          "args": [
            "node",
            "BAD_CAST \"timeStamp\"",
            "BAD_CASTtimeStamp"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%sT%sZ\"",
            "firstRegex[0]",
            "secondRegex[0]"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringSearch",
          "args": [
            "snapshot->timeStamp",
            "\"([0-9]{2}:[0-9]{2}:[0-9]{2})\"",
            "1",
            "&secondRegex"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "965-1029",
          "snippet": "ssize_t\nvirStringSearch(const char *str,\n                const char *regexp,\n                size_t max_matches,\n                char ***matches)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    size_t nmatches = 0;\n    ssize_t ret = -1;\n\n    *matches = NULL;\n\n    VIR_DEBUG(\"search '%s' for '%s'\", str, regexp);\n\n    regex = g_regex_new(regexp, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (g_regex_get_capture_count(regex) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Regular expression '%s' must have exactly 1 match group, not %d\"),\n                       regexp, g_regex_get_capture_count(regex));\n        goto cleanup;\n    }\n\n    /* '*matches' must always be NULL terminated in every iteration\n     * of the loop, so start by allocating 1 element\n     */\n    if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n        goto cleanup;\n\n    while ((nmatches - 1) < max_matches) {\n        g_autoptr(GMatchInfo) info = NULL;\n        char *match;\n        int endpos;\n\n        if (!g_regex_match(regex, str, 0, &info))\n            break;\n\n        if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n            goto cleanup;\n\n        match = g_match_info_fetch(info, 1);\n\n        VIR_DEBUG(\"Got '%s'\", match);\n\n        (*matches)[nmatches-2] = match;\n\n        g_match_info_fetch_pos(info, 1, NULL, &endpos);\n        str += endpos;\n    }\n\n    ret = nmatches - 1; /* don't count the trailing null */\n\n cleanup:\n    if (ret < 0) {\n        virStringListFree(*matches);\n        *matches = NULL;\n    }\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nssize_t\nvirStringSearch(const char *str,\n                const char *regexp,\n                size_t max_matches,\n                char ***matches)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    size_t nmatches = 0;\n    ssize_t ret = -1;\n\n    *matches = NULL;\n\n    VIR_DEBUG(\"search '%s' for '%s'\", str, regexp);\n\n    regex = g_regex_new(regexp, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (g_regex_get_capture_count(regex) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Regular expression '%s' must have exactly 1 match group, not %d\"),\n                       regexp, g_regex_get_capture_count(regex));\n        goto cleanup;\n    }\n\n    /* '*matches' must always be NULL terminated in every iteration\n     * of the loop, so start by allocating 1 element\n     */\n    if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n        goto cleanup;\n\n    while ((nmatches - 1) < max_matches) {\n        g_autoptr(GMatchInfo) info = NULL;\n        char *match;\n        int endpos;\n\n        if (!g_regex_match(regex, str, 0, &info))\n            break;\n\n        if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n            goto cleanup;\n\n        match = g_match_info_fetch(info, 1);\n\n        VIR_DEBUG(\"Got '%s'\", match);\n\n        (*matches)[nmatches-2] = match;\n\n        g_match_info_fetch_pos(info, 1, NULL, &endpos);\n        str += endpos;\n    }\n\n    ret = nmatches - 1; /* don't count the trailing null */\n\n cleanup:\n    if (ret < 0) {\n        virStringListFree(*matches);\n        *matches = NULL;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlNewProp",
          "args": [
            "node",
            "BAD_CAST \"name\"",
            "BAD_CASTsnapshot->name"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewProp",
          "args": [
            "node",
            "BAD_CAST \"uuid\"",
            "BAD_CASTuuid"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic int\nvirVBoxSnapshotConfSerializeSnapshot(xmlNodePtr node,\n                                     virVBoxSnapshotConfSnapshotPtr snapshot)\n{\n    int result = -1;\n    size_t i = 0;\n    xmlNodePtr descriptionNode = NULL;\n    xmlNodePtr snapshotsNode = NULL;\n    xmlNodePtr hardwareNode = NULL;\n    xmlNodePtr storageControllerNode = NULL;\n    xmlParserErrors parseError = XML_ERR_OK;\n    char *uuid = NULL;\n    char *timeStamp = NULL;\n\n    char **firstRegex = NULL;\n    int firstRegexResult = 0;\n    char **secondRegex = NULL;\n    int secondRegexResult = 0;\n\n    uuid = g_strdup_printf(\"{%s}\", snapshot->uuid);\n\n    if (xmlNewProp(node, BAD_CAST \"uuid\", BAD_CAST uuid) == NULL)\n        goto cleanup;\n    if (xmlNewProp(node, BAD_CAST \"name\", BAD_CAST snapshot->name) == NULL)\n        goto cleanup;\n\n    /* We change the date format from \"yyyy-MM-dd hh:mm:ss.msec+timeZone\"\n     * to \"yyyy-MM-ddThh:mm:ssZ\" */\n    firstRegexResult = virStringSearch(snapshot->timeStamp,\n                                       \"([0-9]{4}-[0-9]{2}-[0-9]{2})\",\n                                       1,\n                                       &firstRegex);\n    secondRegexResult = virStringSearch(snapshot->timeStamp,\n                                        \"([0-9]{2}:[0-9]{2}:[0-9]{2})\",\n                                        1,\n                                        &secondRegex);\n    if (firstRegexResult < 1)\n        goto cleanup;\n    if (secondRegexResult < 1)\n        goto cleanup;\n    timeStamp = g_strdup_printf(\"%sT%sZ\", firstRegex[0], secondRegex[0]);\n\n    if (xmlNewProp(node, BAD_CAST \"timeStamp\", BAD_CAST timeStamp) == NULL)\n        goto cleanup;\n\n    /* node description */\n    if (snapshot->description != NULL) {\n        descriptionNode = xmlNewNode(NULL, BAD_CAST \"Description\");\n        xmlNodeSetContent(descriptionNode, BAD_CAST snapshot->description);\n        xmlAddChild(node, descriptionNode);\n    }\n    /* hardware */\n    parseError = xmlParseInNodeContext(node,\n                                       snapshot->hardware,\n                                       (int)strlen(snapshot->hardware),\n                                       0,\n                                       &hardwareNode);\n    if (parseError != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add the snapshot hardware\"));\n        goto cleanup;\n    }\n    xmlAddChild(node, hardwareNode);\n\n    /* storageController */\n    if (xmlParseInNodeContext(node, snapshot->storageController,\n                              (int)strlen(snapshot->storageController),\n                              0,\n                              &storageControllerNode) != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add the snapshot storageController\"));\n        goto cleanup;\n    }\n    xmlAddChild(node, storageControllerNode);\n\n    if (snapshot->nchildren > 0) {\n        snapshotsNode = xmlNewNode(NULL, BAD_CAST \"Snapshots\");\n        xmlAddChild(node, snapshotsNode);\n        for (i = 0; i < snapshot->nchildren; i++) {\n            xmlNodePtr child = xmlNewNode(NULL, BAD_CAST \"Snapshot\");\n            xmlAddChild(snapshotsNode, child);\n            if (virVBoxSnapshotConfSerializeSnapshot(child, snapshot->children[i]) < 0)\n                goto cleanup;\n        }\n    }\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        xmlFreeNode(descriptionNode);\n        xmlUnlinkNode(snapshotsNode);\n        xmlFreeNode(snapshotsNode);\n    }\n    virStringListFree(firstRegex);\n    virStringListFree(secondRegex);\n    VIR_FREE(uuid);\n    VIR_FREE(timeStamp);\n    return result;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfCreateHardDiskNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "326-359",
    "snippet": "static xmlNodePtr\nvirVBoxSnapshotConfCreateHardDiskNode(virVBoxSnapshotConfHardDiskPtr hardDisk)\n{\n    int result = -1;\n    size_t i = 0;\n    char *uuid = NULL;\n    xmlNodePtr ret = xmlNewNode(NULL, BAD_CAST \"HardDisk\");\n    uuid = g_strdup_printf(\"{%s}\", hardDisk->uuid);\n\n    if (xmlNewProp(ret, BAD_CAST \"uuid\", BAD_CAST uuid) == NULL)\n        goto cleanup;\n    if (xmlNewProp(ret, BAD_CAST \"location\", BAD_CAST hardDisk->location) == NULL)\n        goto cleanup;\n    if (xmlNewProp(ret, BAD_CAST \"format\", BAD_CAST hardDisk->format) == NULL)\n        goto cleanup;\n    if (hardDisk->type != NULL && xmlNewProp(ret, BAD_CAST \"type\", BAD_CAST hardDisk->type) == NULL)\n        goto cleanup;\n\n    for (i = 0; i < hardDisk->nchildren; i++) {\n        xmlNodePtr child = virVBoxSnapshotConfCreateHardDiskNode(hardDisk->children[i]);\n        if (child != NULL)\n            xmlAddChild(ret, child);\n    }\n\n    result = 0;\n cleanup:\n    if (result < 0) {\n        xmlUnlinkNode(ret);\n        xmlFreeNode(ret);\n        ret = NULL;\n    }\n    VIR_FREE(uuid);\n    return ret;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeNode",
          "args": [
            "ret"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlUnlinkNode",
          "args": [
            "ret"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlAddChild",
          "args": [
            "ret",
            "child"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfCreateHardDiskNode",
          "args": [
            "hardDisk->children[i]"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfCreateHardDiskNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "326-359",
          "snippet": "static xmlNodePtr\nvirVBoxSnapshotConfCreateHardDiskNode(virVBoxSnapshotConfHardDiskPtr hardDisk)\n{\n    int result = -1;\n    size_t i = 0;\n    char *uuid = NULL;\n    xmlNodePtr ret = xmlNewNode(NULL, BAD_CAST \"HardDisk\");\n    uuid = g_strdup_printf(\"{%s}\", hardDisk->uuid);\n\n    if (xmlNewProp(ret, BAD_CAST \"uuid\", BAD_CAST uuid) == NULL)\n        goto cleanup;\n    if (xmlNewProp(ret, BAD_CAST \"location\", BAD_CAST hardDisk->location) == NULL)\n        goto cleanup;\n    if (xmlNewProp(ret, BAD_CAST \"format\", BAD_CAST hardDisk->format) == NULL)\n        goto cleanup;\n    if (hardDisk->type != NULL && xmlNewProp(ret, BAD_CAST \"type\", BAD_CAST hardDisk->type) == NULL)\n        goto cleanup;\n\n    for (i = 0; i < hardDisk->nchildren; i++) {\n        xmlNodePtr child = virVBoxSnapshotConfCreateHardDiskNode(hardDisk->children[i]);\n        if (child != NULL)\n            xmlAddChild(ret, child);\n    }\n\n    result = 0;\n cleanup:\n    if (result < 0) {\n        xmlUnlinkNode(ret);\n        xmlFreeNode(ret);\n        ret = NULL;\n    }\n    VIR_FREE(uuid);\n    return ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "xmlNewProp",
          "args": [
            "ret",
            "BAD_CAST \"type\"",
            "BAD_CASThardDisk->type"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewProp",
          "args": [
            "ret",
            "BAD_CAST \"format\"",
            "BAD_CASThardDisk->format"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewProp",
          "args": [
            "ret",
            "BAD_CAST \"location\"",
            "BAD_CASThardDisk->location"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewProp",
          "args": [
            "ret",
            "BAD_CAST \"uuid\"",
            "BAD_CASTuuid"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"{%s}\"",
            "hardDisk->uuid"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlNewNode",
          "args": [
            "NULL",
            "BAD_CAST \"HardDisk\""
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic xmlNodePtr\nvirVBoxSnapshotConfCreateHardDiskNode(virVBoxSnapshotConfHardDiskPtr hardDisk)\n{\n    int result = -1;\n    size_t i = 0;\n    char *uuid = NULL;\n    xmlNodePtr ret = xmlNewNode(NULL, BAD_CAST \"HardDisk\");\n    uuid = g_strdup_printf(\"{%s}\", hardDisk->uuid);\n\n    if (xmlNewProp(ret, BAD_CAST \"uuid\", BAD_CAST uuid) == NULL)\n        goto cleanup;\n    if (xmlNewProp(ret, BAD_CAST \"location\", BAD_CAST hardDisk->location) == NULL)\n        goto cleanup;\n    if (xmlNewProp(ret, BAD_CAST \"format\", BAD_CAST hardDisk->format) == NULL)\n        goto cleanup;\n    if (hardDisk->type != NULL && xmlNewProp(ret, BAD_CAST \"type\", BAD_CAST hardDisk->type) == NULL)\n        goto cleanup;\n\n    for (i = 0; i < hardDisk->nchildren; i++) {\n        xmlNodePtr child = virVBoxSnapshotConfCreateHardDiskNode(hardDisk->children[i]);\n        if (child != NULL)\n            xmlAddChild(ret, child);\n    }\n\n    result = 0;\n cleanup:\n    if (result < 0) {\n        xmlUnlinkNode(ret);\n        xmlFreeNode(ret);\n        ret = NULL;\n    }\n    VIR_FREE(uuid);\n    return ret;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfHardDiskByLocation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "310-324",
    "snippet": "static virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskByLocation(virVBoxSnapshotConfHardDiskPtr disk,\n                                      const char *parentLocation)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr ret = NULL;\n    if (STREQ(disk->location, parentLocation))\n        return disk;\n    for (i = 0; i < disk->nchildren; i++) {\n        ret = virVBoxSnapshotConfHardDiskByLocation(disk->children[i], parentLocation);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfHardDiskByLocation",
          "args": [
            "disk->children[i]",
            "parentLocation"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfHardDiskByLocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "310-324",
          "snippet": "static virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskByLocation(virVBoxSnapshotConfHardDiskPtr disk,\n                                      const char *parentLocation)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr ret = NULL;\n    if (STREQ(disk->location, parentLocation))\n        return disk;\n    for (i = 0; i < disk->nchildren; i++) {\n        ret = virVBoxSnapshotConfHardDiskByLocation(disk->children[i], parentLocation);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "disk->location",
            "parentLocation"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskByLocation(virVBoxSnapshotConfHardDiskPtr disk,\n                                      const char *parentLocation)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr ret = NULL;\n    if (STREQ(disk->location, parentLocation))\n        return disk;\n    for (i = 0; i < disk->nchildren; i++) {\n        ret = virVBoxSnapshotConfHardDiskByLocation(disk->children[i], parentLocation);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfHardDiskById",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "294-308",
    "snippet": "static virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskById(virVBoxSnapshotConfHardDiskPtr disk,\n                                const char *parentHardDiskId)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr ret = NULL;\n    if (STREQ(disk->uuid, parentHardDiskId))\n        return disk;\n    for (i = 0; i < disk->nchildren; i++) {\n        ret = virVBoxSnapshotConfHardDiskById(disk->children[i], parentHardDiskId);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfHardDiskById",
          "args": [
            "disk->children[i]",
            "parentHardDiskId"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfHardDiskById",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "294-308",
          "snippet": "static virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskById(virVBoxSnapshotConfHardDiskPtr disk,\n                                const char *parentHardDiskId)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr ret = NULL;\n    if (STREQ(disk->uuid, parentHardDiskId))\n        return disk;\n    for (i = 0; i < disk->nchildren; i++) {\n        ret = virVBoxSnapshotConfHardDiskById(disk->children[i], parentHardDiskId);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "disk->uuid",
            "parentHardDiskId"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskById(virVBoxSnapshotConfHardDiskPtr disk,\n                                const char *parentHardDiskId)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr ret = NULL;\n    if (STREQ(disk->uuid, parentHardDiskId))\n        return disk;\n    for (i = 0; i < disk->nchildren; i++) {\n        ret = virVBoxSnapshotConfHardDiskById(disk->children[i], parentHardDiskId);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfSnapshotByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "278-292",
    "snippet": "virVBoxSnapshotConfSnapshotPtr\nvirVBoxSnapshotConfSnapshotByName(virVBoxSnapshotConfSnapshotPtr snapshot,\n                                  const char *snapshotName)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfSnapshotPtr ret = NULL;\n    if (STREQ(snapshot->name, snapshotName))\n        return snapshot;\n    for (i = 0; i < snapshot->nchildren; i++) {\n        ret = virVBoxSnapshotConfSnapshotByName(snapshot->children[i], snapshotName);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfSnapshotByName",
          "args": [
            "snapshot->children[i]",
            "snapshotName"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfSnapshotByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "278-292",
          "snippet": "virVBoxSnapshotConfSnapshotPtr\nvirVBoxSnapshotConfSnapshotByName(virVBoxSnapshotConfSnapshotPtr snapshot,\n                                  const char *snapshotName)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfSnapshotPtr ret = NULL;\n    if (STREQ(snapshot->name, snapshotName))\n        return snapshot;\n    for (i = 0; i < snapshot->nchildren; i++) {\n        ret = virVBoxSnapshotConfSnapshotByName(snapshot->children[i], snapshotName);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "snapshot->name",
            "snapshotName"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvirVBoxSnapshotConfSnapshotPtr\nvirVBoxSnapshotConfSnapshotByName(virVBoxSnapshotConfSnapshotPtr snapshot,\n                                  const char *snapshotName)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfSnapshotPtr ret = NULL;\n    if (STREQ(snapshot->name, snapshotName))\n        return snapshot;\n    for (i = 0; i < snapshot->nchildren; i++) {\n        ret = virVBoxSnapshotConfSnapshotByName(snapshot->children[i], snapshotName);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfRetrieveSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "176-276",
    "snippet": "static virVBoxSnapshotConfSnapshotPtr\nvirVBoxSnapshotConfRetrieveSnapshot(xmlNodePtr snapshotNode,\n                                    xmlXPathContextPtr xPathContext)\n{\n    virVBoxSnapshotConfSnapshotPtr snapshot = NULL;\n    xmlNodePtr hardwareNode = NULL;\n    xmlNodePtr descriptionNode = NULL;\n    xmlNodePtr storageControllerNode = NULL;\n    xmlNodePtr snapshotsNode = NULL;\n    xmlNodePtr *nodes = NULL;\n    char *uuid = NULL;\n    char **searchTabResult = NULL;\n    int resultSize = 0;\n    size_t i = 0;\n    int result = -1;\n    int n = 0;\n\n    if (VIR_ALLOC(snapshot) < 0)\n        goto cleanup;\n\n    uuid = virXMLPropString(snapshotNode, \"uuid\");\n    /* we use virStringSearch because the uuid is between brackets */\n    resultSize = virStringSearch(uuid,\n                                 VBOX_UUID_REGEX,\n                                 1,\n                                 &searchTabResult);\n    if (resultSize != 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> 'uuid' attribute\"));\n        goto cleanup;\n    }\n    snapshot->uuid = g_strdup(searchTabResult[0]);\n\n    snapshot->name = virXMLPropString(snapshotNode, \"name\");\n    if (snapshot->name == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> 'name' attribute\"));\n        goto cleanup;\n    }\n    snapshot->timeStamp = virXMLPropString(snapshotNode, \"timeStamp\");\n    if (snapshot->timeStamp == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> 'timeStamp' attribute\"));\n        goto cleanup;\n    }\n\n    xPathContext->node = snapshotNode;\n    descriptionNode = virXPathNode(\"./vbox:Description\", xPathContext);\n    if (descriptionNode != NULL)\n        snapshot->description = virXMLNodeToString(descriptionNode->doc, descriptionNode);\n\n    hardwareNode = virXPathNode(\"./vbox:Hardware\", xPathContext);\n    if (hardwareNode == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> <Hardware> node\"));\n        goto cleanup;\n    }\n    snapshot->hardware = virXMLNodeToString(snapshotNode->doc, hardwareNode);\n\n    storageControllerNode = virXPathNode(\"./vbox:StorageControllers\", xPathContext);\n    if (storageControllerNode == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> <StorageControllers> node\"));\n        goto cleanup;\n    }\n    snapshot->storageController = virXMLNodeToString(snapshotNode->doc,\n                                                     storageControllerNode);\n\n    snapshotsNode = virXPathNode(\"./vbox:Snapshots\", xPathContext);\n\n    if (snapshotsNode != NULL) {\n        xPathContext->node = snapshotsNode;\n        n = virXPathNodeSet(\"./vbox:Snapshot\", xPathContext, &nodes);\n        if (n < 0)\n            goto cleanup;\n        if (n && VIR_ALLOC_N(snapshot->children, n) < 0)\n            goto cleanup;\n        snapshot->nchildren = n;\n        for (i = 0; i < snapshot->nchildren; i++) {\n            snapshot->children[i] = virVBoxSnapshotConfRetrieveSnapshot(nodes[i], xPathContext);\n            if (snapshot->children[i] == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Cannot create a vboxSnapshotXmlSnapshotPtr\"));\n                goto cleanup;\n            }\n            snapshot->children[i]->parent = snapshot;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virVBoxSnapshotConfSnapshotFree(snapshot);\n        snapshot = NULL;\n    }\n    VIR_FREE(nodes);\n    VIR_FREE(uuid);\n    virStringListFree(searchTabResult);\n    return snapshot;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "searchTabResult"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfSnapshotFree",
          "args": [
            "snapshot"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfSnapshotFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "535-553",
          "snippet": "void\nvirVBoxSnapshotConfSnapshotFree(virVBoxSnapshotConfSnapshotPtr snapshot)\n{\n    size_t i = 0;\n\n    if (!snapshot)\n        return;\n\n    VIR_FREE(snapshot->uuid);\n    VIR_FREE(snapshot->name);\n    VIR_FREE(snapshot->timeStamp);\n    VIR_FREE(snapshot->description);\n    VIR_FREE(snapshot->hardware);\n    VIR_FREE(snapshot->storageController);\n    for (i = 0; i < snapshot->nchildren; i++)\n        virVBoxSnapshotConfSnapshotFree(snapshot->children[i]);\n    VIR_FREE(snapshot->children);\n    VIR_FREE(snapshot);\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvoid\nvirVBoxSnapshotConfSnapshotFree(virVBoxSnapshotConfSnapshotPtr snapshot)\n{\n    size_t i = 0;\n\n    if (!snapshot)\n        return;\n\n    VIR_FREE(snapshot->uuid);\n    VIR_FREE(snapshot->name);\n    VIR_FREE(snapshot->timeStamp);\n    VIR_FREE(snapshot->description);\n    VIR_FREE(snapshot->hardware);\n    VIR_FREE(snapshot->storageController);\n    for (i = 0; i < snapshot->nchildren; i++)\n        virVBoxSnapshotConfSnapshotFree(snapshot->children[i]);\n    VIR_FREE(snapshot->children);\n    VIR_FREE(snapshot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot create a vboxSnapshotXmlSnapshotPtr\")"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot create a vboxSnapshotXmlSnapshotPtr\""
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfRetrieveSnapshot",
          "args": [
            "nodes[i]",
            "xPathContext"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfRetrieveSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "176-276",
          "snippet": "static virVBoxSnapshotConfSnapshotPtr\nvirVBoxSnapshotConfRetrieveSnapshot(xmlNodePtr snapshotNode,\n                                    xmlXPathContextPtr xPathContext)\n{\n    virVBoxSnapshotConfSnapshotPtr snapshot = NULL;\n    xmlNodePtr hardwareNode = NULL;\n    xmlNodePtr descriptionNode = NULL;\n    xmlNodePtr storageControllerNode = NULL;\n    xmlNodePtr snapshotsNode = NULL;\n    xmlNodePtr *nodes = NULL;\n    char *uuid = NULL;\n    char **searchTabResult = NULL;\n    int resultSize = 0;\n    size_t i = 0;\n    int result = -1;\n    int n = 0;\n\n    if (VIR_ALLOC(snapshot) < 0)\n        goto cleanup;\n\n    uuid = virXMLPropString(snapshotNode, \"uuid\");\n    /* we use virStringSearch because the uuid is between brackets */\n    resultSize = virStringSearch(uuid,\n                                 VBOX_UUID_REGEX,\n                                 1,\n                                 &searchTabResult);\n    if (resultSize != 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> 'uuid' attribute\"));\n        goto cleanup;\n    }\n    snapshot->uuid = g_strdup(searchTabResult[0]);\n\n    snapshot->name = virXMLPropString(snapshotNode, \"name\");\n    if (snapshot->name == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> 'name' attribute\"));\n        goto cleanup;\n    }\n    snapshot->timeStamp = virXMLPropString(snapshotNode, \"timeStamp\");\n    if (snapshot->timeStamp == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> 'timeStamp' attribute\"));\n        goto cleanup;\n    }\n\n    xPathContext->node = snapshotNode;\n    descriptionNode = virXPathNode(\"./vbox:Description\", xPathContext);\n    if (descriptionNode != NULL)\n        snapshot->description = virXMLNodeToString(descriptionNode->doc, descriptionNode);\n\n    hardwareNode = virXPathNode(\"./vbox:Hardware\", xPathContext);\n    if (hardwareNode == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> <Hardware> node\"));\n        goto cleanup;\n    }\n    snapshot->hardware = virXMLNodeToString(snapshotNode->doc, hardwareNode);\n\n    storageControllerNode = virXPathNode(\"./vbox:StorageControllers\", xPathContext);\n    if (storageControllerNode == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> <StorageControllers> node\"));\n        goto cleanup;\n    }\n    snapshot->storageController = virXMLNodeToString(snapshotNode->doc,\n                                                     storageControllerNode);\n\n    snapshotsNode = virXPathNode(\"./vbox:Snapshots\", xPathContext);\n\n    if (snapshotsNode != NULL) {\n        xPathContext->node = snapshotsNode;\n        n = virXPathNodeSet(\"./vbox:Snapshot\", xPathContext, &nodes);\n        if (n < 0)\n            goto cleanup;\n        if (n && VIR_ALLOC_N(snapshot->children, n) < 0)\n            goto cleanup;\n        snapshot->nchildren = n;\n        for (i = 0; i < snapshot->nchildren; i++) {\n            snapshot->children[i] = virVBoxSnapshotConfRetrieveSnapshot(nodes[i], xPathContext);\n            if (snapshot->children[i] == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Cannot create a vboxSnapshotXmlSnapshotPtr\"));\n                goto cleanup;\n            }\n            snapshot->children[i]->parent = snapshot;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virVBoxSnapshotConfSnapshotFree(snapshot);\n        snapshot = NULL;\n    }\n    VIR_FREE(nodes);\n    VIR_FREE(uuid);\n    virStringListFree(searchTabResult);\n    return snapshot;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "snapshot->children",
            "n"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./vbox:Snapshot\"",
            "xPathContext",
            "&nodes"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./vbox:Snapshots\"",
            "xPathContext"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLNodeToString",
          "args": [
            "snapshotNode->doc",
            "storageControllerNode"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "979-1003",
          "snippet": "char *\nvirXMLNodeToString(xmlDocPtr doc,\n                   xmlNodePtr node)\n{\n    xmlBufferPtr xmlbuf = NULL;\n    char *ret = NULL;\n\n    if (!(xmlbuf = xmlBufferCreate())) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    if (xmlNodeDump(xmlbuf, doc, node, 0, 1) == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to convert the XML node tree\"));\n        goto cleanup;\n    }\n\n    ret = g_strdup((const char *)xmlBufferContent(xmlbuf));\n\n cleanup:\n    xmlBufferFree(xmlbuf);\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLNodeToString(xmlDocPtr doc,\n                   xmlNodePtr node)\n{\n    xmlBufferPtr xmlbuf = NULL;\n    char *ret = NULL;\n\n    if (!(xmlbuf = xmlBufferCreate())) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    if (xmlNodeDump(xmlbuf, doc, node, 0, 1) == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to convert the XML node tree\"));\n        goto cleanup;\n    }\n\n    ret = g_strdup((const char *)xmlBufferContent(xmlbuf));\n\n cleanup:\n    xmlBufferFree(xmlbuf);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Cannot parse <Snapshot> <StorageControllers> node\")"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Cannot parse <Snapshot> <Hardware> node\")"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Cannot parse <Snapshot> 'timeStamp' attribute\")"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "snapshotNode",
            "\"timeStamp\""
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Cannot parse <Snapshot> 'name' attribute\")"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "searchTabResult[0]"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Cannot parse <Snapshot> 'uuid' attribute\")"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSearch",
          "args": [
            "uuid",
            "VBOX_UUID_REGEX",
            "1",
            "&searchTabResult"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "965-1029",
          "snippet": "ssize_t\nvirStringSearch(const char *str,\n                const char *regexp,\n                size_t max_matches,\n                char ***matches)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    size_t nmatches = 0;\n    ssize_t ret = -1;\n\n    *matches = NULL;\n\n    VIR_DEBUG(\"search '%s' for '%s'\", str, regexp);\n\n    regex = g_regex_new(regexp, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (g_regex_get_capture_count(regex) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Regular expression '%s' must have exactly 1 match group, not %d\"),\n                       regexp, g_regex_get_capture_count(regex));\n        goto cleanup;\n    }\n\n    /* '*matches' must always be NULL terminated in every iteration\n     * of the loop, so start by allocating 1 element\n     */\n    if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n        goto cleanup;\n\n    while ((nmatches - 1) < max_matches) {\n        g_autoptr(GMatchInfo) info = NULL;\n        char *match;\n        int endpos;\n\n        if (!g_regex_match(regex, str, 0, &info))\n            break;\n\n        if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n            goto cleanup;\n\n        match = g_match_info_fetch(info, 1);\n\n        VIR_DEBUG(\"Got '%s'\", match);\n\n        (*matches)[nmatches-2] = match;\n\n        g_match_info_fetch_pos(info, 1, NULL, &endpos);\n        str += endpos;\n    }\n\n    ret = nmatches - 1; /* don't count the trailing null */\n\n cleanup:\n    if (ret < 0) {\n        virStringListFree(*matches);\n        *matches = NULL;\n    }\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nssize_t\nvirStringSearch(const char *str,\n                const char *regexp,\n                size_t max_matches,\n                char ***matches)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    size_t nmatches = 0;\n    ssize_t ret = -1;\n\n    *matches = NULL;\n\n    VIR_DEBUG(\"search '%s' for '%s'\", str, regexp);\n\n    regex = g_regex_new(regexp, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (g_regex_get_capture_count(regex) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Regular expression '%s' must have exactly 1 match group, not %d\"),\n                       regexp, g_regex_get_capture_count(regex));\n        goto cleanup;\n    }\n\n    /* '*matches' must always be NULL terminated in every iteration\n     * of the loop, so start by allocating 1 element\n     */\n    if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n        goto cleanup;\n\n    while ((nmatches - 1) < max_matches) {\n        g_autoptr(GMatchInfo) info = NULL;\n        char *match;\n        int endpos;\n\n        if (!g_regex_match(regex, str, 0, &info))\n            break;\n\n        if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n            goto cleanup;\n\n        match = g_match_info_fetch(info, 1);\n\n        VIR_DEBUG(\"Got '%s'\", match);\n\n        (*matches)[nmatches-2] = match;\n\n        g_match_info_fetch_pos(info, 1, NULL, &endpos);\n        str += endpos;\n    }\n\n    ret = nmatches - 1; /* don't count the trailing null */\n\n cleanup:\n    if (ret < 0) {\n        virStringListFree(*matches);\n        *matches = NULL;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "snapshot"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic virVBoxSnapshotConfSnapshotPtr\nvirVBoxSnapshotConfRetrieveSnapshot(xmlNodePtr snapshotNode,\n                                    xmlXPathContextPtr xPathContext)\n{\n    virVBoxSnapshotConfSnapshotPtr snapshot = NULL;\n    xmlNodePtr hardwareNode = NULL;\n    xmlNodePtr descriptionNode = NULL;\n    xmlNodePtr storageControllerNode = NULL;\n    xmlNodePtr snapshotsNode = NULL;\n    xmlNodePtr *nodes = NULL;\n    char *uuid = NULL;\n    char **searchTabResult = NULL;\n    int resultSize = 0;\n    size_t i = 0;\n    int result = -1;\n    int n = 0;\n\n    if (VIR_ALLOC(snapshot) < 0)\n        goto cleanup;\n\n    uuid = virXMLPropString(snapshotNode, \"uuid\");\n    /* we use virStringSearch because the uuid is between brackets */\n    resultSize = virStringSearch(uuid,\n                                 VBOX_UUID_REGEX,\n                                 1,\n                                 &searchTabResult);\n    if (resultSize != 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> 'uuid' attribute\"));\n        goto cleanup;\n    }\n    snapshot->uuid = g_strdup(searchTabResult[0]);\n\n    snapshot->name = virXMLPropString(snapshotNode, \"name\");\n    if (snapshot->name == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> 'name' attribute\"));\n        goto cleanup;\n    }\n    snapshot->timeStamp = virXMLPropString(snapshotNode, \"timeStamp\");\n    if (snapshot->timeStamp == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> 'timeStamp' attribute\"));\n        goto cleanup;\n    }\n\n    xPathContext->node = snapshotNode;\n    descriptionNode = virXPathNode(\"./vbox:Description\", xPathContext);\n    if (descriptionNode != NULL)\n        snapshot->description = virXMLNodeToString(descriptionNode->doc, descriptionNode);\n\n    hardwareNode = virXPathNode(\"./vbox:Hardware\", xPathContext);\n    if (hardwareNode == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> <Hardware> node\"));\n        goto cleanup;\n    }\n    snapshot->hardware = virXMLNodeToString(snapshotNode->doc, hardwareNode);\n\n    storageControllerNode = virXPathNode(\"./vbox:StorageControllers\", xPathContext);\n    if (storageControllerNode == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Snapshot> <StorageControllers> node\"));\n        goto cleanup;\n    }\n    snapshot->storageController = virXMLNodeToString(snapshotNode->doc,\n                                                     storageControllerNode);\n\n    snapshotsNode = virXPathNode(\"./vbox:Snapshots\", xPathContext);\n\n    if (snapshotsNode != NULL) {\n        xPathContext->node = snapshotsNode;\n        n = virXPathNodeSet(\"./vbox:Snapshot\", xPathContext, &nodes);\n        if (n < 0)\n            goto cleanup;\n        if (n && VIR_ALLOC_N(snapshot->children, n) < 0)\n            goto cleanup;\n        snapshot->nchildren = n;\n        for (i = 0; i < snapshot->nchildren; i++) {\n            snapshot->children[i] = virVBoxSnapshotConfRetrieveSnapshot(nodes[i], xPathContext);\n            if (snapshot->children[i] == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Cannot create a vboxSnapshotXmlSnapshotPtr\"));\n                goto cleanup;\n            }\n            snapshot->children[i]->parent = snapshot;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virVBoxSnapshotConfSnapshotFree(snapshot);\n        snapshot = NULL;\n    }\n    VIR_FREE(nodes);\n    VIR_FREE(uuid);\n    virStringListFree(searchTabResult);\n    return snapshot;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfRetrieveMediaRegistry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "114-174",
    "snippet": "static virVBoxSnapshotConfMediaRegistryPtr\nvirVBoxSnapshotConfRetrieveMediaRegistry(xmlNodePtr mediaRegistryNode,\n                                         xmlXPathContextPtr xPathContext,\n                                         const char *machineLocation)\n{\n    virVBoxSnapshotConfMediaRegistryPtr mediaRegistry = NULL;\n    xmlNodePtr hardDisksNode = NULL;\n    xmlNodePtr *nodes = NULL;\n    size_t i = 0;\n    int result = -1;\n    int n = 0;\n\n    if (VIR_ALLOC(mediaRegistry) < 0)\n        goto cleanup;\n\n    xPathContext->node = mediaRegistryNode;\n    hardDisksNode = virXPathNode(\"./vbox:HardDisks\", xPathContext);\n\n    xPathContext->node = hardDisksNode;\n    n = virXPathNodeSet(\"./vbox:HardDisk\", xPathContext, &nodes);\n    if (n < 0)\n        goto cleanup;\n    if (n && VIR_ALLOC_N(mediaRegistry->disks, n) < 0)\n        goto cleanup;\n    mediaRegistry->ndisks = n;\n    for (i = 0; i < mediaRegistry->ndisks; i++) {\n        mediaRegistry->disks[i] = virVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr(nodes[i],\n                                                                   xPathContext,\n                                                                   machineLocation);\n        if (mediaRegistry->disks[i] == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot create a vboxSnapshotXmlHardDisk\"));\n            goto cleanup;\n        }\n    }\n    n = 0;\n    VIR_FREE(nodes);\n\n    xPathContext->node = mediaRegistryNode;\n    n = virXPathNodeSet(\"./*[not(self::vbox:HardDisks)]\",\n                                                 xPathContext, &nodes);\n    if (n < 0)\n        goto cleanup;\n    if (n && VIR_ALLOC_N(mediaRegistry->otherMedia, n) < 0)\n        goto cleanup;\n    mediaRegistry->notherMedia = n;\n    for (i = 0; i < mediaRegistry->notherMedia; i++) {\n        mediaRegistry->otherMedia[i] = virXMLNodeToString(mediaRegistryNode->doc,\n                                                          nodes[i]);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virVBoxSnapshotConfMediaRegistryFree(mediaRegistry);\n        mediaRegistry = NULL;\n    }\n    VIR_FREE(nodes);\n    return mediaRegistry;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfMediaRegistryFree",
          "args": [
            "mediaRegistry"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfMediaRegistryFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "518-533",
          "snippet": "void\nvirVBoxSnapshotConfMediaRegistryFree(virVBoxSnapshotConfMediaRegistryPtr mediaRegistry)\n{\n    size_t i = 0;\n\n    if (!mediaRegistry)\n        return;\n\n    for (i = 0; i < mediaRegistry->ndisks; i++)\n        virVboxSnapshotConfHardDiskFree(mediaRegistry->disks[i]);\n    VIR_FREE(mediaRegistry->disks);\n    for (i = 0; i < mediaRegistry->notherMedia; i++)\n        VIR_FREE(mediaRegistry->otherMedia[i]);\n    VIR_FREE(mediaRegistry->otherMedia);\n    VIR_FREE(mediaRegistry);\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvoid\nvirVBoxSnapshotConfMediaRegistryFree(virVBoxSnapshotConfMediaRegistryPtr mediaRegistry)\n{\n    size_t i = 0;\n\n    if (!mediaRegistry)\n        return;\n\n    for (i = 0; i < mediaRegistry->ndisks; i++)\n        virVboxSnapshotConfHardDiskFree(mediaRegistry->disks[i]);\n    VIR_FREE(mediaRegistry->disks);\n    for (i = 0; i < mediaRegistry->notherMedia; i++)\n        VIR_FREE(mediaRegistry->otherMedia[i]);\n    VIR_FREE(mediaRegistry->otherMedia);\n    VIR_FREE(mediaRegistry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLNodeToString",
          "args": [
            "mediaRegistryNode->doc",
            "nodes[i]"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "979-1003",
          "snippet": "char *\nvirXMLNodeToString(xmlDocPtr doc,\n                   xmlNodePtr node)\n{\n    xmlBufferPtr xmlbuf = NULL;\n    char *ret = NULL;\n\n    if (!(xmlbuf = xmlBufferCreate())) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    if (xmlNodeDump(xmlbuf, doc, node, 0, 1) == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to convert the XML node tree\"));\n        goto cleanup;\n    }\n\n    ret = g_strdup((const char *)xmlBufferContent(xmlbuf));\n\n cleanup:\n    xmlBufferFree(xmlbuf);\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLNodeToString(xmlDocPtr doc,\n                   xmlNodePtr node)\n{\n    xmlBufferPtr xmlbuf = NULL;\n    char *ret = NULL;\n\n    if (!(xmlbuf = xmlBufferCreate())) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    if (xmlNodeDump(xmlbuf, doc, node, 0, 1) == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to convert the XML node tree\"));\n        goto cleanup;\n    }\n\n    ret = g_strdup((const char *)xmlBufferContent(xmlbuf));\n\n cleanup:\n    xmlBufferFree(xmlbuf);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "mediaRegistry->otherMedia",
            "n"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./*[not(self::vbox:HardDisks)]\"",
            "xPathContext",
            "&nodes"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot create a vboxSnapshotXmlHardDisk\")"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot create a vboxSnapshotXmlHardDisk\""
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr",
          "args": [
            "nodes[i]",
            "xPathContext",
            "machineLocation"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "33-112",
          "snippet": "static virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr(xmlNodePtr diskNode,\n                                                     xmlXPathContextPtr xPathContext,\n                                                     const char *machineLocation)\n{\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    xmlNodePtr *nodes = NULL;\n    char *uuid = NULL;\n    char **searchTabResult = NULL;\n    int resultSize = 0;\n    size_t i = 0;\n    int result = -1;\n    char *location = NULL;\n    char *tmp = NULL;\n    int n = 0;\n    if (VIR_ALLOC(hardDisk) < 0)\n        goto cleanup;\n\n    xPathContext->node = diskNode;\n\n    n = virXPathNodeSet(\"./vbox:HardDisk\", xPathContext, &nodes);\n    if (n < 0)\n        goto cleanup;\n\n    if (n && VIR_ALLOC_N(hardDisk->children, n) < 0)\n        goto cleanup;\n    hardDisk->nchildren = n;\n    for (i = 0; i < hardDisk->nchildren; i++) {\n        hardDisk->children[i] = virVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr(nodes[i], xPathContext, machineLocation);\n        if (hardDisk->children[i] == NULL)\n            goto cleanup;\n        hardDisk->children[i]->parent = hardDisk;\n    }\n    uuid = virXMLPropString(diskNode, \"uuid\");\n    /* we use virStringSearch because the uuid is between brackets */\n    resultSize = virStringSearch(uuid,\n                                 VBOX_UUID_REGEX,\n                                 1,\n                                 &searchTabResult);\n    if (resultSize != 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <HardDisk> 'uuid' attribute\"));\n        goto cleanup;\n    }\n    hardDisk->uuid = g_strdup(searchTabResult[0]);\n\n    location = virXMLPropString(diskNode, \"location\");\n    if (location == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <HardDisk> 'location' attribute\"));\n        goto cleanup;\n    }\n    if (location[0] != '/') {\n        /* The location is a relative path, so we must change it into an absolute one. */\n        tmp = g_strdup_printf(\"%s%s\", machineLocation, location);\n        hardDisk->location = g_strdup(tmp);\n    } else {\n        hardDisk->location = g_strdup(location);\n    }\n    hardDisk->format = virXMLPropString(diskNode, \"format\");\n    if (hardDisk->format == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <HardDisk> 'format' attribute\"));\n        goto cleanup;\n    }\n    hardDisk->type = virXMLPropString(diskNode, \"type\");\n    result = 0;\n\n cleanup:\n    VIR_FREE(uuid);\n    VIR_FREE(nodes);\n    VIR_FREE(location);\n    VIR_FREE(tmp);\n    virStringListFree(searchTabResult);\n    if (result < 0) {\n        virVboxSnapshotConfHardDiskFree(hardDisk);\n        hardDisk = NULL;\n    }\n    return hardDisk;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr(xmlNodePtr diskNode,\n                                                     xmlXPathContextPtr xPathContext,\n                                                     const char *machineLocation)\n{\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    xmlNodePtr *nodes = NULL;\n    char *uuid = NULL;\n    char **searchTabResult = NULL;\n    int resultSize = 0;\n    size_t i = 0;\n    int result = -1;\n    char *location = NULL;\n    char *tmp = NULL;\n    int n = 0;\n    if (VIR_ALLOC(hardDisk) < 0)\n        goto cleanup;\n\n    xPathContext->node = diskNode;\n\n    n = virXPathNodeSet(\"./vbox:HardDisk\", xPathContext, &nodes);\n    if (n < 0)\n        goto cleanup;\n\n    if (n && VIR_ALLOC_N(hardDisk->children, n) < 0)\n        goto cleanup;\n    hardDisk->nchildren = n;\n    for (i = 0; i < hardDisk->nchildren; i++) {\n        hardDisk->children[i] = virVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr(nodes[i], xPathContext, machineLocation);\n        if (hardDisk->children[i] == NULL)\n            goto cleanup;\n        hardDisk->children[i]->parent = hardDisk;\n    }\n    uuid = virXMLPropString(diskNode, \"uuid\");\n    /* we use virStringSearch because the uuid is between brackets */\n    resultSize = virStringSearch(uuid,\n                                 VBOX_UUID_REGEX,\n                                 1,\n                                 &searchTabResult);\n    if (resultSize != 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <HardDisk> 'uuid' attribute\"));\n        goto cleanup;\n    }\n    hardDisk->uuid = g_strdup(searchTabResult[0]);\n\n    location = virXMLPropString(diskNode, \"location\");\n    if (location == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <HardDisk> 'location' attribute\"));\n        goto cleanup;\n    }\n    if (location[0] != '/') {\n        /* The location is a relative path, so we must change it into an absolute one. */\n        tmp = g_strdup_printf(\"%s%s\", machineLocation, location);\n        hardDisk->location = g_strdup(tmp);\n    } else {\n        hardDisk->location = g_strdup(location);\n    }\n    hardDisk->format = virXMLPropString(diskNode, \"format\");\n    if (hardDisk->format == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <HardDisk> 'format' attribute\"));\n        goto cleanup;\n    }\n    hardDisk->type = virXMLPropString(diskNode, \"type\");\n    result = 0;\n\n cleanup:\n    VIR_FREE(uuid);\n    VIR_FREE(nodes);\n    VIR_FREE(location);\n    VIR_FREE(tmp);\n    virStringListFree(searchTabResult);\n    if (result < 0) {\n        virVboxSnapshotConfHardDiskFree(hardDisk);\n        hardDisk = NULL;\n    }\n    return hardDisk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "mediaRegistry->disks",
            "n"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./vbox:HardDisks\"",
            "xPathContext"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "mediaRegistry"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic virVBoxSnapshotConfMediaRegistryPtr\nvirVBoxSnapshotConfRetrieveMediaRegistry(xmlNodePtr mediaRegistryNode,\n                                         xmlXPathContextPtr xPathContext,\n                                         const char *machineLocation)\n{\n    virVBoxSnapshotConfMediaRegistryPtr mediaRegistry = NULL;\n    xmlNodePtr hardDisksNode = NULL;\n    xmlNodePtr *nodes = NULL;\n    size_t i = 0;\n    int result = -1;\n    int n = 0;\n\n    if (VIR_ALLOC(mediaRegistry) < 0)\n        goto cleanup;\n\n    xPathContext->node = mediaRegistryNode;\n    hardDisksNode = virXPathNode(\"./vbox:HardDisks\", xPathContext);\n\n    xPathContext->node = hardDisksNode;\n    n = virXPathNodeSet(\"./vbox:HardDisk\", xPathContext, &nodes);\n    if (n < 0)\n        goto cleanup;\n    if (n && VIR_ALLOC_N(mediaRegistry->disks, n) < 0)\n        goto cleanup;\n    mediaRegistry->ndisks = n;\n    for (i = 0; i < mediaRegistry->ndisks; i++) {\n        mediaRegistry->disks[i] = virVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr(nodes[i],\n                                                                   xPathContext,\n                                                                   machineLocation);\n        if (mediaRegistry->disks[i] == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot create a vboxSnapshotXmlHardDisk\"));\n            goto cleanup;\n        }\n    }\n    n = 0;\n    VIR_FREE(nodes);\n\n    xPathContext->node = mediaRegistryNode;\n    n = virXPathNodeSet(\"./*[not(self::vbox:HardDisks)]\",\n                                                 xPathContext, &nodes);\n    if (n < 0)\n        goto cleanup;\n    if (n && VIR_ALLOC_N(mediaRegistry->otherMedia, n) < 0)\n        goto cleanup;\n    mediaRegistry->notherMedia = n;\n    for (i = 0; i < mediaRegistry->notherMedia; i++) {\n        mediaRegistry->otherMedia[i] = virXMLNodeToString(mediaRegistryNode->doc,\n                                                          nodes[i]);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virVBoxSnapshotConfMediaRegistryFree(mediaRegistry);\n        mediaRegistry = NULL;\n    }\n    VIR_FREE(nodes);\n    return mediaRegistry;\n}"
  },
  {
    "function_name": "virVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
    "lines": "33-112",
    "snippet": "static virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr(xmlNodePtr diskNode,\n                                                     xmlXPathContextPtr xPathContext,\n                                                     const char *machineLocation)\n{\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    xmlNodePtr *nodes = NULL;\n    char *uuid = NULL;\n    char **searchTabResult = NULL;\n    int resultSize = 0;\n    size_t i = 0;\n    int result = -1;\n    char *location = NULL;\n    char *tmp = NULL;\n    int n = 0;\n    if (VIR_ALLOC(hardDisk) < 0)\n        goto cleanup;\n\n    xPathContext->node = diskNode;\n\n    n = virXPathNodeSet(\"./vbox:HardDisk\", xPathContext, &nodes);\n    if (n < 0)\n        goto cleanup;\n\n    if (n && VIR_ALLOC_N(hardDisk->children, n) < 0)\n        goto cleanup;\n    hardDisk->nchildren = n;\n    for (i = 0; i < hardDisk->nchildren; i++) {\n        hardDisk->children[i] = virVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr(nodes[i], xPathContext, machineLocation);\n        if (hardDisk->children[i] == NULL)\n            goto cleanup;\n        hardDisk->children[i]->parent = hardDisk;\n    }\n    uuid = virXMLPropString(diskNode, \"uuid\");\n    /* we use virStringSearch because the uuid is between brackets */\n    resultSize = virStringSearch(uuid,\n                                 VBOX_UUID_REGEX,\n                                 1,\n                                 &searchTabResult);\n    if (resultSize != 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <HardDisk> 'uuid' attribute\"));\n        goto cleanup;\n    }\n    hardDisk->uuid = g_strdup(searchTabResult[0]);\n\n    location = virXMLPropString(diskNode, \"location\");\n    if (location == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <HardDisk> 'location' attribute\"));\n        goto cleanup;\n    }\n    if (location[0] != '/') {\n        /* The location is a relative path, so we must change it into an absolute one. */\n        tmp = g_strdup_printf(\"%s%s\", machineLocation, location);\n        hardDisk->location = g_strdup(tmp);\n    } else {\n        hardDisk->location = g_strdup(location);\n    }\n    hardDisk->format = virXMLPropString(diskNode, \"format\");\n    if (hardDisk->format == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <HardDisk> 'format' attribute\"));\n        goto cleanup;\n    }\n    hardDisk->type = virXMLPropString(diskNode, \"type\");\n    result = 0;\n\n cleanup:\n    VIR_FREE(uuid);\n    VIR_FREE(nodes);\n    VIR_FREE(location);\n    VIR_FREE(tmp);\n    virStringListFree(searchTabResult);\n    if (result < 0) {\n        virVboxSnapshotConfHardDiskFree(hardDisk);\n        hardDisk = NULL;\n    }\n    return hardDisk;\n}",
    "includes": [
      "#include <libxml/xpathInternals.h>",
      "#include \"virxml.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virVboxSnapshotConfHardDiskFree",
          "args": [
            "hardDisk"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "virVboxSnapshotConfHardDiskFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "499-515",
          "snippet": "void\nvirVboxSnapshotConfHardDiskFree(virVBoxSnapshotConfHardDiskPtr disk)\n{\n    size_t i = 0;\n\n    if (!disk)\n        return;\n\n    VIR_FREE(disk->uuid);\n    VIR_FREE(disk->location);\n    VIR_FREE(disk->format);\n    VIR_FREE(disk->type);\n    for (i = 0; i < disk->nchildren; i++)\n        virVboxSnapshotConfHardDiskFree(disk->children[i]);\n    VIR_FREE(disk->children);\n    VIR_FREE(disk);\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvoid\nvirVboxSnapshotConfHardDiskFree(virVBoxSnapshotConfHardDiskPtr disk)\n{\n    size_t i = 0;\n\n    if (!disk)\n        return;\n\n    VIR_FREE(disk->uuid);\n    VIR_FREE(disk->location);\n    VIR_FREE(disk->format);\n    VIR_FREE(disk->type);\n    for (i = 0; i < disk->nchildren; i++)\n        virVboxSnapshotConfHardDiskFree(disk->children[i]);\n    VIR_FREE(disk->children);\n    VIR_FREE(disk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "searchTabResult"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "location"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "diskNode",
            "\"type\""
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Cannot parse <HardDisk> 'format' attribute\")"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot parse <HardDisk> 'format' attribute\""
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "location"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Cannot parse <HardDisk> 'location' attribute\")"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Cannot parse <HardDisk> 'uuid' attribute\")"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSearch",
          "args": [
            "uuid",
            "VBOX_UUID_REGEX",
            "1",
            "&searchTabResult"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "965-1029",
          "snippet": "ssize_t\nvirStringSearch(const char *str,\n                const char *regexp,\n                size_t max_matches,\n                char ***matches)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    size_t nmatches = 0;\n    ssize_t ret = -1;\n\n    *matches = NULL;\n\n    VIR_DEBUG(\"search '%s' for '%s'\", str, regexp);\n\n    regex = g_regex_new(regexp, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (g_regex_get_capture_count(regex) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Regular expression '%s' must have exactly 1 match group, not %d\"),\n                       regexp, g_regex_get_capture_count(regex));\n        goto cleanup;\n    }\n\n    /* '*matches' must always be NULL terminated in every iteration\n     * of the loop, so start by allocating 1 element\n     */\n    if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n        goto cleanup;\n\n    while ((nmatches - 1) < max_matches) {\n        g_autoptr(GMatchInfo) info = NULL;\n        char *match;\n        int endpos;\n\n        if (!g_regex_match(regex, str, 0, &info))\n            break;\n\n        if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n            goto cleanup;\n\n        match = g_match_info_fetch(info, 1);\n\n        VIR_DEBUG(\"Got '%s'\", match);\n\n        (*matches)[nmatches-2] = match;\n\n        g_match_info_fetch_pos(info, 1, NULL, &endpos);\n        str += endpos;\n    }\n\n    ret = nmatches - 1; /* don't count the trailing null */\n\n cleanup:\n    if (ret < 0) {\n        virStringListFree(*matches);\n        *matches = NULL;\n    }\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nssize_t\nvirStringSearch(const char *str,\n                const char *regexp,\n                size_t max_matches,\n                char ***matches)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    size_t nmatches = 0;\n    ssize_t ret = -1;\n\n    *matches = NULL;\n\n    VIR_DEBUG(\"search '%s' for '%s'\", str, regexp);\n\n    regex = g_regex_new(regexp, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (g_regex_get_capture_count(regex) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Regular expression '%s' must have exactly 1 match group, not %d\"),\n                       regexp, g_regex_get_capture_count(regex));\n        goto cleanup;\n    }\n\n    /* '*matches' must always be NULL terminated in every iteration\n     * of the loop, so start by allocating 1 element\n     */\n    if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n        goto cleanup;\n\n    while ((nmatches - 1) < max_matches) {\n        g_autoptr(GMatchInfo) info = NULL;\n        char *match;\n        int endpos;\n\n        if (!g_regex_match(regex, str, 0, &info))\n            break;\n\n        if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n            goto cleanup;\n\n        match = g_match_info_fetch(info, 1);\n\n        VIR_DEBUG(\"Got '%s'\", match);\n\n        (*matches)[nmatches-2] = match;\n\n        g_match_info_fetch_pos(info, 1, NULL, &endpos);\n        str += endpos;\n    }\n\n    ret = nmatches - 1; /* don't count the trailing null */\n\n cleanup:\n    if (ret < 0) {\n        virStringListFree(*matches);\n        *matches = NULL;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr",
          "args": [
            "nodes[i]",
            "xPathContext",
            "machineLocation"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "33-112",
          "snippet": "static virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr(xmlNodePtr diskNode,\n                                                     xmlXPathContextPtr xPathContext,\n                                                     const char *machineLocation)\n{\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    xmlNodePtr *nodes = NULL;\n    char *uuid = NULL;\n    char **searchTabResult = NULL;\n    int resultSize = 0;\n    size_t i = 0;\n    int result = -1;\n    char *location = NULL;\n    char *tmp = NULL;\n    int n = 0;\n    if (VIR_ALLOC(hardDisk) < 0)\n        goto cleanup;\n\n    xPathContext->node = diskNode;\n\n    n = virXPathNodeSet(\"./vbox:HardDisk\", xPathContext, &nodes);\n    if (n < 0)\n        goto cleanup;\n\n    if (n && VIR_ALLOC_N(hardDisk->children, n) < 0)\n        goto cleanup;\n    hardDisk->nchildren = n;\n    for (i = 0; i < hardDisk->nchildren; i++) {\n        hardDisk->children[i] = virVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr(nodes[i], xPathContext, machineLocation);\n        if (hardDisk->children[i] == NULL)\n            goto cleanup;\n        hardDisk->children[i]->parent = hardDisk;\n    }\n    uuid = virXMLPropString(diskNode, \"uuid\");\n    /* we use virStringSearch because the uuid is between brackets */\n    resultSize = virStringSearch(uuid,\n                                 VBOX_UUID_REGEX,\n                                 1,\n                                 &searchTabResult);\n    if (resultSize != 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <HardDisk> 'uuid' attribute\"));\n        goto cleanup;\n    }\n    hardDisk->uuid = g_strdup(searchTabResult[0]);\n\n    location = virXMLPropString(diskNode, \"location\");\n    if (location == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <HardDisk> 'location' attribute\"));\n        goto cleanup;\n    }\n    if (location[0] != '/') {\n        /* The location is a relative path, so we must change it into an absolute one. */\n        tmp = g_strdup_printf(\"%s%s\", machineLocation, location);\n        hardDisk->location = g_strdup(tmp);\n    } else {\n        hardDisk->location = g_strdup(location);\n    }\n    hardDisk->format = virXMLPropString(diskNode, \"format\");\n    if (hardDisk->format == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <HardDisk> 'format' attribute\"));\n        goto cleanup;\n    }\n    hardDisk->type = virXMLPropString(diskNode, \"type\");\n    result = 0;\n\n cleanup:\n    VIR_FREE(uuid);\n    VIR_FREE(nodes);\n    VIR_FREE(location);\n    VIR_FREE(tmp);\n    virStringListFree(searchTabResult);\n    if (result < 0) {\n        virVboxSnapshotConfHardDiskFree(hardDisk);\n        hardDisk = NULL;\n    }\n    return hardDisk;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "hardDisk->children",
            "n"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./vbox:HardDisk\"",
            "xPathContext",
            "&nodes"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "hardDisk"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nstatic virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr(xmlNodePtr diskNode,\n                                                     xmlXPathContextPtr xPathContext,\n                                                     const char *machineLocation)\n{\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    xmlNodePtr *nodes = NULL;\n    char *uuid = NULL;\n    char **searchTabResult = NULL;\n    int resultSize = 0;\n    size_t i = 0;\n    int result = -1;\n    char *location = NULL;\n    char *tmp = NULL;\n    int n = 0;\n    if (VIR_ALLOC(hardDisk) < 0)\n        goto cleanup;\n\n    xPathContext->node = diskNode;\n\n    n = virXPathNodeSet(\"./vbox:HardDisk\", xPathContext, &nodes);\n    if (n < 0)\n        goto cleanup;\n\n    if (n && VIR_ALLOC_N(hardDisk->children, n) < 0)\n        goto cleanup;\n    hardDisk->nchildren = n;\n    for (i = 0; i < hardDisk->nchildren; i++) {\n        hardDisk->children[i] = virVBoxSnapshotConfCreateVBoxSnapshotConfHardDiskPtr(nodes[i], xPathContext, machineLocation);\n        if (hardDisk->children[i] == NULL)\n            goto cleanup;\n        hardDisk->children[i]->parent = hardDisk;\n    }\n    uuid = virXMLPropString(diskNode, \"uuid\");\n    /* we use virStringSearch because the uuid is between brackets */\n    resultSize = virStringSearch(uuid,\n                                 VBOX_UUID_REGEX,\n                                 1,\n                                 &searchTabResult);\n    if (resultSize != 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <HardDisk> 'uuid' attribute\"));\n        goto cleanup;\n    }\n    hardDisk->uuid = g_strdup(searchTabResult[0]);\n\n    location = virXMLPropString(diskNode, \"location\");\n    if (location == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <HardDisk> 'location' attribute\"));\n        goto cleanup;\n    }\n    if (location[0] != '/') {\n        /* The location is a relative path, so we must change it into an absolute one. */\n        tmp = g_strdup_printf(\"%s%s\", machineLocation, location);\n        hardDisk->location = g_strdup(tmp);\n    } else {\n        hardDisk->location = g_strdup(location);\n    }\n    hardDisk->format = virXMLPropString(diskNode, \"format\");\n    if (hardDisk->format == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <HardDisk> 'format' attribute\"));\n        goto cleanup;\n    }\n    hardDisk->type = virXMLPropString(diskNode, \"type\");\n    result = 0;\n\n cleanup:\n    VIR_FREE(uuid);\n    VIR_FREE(nodes);\n    VIR_FREE(location);\n    VIR_FREE(tmp);\n    virStringListFree(searchTabResult);\n    if (result < 0) {\n        virVboxSnapshotConfHardDiskFree(hardDisk);\n        hardDisk = NULL;\n    }\n    return hardDisk;\n}"
  }
]