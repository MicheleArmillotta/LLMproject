[
  {
    "function_name": "bhyveMonitorClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_monitor.c",
    "lines": "232-242",
    "snippet": "void\nbhyveMonitorClose(bhyveMonitorPtr mon)\n{\n    if (mon == NULL)\n        return;\n\n    VIR_DEBUG(\"cleaning up bhyveMonitor %p\", mon);\n\n    bhyveMonitorUnregister(mon);\n    virObjectUnref(mon);\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_domain.h\"",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/event.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "mon"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveMonitorUnregister",
          "args": [
            "mon"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveMonitorUnregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_monitor.c",
          "lines": "94-102",
          "snippet": "static void\nbhyveMonitorUnregister(bhyveMonitorPtr mon)\n{\n    if (mon->watch < 0)\n        return;\n\n    virEventRemoveHandle(mon->watch);\n    mon->watch = -1;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_domain.h\"",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/event.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_domain.h\"\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/event.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nbhyveMonitorUnregister(bhyveMonitorPtr mon)\n{\n    if (mon->watch < 0)\n        return;\n\n    virEventRemoveHandle(mon->watch);\n    mon->watch = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cleaning up bhyveMonitor %p\"",
            "mon"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_domain.h\"\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/event.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nbhyveMonitorClose(bhyveMonitorPtr mon)\n{\n    if (mon == NULL)\n        return;\n\n    VIR_DEBUG(\"cleaning up bhyveMonitor %p\", mon);\n\n    bhyveMonitorUnregister(mon);\n    virObjectUnref(mon);\n}"
  },
  {
    "function_name": "bhyveMonitorOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_monitor.c",
    "lines": "220-230",
    "snippet": "bhyveMonitorPtr\nbhyveMonitorOpen(virDomainObjPtr vm, bhyveConnPtr driver)\n{\n    bhyveMonitorPtr mon;\n\n    virObjectRef(vm);\n    mon = bhyveMonitorOpenImpl(vm, driver);\n    virObjectUnref(vm);\n\n    return mon;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_domain.h\"",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/event.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "vm"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveMonitorOpenImpl",
          "args": [
            "vm",
            "driver"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveMonitorOpenImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_monitor.c",
          "lines": "175-218",
          "snippet": "static bhyveMonitorPtr\nbhyveMonitorOpenImpl(virDomainObjPtr vm, bhyveConnPtr driver)\n{\n    bhyveMonitorPtr mon;\n    struct kevent kev;\n\n    if (bhyveMonitorInitialize() < 0)\n        return NULL;\n\n    if (!(mon = virObjectNew(bhyveMonitorClass)))\n        return NULL;\n\n    mon->driver = driver;\n    mon->reboot = false;\n\n    virObjectRef(vm);\n    mon->vm = vm;\n\n    mon->kq = kqueue();\n    if (mon->kq < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Unable to create kqueue\"));\n        goto cleanup;\n    }\n\n    EV_SET(&kev, vm->pid, EVFILT_PROC, EV_ADD, NOTE_EXIT, 0, mon);\n    if (kevent(mon->kq, &kev, 1, NULL, 0, NULL) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Unable to register process kevent\"));\n        goto cleanup;\n    }\n\n    if (!bhyveMonitorRegister(mon)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to register monitor events\"));\n        goto cleanup;\n    }\n\n    return mon;\n\n cleanup:\n    bhyveMonitorClose(mon);\n    return NULL;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_domain.h\"",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/event.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr bhyveMonitorClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_domain.h\"\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/event.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virClassPtr bhyveMonitorClass;\n\nstatic bhyveMonitorPtr\nbhyveMonitorOpenImpl(virDomainObjPtr vm, bhyveConnPtr driver)\n{\n    bhyveMonitorPtr mon;\n    struct kevent kev;\n\n    if (bhyveMonitorInitialize() < 0)\n        return NULL;\n\n    if (!(mon = virObjectNew(bhyveMonitorClass)))\n        return NULL;\n\n    mon->driver = driver;\n    mon->reboot = false;\n\n    virObjectRef(vm);\n    mon->vm = vm;\n\n    mon->kq = kqueue();\n    if (mon->kq < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Unable to create kqueue\"));\n        goto cleanup;\n    }\n\n    EV_SET(&kev, vm->pid, EVFILT_PROC, EV_ADD, NOTE_EXIT, 0, mon);\n    if (kevent(mon->kq, &kev, 1, NULL, 0, NULL) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Unable to register process kevent\"));\n        goto cleanup;\n    }\n\n    if (!bhyveMonitorRegister(mon)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to register monitor events\"));\n        goto cleanup;\n    }\n\n    return mon;\n\n cleanup:\n    bhyveMonitorClose(mon);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "vm"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_domain.h\"\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/event.h>\n#include <sys/types.h>\n#include <config.h>\n\nbhyveMonitorPtr\nbhyveMonitorOpen(virDomainObjPtr vm, bhyveConnPtr driver)\n{\n    bhyveMonitorPtr mon;\n\n    virObjectRef(vm);\n    mon = bhyveMonitorOpenImpl(vm, driver);\n    virObjectUnref(vm);\n\n    return mon;\n}"
  },
  {
    "function_name": "bhyveMonitorOpenImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_monitor.c",
    "lines": "175-218",
    "snippet": "static bhyveMonitorPtr\nbhyveMonitorOpenImpl(virDomainObjPtr vm, bhyveConnPtr driver)\n{\n    bhyveMonitorPtr mon;\n    struct kevent kev;\n\n    if (bhyveMonitorInitialize() < 0)\n        return NULL;\n\n    if (!(mon = virObjectNew(bhyveMonitorClass)))\n        return NULL;\n\n    mon->driver = driver;\n    mon->reboot = false;\n\n    virObjectRef(vm);\n    mon->vm = vm;\n\n    mon->kq = kqueue();\n    if (mon->kq < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Unable to create kqueue\"));\n        goto cleanup;\n    }\n\n    EV_SET(&kev, vm->pid, EVFILT_PROC, EV_ADD, NOTE_EXIT, 0, mon);\n    if (kevent(mon->kq, &kev, 1, NULL, 0, NULL) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Unable to register process kevent\"));\n        goto cleanup;\n    }\n\n    if (!bhyveMonitorRegister(mon)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to register monitor events\"));\n        goto cleanup;\n    }\n\n    return mon;\n\n cleanup:\n    bhyveMonitorClose(mon);\n    return NULL;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_domain.h\"",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/event.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr bhyveMonitorClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bhyveMonitorClose",
          "args": [
            "mon"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveMonitorClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_monitor.c",
          "lines": "232-242",
          "snippet": "void\nbhyveMonitorClose(bhyveMonitorPtr mon)\n{\n    if (mon == NULL)\n        return;\n\n    VIR_DEBUG(\"cleaning up bhyveMonitor %p\", mon);\n\n    bhyveMonitorUnregister(mon);\n    virObjectUnref(mon);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_domain.h\"",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/event.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_domain.h\"\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/event.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nbhyveMonitorClose(bhyveMonitorPtr mon)\n{\n    if (mon == NULL)\n        return;\n\n    VIR_DEBUG(\"cleaning up bhyveMonitor %p\", mon);\n\n    bhyveMonitorUnregister(mon);\n    virObjectUnref(mon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"unable to register monitor events\")"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to register monitor events\""
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveMonitorRegister",
          "args": [
            "mon"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveMonitorRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_monitor.c",
          "lines": "75-92",
          "snippet": "static bool\nbhyveMonitorRegister(bhyveMonitorPtr mon)\n{\n    virObjectRef(mon);\n    mon->watch = virEventAddHandle(mon->kq,\n                                   VIR_EVENT_HANDLE_READABLE |\n                                   VIR_EVENT_HANDLE_ERROR |\n                                   VIR_EVENT_HANDLE_HANGUP,\n                                   bhyveMonitorIO,\n                                   mon,\n                                   virObjectFreeCallback);\n    if (mon->watch < 0) {\n        VIR_DEBUG(\"failed to add event handle for mon %p\", mon);\n        virObjectUnref(mon);\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_domain.h\"",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/event.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void bhyveMonitorIO(int, int, int, void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_domain.h\"\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/event.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void bhyveMonitorIO(int, int, int, void *);\n\nstatic bool\nbhyveMonitorRegister(bhyveMonitorPtr mon)\n{\n    virObjectRef(mon);\n    mon->watch = virEventAddHandle(mon->kq,\n                                   VIR_EVENT_HANDLE_READABLE |\n                                   VIR_EVENT_HANDLE_ERROR |\n                                   VIR_EVENT_HANDLE_HANGUP,\n                                   bhyveMonitorIO,\n                                   mon,\n                                   virObjectFreeCallback);\n    if (mon->watch < 0) {\n        VIR_DEBUG(\"failed to add event handle for mon %p\", mon);\n        virObjectUnref(mon);\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "\"%s\"",
            "_(\"Unable to register process kevent\")"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kevent",
          "args": [
            "mon->kq",
            "&kev",
            "1",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EV_SET",
          "args": [
            "&kev",
            "vm->pid",
            "EVFILT_PROC",
            "EV_ADD",
            "NOTE_EXIT",
            "0",
            "mon"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "\"%s\"",
            "_(\"Unable to create kqueue\")"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kqueue",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "vm"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "bhyveMonitorClass"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveMonitorInitialize",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_domain.h\"\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/event.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virClassPtr bhyveMonitorClass;\n\nstatic bhyveMonitorPtr\nbhyveMonitorOpenImpl(virDomainObjPtr vm, bhyveConnPtr driver)\n{\n    bhyveMonitorPtr mon;\n    struct kevent kev;\n\n    if (bhyveMonitorInitialize() < 0)\n        return NULL;\n\n    if (!(mon = virObjectNew(bhyveMonitorClass)))\n        return NULL;\n\n    mon->driver = driver;\n    mon->reboot = false;\n\n    virObjectRef(vm);\n    mon->vm = vm;\n\n    mon->kq = kqueue();\n    if (mon->kq < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Unable to create kqueue\"));\n        goto cleanup;\n    }\n\n    EV_SET(&kev, vm->pid, EVFILT_PROC, EV_ADD, NOTE_EXIT, 0, mon);\n    if (kevent(mon->kq, &kev, 1, NULL, 0, NULL) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Unable to register process kevent\"));\n        goto cleanup;\n    }\n\n    if (!bhyveMonitorRegister(mon)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to register monitor events\"));\n        goto cleanup;\n    }\n\n    return mon;\n\n cleanup:\n    bhyveMonitorClose(mon);\n    return NULL;\n}"
  },
  {
    "function_name": "bhyveMonitorIO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_monitor.c",
    "lines": "110-173",
    "snippet": "static void\nbhyveMonitorIO(int watch, int kq, int events G_GNUC_UNUSED, void *opaque)\n{\n    const struct timespec zerowait = { 0, 0 };\n    bhyveMonitorPtr mon = opaque;\n    virDomainObjPtr vm = mon->vm;\n    bhyveConnPtr driver = mon->driver;\n    const char *name;\n    struct kevent kev;\n    int rc, status;\n\n    if (watch != mon->watch || kq != mon->kq) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"event from unexpected fd %d!=%d / watch %d!=%d\"),\n                       mon->kq, kq, mon->watch, watch);\n        return;\n    }\n\n    rc = kevent(kq, NULL, 0, &kev, 1, &zerowait);\n    if (rc < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to query kqueue\"));\n        return;\n    }\n\n    if (rc == 0)\n        return;\n\n    if ((kev.flags & EV_ERROR) != 0) {\n        virReportSystemError(kev.data, \"%s\", _(\"Unable to query kqueue\"));\n        return;\n    }\n\n    if (kev.filter == EVFILT_PROC && (kev.fflags & NOTE_EXIT) != 0) {\n        if ((pid_t)kev.ident != vm->pid) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"event from unexpected proc %ju!=%ju\"),\n                           (uintmax_t)vm->pid, (uintmax_t)kev.ident);\n            return;\n        }\n\n        name = vm->def->name;\n        status = kev.data;\n        if (WIFSIGNALED(status) && WCOREDUMP(status)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Guest %s got signal %d and crashed\"),\n                           name, WTERMSIG(status));\n            virBhyveProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_CRASHED);\n        } else if (WIFEXITED(status)) {\n            if (WEXITSTATUS(status) == 0 || mon->reboot) {\n                /* 0 - reboot */\n                VIR_INFO(\"Guest %s rebooted; restarting domain.\", name);\n                virBhyveProcessRestart(driver, vm);\n            } else if (WEXITSTATUS(status) < 3) {\n                /* 1 - shutdown, 2 - halt, 3 - triple fault. others - error */\n                VIR_INFO(\"Guest %s shut itself down; destroying domain.\", name);\n                virBhyveProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n            } else {\n                VIR_INFO(\"Guest %s had an error and exited with status %d; destroying domain.\",\n                         name, WEXITSTATUS(status));\n                virBhyveProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_UNKNOWN);\n            }\n        }\n    }\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_domain.h\"",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/event.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void bhyveMonitorIO(int, int, int, void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBhyveProcessStop",
          "args": [
            "driver",
            "vm",
            "VIR_DOMAIN_SHUTOFF_UNKNOWN"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveProcessStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
          "lines": "274-336",
          "snippet": "int\nvirBhyveProcessStop(bhyveConnPtr driver,\n                    virDomainObjPtr vm,\n                    virDomainShutoffReason reason)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    bhyveDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    if (vm->pid <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid PID %d for VM\"),\n                       (int)vm->pid);\n        return -1;\n    }\n\n    if (!(cmd = virBhyveProcessBuildDestroyCmd(driver, vm->def)))\n        return -1;\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if ((priv != NULL) && (priv->mon != NULL))\n         bhyveMonitorClose(priv->mon);\n\n    bhyveProcessStopHook(vm, VIR_HOOK_BHYVE_OP_STOPPED);\n\n    /* Cleanup network interfaces */\n    bhyveNetCleanup(vm);\n\n    /* VNC autoport cleanup */\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n        if (virPortAllocatorRelease(vm->def->graphics[0]->data.vnc.port) < 0) {\n            VIR_WARN(\"Failed to release VNC port for '%s'\",\n                     vm->def->name);\n        }\n    }\n\n    ret = 0;\n\n    virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                           bhyveProcessAutoDestroy);\n\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    vm->pid = -1;\n    vm->def->id = -1;\n\n    bhyveProcessStopHook(vm, VIR_HOOK_BHYVE_OP_RELEASE);\n\n cleanup:\n    virCommandFree(cmd);\n\n    virPidFileDelete(BHYVE_STATE_DIR, vm->def->name);\n    virDomainDeleteConfig(BHYVE_STATE_DIR, NULL, vm);\n\n    return ret;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_device.h\"",
            "#include <net/if_tap.h>",
            "#include <net/if.h>",
            "#include <sys/user.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <kvm.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirBhyveProcessStop(bhyveConnPtr driver,\n                    virDomainObjPtr vm,\n                    virDomainShutoffReason reason)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    bhyveDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    if (vm->pid <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid PID %d for VM\"),\n                       (int)vm->pid);\n        return -1;\n    }\n\n    if (!(cmd = virBhyveProcessBuildDestroyCmd(driver, vm->def)))\n        return -1;\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if ((priv != NULL) && (priv->mon != NULL))\n         bhyveMonitorClose(priv->mon);\n\n    bhyveProcessStopHook(vm, VIR_HOOK_BHYVE_OP_STOPPED);\n\n    /* Cleanup network interfaces */\n    bhyveNetCleanup(vm);\n\n    /* VNC autoport cleanup */\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n        if (virPortAllocatorRelease(vm->def->graphics[0]->data.vnc.port) < 0) {\n            VIR_WARN(\"Failed to release VNC port for '%s'\",\n                     vm->def->name);\n        }\n    }\n\n    ret = 0;\n\n    virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                           bhyveProcessAutoDestroy);\n\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    vm->pid = -1;\n    vm->def->id = -1;\n\n    bhyveProcessStopHook(vm, VIR_HOOK_BHYVE_OP_RELEASE);\n\n cleanup:\n    virCommandFree(cmd);\n\n    virPidFileDelete(BHYVE_STATE_DIR, vm->def->name);\n    virDomainDeleteConfig(BHYVE_STATE_DIR, NULL, vm);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Guest %s had an error and exited with status %d; destroying domain.\"",
            "name",
            "WEXITSTATUS(status)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Guest %s shut itself down; destroying domain.\"",
            "name"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBhyveProcessRestart",
          "args": [
            "driver",
            "vm"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "virBhyveProcessRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_process.c",
          "lines": "361-372",
          "snippet": "int\nvirBhyveProcessRestart(bhyveConnPtr driver,\n                       virDomainObjPtr vm)\n{\n    if (virBhyveProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN) < 0)\n        return -1;\n\n    if (virBhyveProcessStartImpl(driver, vm, VIR_DOMAIN_RUNNING_BOOTED) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"bhyve_process.h\"",
            "#include \"bhyve_monitor.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_driver.h\"",
            "#include \"bhyve_device.h\"",
            "#include <net/if_tap.h>",
            "#include <net/if.h>",
            "#include <sys/user.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <kvm.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdevtap.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_driver.h\"\n#include \"bhyve_device.h\"\n#include <net/if_tap.h>\n#include <net/if.h>\n#include <sys/user.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <kvm.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirBhyveProcessRestart(bhyveConnPtr driver,\n                       virDomainObjPtr vm)\n{\n    if (virBhyveProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN) < 0)\n        return -1;\n\n    if (virBhyveProcessStartImpl(driver, vm, VIR_DOMAIN_RUNNING_BOOTED) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Guest %s rebooted; restarting domain.\"",
            "name"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Guest %s got signal %d and crashed\")",
            "name",
            "WTERMSIG(status)"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Guest %s got signal %d and crashed\""
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WCOREDUMP",
          "args": [
            "status"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"event from unexpected proc %ju!=%ju\")",
            "(uintmax_t)vm->pid",
            "(uintmax_t)kev.ident"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "kev.data",
            "\"%s\"",
            "_(\"Unable to query kqueue\")"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to query kqueue\")"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kevent",
          "args": [
            "kq",
            "NULL",
            "0",
            "&kev",
            "1",
            "&zerowait"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"event from unexpected fd %d!=%d / watch %d!=%d\")",
            "mon->kq",
            "kq",
            "mon->watch",
            "watch"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_domain.h\"\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/event.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void bhyveMonitorIO(int, int, int, void *);\n\nstatic void\nbhyveMonitorIO(int watch, int kq, int events G_GNUC_UNUSED, void *opaque)\n{\n    const struct timespec zerowait = { 0, 0 };\n    bhyveMonitorPtr mon = opaque;\n    virDomainObjPtr vm = mon->vm;\n    bhyveConnPtr driver = mon->driver;\n    const char *name;\n    struct kevent kev;\n    int rc, status;\n\n    if (watch != mon->watch || kq != mon->kq) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"event from unexpected fd %d!=%d / watch %d!=%d\"),\n                       mon->kq, kq, mon->watch, watch);\n        return;\n    }\n\n    rc = kevent(kq, NULL, 0, &kev, 1, &zerowait);\n    if (rc < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to query kqueue\"));\n        return;\n    }\n\n    if (rc == 0)\n        return;\n\n    if ((kev.flags & EV_ERROR) != 0) {\n        virReportSystemError(kev.data, \"%s\", _(\"Unable to query kqueue\"));\n        return;\n    }\n\n    if (kev.filter == EVFILT_PROC && (kev.fflags & NOTE_EXIT) != 0) {\n        if ((pid_t)kev.ident != vm->pid) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"event from unexpected proc %ju!=%ju\"),\n                           (uintmax_t)vm->pid, (uintmax_t)kev.ident);\n            return;\n        }\n\n        name = vm->def->name;\n        status = kev.data;\n        if (WIFSIGNALED(status) && WCOREDUMP(status)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Guest %s got signal %d and crashed\"),\n                           name, WTERMSIG(status));\n            virBhyveProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_CRASHED);\n        } else if (WIFEXITED(status)) {\n            if (WEXITSTATUS(status) == 0 || mon->reboot) {\n                /* 0 - reboot */\n                VIR_INFO(\"Guest %s rebooted; restarting domain.\", name);\n                virBhyveProcessRestart(driver, vm);\n            } else if (WEXITSTATUS(status) < 3) {\n                /* 1 - shutdown, 2 - halt, 3 - triple fault. others - error */\n                VIR_INFO(\"Guest %s shut itself down; destroying domain.\", name);\n                virBhyveProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n            } else {\n                VIR_INFO(\"Guest %s had an error and exited with status %d; destroying domain.\",\n                         name, WEXITSTATUS(status));\n                virBhyveProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_UNKNOWN);\n            }\n        }\n    }\n}"
  },
  {
    "function_name": "bhyveMonitorSetReboot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_monitor.c",
    "lines": "104-108",
    "snippet": "void\nbhyveMonitorSetReboot(bhyveMonitorPtr mon)\n{\n    mon->reboot = true;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_domain.h\"",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/event.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_domain.h\"\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/event.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nbhyveMonitorSetReboot(bhyveMonitorPtr mon)\n{\n    mon->reboot = true;\n}"
  },
  {
    "function_name": "bhyveMonitorUnregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_monitor.c",
    "lines": "94-102",
    "snippet": "static void\nbhyveMonitorUnregister(bhyveMonitorPtr mon)\n{\n    if (mon->watch < 0)\n        return;\n\n    virEventRemoveHandle(mon->watch);\n    mon->watch = -1;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_domain.h\"",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/event.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virEventRemoveHandle",
          "args": [
            "mon->watch"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "virEventRemoveHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "116-123",
          "snippet": "int\nvirEventRemoveHandle(int watch)\n{\n    if (!removeHandleImpl)\n        return -1;\n\n    return removeHandleImpl(watch);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventRemoveHandleFunc removeHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventRemoveHandleFunc removeHandleImpl;\n\nint\nvirEventRemoveHandle(int watch)\n{\n    if (!removeHandleImpl)\n        return -1;\n\n    return removeHandleImpl(watch);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_domain.h\"\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/event.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nbhyveMonitorUnregister(bhyveMonitorPtr mon)\n{\n    if (mon->watch < 0)\n        return;\n\n    virEventRemoveHandle(mon->watch);\n    mon->watch = -1;\n}"
  },
  {
    "function_name": "bhyveMonitorRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_monitor.c",
    "lines": "75-92",
    "snippet": "static bool\nbhyveMonitorRegister(bhyveMonitorPtr mon)\n{\n    virObjectRef(mon);\n    mon->watch = virEventAddHandle(mon->kq,\n                                   VIR_EVENT_HANDLE_READABLE |\n                                   VIR_EVENT_HANDLE_ERROR |\n                                   VIR_EVENT_HANDLE_HANGUP,\n                                   bhyveMonitorIO,\n                                   mon,\n                                   virObjectFreeCallback);\n    if (mon->watch < 0) {\n        VIR_DEBUG(\"failed to add event handle for mon %p\", mon);\n        virObjectUnref(mon);\n        return false;\n    }\n    return true;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_domain.h\"",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/event.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void bhyveMonitorIO(int, int, int, void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "mon"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"failed to add event handle for mon %p\"",
            "mon"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventAddHandle",
          "args": [
            "mon->kq",
            "VIR_EVENT_HANDLE_READABLE |\n                                   VIR_EVENT_HANDLE_ERROR |\n                                   VIR_EVENT_HANDLE_HANGUP",
            "bhyveMonitorIO",
            "mon",
            "virObjectFreeCallback"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "virEventAddHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "73-84",
          "snippet": "int\nvirEventAddHandle(int fd,\n                  int events,\n                  virEventHandleCallback cb,\n                  void *opaque,\n                  virFreeCallback ff)\n{\n    if (!addHandleImpl)\n        return -1;\n\n    return addHandleImpl(fd, events, cb, opaque, ff);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventAddHandleFunc addHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventAddHandleFunc addHandleImpl;\n\nint\nvirEventAddHandle(int fd,\n                  int events,\n                  virEventHandleCallback cb,\n                  void *opaque,\n                  virFreeCallback ff)\n{\n    if (!addHandleImpl)\n        return -1;\n\n    return addHandleImpl(fd, events, cb, opaque, ff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "mon"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_domain.h\"\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/event.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void bhyveMonitorIO(int, int, int, void *);\n\nstatic bool\nbhyveMonitorRegister(bhyveMonitorPtr mon)\n{\n    virObjectRef(mon);\n    mon->watch = virEventAddHandle(mon->kq,\n                                   VIR_EVENT_HANDLE_READABLE |\n                                   VIR_EVENT_HANDLE_ERROR |\n                                   VIR_EVENT_HANDLE_HANGUP,\n                                   bhyveMonitorIO,\n                                   mon,\n                                   virObjectFreeCallback);\n    if (mon->watch < 0) {\n        VIR_DEBUG(\"failed to add event handle for mon %p\", mon);\n        virObjectUnref(mon);\n        return false;\n    }\n    return true;\n}"
  },
  {
    "function_name": "bhyveMonitorOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_monitor.c",
    "lines": "62-69",
    "snippet": "static int\nbhyveMonitorOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(bhyveMonitor, virClassForObject()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_domain.h\"",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/event.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "bhyveMonitor",
            "virClassForObject()"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObject",
          "args": [],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectRWLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "131-138",
          "snippet": "virClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectRWLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectRWLockableClass;\n\nvirClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_domain.h\"\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/event.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nbhyveMonitorOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(bhyveMonitor, virClassForObject()))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "bhyveMonitorDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_monitor.c",
    "lines": "53-60",
    "snippet": "static void\nbhyveMonitorDispose(void *obj)\n{\n    bhyveMonitorPtr mon = obj;\n\n    VIR_FORCE_CLOSE(mon->kq);\n    virObjectUnref(mon->vm);\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_process.h\"",
      "#include \"bhyve_monitor.h\"",
      "#include \"bhyve_domain.h\"",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/event.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "mon->vm"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "mon->kq"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"bhyve_process.h\"\n#include \"bhyve_monitor.h\"\n#include \"bhyve_domain.h\"\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/event.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nbhyveMonitorDispose(void *obj)\n{\n    bhyveMonitorPtr mon = obj;\n\n    VIR_FORCE_CLOSE(mon->kq);\n    virObjectUnref(mon->vm);\n}"
  }
]