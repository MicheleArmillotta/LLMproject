[
  {
    "function_name": "virNetworkDefUpdateSection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "3644-3710",
    "snippet": "int\nvirNetworkDefUpdateSection(virNetworkDefPtr def,\n                           unsigned int command, /* virNetworkUpdateCommand */\n                           unsigned int section, /* virNetworkUpdateSection */\n                           int parentIndex,\n                           const char *xml,\n                           unsigned int flags)  /* virNetworkUpdateFlags */\n{\n    g_autoptr(xmlDoc) doc = NULL;\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!(doc = virXMLParseStringCtxt(xml, _(\"network_update_xml\"), &ctxt)))\n        return -1;\n\n    switch (section) {\n    case VIR_NETWORK_SECTION_BRIDGE:\n        return virNetworkDefUpdateBridge(def, command, parentIndex, ctxt, flags);\n        break;\n\n    case VIR_NETWORK_SECTION_DOMAIN:\n        return virNetworkDefUpdateDomain(def, command, parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_IP:\n        return virNetworkDefUpdateIP(def, command, parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_IP_DHCP_HOST:\n        return virNetworkDefUpdateIPDHCPHost(def, command,\n                                             parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_IP_DHCP_RANGE:\n        return virNetworkDefUpdateIPDHCPRange(def, command,\n                                              parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_FORWARD:\n        return virNetworkDefUpdateForward(def, command,\n                                          parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_FORWARD_INTERFACE:\n        return virNetworkDefUpdateForwardInterface(def, command,\n                                                   parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_FORWARD_PF:\n        return virNetworkDefUpdateForwardPF(def, command,\n                                            parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_PORTGROUP:\n        return virNetworkDefUpdatePortGroup(def, command,\n                                            parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_DNS_HOST:\n        return virNetworkDefUpdateDNSHost(def, command,\n                                          parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_DNS_TXT:\n        return virNetworkDefUpdateDNSTxt(def, command, parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_DNS_SRV:\n        return virNetworkDefUpdateDNSSrv(def, command, parentIndex, ctxt, flags);\n        break;\n    default:\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"can't update unrecognized section of network\"));\n        break;\n    }\n\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"can't update unrecognized section of network\")"
          ],
          "line": 3704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"can't update unrecognized section of network\""
          ],
          "line": 3705
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateDNSSrv",
          "args": [
            "def",
            "command",
            "parentIndex",
            "ctxt",
            "flags"
          ],
          "line": 3701
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateDNSSrv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "3483-3567",
          "snippet": "static int\nvirNetworkDefUpdateDNSSrv(virNetworkDefPtr def,\n                          unsigned int command G_GNUC_UNUSED,\n                          int parentIndex G_GNUC_UNUSED,\n                          xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                          /* virNetworkUpdateFlags */\n                          unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    int foundIdx = -1, ret = -1;\n    virNetworkDNSDefPtr dns = &def->dns;\n    virNetworkDNSSrvDef srv;\n    bool isAdd = (command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST ||\n                  command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST);\n    int foundCt = 0;\n\n    memset(&srv, 0, sizeof(srv));\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"DNS SRV records cannot be modified, \"\n                         \"only added or deleted\"));\n        goto cleanup;\n    }\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"srv\") < 0)\n        goto cleanup;\n\n    if (virNetworkDNSSrvDefParseXML(def->name, ctxt->node, ctxt, &srv, !isAdd) < 0)\n        goto cleanup;\n\n    for (i = 0; i < dns->nsrvs; i++) {\n        if ((!srv.domain || STREQ_NULLABLE(srv.domain, dns->srvs[i].domain)) &&\n            (!srv.service || STREQ_NULLABLE(srv.service, dns->srvs[i].service)) &&\n            (!srv.protocol || STREQ_NULLABLE(srv.protocol, dns->srvs[i].protocol)) &&\n            (!srv.target || STREQ_NULLABLE(srv.target, dns->srvs[i].target))) {\n            foundCt++;\n            foundIdx = i;\n        }\n    }\n\n    if (isAdd) {\n\n        if (foundCt > 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is already at least one DNS SRV \"\n                             \"record matching all specified fields in network %s\"),\n                           def->name);\n            goto cleanup;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(dns->srvs,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : dns->nsrvs, dns->nsrvs, srv) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (foundCt == 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching DNS SRV \"\n                             \"record in network %s\"), def->name);\n            goto cleanup;\n        }\n        if (foundCt > 1) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"multiple DNS SRV records matching all specified \"\n                             \"fields were found in network %s\"), def->name);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkDNSSrvDefClear(&dns->srvs[foundIdx]);\n        VIR_DELETE_ELEMENT(dns->srvs, foundIdx, dns->nsrvs);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDNSSrvDefClear(&srv);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateDNSSrv(virNetworkDefPtr def,\n                          unsigned int command G_GNUC_UNUSED,\n                          int parentIndex G_GNUC_UNUSED,\n                          xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                          /* virNetworkUpdateFlags */\n                          unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    int foundIdx = -1, ret = -1;\n    virNetworkDNSDefPtr dns = &def->dns;\n    virNetworkDNSSrvDef srv;\n    bool isAdd = (command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST ||\n                  command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST);\n    int foundCt = 0;\n\n    memset(&srv, 0, sizeof(srv));\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"DNS SRV records cannot be modified, \"\n                         \"only added or deleted\"));\n        goto cleanup;\n    }\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"srv\") < 0)\n        goto cleanup;\n\n    if (virNetworkDNSSrvDefParseXML(def->name, ctxt->node, ctxt, &srv, !isAdd) < 0)\n        goto cleanup;\n\n    for (i = 0; i < dns->nsrvs; i++) {\n        if ((!srv.domain || STREQ_NULLABLE(srv.domain, dns->srvs[i].domain)) &&\n            (!srv.service || STREQ_NULLABLE(srv.service, dns->srvs[i].service)) &&\n            (!srv.protocol || STREQ_NULLABLE(srv.protocol, dns->srvs[i].protocol)) &&\n            (!srv.target || STREQ_NULLABLE(srv.target, dns->srvs[i].target))) {\n            foundCt++;\n            foundIdx = i;\n        }\n    }\n\n    if (isAdd) {\n\n        if (foundCt > 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is already at least one DNS SRV \"\n                             \"record matching all specified fields in network %s\"),\n                           def->name);\n            goto cleanup;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(dns->srvs,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : dns->nsrvs, dns->nsrvs, srv) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (foundCt == 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching DNS SRV \"\n                             \"record in network %s\"), def->name);\n            goto cleanup;\n        }\n        if (foundCt > 1) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"multiple DNS SRV records matching all specified \"\n                             \"fields were found in network %s\"), def->name);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkDNSSrvDefClear(&dns->srvs[foundIdx]);\n        VIR_DELETE_ELEMENT(dns->srvs, foundIdx, dns->nsrvs);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDNSSrvDefClear(&srv);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateDNSTxt",
          "args": [
            "def",
            "command",
            "parentIndex",
            "ctxt",
            "flags"
          ],
          "line": 3698
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateDNSTxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "3570-3641",
          "snippet": "static int\nvirNetworkDefUpdateDNSTxt(virNetworkDefPtr def,\n                          unsigned int command G_GNUC_UNUSED,\n                          int parentIndex G_GNUC_UNUSED,\n                          xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                          /* virNetworkUpdateFlags */\n                          unsigned int fflags G_GNUC_UNUSED)\n{\n    int foundIdx, ret = -1;\n    virNetworkDNSDefPtr dns = &def->dns;\n    virNetworkDNSTxtDef txt;\n    bool isAdd = (command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST ||\n                  command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST);\n\n    memset(&txt, 0, sizeof(txt));\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"DNS TXT records cannot be modified, \"\n                         \"only added or deleted\"));\n        goto cleanup;\n    }\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"txt\") < 0)\n        goto cleanup;\n\n    if (virNetworkDNSTxtDefParseXML(def->name, ctxt->node, &txt, !isAdd) < 0)\n        goto cleanup;\n\n    for (foundIdx = 0; foundIdx < dns->ntxts; foundIdx++) {\n        if (STREQ(txt.name, dns->txts[foundIdx].name))\n            break;\n    }\n\n    if (isAdd) {\n\n        if (foundIdx < dns->ntxts) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is already a DNS TXT record \"\n                             \"with name '%s' in network %s\"),\n                           txt.name, def->name);\n            goto cleanup;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(dns->txts,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : dns->ntxts, dns->ntxts, txt) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (foundIdx == dns->ntxts) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching DNS TXT \"\n                             \"record in network %s\"), def->name);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkDNSTxtDefClear(&dns->txts[foundIdx]);\n        VIR_DELETE_ELEMENT(dns->txts, foundIdx, dns->ntxts);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDNSTxtDefClear(&txt);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateDNSTxt(virNetworkDefPtr def,\n                          unsigned int command G_GNUC_UNUSED,\n                          int parentIndex G_GNUC_UNUSED,\n                          xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                          /* virNetworkUpdateFlags */\n                          unsigned int fflags G_GNUC_UNUSED)\n{\n    int foundIdx, ret = -1;\n    virNetworkDNSDefPtr dns = &def->dns;\n    virNetworkDNSTxtDef txt;\n    bool isAdd = (command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST ||\n                  command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST);\n\n    memset(&txt, 0, sizeof(txt));\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"DNS TXT records cannot be modified, \"\n                         \"only added or deleted\"));\n        goto cleanup;\n    }\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"txt\") < 0)\n        goto cleanup;\n\n    if (virNetworkDNSTxtDefParseXML(def->name, ctxt->node, &txt, !isAdd) < 0)\n        goto cleanup;\n\n    for (foundIdx = 0; foundIdx < dns->ntxts; foundIdx++) {\n        if (STREQ(txt.name, dns->txts[foundIdx].name))\n            break;\n    }\n\n    if (isAdd) {\n\n        if (foundIdx < dns->ntxts) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is already a DNS TXT record \"\n                             \"with name '%s' in network %s\"),\n                           txt.name, def->name);\n            goto cleanup;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(dns->txts,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : dns->ntxts, dns->ntxts, txt) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (foundIdx == dns->ntxts) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching DNS TXT \"\n                             \"record in network %s\"), def->name);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkDNSTxtDefClear(&dns->txts[foundIdx]);\n        VIR_DELETE_ELEMENT(dns->txts, foundIdx, dns->ntxts);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDNSTxtDefClear(&txt);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateDNSHost",
          "args": [
            "def",
            "command",
            "parentIndex",
            "ctxt",
            "flags"
          ],
          "line": 3694
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateDNSHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "3388-3480",
          "snippet": "static int\nvirNetworkDefUpdateDNSHost(virNetworkDefPtr def,\n                           unsigned int command G_GNUC_UNUSED,\n                           int parentIndex G_GNUC_UNUSED,\n                           xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                           /* virNetworkUpdateFlags */\n                           unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i, j, k;\n    int foundIdx = -1, ret = -1;\n    virNetworkDNSDefPtr dns = &def->dns;\n    virNetworkDNSHostDef host;\n    bool isAdd = (command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST ||\n                  command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST);\n    int foundCt = 0;\n\n    memset(&host, 0, sizeof(host));\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"DNS HOST records cannot be modified, \"\n                         \"only added or deleted\"));\n        goto cleanup;\n    }\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"host\") < 0)\n        goto cleanup;\n\n    if (virNetworkDNSHostDefParseXML(def->name, ctxt->node, &host, !isAdd) < 0)\n        goto cleanup;\n\n    for (i = 0; i < dns->nhosts; i++) {\n        bool foundThisTime = false;\n\n        if (virSocketAddrEqual(&host.ip, &dns->hosts[i].ip))\n            foundThisTime = true;\n\n        for (j = 0; j < host.nnames && !foundThisTime; j++) {\n            for (k = 0; k < dns->hosts[i].nnames && !foundThisTime; k++) {\n                if (STREQ(host.names[j], dns->hosts[i].names[k]))\n                    foundThisTime = true;\n            }\n        }\n        if (foundThisTime) {\n            foundCt++;\n            foundIdx = i;\n        }\n    }\n\n    if (isAdd) {\n\n        if (foundCt > 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is already at least one DNS HOST \"\n                             \"record with a matching field in network %s\"),\n                           def->name);\n            goto cleanup;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(dns->hosts,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : dns->nhosts, dns->nhosts, host) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (foundCt == 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching DNS HOST \"\n                             \"record in network %s\"), def->name);\n            goto cleanup;\n        }\n        if (foundCt > 1) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"multiple matching DNS HOST records were \"\n                             \"found in network %s\"), def->name);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkDNSHostDefClear(&dns->hosts[foundIdx]);\n        VIR_DELETE_ELEMENT(dns->hosts, foundIdx, dns->nhosts);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDNSHostDefClear(&host);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateDNSHost(virNetworkDefPtr def,\n                           unsigned int command G_GNUC_UNUSED,\n                           int parentIndex G_GNUC_UNUSED,\n                           xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                           /* virNetworkUpdateFlags */\n                           unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i, j, k;\n    int foundIdx = -1, ret = -1;\n    virNetworkDNSDefPtr dns = &def->dns;\n    virNetworkDNSHostDef host;\n    bool isAdd = (command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST ||\n                  command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST);\n    int foundCt = 0;\n\n    memset(&host, 0, sizeof(host));\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"DNS HOST records cannot be modified, \"\n                         \"only added or deleted\"));\n        goto cleanup;\n    }\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"host\") < 0)\n        goto cleanup;\n\n    if (virNetworkDNSHostDefParseXML(def->name, ctxt->node, &host, !isAdd) < 0)\n        goto cleanup;\n\n    for (i = 0; i < dns->nhosts; i++) {\n        bool foundThisTime = false;\n\n        if (virSocketAddrEqual(&host.ip, &dns->hosts[i].ip))\n            foundThisTime = true;\n\n        for (j = 0; j < host.nnames && !foundThisTime; j++) {\n            for (k = 0; k < dns->hosts[i].nnames && !foundThisTime; k++) {\n                if (STREQ(host.names[j], dns->hosts[i].names[k]))\n                    foundThisTime = true;\n            }\n        }\n        if (foundThisTime) {\n            foundCt++;\n            foundIdx = i;\n        }\n    }\n\n    if (isAdd) {\n\n        if (foundCt > 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is already at least one DNS HOST \"\n                             \"record with a matching field in network %s\"),\n                           def->name);\n            goto cleanup;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(dns->hosts,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : dns->nhosts, dns->nhosts, host) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (foundCt == 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching DNS HOST \"\n                             \"record in network %s\"), def->name);\n            goto cleanup;\n        }\n        if (foundCt > 1) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"multiple matching DNS HOST records were \"\n                             \"found in network %s\"), def->name);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkDNSHostDefClear(&dns->hosts[foundIdx]);\n        VIR_DELETE_ELEMENT(dns->hosts, foundIdx, dns->nhosts);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDNSHostDefClear(&host);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdatePortGroup",
          "args": [
            "def",
            "command",
            "parentIndex",
            "ctxt",
            "flags"
          ],
          "line": 3690
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdatePortGroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "3293-3385",
          "snippet": "static int\nvirNetworkDefUpdatePortGroup(virNetworkDefPtr def,\n                             unsigned int command,\n                             int parentIndex G_GNUC_UNUSED,\n                             xmlXPathContextPtr ctxt,\n                             /* virNetworkUpdateFlags */\n                             unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    int foundName = -1, foundDefault = -1;\n    int ret = -1;\n    virPortGroupDef portgroup;\n\n    memset(&portgroup, 0, sizeof(portgroup));\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"portgroup\") < 0)\n        goto cleanup;\n\n    if (virNetworkPortGroupParseXML(&portgroup, ctxt->node, ctxt) < 0)\n        goto cleanup;\n\n    /* check if a portgroup with same name already exists */\n    for (i = 0; i < def->nPortGroups; i++) {\n        if (STREQ(portgroup.name, def->portGroups[i].name))\n            foundName = i;\n        if (def->portGroups[i].isDefault)\n            foundDefault = i;\n    }\n    if (foundName == -1 &&\n        ((command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) ||\n         (command == VIR_NETWORK_UPDATE_COMMAND_DELETE))) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"couldn't find a portgroup entry \"\n                         \"in network '%s' matching <portgroup name='%s'>\"),\n                       def->name, portgroup.name);\n        goto cleanup;\n    } else if (foundName >= 0 &&\n               ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n                (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST))) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"there is an existing portgroup entry in \"\n                         \"network '%s' that matches \"\n                         \"\\\"<portgroup name='%s'>\\\"\"),\n                       def->name, portgroup.name);\n        goto cleanup;\n    }\n\n    /* if there is already a different default, we can't make this\n     * one the default.\n     */\n    if (command != VIR_NETWORK_UPDATE_COMMAND_DELETE &&\n        portgroup.isDefault &&\n        foundDefault >= 0 && foundDefault != foundName) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"a different portgroup entry in \"\n                         \"network '%s' is already set as the default. \"\n                         \"Only one default is allowed.\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n\n        /* replace existing entry */\n        virPortGroupDefClear(&def->portGroups[foundName]);\n        def->portGroups[foundName] = portgroup;\n        memset(&portgroup, 0, sizeof(portgroup));\n\n    } else if ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n        (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST)) {\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(def->portGroups,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : def->nPortGroups,\n                               def->nPortGroups, portgroup) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        /* remove it */\n        virPortGroupDefClear(&def->portGroups[foundName]);\n        VIR_DELETE_ELEMENT(def->portGroups, foundName, def->nPortGroups);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virPortGroupDefClear(&portgroup);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdatePortGroup(virNetworkDefPtr def,\n                             unsigned int command,\n                             int parentIndex G_GNUC_UNUSED,\n                             xmlXPathContextPtr ctxt,\n                             /* virNetworkUpdateFlags */\n                             unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    int foundName = -1, foundDefault = -1;\n    int ret = -1;\n    virPortGroupDef portgroup;\n\n    memset(&portgroup, 0, sizeof(portgroup));\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"portgroup\") < 0)\n        goto cleanup;\n\n    if (virNetworkPortGroupParseXML(&portgroup, ctxt->node, ctxt) < 0)\n        goto cleanup;\n\n    /* check if a portgroup with same name already exists */\n    for (i = 0; i < def->nPortGroups; i++) {\n        if (STREQ(portgroup.name, def->portGroups[i].name))\n            foundName = i;\n        if (def->portGroups[i].isDefault)\n            foundDefault = i;\n    }\n    if (foundName == -1 &&\n        ((command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) ||\n         (command == VIR_NETWORK_UPDATE_COMMAND_DELETE))) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"couldn't find a portgroup entry \"\n                         \"in network '%s' matching <portgroup name='%s'>\"),\n                       def->name, portgroup.name);\n        goto cleanup;\n    } else if (foundName >= 0 &&\n               ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n                (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST))) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"there is an existing portgroup entry in \"\n                         \"network '%s' that matches \"\n                         \"\\\"<portgroup name='%s'>\\\"\"),\n                       def->name, portgroup.name);\n        goto cleanup;\n    }\n\n    /* if there is already a different default, we can't make this\n     * one the default.\n     */\n    if (command != VIR_NETWORK_UPDATE_COMMAND_DELETE &&\n        portgroup.isDefault &&\n        foundDefault >= 0 && foundDefault != foundName) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"a different portgroup entry in \"\n                         \"network '%s' is already set as the default. \"\n                         \"Only one default is allowed.\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n\n        /* replace existing entry */\n        virPortGroupDefClear(&def->portGroups[foundName]);\n        def->portGroups[foundName] = portgroup;\n        memset(&portgroup, 0, sizeof(portgroup));\n\n    } else if ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n        (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST)) {\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(def->portGroups,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : def->nPortGroups,\n                               def->nPortGroups, portgroup) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        /* remove it */\n        virPortGroupDefClear(&def->portGroups[foundName]);\n        VIR_DELETE_ELEMENT(def->portGroups, foundName, def->nPortGroups);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virPortGroupDefClear(&portgroup);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateForwardPF",
          "args": [
            "def",
            "command",
            "parentIndex",
            "ctxt",
            "flags"
          ],
          "line": 3686
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateForwardPF",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "3280-3290",
          "snippet": "static int\nvirNetworkDefUpdateForwardPF(virNetworkDefPtr def,\n                             unsigned int command G_GNUC_UNUSED,\n                             int parentIndex G_GNUC_UNUSED,\n                             xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                             /* virNetworkUpdateFlags */\n                             unsigned int fflags G_GNUC_UNUSED)\n{\n    virNetworkDefUpdateNoSupport(def, \"forward pf\");\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateForwardPF(virNetworkDefPtr def,\n                             unsigned int command G_GNUC_UNUSED,\n                             int parentIndex G_GNUC_UNUSED,\n                             xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                             /* virNetworkUpdateFlags */\n                             unsigned int fflags G_GNUC_UNUSED)\n{\n    virNetworkDefUpdateNoSupport(def, \"forward pf\");\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateForwardInterface",
          "args": [
            "def",
            "command",
            "parentIndex",
            "ctxt",
            "flags"
          ],
          "line": 3682
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateForwardInterface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "3185-3277",
          "snippet": "static int\nvirNetworkDefUpdateForwardInterface(virNetworkDefPtr def,\n                                    unsigned int command,\n                                    int parentIndex G_GNUC_UNUSED,\n                                    xmlXPathContextPtr ctxt,\n                                    /* virNetworkUpdateFlags */\n                                    unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    int ret = -1;\n    virNetworkForwardIfDef iface;\n\n    memset(&iface, 0, sizeof(iface));\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"interface\") < 0)\n        goto cleanup;\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"forward interface entries cannot be modified, \"\n                         \"only added or deleted\"));\n        goto cleanup;\n    }\n\n    /* parsing this is so simple that it doesn't have its own function */\n    iface.type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n    if (!(iface.device.dev = virXMLPropString(ctxt->node, \"dev\"))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing dev attribute in <interface> element\"));\n        goto cleanup;\n    }\n\n    /* check if an <interface> with same dev name already exists */\n    for (i = 0; i < def->forward.nifs; i++) {\n        if (def->forward.ifs[i].type\n            == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV &&\n            STREQ(iface.device.dev, def->forward.ifs[i].device.dev))\n            break;\n    }\n\n    if ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n        (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST)) {\n\n        if (i < def->forward.nifs) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is an existing interface entry \"\n                             \"in network '%s' that matches \"\n                             \"\\\"<interface dev='%s'>\\\"\"),\n                           def->name, iface.device.dev);\n            goto cleanup;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(def->forward.ifs,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : def->forward.nifs,\n                               def->forward.nifs, iface) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (i == def->forward.nifs) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't find an interface entry \"\n                             \"in network '%s' matching <interface dev='%s'>\"),\n                           def->name, iface.device.dev);\n            goto cleanup;\n        }\n\n        /* fail if the interface is being used */\n        if (def->forward.ifs[i].connections > 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"unable to delete interface '%s' \"\n                             \"in network '%s'. It is currently being used \"\n                             \" by %d domains.\"),\n                           iface.device.dev, def->name,\n                           def->forward.ifs[i].connections);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkForwardIfDefClear(&def->forward.ifs[i]);\n        VIR_DELETE_ELEMENT(def->forward.ifs, i, def->forward.nifs);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkForwardIfDefClear(&iface);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateForwardInterface(virNetworkDefPtr def,\n                                    unsigned int command,\n                                    int parentIndex G_GNUC_UNUSED,\n                                    xmlXPathContextPtr ctxt,\n                                    /* virNetworkUpdateFlags */\n                                    unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    int ret = -1;\n    virNetworkForwardIfDef iface;\n\n    memset(&iface, 0, sizeof(iface));\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"interface\") < 0)\n        goto cleanup;\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"forward interface entries cannot be modified, \"\n                         \"only added or deleted\"));\n        goto cleanup;\n    }\n\n    /* parsing this is so simple that it doesn't have its own function */\n    iface.type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n    if (!(iface.device.dev = virXMLPropString(ctxt->node, \"dev\"))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing dev attribute in <interface> element\"));\n        goto cleanup;\n    }\n\n    /* check if an <interface> with same dev name already exists */\n    for (i = 0; i < def->forward.nifs; i++) {\n        if (def->forward.ifs[i].type\n            == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV &&\n            STREQ(iface.device.dev, def->forward.ifs[i].device.dev))\n            break;\n    }\n\n    if ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n        (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST)) {\n\n        if (i < def->forward.nifs) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is an existing interface entry \"\n                             \"in network '%s' that matches \"\n                             \"\\\"<interface dev='%s'>\\\"\"),\n                           def->name, iface.device.dev);\n            goto cleanup;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(def->forward.ifs,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : def->forward.nifs,\n                               def->forward.nifs, iface) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (i == def->forward.nifs) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't find an interface entry \"\n                             \"in network '%s' matching <interface dev='%s'>\"),\n                           def->name, iface.device.dev);\n            goto cleanup;\n        }\n\n        /* fail if the interface is being used */\n        if (def->forward.ifs[i].connections > 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"unable to delete interface '%s' \"\n                             \"in network '%s'. It is currently being used \"\n                             \" by %d domains.\"),\n                           iface.device.dev, def->name,\n                           def->forward.ifs[i].connections);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkForwardIfDefClear(&def->forward.ifs[i]);\n        VIR_DELETE_ELEMENT(def->forward.ifs, i, def->forward.nifs);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkForwardIfDefClear(&iface);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateIPDHCPRange",
          "args": [
            "def",
            "command",
            "parentIndex",
            "ctxt",
            "flags"
          ],
          "line": 3674
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateIPDHCPRange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "3073-3169",
          "snippet": "static int\nvirNetworkDefUpdateIPDHCPRange(virNetworkDefPtr def,\n                               unsigned int command,\n                               int parentIndex,\n                               xmlXPathContextPtr ctxt,\n                               /* virNetworkUpdateFlags */\n                               unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    virNetworkIPDefPtr ipdef = virNetworkIPDefByIndex(def, parentIndex);\n    virSocketAddrRange range;\n\n    memset(&range, 0, sizeof(range));\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"range\") < 0)\n        return -1;\n\n    /* ipdef is the ip element that needs its range array updated */\n    if (!ipdef)\n        return -1;\n\n    /* parse the xml into a virSocketAddrRange */\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"dhcp ranges cannot be modified, \"\n                         \"only added or deleted\"));\n        return -1;\n    }\n\n    if (virSocketAddrRangeParseXML(def->name, ipdef, ctxt->node, &range) < 0)\n        return -1;\n\n    if (VIR_SOCKET_ADDR_FAMILY(&ipdef->address)\n        != VIR_SOCKET_ADDR_FAMILY(&range.start)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"the address family of a dhcp range must match \"\n                         \"the address family of the dhcp element's parent\"));\n        return -1;\n    }\n\n    /* check if an entry with same name/address/ip already exists */\n    for (i = 0; i < ipdef->nranges; i++) {\n        if (virSocketAddrEqual(&range.start, &ipdef->ranges[i].start) &&\n            virSocketAddrEqual(&range.end, &ipdef->ranges[i].end)) {\n            break;\n        }\n    }\n\n    if ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n        (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST)) {\n\n        if (virNetworkDefUpdateCheckMultiDHCP(def, ipdef) < 0)\n            return -1;\n\n        if (i < ipdef->nranges) {\n            char *startip = virSocketAddrFormat(&range.start);\n            char *endip = virSocketAddrFormat(&range.end);\n\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is an existing dhcp range entry in \"\n                             \"network '%s' that matches \"\n                             \"\\\"<range start='%s' end='%s'/>\\\"\"),\n                           def->name,\n                           startip ? startip : \"unknown\",\n                           endip ? endip : \"unknown\");\n            VIR_FREE(startip);\n            VIR_FREE(endip);\n            return -1;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(ipdef->ranges,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : ipdef->nranges,\n                               ipdef->nranges, range) < 0)\n            return -1;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (i == ipdef->nranges) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching dhcp range entry \"\n                             \"in network '%s'\"), def->name);\n            return -1;\n        }\n\n        /* remove it */\n        /* NB: nothing to clear from a RangeDef that's being freed */\n        VIR_DELETE_ELEMENT(ipdef->ranges, i, ipdef->nranges);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateIPDHCPRange(virNetworkDefPtr def,\n                               unsigned int command,\n                               int parentIndex,\n                               xmlXPathContextPtr ctxt,\n                               /* virNetworkUpdateFlags */\n                               unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    virNetworkIPDefPtr ipdef = virNetworkIPDefByIndex(def, parentIndex);\n    virSocketAddrRange range;\n\n    memset(&range, 0, sizeof(range));\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"range\") < 0)\n        return -1;\n\n    /* ipdef is the ip element that needs its range array updated */\n    if (!ipdef)\n        return -1;\n\n    /* parse the xml into a virSocketAddrRange */\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"dhcp ranges cannot be modified, \"\n                         \"only added or deleted\"));\n        return -1;\n    }\n\n    if (virSocketAddrRangeParseXML(def->name, ipdef, ctxt->node, &range) < 0)\n        return -1;\n\n    if (VIR_SOCKET_ADDR_FAMILY(&ipdef->address)\n        != VIR_SOCKET_ADDR_FAMILY(&range.start)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"the address family of a dhcp range must match \"\n                         \"the address family of the dhcp element's parent\"));\n        return -1;\n    }\n\n    /* check if an entry with same name/address/ip already exists */\n    for (i = 0; i < ipdef->nranges; i++) {\n        if (virSocketAddrEqual(&range.start, &ipdef->ranges[i].start) &&\n            virSocketAddrEqual(&range.end, &ipdef->ranges[i].end)) {\n            break;\n        }\n    }\n\n    if ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n        (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST)) {\n\n        if (virNetworkDefUpdateCheckMultiDHCP(def, ipdef) < 0)\n            return -1;\n\n        if (i < ipdef->nranges) {\n            char *startip = virSocketAddrFormat(&range.start);\n            char *endip = virSocketAddrFormat(&range.end);\n\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is an existing dhcp range entry in \"\n                             \"network '%s' that matches \"\n                             \"\\\"<range start='%s' end='%s'/>\\\"\"),\n                           def->name,\n                           startip ? startip : \"unknown\",\n                           endip ? endip : \"unknown\");\n            VIR_FREE(startip);\n            VIR_FREE(endip);\n            return -1;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(ipdef->ranges,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : ipdef->nranges,\n                               ipdef->nranges, range) < 0)\n            return -1;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (i == ipdef->nranges) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching dhcp range entry \"\n                             \"in network '%s'\"), def->name);\n            return -1;\n        }\n\n        /* remove it */\n        /* NB: nothing to clear from a RangeDef that's being freed */\n        VIR_DELETE_ELEMENT(ipdef->ranges, i, ipdef->nranges);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateIPDHCPHost",
          "args": [
            "def",
            "command",
            "parentIndex",
            "ctxt",
            "flags"
          ],
          "line": 3670
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateIPDHCPHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2933-3070",
          "snippet": "static int\nvirNetworkDefUpdateIPDHCPHost(virNetworkDefPtr def,\n                              unsigned int command,\n                              int parentIndex,\n                              xmlXPathContextPtr ctxt,\n                              /* virNetworkUpdateFlags */\n                              unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    int ret = -1;\n    virNetworkIPDefPtr ipdef = virNetworkIPDefByIndex(def, parentIndex);\n    virNetworkDHCPHostDef host;\n    bool partialOkay = (command == VIR_NETWORK_UPDATE_COMMAND_DELETE);\n\n    memset(&host, 0, sizeof(host));\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"host\") < 0)\n        goto cleanup;\n\n    /* ipdef is the ip element that needs its host array updated */\n    if (!ipdef)\n        goto cleanup;\n\n    if (virNetworkDHCPHostDefParseXML(def->name, ipdef, ctxt->node,\n                                      &host, partialOkay) < 0)\n        goto cleanup;\n\n    if (!partialOkay &&\n        VIR_SOCKET_ADDR_FAMILY(&ipdef->address)\n        != VIR_SOCKET_ADDR_FAMILY(&host.ip)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"the address family of a host entry IP must match \"\n                         \"the address family of the dhcp element's parent\"));\n        goto cleanup;\n    }\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n\n        /* search for the entry with this (ip|mac|name),\n         * and update the IP+(mac|name) */\n        for (i = 0; i < ipdef->nhosts; i++) {\n            if ((host.mac && ipdef->hosts[i].mac &&\n                 !virMacAddrCompare(host.mac, ipdef->hosts[i].mac)) ||\n                (VIR_SOCKET_ADDR_VALID(&host.ip) &&\n                 virSocketAddrEqual(&host.ip, &ipdef->hosts[i].ip)) ||\n                (host.name &&\n                 STREQ_NULLABLE(host.name, ipdef->hosts[i].name))) {\n                break;\n            }\n        }\n\n        if (i == ipdef->nhosts) {\n            char *ip = virSocketAddrFormat(&host.ip);\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate an existing dhcp host entry with \"\n                             \"\\\"mac='%s'\\\" \\\"name='%s'\\\" \\\"ip='%s'\\\" in\"\n                             \" network '%s'\"),\n                           host.mac ? host.mac : _(\"unknown\"), host.name,\n                           ip ? ip : _(\"unknown\"), def->name);\n            VIR_FREE(ip);\n            goto cleanup;\n        }\n\n        /* clear the existing hosts entry, move the new one in its place,\n         * then clear out the extra copy to get rid of the duplicate pointers\n         * to its data (mac and name strings).\n         */\n        virNetworkDHCPHostDefClear(&ipdef->hosts[i]);\n        ipdef->hosts[i] = host;\n        memset(&host, 0, sizeof(host));\n\n    } else if ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n               (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST)) {\n\n        if (virNetworkDefUpdateCheckMultiDHCP(def, ipdef) < 0)\n            goto cleanup;\n\n        /* log error if an entry with same name/address/ip already exists */\n        for (i = 0; i < ipdef->nhosts; i++) {\n            if ((host.mac && ipdef->hosts[i].mac &&\n                 !virMacAddrCompare(host.mac, ipdef->hosts[i].mac)) ||\n                (host.name &&\n                 STREQ_NULLABLE(host.name, ipdef->hosts[i].name)) ||\n                (VIR_SOCKET_ADDR_VALID(&host.ip) &&\n                 virSocketAddrEqual(&host.ip, &ipdef->hosts[i].ip))) {\n                char *ip = virSocketAddrFormat(&host.ip);\n\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"there is an existing dhcp host entry in \"\n                                 \"network '%s' that matches \"\n                                 \"\\\"<host mac='%s' name='%s' ip='%s'/>\\\"\"),\n                               def->name, host.mac ? host.mac : _(\"unknown\"),\n                               host.name, ip ? ip : _(\"unknown\"));\n                VIR_FREE(ip);\n                goto cleanup;\n            }\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(ipdef->hosts,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : ipdef->nhosts,\n                               ipdef->nhosts, host) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        /* find matching entry - all specified attributes must match */\n        for (i = 0; i < ipdef->nhosts; i++) {\n            if ((!host.mac || !ipdef->hosts[i].mac ||\n                 !virMacAddrCompare(host.mac, ipdef->hosts[i].mac)) &&\n                (!host.name ||\n                 STREQ_NULLABLE(host.name, ipdef->hosts[i].name)) &&\n                (!VIR_SOCKET_ADDR_VALID(&host.ip) ||\n                 virSocketAddrEqual(&host.ip, &ipdef->hosts[i].ip))) {\n                break;\n            }\n        }\n        if (i == ipdef->nhosts) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching dhcp host entry \"\n                             \"in network '%s'\"), def->name);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkDHCPHostDefClear(&ipdef->hosts[i]);\n        VIR_DELETE_ELEMENT(ipdef->hosts, i, ipdef->nhosts);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDHCPHostDefClear(&host);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateIPDHCPHost(virNetworkDefPtr def,\n                              unsigned int command,\n                              int parentIndex,\n                              xmlXPathContextPtr ctxt,\n                              /* virNetworkUpdateFlags */\n                              unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    int ret = -1;\n    virNetworkIPDefPtr ipdef = virNetworkIPDefByIndex(def, parentIndex);\n    virNetworkDHCPHostDef host;\n    bool partialOkay = (command == VIR_NETWORK_UPDATE_COMMAND_DELETE);\n\n    memset(&host, 0, sizeof(host));\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"host\") < 0)\n        goto cleanup;\n\n    /* ipdef is the ip element that needs its host array updated */\n    if (!ipdef)\n        goto cleanup;\n\n    if (virNetworkDHCPHostDefParseXML(def->name, ipdef, ctxt->node,\n                                      &host, partialOkay) < 0)\n        goto cleanup;\n\n    if (!partialOkay &&\n        VIR_SOCKET_ADDR_FAMILY(&ipdef->address)\n        != VIR_SOCKET_ADDR_FAMILY(&host.ip)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"the address family of a host entry IP must match \"\n                         \"the address family of the dhcp element's parent\"));\n        goto cleanup;\n    }\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n\n        /* search for the entry with this (ip|mac|name),\n         * and update the IP+(mac|name) */\n        for (i = 0; i < ipdef->nhosts; i++) {\n            if ((host.mac && ipdef->hosts[i].mac &&\n                 !virMacAddrCompare(host.mac, ipdef->hosts[i].mac)) ||\n                (VIR_SOCKET_ADDR_VALID(&host.ip) &&\n                 virSocketAddrEqual(&host.ip, &ipdef->hosts[i].ip)) ||\n                (host.name &&\n                 STREQ_NULLABLE(host.name, ipdef->hosts[i].name))) {\n                break;\n            }\n        }\n\n        if (i == ipdef->nhosts) {\n            char *ip = virSocketAddrFormat(&host.ip);\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate an existing dhcp host entry with \"\n                             \"\\\"mac='%s'\\\" \\\"name='%s'\\\" \\\"ip='%s'\\\" in\"\n                             \" network '%s'\"),\n                           host.mac ? host.mac : _(\"unknown\"), host.name,\n                           ip ? ip : _(\"unknown\"), def->name);\n            VIR_FREE(ip);\n            goto cleanup;\n        }\n\n        /* clear the existing hosts entry, move the new one in its place,\n         * then clear out the extra copy to get rid of the duplicate pointers\n         * to its data (mac and name strings).\n         */\n        virNetworkDHCPHostDefClear(&ipdef->hosts[i]);\n        ipdef->hosts[i] = host;\n        memset(&host, 0, sizeof(host));\n\n    } else if ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n               (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST)) {\n\n        if (virNetworkDefUpdateCheckMultiDHCP(def, ipdef) < 0)\n            goto cleanup;\n\n        /* log error if an entry with same name/address/ip already exists */\n        for (i = 0; i < ipdef->nhosts; i++) {\n            if ((host.mac && ipdef->hosts[i].mac &&\n                 !virMacAddrCompare(host.mac, ipdef->hosts[i].mac)) ||\n                (host.name &&\n                 STREQ_NULLABLE(host.name, ipdef->hosts[i].name)) ||\n                (VIR_SOCKET_ADDR_VALID(&host.ip) &&\n                 virSocketAddrEqual(&host.ip, &ipdef->hosts[i].ip))) {\n                char *ip = virSocketAddrFormat(&host.ip);\n\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"there is an existing dhcp host entry in \"\n                                 \"network '%s' that matches \"\n                                 \"\\\"<host mac='%s' name='%s' ip='%s'/>\\\"\"),\n                               def->name, host.mac ? host.mac : _(\"unknown\"),\n                               host.name, ip ? ip : _(\"unknown\"));\n                VIR_FREE(ip);\n                goto cleanup;\n            }\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(ipdef->hosts,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : ipdef->nhosts,\n                               ipdef->nhosts, host) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        /* find matching entry - all specified attributes must match */\n        for (i = 0; i < ipdef->nhosts; i++) {\n            if ((!host.mac || !ipdef->hosts[i].mac ||\n                 !virMacAddrCompare(host.mac, ipdef->hosts[i].mac)) &&\n                (!host.name ||\n                 STREQ_NULLABLE(host.name, ipdef->hosts[i].name)) &&\n                (!VIR_SOCKET_ADDR_VALID(&host.ip) ||\n                 virSocketAddrEqual(&host.ip, &ipdef->hosts[i].ip))) {\n                break;\n            }\n        }\n        if (i == ipdef->nhosts) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching dhcp host entry \"\n                             \"in network '%s'\"), def->name);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkDHCPHostDefClear(&ipdef->hosts[i]);\n        VIR_DELETE_ELEMENT(ipdef->hosts, i, ipdef->nhosts);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDHCPHostDefClear(&host);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateDomain",
          "args": [
            "def",
            "command",
            "parentIndex",
            "ctxt",
            "flags"
          ],
          "line": 3664
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2843-2853",
          "snippet": "static int\nvirNetworkDefUpdateDomain(virNetworkDefPtr def,\n                          unsigned int command G_GNUC_UNUSED,\n                          int parentIndex G_GNUC_UNUSED,\n                          xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                          /* virNetworkUpdateFlags */\n                          unsigned int fflags G_GNUC_UNUSED)\n{\n    virNetworkDefUpdateNoSupport(def, \"domain\");\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateDomain(virNetworkDefPtr def,\n                          unsigned int command G_GNUC_UNUSED,\n                          int parentIndex G_GNUC_UNUSED,\n                          xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                          /* virNetworkUpdateFlags */\n                          unsigned int fflags G_GNUC_UNUSED)\n{\n    virNetworkDefUpdateNoSupport(def, \"domain\");\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateBridge",
          "args": [
            "def",
            "command",
            "parentIndex",
            "ctxt",
            "flags"
          ],
          "line": 3660
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateBridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2830-2840",
          "snippet": "static int\nvirNetworkDefUpdateBridge(virNetworkDefPtr def,\n                          unsigned int command G_GNUC_UNUSED,\n                          int parentIndex G_GNUC_UNUSED,\n                          xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                          /* virNetworkUpdateFlags */\n                          unsigned int fflags G_GNUC_UNUSED)\n{\n    virNetworkDefUpdateNoSupport(def, \"bridge\");\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateBridge(virNetworkDefPtr def,\n                          unsigned int command G_GNUC_UNUSED,\n                          int parentIndex G_GNUC_UNUSED,\n                          xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                          /* virNetworkUpdateFlags */\n                          unsigned int fflags G_GNUC_UNUSED)\n{\n    virNetworkDefUpdateNoSupport(def, \"bridge\");\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLParseStringCtxt",
          "args": [
            "xml",
            "_(\"network_update_xml\")",
            "&ctxt"
          ],
          "line": 3655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkDefUpdateSection(virNetworkDefPtr def,\n                           unsigned int command, /* virNetworkUpdateCommand */\n                           unsigned int section, /* virNetworkUpdateSection */\n                           int parentIndex,\n                           const char *xml,\n                           unsigned int flags)  /* virNetworkUpdateFlags */\n{\n    g_autoptr(xmlDoc) doc = NULL;\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!(doc = virXMLParseStringCtxt(xml, _(\"network_update_xml\"), &ctxt)))\n        return -1;\n\n    switch (section) {\n    case VIR_NETWORK_SECTION_BRIDGE:\n        return virNetworkDefUpdateBridge(def, command, parentIndex, ctxt, flags);\n        break;\n\n    case VIR_NETWORK_SECTION_DOMAIN:\n        return virNetworkDefUpdateDomain(def, command, parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_IP:\n        return virNetworkDefUpdateIP(def, command, parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_IP_DHCP_HOST:\n        return virNetworkDefUpdateIPDHCPHost(def, command,\n                                             parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_IP_DHCP_RANGE:\n        return virNetworkDefUpdateIPDHCPRange(def, command,\n                                              parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_FORWARD:\n        return virNetworkDefUpdateForward(def, command,\n                                          parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_FORWARD_INTERFACE:\n        return virNetworkDefUpdateForwardInterface(def, command,\n                                                   parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_FORWARD_PF:\n        return virNetworkDefUpdateForwardPF(def, command,\n                                            parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_PORTGROUP:\n        return virNetworkDefUpdatePortGroup(def, command,\n                                            parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_DNS_HOST:\n        return virNetworkDefUpdateDNSHost(def, command,\n                                          parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_DNS_TXT:\n        return virNetworkDefUpdateDNSTxt(def, command, parentIndex, ctxt, flags);\n        break;\n    case VIR_NETWORK_SECTION_DNS_SRV:\n        return virNetworkDefUpdateDNSSrv(def, command, parentIndex, ctxt, flags);\n        break;\n    default:\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"can't update unrecognized section of network\"));\n        break;\n    }\n\n    return -1;\n}"
  },
  {
    "function_name": "virNetworkDefUpdateDNSTxt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "3570-3641",
    "snippet": "static int\nvirNetworkDefUpdateDNSTxt(virNetworkDefPtr def,\n                          unsigned int command G_GNUC_UNUSED,\n                          int parentIndex G_GNUC_UNUSED,\n                          xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                          /* virNetworkUpdateFlags */\n                          unsigned int fflags G_GNUC_UNUSED)\n{\n    int foundIdx, ret = -1;\n    virNetworkDNSDefPtr dns = &def->dns;\n    virNetworkDNSTxtDef txt;\n    bool isAdd = (command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST ||\n                  command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST);\n\n    memset(&txt, 0, sizeof(txt));\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"DNS TXT records cannot be modified, \"\n                         \"only added or deleted\"));\n        goto cleanup;\n    }\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"txt\") < 0)\n        goto cleanup;\n\n    if (virNetworkDNSTxtDefParseXML(def->name, ctxt->node, &txt, !isAdd) < 0)\n        goto cleanup;\n\n    for (foundIdx = 0; foundIdx < dns->ntxts; foundIdx++) {\n        if (STREQ(txt.name, dns->txts[foundIdx].name))\n            break;\n    }\n\n    if (isAdd) {\n\n        if (foundIdx < dns->ntxts) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is already a DNS TXT record \"\n                             \"with name '%s' in network %s\"),\n                           txt.name, def->name);\n            goto cleanup;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(dns->txts,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : dns->ntxts, dns->ntxts, txt) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (foundIdx == dns->ntxts) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching DNS TXT \"\n                             \"record in network %s\"), def->name);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkDNSTxtDefClear(&dns->txts[foundIdx]);\n        VIR_DELETE_ELEMENT(dns->txts, foundIdx, dns->ntxts);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDNSTxtDefClear(&txt);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkDNSTxtDefClear",
          "args": [
            "&txt"
          ],
          "line": 3639
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDNSTxtDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "159-164",
          "snippet": "static void\nvirNetworkDNSTxtDefClear(virNetworkDNSTxtDefPtr def)\n{\n    VIR_FREE(def->name);\n    VIR_FREE(def->value);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDNSTxtDefClear(virNetworkDNSTxtDefPtr def)\n{\n    VIR_FREE(def->name);\n    VIR_FREE(def->value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateUnknownCommand",
          "args": [
            "command"
          ],
          "line": 3633
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateUnknownCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2806-2811",
          "snippet": "static void\nvirNetworkDefUpdateUnknownCommand(unsigned int command)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"unrecognized network update command code %d\"), command);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDefUpdateUnknownCommand(unsigned int command)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"unrecognized network update command code %d\"), command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "dns->txts",
            "foundIdx",
            "dns->ntxts"
          ],
          "line": 3630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"couldn't locate a matching DNS TXT \"\n                             \"record in network %s\")",
            "def->name"
          ],
          "line": 3622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"couldn't locate a matching DNS TXT \"\n                             \"record in network %s\""
          ],
          "line": 3623
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INSERT_ELEMENT",
          "args": [
            "dns->txts",
            "command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : dns->ntxts",
            "dns->ntxts",
            "txt"
          ],
          "line": 3615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"there is already a DNS TXT record \"\n                             \"with name '%s' in network %s\")",
            "txt.name",
            "def->name"
          ],
          "line": 3607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "txt.name",
            "dns->txts[foundIdx].name"
          ],
          "line": 3600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDNSTxtDefParseXML",
          "args": [
            "def->name",
            "ctxt->node",
            "&txt",
            "!isAdd"
          ],
          "line": 3596
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDNSTxtDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "819-857",
          "snippet": "static int\nvirNetworkDNSTxtDefParseXML(const char *networkName,\n                            xmlNodePtr node,\n                            virNetworkDNSTxtDefPtr def,\n                            bool partialOkay)\n{\n    const char *bad = \" ,\";\n\n    if (!(def->name = virXMLPropString(node, \"name\"))) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"missing required name attribute in DNS TXT record \"\n                         \"of network %s\"), networkName);\n        goto error;\n    }\n    if (strcspn(def->name, bad) != strlen(def->name)) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"prohibited character in DNS TXT record \"\n                         \"name '%s' of network %s\"), def->name, networkName);\n        goto error;\n    }\n    if (!(def->value = virXMLPropString(node, \"value\")) && !partialOkay) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"missing required value attribute in DNS TXT record \"\n                         \"named '%s' of network %s\"), def->name, networkName);\n        goto error;\n    }\n\n    if (!(def->name || def->value)) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing required name or value \"\n                         \"in DNS TXT record of network %s\"), networkName);\n        goto error;\n    }\n    return 0;\n\n error:\n    virNetworkDNSTxtDefClear(def);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDNSTxtDefParseXML(const char *networkName,\n                            xmlNodePtr node,\n                            virNetworkDNSTxtDefPtr def,\n                            bool partialOkay)\n{\n    const char *bad = \" ,\";\n\n    if (!(def->name = virXMLPropString(node, \"name\"))) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"missing required name attribute in DNS TXT record \"\n                         \"of network %s\"), networkName);\n        goto error;\n    }\n    if (strcspn(def->name, bad) != strlen(def->name)) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"prohibited character in DNS TXT record \"\n                         \"name '%s' of network %s\"), def->name, networkName);\n        goto error;\n    }\n    if (!(def->value = virXMLPropString(node, \"value\")) && !partialOkay) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"missing required value attribute in DNS TXT record \"\n                         \"named '%s' of network %s\"), def->name, networkName);\n        goto error;\n    }\n\n    if (!(def->name || def->value)) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing required name or value \"\n                         \"in DNS TXT record of network %s\"), networkName);\n        goto error;\n    }\n    return 0;\n\n error:\n    virNetworkDNSTxtDefClear(def);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateCheckElementName",
          "args": [
            "def",
            "ctxt->node",
            "\"txt\""
          ],
          "line": 3593
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateCheckElementName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2814-2827",
          "snippet": "static int\nvirNetworkDefUpdateCheckElementName(virNetworkDefPtr def,\n                                    xmlNodePtr node,\n                                    const char *section)\n{\n    if (!virXMLNodeNameEqual(node, section)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected element <%s>, expecting <%s>, \"\n                         \"while updating network '%s'\"),\n                       node->name, section, def->name);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateCheckElementName(virNetworkDefPtr def,\n                                    xmlNodePtr node,\n                                    const char *section)\n{\n    if (!virXMLNodeNameEqual(node, section)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected element <%s>, expecting <%s>, \"\n                         \"while updating network '%s'\"),\n                       node->name, section, def->name);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"DNS TXT records cannot be modified, \"\n                         \"only added or deleted\")"
          ],
          "line": 3587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&txt",
            "0",
            "sizeof(txt)"
          ],
          "line": 3584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateDNSTxt(virNetworkDefPtr def,\n                          unsigned int command G_GNUC_UNUSED,\n                          int parentIndex G_GNUC_UNUSED,\n                          xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                          /* virNetworkUpdateFlags */\n                          unsigned int fflags G_GNUC_UNUSED)\n{\n    int foundIdx, ret = -1;\n    virNetworkDNSDefPtr dns = &def->dns;\n    virNetworkDNSTxtDef txt;\n    bool isAdd = (command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST ||\n                  command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST);\n\n    memset(&txt, 0, sizeof(txt));\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"DNS TXT records cannot be modified, \"\n                         \"only added or deleted\"));\n        goto cleanup;\n    }\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"txt\") < 0)\n        goto cleanup;\n\n    if (virNetworkDNSTxtDefParseXML(def->name, ctxt->node, &txt, !isAdd) < 0)\n        goto cleanup;\n\n    for (foundIdx = 0; foundIdx < dns->ntxts; foundIdx++) {\n        if (STREQ(txt.name, dns->txts[foundIdx].name))\n            break;\n    }\n\n    if (isAdd) {\n\n        if (foundIdx < dns->ntxts) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is already a DNS TXT record \"\n                             \"with name '%s' in network %s\"),\n                           txt.name, def->name);\n            goto cleanup;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(dns->txts,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : dns->ntxts, dns->ntxts, txt) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (foundIdx == dns->ntxts) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching DNS TXT \"\n                             \"record in network %s\"), def->name);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkDNSTxtDefClear(&dns->txts[foundIdx]);\n        VIR_DELETE_ELEMENT(dns->txts, foundIdx, dns->ntxts);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDNSTxtDefClear(&txt);\n    return ret;\n}"
  },
  {
    "function_name": "virNetworkDefUpdateDNSSrv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "3483-3567",
    "snippet": "static int\nvirNetworkDefUpdateDNSSrv(virNetworkDefPtr def,\n                          unsigned int command G_GNUC_UNUSED,\n                          int parentIndex G_GNUC_UNUSED,\n                          xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                          /* virNetworkUpdateFlags */\n                          unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    int foundIdx = -1, ret = -1;\n    virNetworkDNSDefPtr dns = &def->dns;\n    virNetworkDNSSrvDef srv;\n    bool isAdd = (command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST ||\n                  command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST);\n    int foundCt = 0;\n\n    memset(&srv, 0, sizeof(srv));\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"DNS SRV records cannot be modified, \"\n                         \"only added or deleted\"));\n        goto cleanup;\n    }\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"srv\") < 0)\n        goto cleanup;\n\n    if (virNetworkDNSSrvDefParseXML(def->name, ctxt->node, ctxt, &srv, !isAdd) < 0)\n        goto cleanup;\n\n    for (i = 0; i < dns->nsrvs; i++) {\n        if ((!srv.domain || STREQ_NULLABLE(srv.domain, dns->srvs[i].domain)) &&\n            (!srv.service || STREQ_NULLABLE(srv.service, dns->srvs[i].service)) &&\n            (!srv.protocol || STREQ_NULLABLE(srv.protocol, dns->srvs[i].protocol)) &&\n            (!srv.target || STREQ_NULLABLE(srv.target, dns->srvs[i].target))) {\n            foundCt++;\n            foundIdx = i;\n        }\n    }\n\n    if (isAdd) {\n\n        if (foundCt > 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is already at least one DNS SRV \"\n                             \"record matching all specified fields in network %s\"),\n                           def->name);\n            goto cleanup;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(dns->srvs,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : dns->nsrvs, dns->nsrvs, srv) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (foundCt == 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching DNS SRV \"\n                             \"record in network %s\"), def->name);\n            goto cleanup;\n        }\n        if (foundCt > 1) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"multiple DNS SRV records matching all specified \"\n                             \"fields were found in network %s\"), def->name);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkDNSSrvDefClear(&dns->srvs[foundIdx]);\n        VIR_DELETE_ELEMENT(dns->srvs, foundIdx, dns->nsrvs);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDNSSrvDefClear(&srv);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkDNSSrvDefClear",
          "args": [
            "&srv"
          ],
          "line": 3565
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDNSSrvDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "176-183",
          "snippet": "static void\nvirNetworkDNSSrvDefClear(virNetworkDNSSrvDefPtr def)\n{\n    VIR_FREE(def->domain);\n    VIR_FREE(def->service);\n    VIR_FREE(def->protocol);\n    VIR_FREE(def->target);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDNSSrvDefClear(virNetworkDNSSrvDefPtr def)\n{\n    VIR_FREE(def->domain);\n    VIR_FREE(def->service);\n    VIR_FREE(def->protocol);\n    VIR_FREE(def->target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateUnknownCommand",
          "args": [
            "command"
          ],
          "line": 3559
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateUnknownCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2806-2811",
          "snippet": "static void\nvirNetworkDefUpdateUnknownCommand(unsigned int command)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"unrecognized network update command code %d\"), command);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDefUpdateUnknownCommand(unsigned int command)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"unrecognized network update command code %d\"), command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "dns->srvs",
            "foundIdx",
            "dns->nsrvs"
          ],
          "line": 3556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"multiple DNS SRV records matching all specified \"\n                             \"fields were found in network %s\")",
            "def->name"
          ],
          "line": 3548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"multiple DNS SRV records matching all specified \"\n                             \"fields were found in network %s\""
          ],
          "line": 3549
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"couldn't locate a matching DNS SRV \"\n                             \"record in network %s\")",
            "def->name"
          ],
          "line": 3542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INSERT_ELEMENT",
          "args": [
            "dns->srvs",
            "command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : dns->nsrvs",
            "dns->nsrvs",
            "srv"
          ],
          "line": 3535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"there is already at least one DNS SRV \"\n                             \"record matching all specified fields in network %s\")",
            "def->name"
          ],
          "line": 3527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "srv.target",
            "dns->srvs[i].target"
          ],
          "line": 3518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "srv.protocol",
            "dns->srvs[i].protocol"
          ],
          "line": 3517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "srv.service",
            "dns->srvs[i].service"
          ],
          "line": 3516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "srv.domain",
            "dns->srvs[i].domain"
          ],
          "line": 3515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDNSSrvDefParseXML",
          "args": [
            "def->name",
            "ctxt->node",
            "ctxt",
            "&srv",
            "!isAdd"
          ],
          "line": 3511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateCheckElementName",
          "args": [
            "def",
            "ctxt->node",
            "\"srv\""
          ],
          "line": 3508
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateCheckElementName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2814-2827",
          "snippet": "static int\nvirNetworkDefUpdateCheckElementName(virNetworkDefPtr def,\n                                    xmlNodePtr node,\n                                    const char *section)\n{\n    if (!virXMLNodeNameEqual(node, section)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected element <%s>, expecting <%s>, \"\n                         \"while updating network '%s'\"),\n                       node->name, section, def->name);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateCheckElementName(virNetworkDefPtr def,\n                                    xmlNodePtr node,\n                                    const char *section)\n{\n    if (!virXMLNodeNameEqual(node, section)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected element <%s>, expecting <%s>, \"\n                         \"while updating network '%s'\"),\n                       node->name, section, def->name);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"DNS SRV records cannot be modified, \"\n                         \"only added or deleted\")"
          ],
          "line": 3502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&srv",
            "0",
            "sizeof(srv)"
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateDNSSrv(virNetworkDefPtr def,\n                          unsigned int command G_GNUC_UNUSED,\n                          int parentIndex G_GNUC_UNUSED,\n                          xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                          /* virNetworkUpdateFlags */\n                          unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    int foundIdx = -1, ret = -1;\n    virNetworkDNSDefPtr dns = &def->dns;\n    virNetworkDNSSrvDef srv;\n    bool isAdd = (command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST ||\n                  command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST);\n    int foundCt = 0;\n\n    memset(&srv, 0, sizeof(srv));\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"DNS SRV records cannot be modified, \"\n                         \"only added or deleted\"));\n        goto cleanup;\n    }\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"srv\") < 0)\n        goto cleanup;\n\n    if (virNetworkDNSSrvDefParseXML(def->name, ctxt->node, ctxt, &srv, !isAdd) < 0)\n        goto cleanup;\n\n    for (i = 0; i < dns->nsrvs; i++) {\n        if ((!srv.domain || STREQ_NULLABLE(srv.domain, dns->srvs[i].domain)) &&\n            (!srv.service || STREQ_NULLABLE(srv.service, dns->srvs[i].service)) &&\n            (!srv.protocol || STREQ_NULLABLE(srv.protocol, dns->srvs[i].protocol)) &&\n            (!srv.target || STREQ_NULLABLE(srv.target, dns->srvs[i].target))) {\n            foundCt++;\n            foundIdx = i;\n        }\n    }\n\n    if (isAdd) {\n\n        if (foundCt > 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is already at least one DNS SRV \"\n                             \"record matching all specified fields in network %s\"),\n                           def->name);\n            goto cleanup;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(dns->srvs,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : dns->nsrvs, dns->nsrvs, srv) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (foundCt == 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching DNS SRV \"\n                             \"record in network %s\"), def->name);\n            goto cleanup;\n        }\n        if (foundCt > 1) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"multiple DNS SRV records matching all specified \"\n                             \"fields were found in network %s\"), def->name);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkDNSSrvDefClear(&dns->srvs[foundIdx]);\n        VIR_DELETE_ELEMENT(dns->srvs, foundIdx, dns->nsrvs);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDNSSrvDefClear(&srv);\n    return ret;\n}"
  },
  {
    "function_name": "virNetworkDefUpdateDNSHost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "3388-3480",
    "snippet": "static int\nvirNetworkDefUpdateDNSHost(virNetworkDefPtr def,\n                           unsigned int command G_GNUC_UNUSED,\n                           int parentIndex G_GNUC_UNUSED,\n                           xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                           /* virNetworkUpdateFlags */\n                           unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i, j, k;\n    int foundIdx = -1, ret = -1;\n    virNetworkDNSDefPtr dns = &def->dns;\n    virNetworkDNSHostDef host;\n    bool isAdd = (command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST ||\n                  command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST);\n    int foundCt = 0;\n\n    memset(&host, 0, sizeof(host));\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"DNS HOST records cannot be modified, \"\n                         \"only added or deleted\"));\n        goto cleanup;\n    }\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"host\") < 0)\n        goto cleanup;\n\n    if (virNetworkDNSHostDefParseXML(def->name, ctxt->node, &host, !isAdd) < 0)\n        goto cleanup;\n\n    for (i = 0; i < dns->nhosts; i++) {\n        bool foundThisTime = false;\n\n        if (virSocketAddrEqual(&host.ip, &dns->hosts[i].ip))\n            foundThisTime = true;\n\n        for (j = 0; j < host.nnames && !foundThisTime; j++) {\n            for (k = 0; k < dns->hosts[i].nnames && !foundThisTime; k++) {\n                if (STREQ(host.names[j], dns->hosts[i].names[k]))\n                    foundThisTime = true;\n            }\n        }\n        if (foundThisTime) {\n            foundCt++;\n            foundIdx = i;\n        }\n    }\n\n    if (isAdd) {\n\n        if (foundCt > 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is already at least one DNS HOST \"\n                             \"record with a matching field in network %s\"),\n                           def->name);\n            goto cleanup;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(dns->hosts,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : dns->nhosts, dns->nhosts, host) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (foundCt == 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching DNS HOST \"\n                             \"record in network %s\"), def->name);\n            goto cleanup;\n        }\n        if (foundCt > 1) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"multiple matching DNS HOST records were \"\n                             \"found in network %s\"), def->name);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkDNSHostDefClear(&dns->hosts[foundIdx]);\n        VIR_DELETE_ELEMENT(dns->hosts, foundIdx, dns->nhosts);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDNSHostDefClear(&host);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkDNSHostDefClear",
          "args": [
            "&host"
          ],
          "line": 3478
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDNSHostDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "167-173",
          "snippet": "static void\nvirNetworkDNSHostDefClear(virNetworkDNSHostDefPtr def)\n{\n    while (def->nnames)\n        VIR_FREE(def->names[--def->nnames]);\n    VIR_FREE(def->names);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDNSHostDefClear(virNetworkDNSHostDefPtr def)\n{\n    while (def->nnames)\n        VIR_FREE(def->names[--def->nnames]);\n    VIR_FREE(def->names);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateUnknownCommand",
          "args": [
            "command"
          ],
          "line": 3472
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateUnknownCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2806-2811",
          "snippet": "static void\nvirNetworkDefUpdateUnknownCommand(unsigned int command)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"unrecognized network update command code %d\"), command);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDefUpdateUnknownCommand(unsigned int command)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"unrecognized network update command code %d\"), command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "dns->hosts",
            "foundIdx",
            "dns->nhosts"
          ],
          "line": 3469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"multiple matching DNS HOST records were \"\n                             \"found in network %s\")",
            "def->name"
          ],
          "line": 3461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"multiple matching DNS HOST records were \"\n                             \"found in network %s\""
          ],
          "line": 3462
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"couldn't locate a matching DNS HOST \"\n                             \"record in network %s\")",
            "def->name"
          ],
          "line": 3455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INSERT_ELEMENT",
          "args": [
            "dns->hosts",
            "command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : dns->nhosts",
            "dns->nhosts",
            "host"
          ],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"there is already at least one DNS HOST \"\n                             \"record with a matching field in network %s\")",
            "def->name"
          ],
          "line": 3440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "host.names[j]",
            "dns->hosts[i].names[k]"
          ],
          "line": 3427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrEqual",
          "args": [
            "&host.ip",
            "&dns->hosts[i].ip"
          ],
          "line": 3422
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "359-378",
          "snippet": "bool\nvirSocketAddrEqual(const virSocketAddr *s1, const virSocketAddr *s2)\n{\n    if (s1->data.stor.ss_family != s2->data.stor.ss_family)\n        return false;\n\n    switch (s1->data.stor.ss_family) {\n    case AF_INET:\n        return (memcmp(&s1->data.inet4.sin_addr.s_addr,\n                       &s2->data.inet4.sin_addr.s_addr,\n                       sizeof(s1->data.inet4.sin_addr.s_addr)) == 0 &&\n                s1->data.inet4.sin_port == s2->data.inet4.sin_port);\n    case AF_INET6:\n        return (memcmp(&s1->data.inet6.sin6_addr.s6_addr,\n                       &s2->data.inet6.sin6_addr.s6_addr,\n                       sizeof(s1->data.inet6.sin6_addr.s6_addr)) == 0 &&\n                s1->data.inet6.sin6_port == s2->data.inet6.sin6_port);\n    }\n    return false;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nbool\nvirSocketAddrEqual(const virSocketAddr *s1, const virSocketAddr *s2)\n{\n    if (s1->data.stor.ss_family != s2->data.stor.ss_family)\n        return false;\n\n    switch (s1->data.stor.ss_family) {\n    case AF_INET:\n        return (memcmp(&s1->data.inet4.sin_addr.s_addr,\n                       &s2->data.inet4.sin_addr.s_addr,\n                       sizeof(s1->data.inet4.sin_addr.s_addr)) == 0 &&\n                s1->data.inet4.sin_port == s2->data.inet4.sin_port);\n    case AF_INET6:\n        return (memcmp(&s1->data.inet6.sin6_addr.s6_addr,\n                       &s2->data.inet6.sin6_addr.s6_addr,\n                       sizeof(s1->data.inet6.sin6_addr.s6_addr)) == 0 &&\n                s1->data.inet6.sin6_port == s2->data.inet6.sin6_port);\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDNSHostDefParseXML",
          "args": [
            "def->name",
            "ctxt->node",
            "&host",
            "!isAdd"
          ],
          "line": 3416
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDNSHostDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "623-688",
          "snippet": "static int\nvirNetworkDNSHostDefParseXML(const char *networkName,\n                             xmlNodePtr node,\n                             virNetworkDNSHostDefPtr def,\n                             bool partialOkay)\n{\n    xmlNodePtr cur;\n    char *ip;\n\n    if (!(ip = virXMLPropString(node, \"ip\")) && !partialOkay) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing IP address in network '%s' DNS HOST record\"),\n                       networkName);\n        goto error;\n    }\n\n    if (ip && (virSocketAddrParse(&def->ip, ip, AF_UNSPEC) < 0)) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Invalid IP address in network '%s' DNS HOST record\"),\n                       networkName);\n        VIR_FREE(ip);\n        goto error;\n    }\n    VIR_FREE(ip);\n\n    cur = node->children;\n    while (cur != NULL) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"hostname\")) {\n              if (cur->children != NULL) {\n                  char *name = (char *) xmlNodeGetContent(cur);\n\n                  if (!name) {\n                      virReportError(VIR_ERR_XML_DETAIL,\n                                     _(\"Missing hostname in network '%s' DNS HOST record\"),\n                                     networkName);\n                      goto error;\n                  }\n                  if (VIR_APPEND_ELEMENT(def->names, def->nnames, name) < 0) {\n                      VIR_FREE(name);\n                      goto error;\n                  }\n              }\n        }\n        cur = cur->next;\n    }\n    if (def->nnames == 0 && !partialOkay) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing hostname in network '%s' DNS HOST record\"),\n                       networkName);\n        goto error;\n    }\n\n    if (!VIR_SOCKET_ADDR_VALID(&def->ip) && def->nnames == 0) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing ip and hostname in network '%s' DNS HOST record\"),\n                       networkName);\n        goto error;\n    }\n\n    return 0;\n\n error:\n    virNetworkDNSHostDefClear(def);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDNSHostDefParseXML(const char *networkName,\n                             xmlNodePtr node,\n                             virNetworkDNSHostDefPtr def,\n                             bool partialOkay)\n{\n    xmlNodePtr cur;\n    char *ip;\n\n    if (!(ip = virXMLPropString(node, \"ip\")) && !partialOkay) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing IP address in network '%s' DNS HOST record\"),\n                       networkName);\n        goto error;\n    }\n\n    if (ip && (virSocketAddrParse(&def->ip, ip, AF_UNSPEC) < 0)) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Invalid IP address in network '%s' DNS HOST record\"),\n                       networkName);\n        VIR_FREE(ip);\n        goto error;\n    }\n    VIR_FREE(ip);\n\n    cur = node->children;\n    while (cur != NULL) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"hostname\")) {\n              if (cur->children != NULL) {\n                  char *name = (char *) xmlNodeGetContent(cur);\n\n                  if (!name) {\n                      virReportError(VIR_ERR_XML_DETAIL,\n                                     _(\"Missing hostname in network '%s' DNS HOST record\"),\n                                     networkName);\n                      goto error;\n                  }\n                  if (VIR_APPEND_ELEMENT(def->names, def->nnames, name) < 0) {\n                      VIR_FREE(name);\n                      goto error;\n                  }\n              }\n        }\n        cur = cur->next;\n    }\n    if (def->nnames == 0 && !partialOkay) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing hostname in network '%s' DNS HOST record\"),\n                       networkName);\n        goto error;\n    }\n\n    if (!VIR_SOCKET_ADDR_VALID(&def->ip) && def->nnames == 0) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing ip and hostname in network '%s' DNS HOST record\"),\n                       networkName);\n        goto error;\n    }\n\n    return 0;\n\n error:\n    virNetworkDNSHostDefClear(def);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateCheckElementName",
          "args": [
            "def",
            "ctxt->node",
            "\"host\""
          ],
          "line": 3413
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateCheckElementName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2814-2827",
          "snippet": "static int\nvirNetworkDefUpdateCheckElementName(virNetworkDefPtr def,\n                                    xmlNodePtr node,\n                                    const char *section)\n{\n    if (!virXMLNodeNameEqual(node, section)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected element <%s>, expecting <%s>, \"\n                         \"while updating network '%s'\"),\n                       node->name, section, def->name);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateCheckElementName(virNetworkDefPtr def,\n                                    xmlNodePtr node,\n                                    const char *section)\n{\n    if (!virXMLNodeNameEqual(node, section)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected element <%s>, expecting <%s>, \"\n                         \"while updating network '%s'\"),\n                       node->name, section, def->name);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"DNS HOST records cannot be modified, \"\n                         \"only added or deleted\")"
          ],
          "line": 3407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&host",
            "0",
            "sizeof(host)"
          ],
          "line": 3404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateDNSHost(virNetworkDefPtr def,\n                           unsigned int command G_GNUC_UNUSED,\n                           int parentIndex G_GNUC_UNUSED,\n                           xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                           /* virNetworkUpdateFlags */\n                           unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i, j, k;\n    int foundIdx = -1, ret = -1;\n    virNetworkDNSDefPtr dns = &def->dns;\n    virNetworkDNSHostDef host;\n    bool isAdd = (command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST ||\n                  command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST);\n    int foundCt = 0;\n\n    memset(&host, 0, sizeof(host));\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"DNS HOST records cannot be modified, \"\n                         \"only added or deleted\"));\n        goto cleanup;\n    }\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"host\") < 0)\n        goto cleanup;\n\n    if (virNetworkDNSHostDefParseXML(def->name, ctxt->node, &host, !isAdd) < 0)\n        goto cleanup;\n\n    for (i = 0; i < dns->nhosts; i++) {\n        bool foundThisTime = false;\n\n        if (virSocketAddrEqual(&host.ip, &dns->hosts[i].ip))\n            foundThisTime = true;\n\n        for (j = 0; j < host.nnames && !foundThisTime; j++) {\n            for (k = 0; k < dns->hosts[i].nnames && !foundThisTime; k++) {\n                if (STREQ(host.names[j], dns->hosts[i].names[k]))\n                    foundThisTime = true;\n            }\n        }\n        if (foundThisTime) {\n            foundCt++;\n            foundIdx = i;\n        }\n    }\n\n    if (isAdd) {\n\n        if (foundCt > 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is already at least one DNS HOST \"\n                             \"record with a matching field in network %s\"),\n                           def->name);\n            goto cleanup;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(dns->hosts,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : dns->nhosts, dns->nhosts, host) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (foundCt == 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching DNS HOST \"\n                             \"record in network %s\"), def->name);\n            goto cleanup;\n        }\n        if (foundCt > 1) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"multiple matching DNS HOST records were \"\n                             \"found in network %s\"), def->name);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkDNSHostDefClear(&dns->hosts[foundIdx]);\n        VIR_DELETE_ELEMENT(dns->hosts, foundIdx, dns->nhosts);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDNSHostDefClear(&host);\n    return ret;\n}"
  },
  {
    "function_name": "virNetworkDefUpdatePortGroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "3293-3385",
    "snippet": "static int\nvirNetworkDefUpdatePortGroup(virNetworkDefPtr def,\n                             unsigned int command,\n                             int parentIndex G_GNUC_UNUSED,\n                             xmlXPathContextPtr ctxt,\n                             /* virNetworkUpdateFlags */\n                             unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    int foundName = -1, foundDefault = -1;\n    int ret = -1;\n    virPortGroupDef portgroup;\n\n    memset(&portgroup, 0, sizeof(portgroup));\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"portgroup\") < 0)\n        goto cleanup;\n\n    if (virNetworkPortGroupParseXML(&portgroup, ctxt->node, ctxt) < 0)\n        goto cleanup;\n\n    /* check if a portgroup with same name already exists */\n    for (i = 0; i < def->nPortGroups; i++) {\n        if (STREQ(portgroup.name, def->portGroups[i].name))\n            foundName = i;\n        if (def->portGroups[i].isDefault)\n            foundDefault = i;\n    }\n    if (foundName == -1 &&\n        ((command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) ||\n         (command == VIR_NETWORK_UPDATE_COMMAND_DELETE))) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"couldn't find a portgroup entry \"\n                         \"in network '%s' matching <portgroup name='%s'>\"),\n                       def->name, portgroup.name);\n        goto cleanup;\n    } else if (foundName >= 0 &&\n               ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n                (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST))) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"there is an existing portgroup entry in \"\n                         \"network '%s' that matches \"\n                         \"\\\"<portgroup name='%s'>\\\"\"),\n                       def->name, portgroup.name);\n        goto cleanup;\n    }\n\n    /* if there is already a different default, we can't make this\n     * one the default.\n     */\n    if (command != VIR_NETWORK_UPDATE_COMMAND_DELETE &&\n        portgroup.isDefault &&\n        foundDefault >= 0 && foundDefault != foundName) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"a different portgroup entry in \"\n                         \"network '%s' is already set as the default. \"\n                         \"Only one default is allowed.\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n\n        /* replace existing entry */\n        virPortGroupDefClear(&def->portGroups[foundName]);\n        def->portGroups[foundName] = portgroup;\n        memset(&portgroup, 0, sizeof(portgroup));\n\n    } else if ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n        (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST)) {\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(def->portGroups,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : def->nPortGroups,\n                               def->nPortGroups, portgroup) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        /* remove it */\n        virPortGroupDefClear(&def->portGroups[foundName]);\n        VIR_DELETE_ELEMENT(def->portGroups, foundName, def->nPortGroups);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virPortGroupDefClear(&portgroup);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPortGroupDefClear",
          "args": [
            "&portgroup"
          ],
          "line": 3383
        },
        "resolved": true,
        "details": {
          "function_name": "virPortGroupDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "109-117",
          "snippet": "static void\nvirPortGroupDefClear(virPortGroupDefPtr def)\n{\n    VIR_FREE(def->name);\n    VIR_FREE(def->virtPortProfile);\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n    def->bandwidth = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirPortGroupDefClear(virPortGroupDefPtr def)\n{\n    VIR_FREE(def->name);\n    VIR_FREE(def->virtPortProfile);\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n    def->bandwidth = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateUnknownCommand",
          "args": [
            "command"
          ],
          "line": 3377
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateUnknownCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2806-2811",
          "snippet": "static void\nvirNetworkDefUpdateUnknownCommand(unsigned int command)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"unrecognized network update command code %d\"), command);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDefUpdateUnknownCommand(unsigned int command)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"unrecognized network update command code %d\"), command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "def->portGroups",
            "foundName",
            "def->nPortGroups"
          ],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INSERT_ELEMENT",
          "args": [
            "def->portGroups",
            "command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : def->nPortGroups",
            "def->nPortGroups",
            "portgroup"
          ],
          "line": 3365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&portgroup",
            "0",
            "sizeof(portgroup)"
          ],
          "line": 3359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"a different portgroup entry in \"\n                         \"network '%s' is already set as the default. \"\n                         \"Only one default is allowed.\")",
            "def->name"
          ],
          "line": 3346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"a different portgroup entry in \"\n                         \"network '%s' is already set as the default. \"\n                         \"Only one default is allowed.\""
          ],
          "line": 3347
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"there is an existing portgroup entry in \"\n                         \"network '%s' that matches \"\n                         \"\\\"<portgroup name='%s'>\\\"\")",
            "def->name",
            "portgroup.name"
          ],
          "line": 3332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"couldn't find a portgroup entry \"\n                         \"in network '%s' matching <portgroup name='%s'>\")",
            "def->name",
            "portgroup.name"
          ],
          "line": 3324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "portgroup.name",
            "def->portGroups[i].name"
          ],
          "line": 3316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkPortGroupParseXML",
          "args": [
            "&portgroup",
            "ctxt->node",
            "ctxt"
          ],
          "line": 3311
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkPortGroupParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "1195-1264",
          "snippet": "static int\nvirNetworkPortGroupParseXML(virPortGroupDefPtr def,\n                            xmlNodePtr node,\n                            xmlXPathContextPtr ctxt)\n{\n    /*\n     * virPortGroupDef object is already allocated as part of an array.\n     * On failure clear it out, but don't free it.\n     */\n\n    xmlNodePtr save;\n    xmlNodePtr virtPortNode;\n    xmlNodePtr vlanNode;\n    xmlNodePtr bandwidth_node;\n    char *isDefault = NULL;\n    char *trustGuestRxFilters = NULL;\n\n    int result = -1;\n\n    save = ctxt->node;\n    ctxt->node = node;\n\n    /* grab raw data from XML */\n    def->name = virXPathString(\"string(./@name)\", ctxt);\n    if (!def->name) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Missing required name attribute in portgroup\"));\n        goto cleanup;\n    }\n\n    isDefault = virXPathString(\"string(./@default)\", ctxt);\n    def->isDefault = isDefault && STRCASEEQ(isDefault, \"yes\");\n\n    trustGuestRxFilters\n        = virXPathString(\"string(./@trustGuestRxFilters)\", ctxt);\n    if (trustGuestRxFilters) {\n        if ((def->trustGuestRxFilters\n             = virTristateBoolTypeFromString(trustGuestRxFilters)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid trustGuestRxFilters setting '%s' \"\n                             \"in portgroup\"), trustGuestRxFilters);\n            goto cleanup;\n        }\n    }\n\n    virtPortNode = virXPathNode(\"./virtualport\", ctxt);\n    if (virtPortNode &&\n        (!(def->virtPortProfile = virNetDevVPortProfileParse(virtPortNode, 0)))) {\n        goto cleanup;\n    }\n\n    bandwidth_node = virXPathNode(\"./bandwidth\", ctxt);\n    if (bandwidth_node &&\n        virNetDevBandwidthParse(&def->bandwidth, NULL, bandwidth_node, false) < 0)\n        goto cleanup;\n\n    vlanNode = virXPathNode(\"./vlan\", ctxt);\n    if (vlanNode && virNetDevVlanParse(vlanNode, ctxt, &def->vlan) < 0)\n        goto cleanup;\n\n    result = 0;\n cleanup:\n    if (result < 0)\n        virPortGroupDefClear(def);\n    VIR_FREE(isDefault);\n    VIR_FREE(trustGuestRxFilters);\n\n    ctxt->node = save;\n    return result;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkPortGroupParseXML(virPortGroupDefPtr def,\n                            xmlNodePtr node,\n                            xmlXPathContextPtr ctxt)\n{\n    /*\n     * virPortGroupDef object is already allocated as part of an array.\n     * On failure clear it out, but don't free it.\n     */\n\n    xmlNodePtr save;\n    xmlNodePtr virtPortNode;\n    xmlNodePtr vlanNode;\n    xmlNodePtr bandwidth_node;\n    char *isDefault = NULL;\n    char *trustGuestRxFilters = NULL;\n\n    int result = -1;\n\n    save = ctxt->node;\n    ctxt->node = node;\n\n    /* grab raw data from XML */\n    def->name = virXPathString(\"string(./@name)\", ctxt);\n    if (!def->name) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Missing required name attribute in portgroup\"));\n        goto cleanup;\n    }\n\n    isDefault = virXPathString(\"string(./@default)\", ctxt);\n    def->isDefault = isDefault && STRCASEEQ(isDefault, \"yes\");\n\n    trustGuestRxFilters\n        = virXPathString(\"string(./@trustGuestRxFilters)\", ctxt);\n    if (trustGuestRxFilters) {\n        if ((def->trustGuestRxFilters\n             = virTristateBoolTypeFromString(trustGuestRxFilters)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid trustGuestRxFilters setting '%s' \"\n                             \"in portgroup\"), trustGuestRxFilters);\n            goto cleanup;\n        }\n    }\n\n    virtPortNode = virXPathNode(\"./virtualport\", ctxt);\n    if (virtPortNode &&\n        (!(def->virtPortProfile = virNetDevVPortProfileParse(virtPortNode, 0)))) {\n        goto cleanup;\n    }\n\n    bandwidth_node = virXPathNode(\"./bandwidth\", ctxt);\n    if (bandwidth_node &&\n        virNetDevBandwidthParse(&def->bandwidth, NULL, bandwidth_node, false) < 0)\n        goto cleanup;\n\n    vlanNode = virXPathNode(\"./vlan\", ctxt);\n    if (vlanNode && virNetDevVlanParse(vlanNode, ctxt, &def->vlan) < 0)\n        goto cleanup;\n\n    result = 0;\n cleanup:\n    if (result < 0)\n        virPortGroupDefClear(def);\n    VIR_FREE(isDefault);\n    VIR_FREE(trustGuestRxFilters);\n\n    ctxt->node = save;\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateCheckElementName",
          "args": [
            "def",
            "ctxt->node",
            "\"portgroup\""
          ],
          "line": 3308
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateCheckElementName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2814-2827",
          "snippet": "static int\nvirNetworkDefUpdateCheckElementName(virNetworkDefPtr def,\n                                    xmlNodePtr node,\n                                    const char *section)\n{\n    if (!virXMLNodeNameEqual(node, section)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected element <%s>, expecting <%s>, \"\n                         \"while updating network '%s'\"),\n                       node->name, section, def->name);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateCheckElementName(virNetworkDefPtr def,\n                                    xmlNodePtr node,\n                                    const char *section)\n{\n    if (!virXMLNodeNameEqual(node, section)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected element <%s>, expecting <%s>, \"\n                         \"while updating network '%s'\"),\n                       node->name, section, def->name);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&portgroup",
            "0",
            "sizeof(portgroup)"
          ],
          "line": 3306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdatePortGroup(virNetworkDefPtr def,\n                             unsigned int command,\n                             int parentIndex G_GNUC_UNUSED,\n                             xmlXPathContextPtr ctxt,\n                             /* virNetworkUpdateFlags */\n                             unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    int foundName = -1, foundDefault = -1;\n    int ret = -1;\n    virPortGroupDef portgroup;\n\n    memset(&portgroup, 0, sizeof(portgroup));\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"portgroup\") < 0)\n        goto cleanup;\n\n    if (virNetworkPortGroupParseXML(&portgroup, ctxt->node, ctxt) < 0)\n        goto cleanup;\n\n    /* check if a portgroup with same name already exists */\n    for (i = 0; i < def->nPortGroups; i++) {\n        if (STREQ(portgroup.name, def->portGroups[i].name))\n            foundName = i;\n        if (def->portGroups[i].isDefault)\n            foundDefault = i;\n    }\n    if (foundName == -1 &&\n        ((command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) ||\n         (command == VIR_NETWORK_UPDATE_COMMAND_DELETE))) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"couldn't find a portgroup entry \"\n                         \"in network '%s' matching <portgroup name='%s'>\"),\n                       def->name, portgroup.name);\n        goto cleanup;\n    } else if (foundName >= 0 &&\n               ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n                (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST))) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"there is an existing portgroup entry in \"\n                         \"network '%s' that matches \"\n                         \"\\\"<portgroup name='%s'>\\\"\"),\n                       def->name, portgroup.name);\n        goto cleanup;\n    }\n\n    /* if there is already a different default, we can't make this\n     * one the default.\n     */\n    if (command != VIR_NETWORK_UPDATE_COMMAND_DELETE &&\n        portgroup.isDefault &&\n        foundDefault >= 0 && foundDefault != foundName) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"a different portgroup entry in \"\n                         \"network '%s' is already set as the default. \"\n                         \"Only one default is allowed.\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n\n        /* replace existing entry */\n        virPortGroupDefClear(&def->portGroups[foundName]);\n        def->portGroups[foundName] = portgroup;\n        memset(&portgroup, 0, sizeof(portgroup));\n\n    } else if ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n        (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST)) {\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(def->portGroups,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : def->nPortGroups,\n                               def->nPortGroups, portgroup) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        /* remove it */\n        virPortGroupDefClear(&def->portGroups[foundName]);\n        VIR_DELETE_ELEMENT(def->portGroups, foundName, def->nPortGroups);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virPortGroupDefClear(&portgroup);\n    return ret;\n}"
  },
  {
    "function_name": "virNetworkDefUpdateForwardPF",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "3280-3290",
    "snippet": "static int\nvirNetworkDefUpdateForwardPF(virNetworkDefPtr def,\n                             unsigned int command G_GNUC_UNUSED,\n                             int parentIndex G_GNUC_UNUSED,\n                             xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                             /* virNetworkUpdateFlags */\n                             unsigned int fflags G_GNUC_UNUSED)\n{\n    virNetworkDefUpdateNoSupport(def, \"forward pf\");\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkDefUpdateNoSupport",
          "args": [
            "def",
            "\"forward pf\""
          ],
          "line": 3288
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateNoSupport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2797-2803",
          "snippet": "static void\nvirNetworkDefUpdateNoSupport(virNetworkDefPtr def, const char *section)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"can't update '%s' section of network '%s'\"),\n                   section, def->name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDefUpdateNoSupport(virNetworkDefPtr def, const char *section)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"can't update '%s' section of network '%s'\"),\n                   section, def->name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateForwardPF(virNetworkDefPtr def,\n                             unsigned int command G_GNUC_UNUSED,\n                             int parentIndex G_GNUC_UNUSED,\n                             xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                             /* virNetworkUpdateFlags */\n                             unsigned int fflags G_GNUC_UNUSED)\n{\n    virNetworkDefUpdateNoSupport(def, \"forward pf\");\n    return -1;\n}"
  },
  {
    "function_name": "virNetworkDefUpdateForwardInterface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "3185-3277",
    "snippet": "static int\nvirNetworkDefUpdateForwardInterface(virNetworkDefPtr def,\n                                    unsigned int command,\n                                    int parentIndex G_GNUC_UNUSED,\n                                    xmlXPathContextPtr ctxt,\n                                    /* virNetworkUpdateFlags */\n                                    unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    int ret = -1;\n    virNetworkForwardIfDef iface;\n\n    memset(&iface, 0, sizeof(iface));\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"interface\") < 0)\n        goto cleanup;\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"forward interface entries cannot be modified, \"\n                         \"only added or deleted\"));\n        goto cleanup;\n    }\n\n    /* parsing this is so simple that it doesn't have its own function */\n    iface.type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n    if (!(iface.device.dev = virXMLPropString(ctxt->node, \"dev\"))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing dev attribute in <interface> element\"));\n        goto cleanup;\n    }\n\n    /* check if an <interface> with same dev name already exists */\n    for (i = 0; i < def->forward.nifs; i++) {\n        if (def->forward.ifs[i].type\n            == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV &&\n            STREQ(iface.device.dev, def->forward.ifs[i].device.dev))\n            break;\n    }\n\n    if ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n        (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST)) {\n\n        if (i < def->forward.nifs) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is an existing interface entry \"\n                             \"in network '%s' that matches \"\n                             \"\\\"<interface dev='%s'>\\\"\"),\n                           def->name, iface.device.dev);\n            goto cleanup;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(def->forward.ifs,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : def->forward.nifs,\n                               def->forward.nifs, iface) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (i == def->forward.nifs) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't find an interface entry \"\n                             \"in network '%s' matching <interface dev='%s'>\"),\n                           def->name, iface.device.dev);\n            goto cleanup;\n        }\n\n        /* fail if the interface is being used */\n        if (def->forward.ifs[i].connections > 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"unable to delete interface '%s' \"\n                             \"in network '%s'. It is currently being used \"\n                             \" by %d domains.\"),\n                           iface.device.dev, def->name,\n                           def->forward.ifs[i].connections);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkForwardIfDefClear(&def->forward.ifs[i]);\n        VIR_DELETE_ELEMENT(def->forward.ifs, i, def->forward.nifs);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkForwardIfDefClear(&iface);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkForwardIfDefClear",
          "args": [
            "&iface"
          ],
          "line": 3275
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkForwardIfDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "120-125",
          "snippet": "static void\nvirNetworkForwardIfDefClear(virNetworkForwardIfDefPtr def)\n{\n    if (def->type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n        VIR_FREE(def->device.dev);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkForwardIfDefClear(virNetworkForwardIfDefPtr def)\n{\n    if (def->type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n        VIR_FREE(def->device.dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateUnknownCommand",
          "args": [
            "command"
          ],
          "line": 3269
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateUnknownCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2806-2811",
          "snippet": "static void\nvirNetworkDefUpdateUnknownCommand(unsigned int command)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"unrecognized network update command code %d\"), command);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDefUpdateUnknownCommand(unsigned int command)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"unrecognized network update command code %d\"), command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "def->forward.ifs",
            "i",
            "def->forward.nifs"
          ],
          "line": 3266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"unable to delete interface '%s' \"\n                             \"in network '%s'. It is currently being used \"\n                             \" by %d domains.\")",
            "iface.device.dev",
            "def->name",
            "def->forward.ifs[i].connections"
          ],
          "line": 3255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to delete interface '%s' \"\n                             \"in network '%s'. It is currently being used \"\n                             \" by %d domains.\""
          ],
          "line": 3256
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"couldn't find an interface entry \"\n                             \"in network '%s' matching <interface dev='%s'>\")",
            "def->name",
            "iface.device.dev"
          ],
          "line": 3246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INSERT_ELEMENT",
          "args": [
            "def->forward.ifs",
            "command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : def->forward.nifs",
            "def->forward.nifs",
            "iface"
          ],
          "line": 3238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"there is an existing interface entry \"\n                             \"in network '%s' that matches \"\n                             \"\\\"<interface dev='%s'>\\\"\")",
            "def->name",
            "iface.device.dev"
          ],
          "line": 3229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "iface.device.dev",
            "def->forward.ifs[i].device.dev"
          ],
          "line": 3221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing dev attribute in <interface> element\")"
          ],
          "line": 3212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "ctxt->node",
            "\"dev\""
          ],
          "line": 3211
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"forward interface entries cannot be modified, \"\n                         \"only added or deleted\")"
          ],
          "line": 3203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateCheckElementName",
          "args": [
            "def",
            "ctxt->node",
            "\"interface\""
          ],
          "line": 3199
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateCheckElementName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2814-2827",
          "snippet": "static int\nvirNetworkDefUpdateCheckElementName(virNetworkDefPtr def,\n                                    xmlNodePtr node,\n                                    const char *section)\n{\n    if (!virXMLNodeNameEqual(node, section)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected element <%s>, expecting <%s>, \"\n                         \"while updating network '%s'\"),\n                       node->name, section, def->name);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateCheckElementName(virNetworkDefPtr def,\n                                    xmlNodePtr node,\n                                    const char *section)\n{\n    if (!virXMLNodeNameEqual(node, section)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected element <%s>, expecting <%s>, \"\n                         \"while updating network '%s'\"),\n                       node->name, section, def->name);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&iface",
            "0",
            "sizeof(iface)"
          ],
          "line": 3197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateForwardInterface(virNetworkDefPtr def,\n                                    unsigned int command,\n                                    int parentIndex G_GNUC_UNUSED,\n                                    xmlXPathContextPtr ctxt,\n                                    /* virNetworkUpdateFlags */\n                                    unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    int ret = -1;\n    virNetworkForwardIfDef iface;\n\n    memset(&iface, 0, sizeof(iface));\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"interface\") < 0)\n        goto cleanup;\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"forward interface entries cannot be modified, \"\n                         \"only added or deleted\"));\n        goto cleanup;\n    }\n\n    /* parsing this is so simple that it doesn't have its own function */\n    iface.type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n    if (!(iface.device.dev = virXMLPropString(ctxt->node, \"dev\"))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing dev attribute in <interface> element\"));\n        goto cleanup;\n    }\n\n    /* check if an <interface> with same dev name already exists */\n    for (i = 0; i < def->forward.nifs; i++) {\n        if (def->forward.ifs[i].type\n            == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV &&\n            STREQ(iface.device.dev, def->forward.ifs[i].device.dev))\n            break;\n    }\n\n    if ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n        (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST)) {\n\n        if (i < def->forward.nifs) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is an existing interface entry \"\n                             \"in network '%s' that matches \"\n                             \"\\\"<interface dev='%s'>\\\"\"),\n                           def->name, iface.device.dev);\n            goto cleanup;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(def->forward.ifs,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : def->forward.nifs,\n                               def->forward.nifs, iface) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (i == def->forward.nifs) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't find an interface entry \"\n                             \"in network '%s' matching <interface dev='%s'>\"),\n                           def->name, iface.device.dev);\n            goto cleanup;\n        }\n\n        /* fail if the interface is being used */\n        if (def->forward.ifs[i].connections > 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"unable to delete interface '%s' \"\n                             \"in network '%s'. It is currently being used \"\n                             \" by %d domains.\"),\n                           iface.device.dev, def->name,\n                           def->forward.ifs[i].connections);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkForwardIfDefClear(&def->forward.ifs[i]);\n        VIR_DELETE_ELEMENT(def->forward.ifs, i, def->forward.nifs);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkForwardIfDefClear(&iface);\n    return ret;\n}"
  },
  {
    "function_name": "virNetworkDefUpdateForward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "3172-3182",
    "snippet": "static int\nvirNetworkDefUpdateForward(virNetworkDefPtr def,\n                           unsigned int command G_GNUC_UNUSED,\n                           int parentIndex G_GNUC_UNUSED,\n                           xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                           /* virNetworkUpdateFlags */\n                           unsigned int fflags G_GNUC_UNUSED)\n{\n    virNetworkDefUpdateNoSupport(def, \"forward\");\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkDefUpdateNoSupport",
          "args": [
            "def",
            "\"forward\""
          ],
          "line": 3180
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateNoSupport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2797-2803",
          "snippet": "static void\nvirNetworkDefUpdateNoSupport(virNetworkDefPtr def, const char *section)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"can't update '%s' section of network '%s'\"),\n                   section, def->name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDefUpdateNoSupport(virNetworkDefPtr def, const char *section)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"can't update '%s' section of network '%s'\"),\n                   section, def->name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateForward(virNetworkDefPtr def,\n                           unsigned int command G_GNUC_UNUSED,\n                           int parentIndex G_GNUC_UNUSED,\n                           xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                           /* virNetworkUpdateFlags */\n                           unsigned int fflags G_GNUC_UNUSED)\n{\n    virNetworkDefUpdateNoSupport(def, \"forward\");\n    return -1;\n}"
  },
  {
    "function_name": "virNetworkDefUpdateIPDHCPRange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "3073-3169",
    "snippet": "static int\nvirNetworkDefUpdateIPDHCPRange(virNetworkDefPtr def,\n                               unsigned int command,\n                               int parentIndex,\n                               xmlXPathContextPtr ctxt,\n                               /* virNetworkUpdateFlags */\n                               unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    virNetworkIPDefPtr ipdef = virNetworkIPDefByIndex(def, parentIndex);\n    virSocketAddrRange range;\n\n    memset(&range, 0, sizeof(range));\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"range\") < 0)\n        return -1;\n\n    /* ipdef is the ip element that needs its range array updated */\n    if (!ipdef)\n        return -1;\n\n    /* parse the xml into a virSocketAddrRange */\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"dhcp ranges cannot be modified, \"\n                         \"only added or deleted\"));\n        return -1;\n    }\n\n    if (virSocketAddrRangeParseXML(def->name, ipdef, ctxt->node, &range) < 0)\n        return -1;\n\n    if (VIR_SOCKET_ADDR_FAMILY(&ipdef->address)\n        != VIR_SOCKET_ADDR_FAMILY(&range.start)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"the address family of a dhcp range must match \"\n                         \"the address family of the dhcp element's parent\"));\n        return -1;\n    }\n\n    /* check if an entry with same name/address/ip already exists */\n    for (i = 0; i < ipdef->nranges; i++) {\n        if (virSocketAddrEqual(&range.start, &ipdef->ranges[i].start) &&\n            virSocketAddrEqual(&range.end, &ipdef->ranges[i].end)) {\n            break;\n        }\n    }\n\n    if ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n        (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST)) {\n\n        if (virNetworkDefUpdateCheckMultiDHCP(def, ipdef) < 0)\n            return -1;\n\n        if (i < ipdef->nranges) {\n            char *startip = virSocketAddrFormat(&range.start);\n            char *endip = virSocketAddrFormat(&range.end);\n\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is an existing dhcp range entry in \"\n                             \"network '%s' that matches \"\n                             \"\\\"<range start='%s' end='%s'/>\\\"\"),\n                           def->name,\n                           startip ? startip : \"unknown\",\n                           endip ? endip : \"unknown\");\n            VIR_FREE(startip);\n            VIR_FREE(endip);\n            return -1;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(ipdef->ranges,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : ipdef->nranges,\n                               ipdef->nranges, range) < 0)\n            return -1;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (i == ipdef->nranges) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching dhcp range entry \"\n                             \"in network '%s'\"), def->name);\n            return -1;\n        }\n\n        /* remove it */\n        /* NB: nothing to clear from a RangeDef that's being freed */\n        VIR_DELETE_ELEMENT(ipdef->ranges, i, ipdef->nranges);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkDefUpdateUnknownCommand",
          "args": [
            "command"
          ],
          "line": 3164
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateUnknownCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2806-2811",
          "snippet": "static void\nvirNetworkDefUpdateUnknownCommand(unsigned int command)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"unrecognized network update command code %d\"), command);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDefUpdateUnknownCommand(unsigned int command)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"unrecognized network update command code %d\"), command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "ipdef->ranges",
            "i",
            "ipdef->nranges"
          ],
          "line": 3161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"couldn't locate a matching dhcp range entry \"\n                             \"in network '%s'\")",
            "def->name"
          ],
          "line": 3153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"couldn't locate a matching dhcp range entry \"\n                             \"in network '%s'\""
          ],
          "line": 3154
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INSERT_ELEMENT",
          "args": [
            "ipdef->ranges",
            "command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : ipdef->nranges",
            "ipdef->nranges",
            "range"
          ],
          "line": 3145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "endip"
          ],
          "line": 3140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "startip"
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"there is an existing dhcp range entry in \"\n                             \"network '%s' that matches \"\n                             \"\\\"<range start='%s' end='%s'/>\\\"\")",
            "def->name",
            "startip ? startip : \"unknown\"",
            "endip ? endip : \"unknown\""
          ],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "&range.end"
          ],
          "line": 3130
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateCheckMultiDHCP",
          "args": [
            "def",
            "ipdef"
          ],
          "line": 3125
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateCheckMultiDHCP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2910-2930",
          "snippet": "static int\nvirNetworkDefUpdateCheckMultiDHCP(virNetworkDefPtr def,\n                                  virNetworkIPDefPtr ipdef)\n{\n    int family = VIR_SOCKET_ADDR_FAMILY(&ipdef->address);\n    size_t i;\n    virNetworkIPDefPtr ip;\n\n    for (i = 0; (ip = virNetworkDefGetIPByIndex(def, family, i)); i++) {\n        if (ip != ipdef) {\n            if (ip->nranges || ip->nhosts) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"dhcp is supported only for a \"\n                                 \"single %s address on each network\"),\n                               (family == AF_INET) ? \"IPv4\" : \"IPv6\");\n                return -1;\n            }\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateCheckMultiDHCP(virNetworkDefPtr def,\n                                  virNetworkIPDefPtr ipdef)\n{\n    int family = VIR_SOCKET_ADDR_FAMILY(&ipdef->address);\n    size_t i;\n    virNetworkIPDefPtr ip;\n\n    for (i = 0; (ip = virNetworkDefGetIPByIndex(def, family, i)); i++) {\n        if (ip != ipdef) {\n            if (ip->nranges || ip->nhosts) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"dhcp is supported only for a \"\n                                 \"single %s address on each network\"),\n                               (family == AF_INET) ? \"IPv4\" : \"IPv6\");\n                return -1;\n            }\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrEqual",
          "args": [
            "&range.end",
            "&ipdef->ranges[i].end"
          ],
          "line": 3117
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "359-378",
          "snippet": "bool\nvirSocketAddrEqual(const virSocketAddr *s1, const virSocketAddr *s2)\n{\n    if (s1->data.stor.ss_family != s2->data.stor.ss_family)\n        return false;\n\n    switch (s1->data.stor.ss_family) {\n    case AF_INET:\n        return (memcmp(&s1->data.inet4.sin_addr.s_addr,\n                       &s2->data.inet4.sin_addr.s_addr,\n                       sizeof(s1->data.inet4.sin_addr.s_addr)) == 0 &&\n                s1->data.inet4.sin_port == s2->data.inet4.sin_port);\n    case AF_INET6:\n        return (memcmp(&s1->data.inet6.sin6_addr.s6_addr,\n                       &s2->data.inet6.sin6_addr.s6_addr,\n                       sizeof(s1->data.inet6.sin6_addr.s6_addr)) == 0 &&\n                s1->data.inet6.sin6_port == s2->data.inet6.sin6_port);\n    }\n    return false;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nbool\nvirSocketAddrEqual(const virSocketAddr *s1, const virSocketAddr *s2)\n{\n    if (s1->data.stor.ss_family != s2->data.stor.ss_family)\n        return false;\n\n    switch (s1->data.stor.ss_family) {\n    case AF_INET:\n        return (memcmp(&s1->data.inet4.sin_addr.s_addr,\n                       &s2->data.inet4.sin_addr.s_addr,\n                       sizeof(s1->data.inet4.sin_addr.s_addr)) == 0 &&\n                s1->data.inet4.sin_port == s2->data.inet4.sin_port);\n    case AF_INET6:\n        return (memcmp(&s1->data.inet6.sin6_addr.s6_addr,\n                       &s2->data.inet6.sin6_addr.s6_addr,\n                       sizeof(s1->data.inet6.sin6_addr.s6_addr)) == 0 &&\n                s1->data.inet6.sin6_port == s2->data.inet6.sin6_port);\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"the address family of a dhcp range must match \"\n                         \"the address family of the dhcp element's parent\")"
          ],
          "line": 3108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "&range.start"
          ],
          "line": 3107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "&ipdef->address"
          ],
          "line": 3106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrRangeParseXML",
          "args": [
            "def->name",
            "ipdef",
            "ctxt->node",
            "&range"
          ],
          "line": 3103
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrRangeParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "393-431",
          "snippet": "static int\nvirSocketAddrRangeParseXML(const char *networkName,\n                           virNetworkIPDefPtr ipdef,\n                           xmlNodePtr node,\n                           virSocketAddrRangePtr range)\n{\n    char *start = NULL, *end = NULL;\n    int ret = -1;\n\n    if (!(start = virXMLPropString(node, \"start\"))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Missing 'start' attribute in dhcp range for network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (virSocketAddrParse(&range->start, start, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    if (!(end = virXMLPropString(node, \"end\"))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Missing 'end' attribute in dhcp range for network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (virSocketAddrParse(&range->end, end, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    /* do a sanity check of the range */\n    if (virSocketAddrGetRange(&range->start, &range->end, &ipdef->address,\n                              virNetworkIPDefPrefix(ipdef)) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(start);\n    VIR_FREE(end);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirSocketAddrRangeParseXML(const char *networkName,\n                           virNetworkIPDefPtr ipdef,\n                           xmlNodePtr node,\n                           virSocketAddrRangePtr range)\n{\n    char *start = NULL, *end = NULL;\n    int ret = -1;\n\n    if (!(start = virXMLPropString(node, \"start\"))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Missing 'start' attribute in dhcp range for network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (virSocketAddrParse(&range->start, start, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    if (!(end = virXMLPropString(node, \"end\"))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Missing 'end' attribute in dhcp range for network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (virSocketAddrParse(&range->end, end, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    /* do a sanity check of the range */\n    if (virSocketAddrGetRange(&range->start, &range->end, &ipdef->address,\n                              virNetworkIPDefPrefix(ipdef)) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(start);\n    VIR_FREE(end);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"dhcp ranges cannot be modified, \"\n                         \"only added or deleted\")"
          ],
          "line": 3097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateCheckElementName",
          "args": [
            "def",
            "ctxt->node",
            "\"range\""
          ],
          "line": 3087
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateCheckElementName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2814-2827",
          "snippet": "static int\nvirNetworkDefUpdateCheckElementName(virNetworkDefPtr def,\n                                    xmlNodePtr node,\n                                    const char *section)\n{\n    if (!virXMLNodeNameEqual(node, section)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected element <%s>, expecting <%s>, \"\n                         \"while updating network '%s'\"),\n                       node->name, section, def->name);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateCheckElementName(virNetworkDefPtr def,\n                                    xmlNodePtr node,\n                                    const char *section)\n{\n    if (!virXMLNodeNameEqual(node, section)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected element <%s>, expecting <%s>, \"\n                         \"while updating network '%s'\"),\n                       node->name, section, def->name);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&range",
            "0",
            "sizeof(range)"
          ],
          "line": 3085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefByIndex",
          "args": [
            "def",
            "parentIndex"
          ],
          "line": 3082
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2869-2907",
          "snippet": "static virNetworkIPDefPtr\nvirNetworkIPDefByIndex(virNetworkDefPtr def, int parentIndex)\n{\n    virNetworkIPDefPtr ipdef = NULL;\n    size_t i;\n\n    /* first find which ip element's dhcp host list to work on */\n    if (parentIndex >= 0) {\n        ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, parentIndex);\n        if (!(ipdef)) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't update dhcp host entry - no <ip> \"\n                             \"element found at index %d in network '%s'\"),\n                           parentIndex, def->name);\n        }\n        return ipdef;\n    }\n\n    /* -1 means \"find the most appropriate\", which in this case\n     * means the one and only <ip> that has <dhcp> element\n     */\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (ipdef->nranges || ipdef->nhosts)\n            break;\n    }\n    if (!ipdef) {\n        ipdef = virNetworkDefGetIPByIndex(def, AF_INET, 0);\n        if (!ipdef)\n            ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, 0);\n    }\n    if (!ipdef) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"couldn't update dhcp host entry - no <ip> \"\n                         \"element found in network '%s'\"), def->name);\n    }\n    return ipdef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virNetworkIPDefPtr\nvirNetworkIPDefByIndex(virNetworkDefPtr def, int parentIndex)\n{\n    virNetworkIPDefPtr ipdef = NULL;\n    size_t i;\n\n    /* first find which ip element's dhcp host list to work on */\n    if (parentIndex >= 0) {\n        ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, parentIndex);\n        if (!(ipdef)) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't update dhcp host entry - no <ip> \"\n                             \"element found at index %d in network '%s'\"),\n                           parentIndex, def->name);\n        }\n        return ipdef;\n    }\n\n    /* -1 means \"find the most appropriate\", which in this case\n     * means the one and only <ip> that has <dhcp> element\n     */\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (ipdef->nranges || ipdef->nhosts)\n            break;\n    }\n    if (!ipdef) {\n        ipdef = virNetworkDefGetIPByIndex(def, AF_INET, 0);\n        if (!ipdef)\n            ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, 0);\n    }\n    if (!ipdef) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"couldn't update dhcp host entry - no <ip> \"\n                         \"element found in network '%s'\"), def->name);\n    }\n    return ipdef;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateIPDHCPRange(virNetworkDefPtr def,\n                               unsigned int command,\n                               int parentIndex,\n                               xmlXPathContextPtr ctxt,\n                               /* virNetworkUpdateFlags */\n                               unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    virNetworkIPDefPtr ipdef = virNetworkIPDefByIndex(def, parentIndex);\n    virSocketAddrRange range;\n\n    memset(&range, 0, sizeof(range));\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"range\") < 0)\n        return -1;\n\n    /* ipdef is the ip element that needs its range array updated */\n    if (!ipdef)\n        return -1;\n\n    /* parse the xml into a virSocketAddrRange */\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"dhcp ranges cannot be modified, \"\n                         \"only added or deleted\"));\n        return -1;\n    }\n\n    if (virSocketAddrRangeParseXML(def->name, ipdef, ctxt->node, &range) < 0)\n        return -1;\n\n    if (VIR_SOCKET_ADDR_FAMILY(&ipdef->address)\n        != VIR_SOCKET_ADDR_FAMILY(&range.start)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"the address family of a dhcp range must match \"\n                         \"the address family of the dhcp element's parent\"));\n        return -1;\n    }\n\n    /* check if an entry with same name/address/ip already exists */\n    for (i = 0; i < ipdef->nranges; i++) {\n        if (virSocketAddrEqual(&range.start, &ipdef->ranges[i].start) &&\n            virSocketAddrEqual(&range.end, &ipdef->ranges[i].end)) {\n            break;\n        }\n    }\n\n    if ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n        (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST)) {\n\n        if (virNetworkDefUpdateCheckMultiDHCP(def, ipdef) < 0)\n            return -1;\n\n        if (i < ipdef->nranges) {\n            char *startip = virSocketAddrFormat(&range.start);\n            char *endip = virSocketAddrFormat(&range.end);\n\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"there is an existing dhcp range entry in \"\n                             \"network '%s' that matches \"\n                             \"\\\"<range start='%s' end='%s'/>\\\"\"),\n                           def->name,\n                           startip ? startip : \"unknown\",\n                           endip ? endip : \"unknown\");\n            VIR_FREE(startip);\n            VIR_FREE(endip);\n            return -1;\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(ipdef->ranges,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : ipdef->nranges,\n                               ipdef->nranges, range) < 0)\n            return -1;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        if (i == ipdef->nranges) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching dhcp range entry \"\n                             \"in network '%s'\"), def->name);\n            return -1;\n        }\n\n        /* remove it */\n        /* NB: nothing to clear from a RangeDef that's being freed */\n        VIR_DELETE_ELEMENT(ipdef->ranges, i, ipdef->nranges);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetworkDefUpdateIPDHCPHost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2933-3070",
    "snippet": "static int\nvirNetworkDefUpdateIPDHCPHost(virNetworkDefPtr def,\n                              unsigned int command,\n                              int parentIndex,\n                              xmlXPathContextPtr ctxt,\n                              /* virNetworkUpdateFlags */\n                              unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    int ret = -1;\n    virNetworkIPDefPtr ipdef = virNetworkIPDefByIndex(def, parentIndex);\n    virNetworkDHCPHostDef host;\n    bool partialOkay = (command == VIR_NETWORK_UPDATE_COMMAND_DELETE);\n\n    memset(&host, 0, sizeof(host));\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"host\") < 0)\n        goto cleanup;\n\n    /* ipdef is the ip element that needs its host array updated */\n    if (!ipdef)\n        goto cleanup;\n\n    if (virNetworkDHCPHostDefParseXML(def->name, ipdef, ctxt->node,\n                                      &host, partialOkay) < 0)\n        goto cleanup;\n\n    if (!partialOkay &&\n        VIR_SOCKET_ADDR_FAMILY(&ipdef->address)\n        != VIR_SOCKET_ADDR_FAMILY(&host.ip)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"the address family of a host entry IP must match \"\n                         \"the address family of the dhcp element's parent\"));\n        goto cleanup;\n    }\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n\n        /* search for the entry with this (ip|mac|name),\n         * and update the IP+(mac|name) */\n        for (i = 0; i < ipdef->nhosts; i++) {\n            if ((host.mac && ipdef->hosts[i].mac &&\n                 !virMacAddrCompare(host.mac, ipdef->hosts[i].mac)) ||\n                (VIR_SOCKET_ADDR_VALID(&host.ip) &&\n                 virSocketAddrEqual(&host.ip, &ipdef->hosts[i].ip)) ||\n                (host.name &&\n                 STREQ_NULLABLE(host.name, ipdef->hosts[i].name))) {\n                break;\n            }\n        }\n\n        if (i == ipdef->nhosts) {\n            char *ip = virSocketAddrFormat(&host.ip);\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate an existing dhcp host entry with \"\n                             \"\\\"mac='%s'\\\" \\\"name='%s'\\\" \\\"ip='%s'\\\" in\"\n                             \" network '%s'\"),\n                           host.mac ? host.mac : _(\"unknown\"), host.name,\n                           ip ? ip : _(\"unknown\"), def->name);\n            VIR_FREE(ip);\n            goto cleanup;\n        }\n\n        /* clear the existing hosts entry, move the new one in its place,\n         * then clear out the extra copy to get rid of the duplicate pointers\n         * to its data (mac and name strings).\n         */\n        virNetworkDHCPHostDefClear(&ipdef->hosts[i]);\n        ipdef->hosts[i] = host;\n        memset(&host, 0, sizeof(host));\n\n    } else if ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n               (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST)) {\n\n        if (virNetworkDefUpdateCheckMultiDHCP(def, ipdef) < 0)\n            goto cleanup;\n\n        /* log error if an entry with same name/address/ip already exists */\n        for (i = 0; i < ipdef->nhosts; i++) {\n            if ((host.mac && ipdef->hosts[i].mac &&\n                 !virMacAddrCompare(host.mac, ipdef->hosts[i].mac)) ||\n                (host.name &&\n                 STREQ_NULLABLE(host.name, ipdef->hosts[i].name)) ||\n                (VIR_SOCKET_ADDR_VALID(&host.ip) &&\n                 virSocketAddrEqual(&host.ip, &ipdef->hosts[i].ip))) {\n                char *ip = virSocketAddrFormat(&host.ip);\n\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"there is an existing dhcp host entry in \"\n                                 \"network '%s' that matches \"\n                                 \"\\\"<host mac='%s' name='%s' ip='%s'/>\\\"\"),\n                               def->name, host.mac ? host.mac : _(\"unknown\"),\n                               host.name, ip ? ip : _(\"unknown\"));\n                VIR_FREE(ip);\n                goto cleanup;\n            }\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(ipdef->hosts,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : ipdef->nhosts,\n                               ipdef->nhosts, host) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        /* find matching entry - all specified attributes must match */\n        for (i = 0; i < ipdef->nhosts; i++) {\n            if ((!host.mac || !ipdef->hosts[i].mac ||\n                 !virMacAddrCompare(host.mac, ipdef->hosts[i].mac)) &&\n                (!host.name ||\n                 STREQ_NULLABLE(host.name, ipdef->hosts[i].name)) &&\n                (!VIR_SOCKET_ADDR_VALID(&host.ip) ||\n                 virSocketAddrEqual(&host.ip, &ipdef->hosts[i].ip))) {\n                break;\n            }\n        }\n        if (i == ipdef->nhosts) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching dhcp host entry \"\n                             \"in network '%s'\"), def->name);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkDHCPHostDefClear(&ipdef->hosts[i]);\n        VIR_DELETE_ELEMENT(ipdef->hosts, i, ipdef->nhosts);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDHCPHostDefClear(&host);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkDHCPHostDefClear",
          "args": [
            "&host"
          ],
          "line": 3068
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDHCPHostDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "135-141",
          "snippet": "static void\nvirNetworkDHCPHostDefClear(virNetworkDHCPHostDefPtr def)\n{\n    VIR_FREE(def->mac);\n    VIR_FREE(def->id);\n    VIR_FREE(def->name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDHCPHostDefClear(virNetworkDHCPHostDefPtr def)\n{\n    VIR_FREE(def->mac);\n    VIR_FREE(def->id);\n    VIR_FREE(def->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateUnknownCommand",
          "args": [
            "command"
          ],
          "line": 3062
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateUnknownCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2806-2811",
          "snippet": "static void\nvirNetworkDefUpdateUnknownCommand(unsigned int command)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"unrecognized network update command code %d\"), command);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDefUpdateUnknownCommand(unsigned int command)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"unrecognized network update command code %d\"), command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "ipdef->hosts",
            "i",
            "ipdef->nhosts"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"couldn't locate a matching dhcp host entry \"\n                             \"in network '%s'\")",
            "def->name"
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"couldn't locate a matching dhcp host entry \"\n                             \"in network '%s'\""
          ],
          "line": 3052
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrEqual",
          "args": [
            "&host.ip",
            "&ipdef->hosts[i].ip"
          ],
          "line": 3046
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "359-378",
          "snippet": "bool\nvirSocketAddrEqual(const virSocketAddr *s1, const virSocketAddr *s2)\n{\n    if (s1->data.stor.ss_family != s2->data.stor.ss_family)\n        return false;\n\n    switch (s1->data.stor.ss_family) {\n    case AF_INET:\n        return (memcmp(&s1->data.inet4.sin_addr.s_addr,\n                       &s2->data.inet4.sin_addr.s_addr,\n                       sizeof(s1->data.inet4.sin_addr.s_addr)) == 0 &&\n                s1->data.inet4.sin_port == s2->data.inet4.sin_port);\n    case AF_INET6:\n        return (memcmp(&s1->data.inet6.sin6_addr.s6_addr,\n                       &s2->data.inet6.sin6_addr.s6_addr,\n                       sizeof(s1->data.inet6.sin6_addr.s6_addr)) == 0 &&\n                s1->data.inet6.sin6_port == s2->data.inet6.sin6_port);\n    }\n    return false;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nbool\nvirSocketAddrEqual(const virSocketAddr *s1, const virSocketAddr *s2)\n{\n    if (s1->data.stor.ss_family != s2->data.stor.ss_family)\n        return false;\n\n    switch (s1->data.stor.ss_family) {\n    case AF_INET:\n        return (memcmp(&s1->data.inet4.sin_addr.s_addr,\n                       &s2->data.inet4.sin_addr.s_addr,\n                       sizeof(s1->data.inet4.sin_addr.s_addr)) == 0 &&\n                s1->data.inet4.sin_port == s2->data.inet4.sin_port);\n    case AF_INET6:\n        return (memcmp(&s1->data.inet6.sin6_addr.s6_addr,\n                       &s2->data.inet6.sin6_addr.s6_addr,\n                       sizeof(s1->data.inet6.sin6_addr.s6_addr)) == 0 &&\n                s1->data.inet6.sin6_port == s2->data.inet6.sin6_port);\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&host.ip"
          ],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "host.name",
            "ipdef->hosts[i].name"
          ],
          "line": 3044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrCompare",
          "args": [
            "host.mac",
            "ipdef->hosts[i].mac"
          ],
          "line": 3042
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrCompare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "34-60",
          "snippet": "int\nvirMacAddrCompare(const char *p, const char *q)\n{\n    unsigned char c, d;\n    do {\n        while (*p == '0' && g_ascii_isxdigit(p[1]))\n            ++p;\n        while (*q == '0' && g_ascii_isxdigit(q[1]))\n            ++q;\n        c = g_ascii_tolower(*p);\n        d = g_ascii_tolower(*q);\n\n        if (c == 0 || d == 0)\n            break;\n\n        ++p;\n        ++q;\n    } while (c == d);\n\n    if (UCHAR_MAX <= INT_MAX)\n        return c - d;\n\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return c > d ? 1 : c < d ? -1 : 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint\nvirMacAddrCompare(const char *p, const char *q)\n{\n    unsigned char c, d;\n    do {\n        while (*p == '0' && g_ascii_isxdigit(p[1]))\n            ++p;\n        while (*q == '0' && g_ascii_isxdigit(q[1]))\n            ++q;\n        c = g_ascii_tolower(*p);\n        d = g_ascii_tolower(*q);\n\n        if (c == 0 || d == 0)\n            break;\n\n        ++p;\n        ++q;\n    } while (c == d);\n\n    if (UCHAR_MAX <= INT_MAX)\n        return c - d;\n\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return c > d ? 1 : c < d ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INSERT_ELEMENT",
          "args": [
            "ipdef->hosts",
            "command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : ipdef->nhosts",
            "ipdef->nhosts",
            "host"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ip"
          ],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"there is an existing dhcp host entry in \"\n                                 \"network '%s' that matches \"\n                                 \"\\\"<host mac='%s' name='%s' ip='%s'/>\\\"\")",
            "def->name",
            "host.mac ? host.mac : _(\"unknown\")",
            "host.name",
            "ip ? ip : _(\"unknown\")"
          ],
          "line": 3020
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "&host.ip"
          ],
          "line": 3018
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&host.ip"
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "host.name",
            "ipdef->hosts[i].name"
          ],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateCheckMultiDHCP",
          "args": [
            "def",
            "ipdef"
          ],
          "line": 3007
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateCheckMultiDHCP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2910-2930",
          "snippet": "static int\nvirNetworkDefUpdateCheckMultiDHCP(virNetworkDefPtr def,\n                                  virNetworkIPDefPtr ipdef)\n{\n    int family = VIR_SOCKET_ADDR_FAMILY(&ipdef->address);\n    size_t i;\n    virNetworkIPDefPtr ip;\n\n    for (i = 0; (ip = virNetworkDefGetIPByIndex(def, family, i)); i++) {\n        if (ip != ipdef) {\n            if (ip->nranges || ip->nhosts) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"dhcp is supported only for a \"\n                                 \"single %s address on each network\"),\n                               (family == AF_INET) ? \"IPv4\" : \"IPv6\");\n                return -1;\n            }\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateCheckMultiDHCP(virNetworkDefPtr def,\n                                  virNetworkIPDefPtr ipdef)\n{\n    int family = VIR_SOCKET_ADDR_FAMILY(&ipdef->address);\n    size_t i;\n    virNetworkIPDefPtr ip;\n\n    for (i = 0; (ip = virNetworkDefGetIPByIndex(def, family, i)); i++) {\n        if (ip != ipdef) {\n            if (ip->nranges || ip->nhosts) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"dhcp is supported only for a \"\n                                 \"single %s address on each network\"),\n                               (family == AF_INET) ? \"IPv4\" : \"IPv6\");\n                return -1;\n            }\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&host",
            "0",
            "sizeof(host)"
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ip"
          ],
          "line": 2992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "host.name",
            "ipdef->hosts[i].name"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&host.ip"
          ],
          "line": 2976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"the address family of a host entry IP must match \"\n                         \"the address family of the dhcp element's parent\")"
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "&host.ip"
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "&ipdef->address"
          ],
          "line": 2961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDHCPHostDefParseXML",
          "args": [
            "def->name",
            "ipdef",
            "ctxt->node",
            "&host",
            "partialOkay"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDHCPHostDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "434-552",
          "snippet": "static int\nvirNetworkDHCPHostDefParseXML(const char *networkName,\n                              virNetworkIPDefPtr def,\n                              xmlNodePtr node,\n                              virNetworkDHCPHostDefPtr host,\n                              bool partialOkay)\n{\n    char *mac = NULL, *name = NULL, *ip = NULL, *id = NULL;\n    virMacAddr addr;\n    virSocketAddr inaddr;\n    int ret = -1;\n\n    mac = virXMLPropString(node, \"mac\");\n    if (mac != NULL) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET6)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid to specify MAC address '%s' \"\n                             \"in network '%s' IPv6 static host definition\"),\n                           mac, networkName);\n            goto cleanup;\n        }\n        if (virMacAddrParse(mac, &addr) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Cannot parse MAC address '%s' in network '%s'\"),\n                           mac, networkName);\n            goto cleanup;\n        }\n        if (virMacAddrIsMulticast(&addr)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"expected unicast mac address, found \"\n                             \"multicast '%s' in network '%s'\"),\n                           (const char *)mac, networkName);\n            goto cleanup;\n        }\n    }\n\n    id = virXMLPropString(node, \"id\");\n    if (id) {\n        char *cp = id + strspn(id, \"0123456789abcdefABCDEF:\");\n        if (*cp) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid character '%c' in id '%s' of network '%s'\"),\n                           *cp, id, networkName);\n            goto cleanup;\n        }\n    }\n\n    name = virXMLPropString(node, \"name\");\n    if (name && (!g_ascii_isalpha(name[0]))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Cannot use host name '%s' in network '%s'\"),\n                       name, networkName);\n        goto cleanup;\n    }\n\n    ip = virXMLPropString(node, \"ip\");\n    if (ip && (virSocketAddrParse(&inaddr, ip, AF_UNSPEC) < 0)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid IP address in static host definition \"\n                         \"for network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    if (partialOkay) {\n        /* for search/match, you just need one of the three */\n        if (!(mac || name || ip)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"At least one of name, mac, or ip attribute \"\n                             \"must be specified for static host definition \"\n                             \"in network '%s' \"),\n                           networkName);\n            goto cleanup;\n        }\n    } else {\n        /* normal usage - you need at least name (IPv6) or one of MAC\n         * address or name (IPv4)\n         */\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET6)) {\n            if (!(id || name)) {\n                virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Static host definition in IPv6 network '%s' \"\n                             \"must have id or name attribute\"),\n                           networkName);\n                goto cleanup;\n            }\n        } else if (!(mac || name)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Static host definition in IPv4 network '%s' \"\n                             \"must have mac or name attribute\"),\n                           networkName);\n            goto cleanup;\n        }\n        if (!ip) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Missing IP address in static host definition \"\n                             \"for network '%s'\"),\n                           networkName);\n            goto cleanup;\n        }\n    }\n\n    host->mac = mac;\n    mac = NULL;\n    host->id = id;\n    id = NULL;\n    host->name = name;\n    name = NULL;\n    if (ip)\n        host->ip = inaddr;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(mac);\n    VIR_FREE(id);\n    VIR_FREE(name);\n    VIR_FREE(ip);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDHCPHostDefParseXML(const char *networkName,\n                              virNetworkIPDefPtr def,\n                              xmlNodePtr node,\n                              virNetworkDHCPHostDefPtr host,\n                              bool partialOkay)\n{\n    char *mac = NULL, *name = NULL, *ip = NULL, *id = NULL;\n    virMacAddr addr;\n    virSocketAddr inaddr;\n    int ret = -1;\n\n    mac = virXMLPropString(node, \"mac\");\n    if (mac != NULL) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET6)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid to specify MAC address '%s' \"\n                             \"in network '%s' IPv6 static host definition\"),\n                           mac, networkName);\n            goto cleanup;\n        }\n        if (virMacAddrParse(mac, &addr) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Cannot parse MAC address '%s' in network '%s'\"),\n                           mac, networkName);\n            goto cleanup;\n        }\n        if (virMacAddrIsMulticast(&addr)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"expected unicast mac address, found \"\n                             \"multicast '%s' in network '%s'\"),\n                           (const char *)mac, networkName);\n            goto cleanup;\n        }\n    }\n\n    id = virXMLPropString(node, \"id\");\n    if (id) {\n        char *cp = id + strspn(id, \"0123456789abcdefABCDEF:\");\n        if (*cp) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid character '%c' in id '%s' of network '%s'\"),\n                           *cp, id, networkName);\n            goto cleanup;\n        }\n    }\n\n    name = virXMLPropString(node, \"name\");\n    if (name && (!g_ascii_isalpha(name[0]))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Cannot use host name '%s' in network '%s'\"),\n                       name, networkName);\n        goto cleanup;\n    }\n\n    ip = virXMLPropString(node, \"ip\");\n    if (ip && (virSocketAddrParse(&inaddr, ip, AF_UNSPEC) < 0)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid IP address in static host definition \"\n                         \"for network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    if (partialOkay) {\n        /* for search/match, you just need one of the three */\n        if (!(mac || name || ip)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"At least one of name, mac, or ip attribute \"\n                             \"must be specified for static host definition \"\n                             \"in network '%s' \"),\n                           networkName);\n            goto cleanup;\n        }\n    } else {\n        /* normal usage - you need at least name (IPv6) or one of MAC\n         * address or name (IPv4)\n         */\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET6)) {\n            if (!(id || name)) {\n                virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Static host definition in IPv6 network '%s' \"\n                             \"must have id or name attribute\"),\n                           networkName);\n                goto cleanup;\n            }\n        } else if (!(mac || name)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Static host definition in IPv4 network '%s' \"\n                             \"must have mac or name attribute\"),\n                           networkName);\n            goto cleanup;\n        }\n        if (!ip) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Missing IP address in static host definition \"\n                             \"for network '%s'\"),\n                           networkName);\n            goto cleanup;\n        }\n    }\n\n    host->mac = mac;\n    mac = NULL;\n    host->id = id;\n    id = NULL;\n    host->name = name;\n    name = NULL;\n    if (ip)\n        host->ip = inaddr;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(mac);\n    VIR_FREE(id);\n    VIR_FREE(name);\n    VIR_FREE(ip);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefUpdateCheckElementName",
          "args": [
            "def",
            "ctxt->node",
            "\"host\""
          ],
          "line": 2949
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateCheckElementName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2814-2827",
          "snippet": "static int\nvirNetworkDefUpdateCheckElementName(virNetworkDefPtr def,\n                                    xmlNodePtr node,\n                                    const char *section)\n{\n    if (!virXMLNodeNameEqual(node, section)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected element <%s>, expecting <%s>, \"\n                         \"while updating network '%s'\"),\n                       node->name, section, def->name);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateCheckElementName(virNetworkDefPtr def,\n                                    xmlNodePtr node,\n                                    const char *section)\n{\n    if (!virXMLNodeNameEqual(node, section)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected element <%s>, expecting <%s>, \"\n                         \"while updating network '%s'\"),\n                       node->name, section, def->name);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&host",
            "0",
            "sizeof(host)"
          ],
          "line": 2947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefByIndex",
          "args": [
            "def",
            "parentIndex"
          ],
          "line": 2943
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2869-2907",
          "snippet": "static virNetworkIPDefPtr\nvirNetworkIPDefByIndex(virNetworkDefPtr def, int parentIndex)\n{\n    virNetworkIPDefPtr ipdef = NULL;\n    size_t i;\n\n    /* first find which ip element's dhcp host list to work on */\n    if (parentIndex >= 0) {\n        ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, parentIndex);\n        if (!(ipdef)) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't update dhcp host entry - no <ip> \"\n                             \"element found at index %d in network '%s'\"),\n                           parentIndex, def->name);\n        }\n        return ipdef;\n    }\n\n    /* -1 means \"find the most appropriate\", which in this case\n     * means the one and only <ip> that has <dhcp> element\n     */\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (ipdef->nranges || ipdef->nhosts)\n            break;\n    }\n    if (!ipdef) {\n        ipdef = virNetworkDefGetIPByIndex(def, AF_INET, 0);\n        if (!ipdef)\n            ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, 0);\n    }\n    if (!ipdef) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"couldn't update dhcp host entry - no <ip> \"\n                         \"element found in network '%s'\"), def->name);\n    }\n    return ipdef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virNetworkIPDefPtr\nvirNetworkIPDefByIndex(virNetworkDefPtr def, int parentIndex)\n{\n    virNetworkIPDefPtr ipdef = NULL;\n    size_t i;\n\n    /* first find which ip element's dhcp host list to work on */\n    if (parentIndex >= 0) {\n        ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, parentIndex);\n        if (!(ipdef)) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't update dhcp host entry - no <ip> \"\n                             \"element found at index %d in network '%s'\"),\n                           parentIndex, def->name);\n        }\n        return ipdef;\n    }\n\n    /* -1 means \"find the most appropriate\", which in this case\n     * means the one and only <ip> that has <dhcp> element\n     */\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (ipdef->nranges || ipdef->nhosts)\n            break;\n    }\n    if (!ipdef) {\n        ipdef = virNetworkDefGetIPByIndex(def, AF_INET, 0);\n        if (!ipdef)\n            ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, 0);\n    }\n    if (!ipdef) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"couldn't update dhcp host entry - no <ip> \"\n                         \"element found in network '%s'\"), def->name);\n    }\n    return ipdef;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateIPDHCPHost(virNetworkDefPtr def,\n                              unsigned int command,\n                              int parentIndex,\n                              xmlXPathContextPtr ctxt,\n                              /* virNetworkUpdateFlags */\n                              unsigned int fflags G_GNUC_UNUSED)\n{\n    size_t i;\n    int ret = -1;\n    virNetworkIPDefPtr ipdef = virNetworkIPDefByIndex(def, parentIndex);\n    virNetworkDHCPHostDef host;\n    bool partialOkay = (command == VIR_NETWORK_UPDATE_COMMAND_DELETE);\n\n    memset(&host, 0, sizeof(host));\n\n    if (virNetworkDefUpdateCheckElementName(def, ctxt->node, \"host\") < 0)\n        goto cleanup;\n\n    /* ipdef is the ip element that needs its host array updated */\n    if (!ipdef)\n        goto cleanup;\n\n    if (virNetworkDHCPHostDefParseXML(def->name, ipdef, ctxt->node,\n                                      &host, partialOkay) < 0)\n        goto cleanup;\n\n    if (!partialOkay &&\n        VIR_SOCKET_ADDR_FAMILY(&ipdef->address)\n        != VIR_SOCKET_ADDR_FAMILY(&host.ip)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"the address family of a host entry IP must match \"\n                         \"the address family of the dhcp element's parent\"));\n        goto cleanup;\n    }\n\n    if (command == VIR_NETWORK_UPDATE_COMMAND_MODIFY) {\n\n        /* search for the entry with this (ip|mac|name),\n         * and update the IP+(mac|name) */\n        for (i = 0; i < ipdef->nhosts; i++) {\n            if ((host.mac && ipdef->hosts[i].mac &&\n                 !virMacAddrCompare(host.mac, ipdef->hosts[i].mac)) ||\n                (VIR_SOCKET_ADDR_VALID(&host.ip) &&\n                 virSocketAddrEqual(&host.ip, &ipdef->hosts[i].ip)) ||\n                (host.name &&\n                 STREQ_NULLABLE(host.name, ipdef->hosts[i].name))) {\n                break;\n            }\n        }\n\n        if (i == ipdef->nhosts) {\n            char *ip = virSocketAddrFormat(&host.ip);\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate an existing dhcp host entry with \"\n                             \"\\\"mac='%s'\\\" \\\"name='%s'\\\" \\\"ip='%s'\\\" in\"\n                             \" network '%s'\"),\n                           host.mac ? host.mac : _(\"unknown\"), host.name,\n                           ip ? ip : _(\"unknown\"), def->name);\n            VIR_FREE(ip);\n            goto cleanup;\n        }\n\n        /* clear the existing hosts entry, move the new one in its place,\n         * then clear out the extra copy to get rid of the duplicate pointers\n         * to its data (mac and name strings).\n         */\n        virNetworkDHCPHostDefClear(&ipdef->hosts[i]);\n        ipdef->hosts[i] = host;\n        memset(&host, 0, sizeof(host));\n\n    } else if ((command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST) ||\n               (command == VIR_NETWORK_UPDATE_COMMAND_ADD_LAST)) {\n\n        if (virNetworkDefUpdateCheckMultiDHCP(def, ipdef) < 0)\n            goto cleanup;\n\n        /* log error if an entry with same name/address/ip already exists */\n        for (i = 0; i < ipdef->nhosts; i++) {\n            if ((host.mac && ipdef->hosts[i].mac &&\n                 !virMacAddrCompare(host.mac, ipdef->hosts[i].mac)) ||\n                (host.name &&\n                 STREQ_NULLABLE(host.name, ipdef->hosts[i].name)) ||\n                (VIR_SOCKET_ADDR_VALID(&host.ip) &&\n                 virSocketAddrEqual(&host.ip, &ipdef->hosts[i].ip))) {\n                char *ip = virSocketAddrFormat(&host.ip);\n\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"there is an existing dhcp host entry in \"\n                                 \"network '%s' that matches \"\n                                 \"\\\"<host mac='%s' name='%s' ip='%s'/>\\\"\"),\n                               def->name, host.mac ? host.mac : _(\"unknown\"),\n                               host.name, ip ? ip : _(\"unknown\"));\n                VIR_FREE(ip);\n                goto cleanup;\n            }\n        }\n\n        /* add to beginning/end of list */\n        if (VIR_INSERT_ELEMENT(ipdef->hosts,\n                               command == VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST\n                               ? 0 : ipdef->nhosts,\n                               ipdef->nhosts, host) < 0)\n            goto cleanup;\n    } else if (command == VIR_NETWORK_UPDATE_COMMAND_DELETE) {\n\n        /* find matching entry - all specified attributes must match */\n        for (i = 0; i < ipdef->nhosts; i++) {\n            if ((!host.mac || !ipdef->hosts[i].mac ||\n                 !virMacAddrCompare(host.mac, ipdef->hosts[i].mac)) &&\n                (!host.name ||\n                 STREQ_NULLABLE(host.name, ipdef->hosts[i].name)) &&\n                (!VIR_SOCKET_ADDR_VALID(&host.ip) ||\n                 virSocketAddrEqual(&host.ip, &ipdef->hosts[i].ip))) {\n                break;\n            }\n        }\n        if (i == ipdef->nhosts) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't locate a matching dhcp host entry \"\n                             \"in network '%s'\"), def->name);\n            goto cleanup;\n        }\n\n        /* remove it */\n        virNetworkDHCPHostDefClear(&ipdef->hosts[i]);\n        VIR_DELETE_ELEMENT(ipdef->hosts, i, ipdef->nhosts);\n\n    } else {\n        virNetworkDefUpdateUnknownCommand(command);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDHCPHostDefClear(&host);\n    return ret;\n}"
  },
  {
    "function_name": "virNetworkDefUpdateCheckMultiDHCP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2910-2930",
    "snippet": "static int\nvirNetworkDefUpdateCheckMultiDHCP(virNetworkDefPtr def,\n                                  virNetworkIPDefPtr ipdef)\n{\n    int family = VIR_SOCKET_ADDR_FAMILY(&ipdef->address);\n    size_t i;\n    virNetworkIPDefPtr ip;\n\n    for (i = 0; (ip = virNetworkDefGetIPByIndex(def, family, i)); i++) {\n        if (ip != ipdef) {\n            if (ip->nranges || ip->nhosts) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"dhcp is supported only for a \"\n                                 \"single %s address on each network\"),\n                               (family == AF_INET) ? \"IPv4\" : \"IPv6\");\n                return -1;\n            }\n        }\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"dhcp is supported only for a \"\n                                 \"single %s address on each network\")",
            "(family == AF_INET) ? \"IPv4\" : \"IPv6\""
          ],
          "line": 2921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"dhcp is supported only for a \"\n                                 \"single %s address on each network\""
          ],
          "line": 2922
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "family",
            "i"
          ],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "&ipdef->address"
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateCheckMultiDHCP(virNetworkDefPtr def,\n                                  virNetworkIPDefPtr ipdef)\n{\n    int family = VIR_SOCKET_ADDR_FAMILY(&ipdef->address);\n    size_t i;\n    virNetworkIPDefPtr ip;\n\n    for (i = 0; (ip = virNetworkDefGetIPByIndex(def, family, i)); i++) {\n        if (ip != ipdef) {\n            if (ip->nranges || ip->nhosts) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"dhcp is supported only for a \"\n                                 \"single %s address on each network\"),\n                               (family == AF_INET) ? \"IPv4\" : \"IPv6\");\n                return -1;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virNetworkIPDefByIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2869-2907",
    "snippet": "static virNetworkIPDefPtr\nvirNetworkIPDefByIndex(virNetworkDefPtr def, int parentIndex)\n{\n    virNetworkIPDefPtr ipdef = NULL;\n    size_t i;\n\n    /* first find which ip element's dhcp host list to work on */\n    if (parentIndex >= 0) {\n        ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, parentIndex);\n        if (!(ipdef)) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't update dhcp host entry - no <ip> \"\n                             \"element found at index %d in network '%s'\"),\n                           parentIndex, def->name);\n        }\n        return ipdef;\n    }\n\n    /* -1 means \"find the most appropriate\", which in this case\n     * means the one and only <ip> that has <dhcp> element\n     */\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (ipdef->nranges || ipdef->nhosts)\n            break;\n    }\n    if (!ipdef) {\n        ipdef = virNetworkDefGetIPByIndex(def, AF_INET, 0);\n        if (!ipdef)\n            ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, 0);\n    }\n    if (!ipdef) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"couldn't update dhcp host entry - no <ip> \"\n                         \"element found in network '%s'\"), def->name);\n    }\n    return ipdef;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"couldn't update dhcp host entry - no <ip> \"\n                         \"element found in network '%s'\")",
            "def->name"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"couldn't update dhcp host entry - no <ip> \"\n                         \"element found in network '%s'\""
          ],
          "line": 2903
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_INET6",
            "0"
          ],
          "line": 2899
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"couldn't update dhcp host entry - no <ip> \"\n                             \"element found at index %d in network '%s'\")",
            "parentIndex",
            "def->name"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virNetworkIPDefPtr\nvirNetworkIPDefByIndex(virNetworkDefPtr def, int parentIndex)\n{\n    virNetworkIPDefPtr ipdef = NULL;\n    size_t i;\n\n    /* first find which ip element's dhcp host list to work on */\n    if (parentIndex >= 0) {\n        ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, parentIndex);\n        if (!(ipdef)) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"couldn't update dhcp host entry - no <ip> \"\n                             \"element found at index %d in network '%s'\"),\n                           parentIndex, def->name);\n        }\n        return ipdef;\n    }\n\n    /* -1 means \"find the most appropriate\", which in this case\n     * means the one and only <ip> that has <dhcp> element\n     */\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (ipdef->nranges || ipdef->nhosts)\n            break;\n    }\n    if (!ipdef) {\n        ipdef = virNetworkDefGetIPByIndex(def, AF_INET, 0);\n        if (!ipdef)\n            ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, 0);\n    }\n    if (!ipdef) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"couldn't update dhcp host entry - no <ip> \"\n                         \"element found in network '%s'\"), def->name);\n    }\n    return ipdef;\n}"
  },
  {
    "function_name": "virNetworkDefUpdateIP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2856-2866",
    "snippet": "static int\nvirNetworkDefUpdateIP(virNetworkDefPtr def,\n                      unsigned int command G_GNUC_UNUSED,\n                      int parentIndex G_GNUC_UNUSED,\n                      xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                      /* virNetworkUpdateFlags */\n                      unsigned int fflags G_GNUC_UNUSED)\n{\n    virNetworkDefUpdateNoSupport(def, \"ip\");\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkDefUpdateNoSupport",
          "args": [
            "def",
            "\"ip\""
          ],
          "line": 2864
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateNoSupport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2797-2803",
          "snippet": "static void\nvirNetworkDefUpdateNoSupport(virNetworkDefPtr def, const char *section)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"can't update '%s' section of network '%s'\"),\n                   section, def->name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDefUpdateNoSupport(virNetworkDefPtr def, const char *section)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"can't update '%s' section of network '%s'\"),\n                   section, def->name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateIP(virNetworkDefPtr def,\n                      unsigned int command G_GNUC_UNUSED,\n                      int parentIndex G_GNUC_UNUSED,\n                      xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                      /* virNetworkUpdateFlags */\n                      unsigned int fflags G_GNUC_UNUSED)\n{\n    virNetworkDefUpdateNoSupport(def, \"ip\");\n    return -1;\n}"
  },
  {
    "function_name": "virNetworkDefUpdateDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2843-2853",
    "snippet": "static int\nvirNetworkDefUpdateDomain(virNetworkDefPtr def,\n                          unsigned int command G_GNUC_UNUSED,\n                          int parentIndex G_GNUC_UNUSED,\n                          xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                          /* virNetworkUpdateFlags */\n                          unsigned int fflags G_GNUC_UNUSED)\n{\n    virNetworkDefUpdateNoSupport(def, \"domain\");\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkDefUpdateNoSupport",
          "args": [
            "def",
            "\"domain\""
          ],
          "line": 2851
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateNoSupport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2797-2803",
          "snippet": "static void\nvirNetworkDefUpdateNoSupport(virNetworkDefPtr def, const char *section)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"can't update '%s' section of network '%s'\"),\n                   section, def->name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDefUpdateNoSupport(virNetworkDefPtr def, const char *section)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"can't update '%s' section of network '%s'\"),\n                   section, def->name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateDomain(virNetworkDefPtr def,\n                          unsigned int command G_GNUC_UNUSED,\n                          int parentIndex G_GNUC_UNUSED,\n                          xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                          /* virNetworkUpdateFlags */\n                          unsigned int fflags G_GNUC_UNUSED)\n{\n    virNetworkDefUpdateNoSupport(def, \"domain\");\n    return -1;\n}"
  },
  {
    "function_name": "virNetworkDefUpdateBridge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2830-2840",
    "snippet": "static int\nvirNetworkDefUpdateBridge(virNetworkDefPtr def,\n                          unsigned int command G_GNUC_UNUSED,\n                          int parentIndex G_GNUC_UNUSED,\n                          xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                          /* virNetworkUpdateFlags */\n                          unsigned int fflags G_GNUC_UNUSED)\n{\n    virNetworkDefUpdateNoSupport(def, \"bridge\");\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkDefUpdateNoSupport",
          "args": [
            "def",
            "\"bridge\""
          ],
          "line": 2838
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefUpdateNoSupport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2797-2803",
          "snippet": "static void\nvirNetworkDefUpdateNoSupport(virNetworkDefPtr def, const char *section)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"can't update '%s' section of network '%s'\"),\n                   section, def->name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDefUpdateNoSupport(virNetworkDefPtr def, const char *section)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"can't update '%s' section of network '%s'\"),\n                   section, def->name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateBridge(virNetworkDefPtr def,\n                          unsigned int command G_GNUC_UNUSED,\n                          int parentIndex G_GNUC_UNUSED,\n                          xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                          /* virNetworkUpdateFlags */\n                          unsigned int fflags G_GNUC_UNUSED)\n{\n    virNetworkDefUpdateNoSupport(def, \"bridge\");\n    return -1;\n}"
  },
  {
    "function_name": "virNetworkDefUpdateCheckElementName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2814-2827",
    "snippet": "static int\nvirNetworkDefUpdateCheckElementName(virNetworkDefPtr def,\n                                    xmlNodePtr node,\n                                    const char *section)\n{\n    if (!virXMLNodeNameEqual(node, section)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected element <%s>, expecting <%s>, \"\n                         \"while updating network '%s'\"),\n                       node->name, section, def->name);\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unexpected element <%s>, expecting <%s>, \"\n                         \"while updating network '%s'\")",
            "node->name",
            "section",
            "def->name"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unexpected element <%s>, expecting <%s>, \"\n                         \"while updating network '%s'\""
          ],
          "line": 2821
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLNodeNameEqual",
          "args": [
            "node",
            "section"
          ],
          "line": 2819
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeNameEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1013-1018",
          "snippet": "bool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nbool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDefUpdateCheckElementName(virNetworkDefPtr def,\n                                    xmlNodePtr node,\n                                    const char *section)\n{\n    if (!virXMLNodeNameEqual(node, section)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected element <%s>, expecting <%s>, \"\n                         \"while updating network '%s'\"),\n                       node->name, section, def->name);\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virNetworkDefUpdateUnknownCommand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2806-2811",
    "snippet": "static void\nvirNetworkDefUpdateUnknownCommand(unsigned int command)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"unrecognized network update command code %d\"), command);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "_(\"unrecognized network update command code %d\")",
            "command"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unrecognized network update command code %d\""
          ],
          "line": 2810
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDefUpdateUnknownCommand(unsigned int command)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"unrecognized network update command code %d\"), command);\n}"
  },
  {
    "function_name": "virNetworkDefUpdateNoSupport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2797-2803",
    "snippet": "static void\nvirNetworkDefUpdateNoSupport(virNetworkDefPtr def, const char *section)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"can't update '%s' section of network '%s'\"),\n                   section, def->name);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "_(\"can't update '%s' section of network '%s'\")",
            "section",
            "def->name"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"can't update '%s' section of network '%s'\""
          ],
          "line": 2801
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDefUpdateNoSupport(virNetworkDefPtr def, const char *section)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                   _(\"can't update '%s' section of network '%s'\"),\n                   section, def->name);\n}"
  },
  {
    "function_name": "virNetworkSetBridgeMacAddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2781-2792",
    "snippet": "void\nvirNetworkSetBridgeMacAddr(virNetworkDefPtr def)\n{\n    if (!def->mac_specified) {\n        /* if the bridge doesn't have a mac address explicitly defined,\n         * autogenerate a random one.\n         */\n        virMacAddrGenerate((unsigned char[]){ 0x52, 0x54, 0 },\n                           &def->mac);\n        def->mac_specified = true;\n    }\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMacAddrGenerate",
          "args": [
            "(unsigned char[]){ 0x52, 0x54, 0 }",
            "&def->mac"
          ],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrGenerate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "220-229",
          "snippet": "void virMacAddrGenerate(const unsigned char prefix[VIR_MAC_PREFIX_BUFLEN],\n                        virMacAddrPtr addr)\n{\n    addr->addr[0] = prefix[0];\n    addr->addr[1] = prefix[1];\n    addr->addr[2] = prefix[2];\n    addr->addr[3] = virRandomBits(8);\n    addr->addr[4] = virRandomBits(8);\n    addr->addr[5] = virRandomBits(8);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nvoid virMacAddrGenerate(const unsigned char prefix[VIR_MAC_PREFIX_BUFLEN],\n                        virMacAddrPtr addr)\n{\n    addr->addr[0] = prefix[0];\n    addr->addr[1] = prefix[1];\n    addr->addr[2] = prefix[2];\n    addr->addr[3] = virRandomBits(8);\n    addr->addr[4] = virRandomBits(8);\n    addr->addr[5] = virRandomBits(8);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetworkSetBridgeMacAddr(virNetworkDefPtr def)\n{\n    if (!def->mac_specified) {\n        /* if the bridge doesn't have a mac address explicitly defined,\n         * autogenerate a random one.\n         */\n        virMacAddrGenerate((unsigned char[]){ 0x52, 0x54, 0 },\n                           &def->mac);\n        def->mac_specified = true;\n    }\n}"
  },
  {
    "function_name": "virNetworkConfigFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2770-2778",
    "snippet": "char *\nvirNetworkConfigFile(const char *dir,\n                     const char *name)\n{\n    char *ret = NULL;\n\n    ret = g_strdup_printf(\"%s/%s.xml\", dir, name);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s.xml\"",
            "dir",
            "name"
          ],
          "line": 2776
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirNetworkConfigFile(const char *dir,\n                     const char *name)\n{\n    char *ret = NULL;\n\n    ret = g_strdup_printf(\"%s/%s.xml\", dir, name);\n    return ret;\n}"
  },
  {
    "function_name": "virNetworkSaveConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2749-2767",
    "snippet": "int\nvirNetworkSaveConfig(const char *configDir,\n                     virNetworkDefPtr def,\n                     virNetworkXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    char *xml;\n\n    if (!(xml = virNetworkDefFormat(def, xmlopt, VIR_NETWORK_XML_INACTIVE)))\n        goto cleanup;\n\n    if (virNetworkSaveXML(configDir, def, xml))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(xml);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkSaveXML",
          "args": [
            "configDir",
            "def",
            "xml"
          ],
          "line": 2760
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkSaveXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2719-2746",
          "snippet": "int\nvirNetworkSaveXML(const char *configDir,\n                  virNetworkDefPtr def,\n                  const char *xml)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *configFile = NULL;\n    int ret = -1;\n\n    if ((configFile = virNetworkConfigFile(configDir, def->name)) == NULL)\n        goto cleanup;\n\n    if (virFileMakePath(configDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create config directory '%s'\"),\n                             configDir);\n        goto cleanup;\n    }\n\n    virUUIDFormat(def->uuid, uuidstr);\n    ret = virXMLSaveFile(configFile,\n                         virXMLPickShellSafeComment(def->name, uuidstr),\n                         \"net-edit\", xml);\n\n cleanup:\n    VIR_FREE(configFile);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkSaveXML(const char *configDir,\n                  virNetworkDefPtr def,\n                  const char *xml)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *configFile = NULL;\n    int ret = -1;\n\n    if ((configFile = virNetworkConfigFile(configDir, def->name)) == NULL)\n        goto cleanup;\n\n    if (virFileMakePath(configDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create config directory '%s'\"),\n                             configDir);\n        goto cleanup;\n    }\n\n    virUUIDFormat(def->uuid, uuidstr);\n    ret = virXMLSaveFile(configFile,\n                         virXMLPickShellSafeComment(def->name, uuidstr),\n                         \"net-edit\", xml);\n\n cleanup:\n    VIR_FREE(configFile);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefFormat",
          "args": [
            "def",
            "xmlopt",
            "VIR_NETWORK_XML_INACTIVE"
          ],
          "line": 2757
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2673-2688",
          "snippet": "char *\nvirNetworkDefFormat(const virNetworkDef *def,\n                    virNetworkXMLOptionPtr xmlopt,\n                    unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virNetworkDefFormatBuf(&buf, def, xmlopt, flags) < 0)\n        goto error;\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirNetworkDefFormat(const virNetworkDef *def,\n                    virNetworkXMLOptionPtr xmlopt,\n                    unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virNetworkDefFormatBuf(&buf, def, xmlopt, flags) < 0)\n        goto error;\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkSaveConfig(const char *configDir,\n                     virNetworkDefPtr def,\n                     virNetworkXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    char *xml;\n\n    if (!(xml = virNetworkDefFormat(def, xmlopt, VIR_NETWORK_XML_INACTIVE)))\n        goto cleanup;\n\n    if (virNetworkSaveXML(configDir, def, xml))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(xml);\n    return ret;\n}"
  },
  {
    "function_name": "virNetworkSaveXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2719-2746",
    "snippet": "int\nvirNetworkSaveXML(const char *configDir,\n                  virNetworkDefPtr def,\n                  const char *xml)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *configFile = NULL;\n    int ret = -1;\n\n    if ((configFile = virNetworkConfigFile(configDir, def->name)) == NULL)\n        goto cleanup;\n\n    if (virFileMakePath(configDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create config directory '%s'\"),\n                             configDir);\n        goto cleanup;\n    }\n\n    virUUIDFormat(def->uuid, uuidstr);\n    ret = virXMLSaveFile(configFile,\n                         virXMLPickShellSafeComment(def->name, uuidstr),\n                         \"net-edit\", xml);\n\n cleanup:\n    VIR_FREE(configFile);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "configFile"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLSaveFile",
          "args": [
            "configFile",
            "virXMLPickShellSafeComment(def->name, uuidstr)",
            "\"net-edit\"",
            "xml"
          ],
          "line": 2739
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLSaveFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "941-950",
          "snippet": "int\nvirXMLSaveFile(const char *path,\n               const char *warnName,\n               const char *warnCommand,\n               const char *xml)\n{\n    struct virXMLRewriteFileData data = { warnName, warnCommand, xml };\n\n    return virFileRewrite(path, S_IRUSR | S_IWUSR, virXMLRewriteFile, &data);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXMLSaveFile(const char *path,\n               const char *warnName,\n               const char *warnCommand,\n               const char *xml)\n{\n    struct virXMLRewriteFileData data = { warnName, warnCommand, xml };\n\n    return virFileRewrite(path, S_IRUSR | S_IWUSR, virXMLRewriteFile, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLPickShellSafeComment",
          "args": [
            "def->name",
            "uuidstr"
          ],
          "line": 2740
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPickShellSafeComment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "863-872",
          "snippet": "const char *virXMLPickShellSafeComment(const char *str1, const char *str2)\n{\n    if (str1 && !strpbrk(str1, \"\\r\\t\\n !\\\"#$&'()*;<>?[\\\\]^`{|}~\") &&\n        !strstr(str1, \"--\"))\n        return str1;\n    if (str2 && !strpbrk(str2, \"\\r\\t\\n !\\\"#$&'()*;<>?[\\\\]^`{|}~\") &&\n        !strstr(str2, \"--\"))\n        return str2;\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nconst char *virXMLPickShellSafeComment(const char *str1, const char *str2)\n{\n    if (str1 && !strpbrk(str1, \"\\r\\t\\n !\\\"#$&'()*;<>?[\\\\]^`{|}~\") &&\n        !strstr(str1, \"--\"))\n        return str1;\n    if (str2 && !strpbrk(str2, \"\\r\\t\\n !\\\"#$&'()*;<>?[\\\\]^`{|}~\") &&\n        !strstr(str2, \"--\"))\n        return str2;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "def->uuid",
            "uuidstr"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot create config directory '%s'\")",
            "configDir"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot create config directory '%s'\""
          ],
          "line": 2733
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileMakePath",
          "args": [
            "configDir"
          ],
          "line": 2731
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3076-3080",
          "snippet": "int\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkConfigFile",
          "args": [
            "configDir",
            "def->name"
          ],
          "line": 2728
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkConfigFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2770-2778",
          "snippet": "char *\nvirNetworkConfigFile(const char *dir,\n                     const char *name)\n{\n    char *ret = NULL;\n\n    ret = g_strdup_printf(\"%s/%s.xml\", dir, name);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirNetworkConfigFile(const char *dir,\n                     const char *name)\n{\n    char *ret = NULL;\n\n    ret = g_strdup_printf(\"%s/%s.xml\", dir, name);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkSaveXML(const char *configDir,\n                  virNetworkDefPtr def,\n                  const char *xml)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *configFile = NULL;\n    int ret = -1;\n\n    if ((configFile = virNetworkConfigFile(configDir, def->name)) == NULL)\n        goto cleanup;\n\n    if (virFileMakePath(configDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create config directory '%s'\"),\n                             configDir);\n        goto cleanup;\n    }\n\n    virUUIDFormat(def->uuid, uuidstr);\n    ret = virXMLSaveFile(configFile,\n                         virXMLPickShellSafeComment(def->name, uuidstr),\n                         \"net-edit\", xml);\n\n cleanup:\n    VIR_FREE(configFile);\n    return ret;\n}"
  },
  {
    "function_name": "virPortGroupFindByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2701-2716",
    "snippet": "virPortGroupDefPtr\nvirPortGroupFindByName(virNetworkDefPtr net,\n                       const char *portgroup)\n{\n    size_t i;\n    for (i = 0; i < net->nPortGroups; i++) {\n        if (portgroup) {\n            if (STREQ(portgroup, net->portGroups[i].name))\n                return &net->portGroups[i];\n        } else {\n            if (net->portGroups[i].isDefault)\n                return &net->portGroups[i];\n        }\n    }\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "portgroup",
            "net->portGroups[i].name"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirPortGroupDefPtr\nvirPortGroupFindByName(virNetworkDefPtr net,\n                       const char *portgroup)\n{\n    size_t i;\n    for (i = 0; i < net->nPortGroups; i++) {\n        if (portgroup) {\n            if (STREQ(portgroup, net->portGroups[i].name))\n                return &net->portGroups[i];\n        } else {\n            if (net->portGroups[i].isDefault)\n                return &net->portGroups[i];\n        }\n    }\n    return NULL;\n}"
  },
  {
    "function_name": "virNetworkDefForwardIf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2691-2698",
    "snippet": "const char *\nvirNetworkDefForwardIf(const virNetworkDef *def,\n                       size_t n)\n{\n    return ((def->forward.ifs && (def->forward.nifs > n) &&\n             def->forward.ifs[n].type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n            ? def->forward.ifs[n].device.dev : NULL);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nconst char *\nvirNetworkDefForwardIf(const virNetworkDef *def,\n                       size_t n)\n{\n    return ((def->forward.ifs && (def->forward.nifs > n) &&\n             def->forward.ifs[n].type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n            ? def->forward.ifs[n].device.dev : NULL);\n}"
  },
  {
    "function_name": "virNetworkDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2673-2688",
    "snippet": "char *\nvirNetworkDefFormat(const virNetworkDef *def,\n                    virNetworkXMLOptionPtr xmlopt,\n                    unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virNetworkDefFormatBuf(&buf, def, xmlopt, flags) < 0)\n        goto error;\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 2686
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefFormatBuf",
          "args": [
            "&buf",
            "def",
            "xmlopt",
            "flags"
          ],
          "line": 2680
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefFormatBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2440-2670",
          "snippet": "int\nvirNetworkDefFormatBuf(virBufferPtr buf,\n                       const virNetworkDef *def,\n                       virNetworkXMLOptionPtr xmlopt G_GNUC_UNUSED,\n                       unsigned int flags)\n{\n    const unsigned char *uuid;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    size_t i;\n    bool shortforward;\n    bool hasbridge = false;\n\n    virBufferAddLit(buf, \"<network\");\n    if (def->namespaceData && def->ns.format)\n        virXMLNamespaceFormatNS(buf, &def->ns);\n    if (!(flags & VIR_NETWORK_XML_INACTIVE) && (def->connections > 0))\n        virBufferAsprintf(buf, \" connections='%d'\", def->connections);\n    if (def->ipv6nogw)\n        virBufferAddLit(buf, \" ipv6='yes'\");\n    if (def->trustGuestRxFilters)\n        virBufferAsprintf(buf, \" trustGuestRxFilters='%s'\",\n                          virTristateBoolTypeToString(def->trustGuestRxFilters));\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->name);\n\n    uuid = def->uuid;\n    virUUIDFormat(uuid, uuidstr);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n\n    if (def->metadata) {\n        xmlBufferPtr xmlbuf;\n        int oldIndentTreeOutput = xmlIndentTreeOutput;\n\n        /* Indentation on output requires that we previously set\n         * xmlKeepBlanksDefault to 0 when parsing; also, libxml does 2\n         * spaces per level of indentation of intermediate elements,\n         * but no leading indentation before the starting element.\n         * Thankfully, libxml maps what looks like globals into\n         * thread-local uses, so we are thread-safe.  */\n        xmlIndentTreeOutput = 1;\n        xmlbuf = xmlBufferCreate();\n        if (xmlNodeDump(xmlbuf, def->metadata->doc, def->metadata,\n                        virBufferGetIndent(buf) / 2, 1) < 0) {\n            xmlBufferFree(xmlbuf);\n            xmlIndentTreeOutput = oldIndentTreeOutput;\n            return -1;\n        }\n        virBufferAsprintf(buf, \"%s\\n\", (char *) xmlBufferContent(xmlbuf));\n        xmlBufferFree(xmlbuf);\n        xmlIndentTreeOutput = oldIndentTreeOutput;\n    }\n\n    if (def->forward.type != VIR_NETWORK_FORWARD_NONE) {\n        const char *dev = NULL;\n        if (!def->forward.npfs)\n            dev = virNetworkDefForwardIf(def, 0);\n        const char *mode = virNetworkForwardTypeToString(def->forward.type);\n\n        if (!mode) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown forward type %d in network '%s'\"),\n                           def->forward.type, def->name);\n            return -1;\n        }\n        virBufferAddLit(buf, \"<forward\");\n        virBufferEscapeString(buf, \" dev='%s'\", dev);\n        virBufferAsprintf(buf, \" mode='%s'\", mode);\n        if (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n            if (def->forward.managed)\n                virBufferAddLit(buf, \" managed='yes'\");\n            else\n                virBufferAddLit(buf, \" managed='no'\");\n        }\n        shortforward = !(def->forward.nifs || def->forward.npfs\n                         || VIR_SOCKET_ADDR_VALID(&def->forward.addr.start)\n                         || VIR_SOCKET_ADDR_VALID(&def->forward.addr.end)\n                         || def->forward.port.start\n                         || def->forward.port.end\n                         || (def->forward.driverName\n                             != VIR_NETWORK_FORWARD_DRIVER_NAME_DEFAULT));\n        virBufferAsprintf(buf, \"%s>\\n\", shortforward ? \"/\" : \"\");\n        virBufferAdjustIndent(buf, 2);\n\n        if (def->forward.driverName\n            != VIR_NETWORK_FORWARD_DRIVER_NAME_DEFAULT) {\n            const char *driverName\n                = virNetworkForwardDriverNameTypeToString(def->forward.driverName);\n            if (!driverName) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unexpected hostdev driver name type %d \"),\n                               def->forward.driverName);\n                return -1;\n            }\n            virBufferAsprintf(buf, \"<driver name='%s'/>\\n\", driverName);\n        }\n        if (def->forward.type == VIR_NETWORK_FORWARD_NAT) {\n            if (virNetworkForwardNatDefFormat(buf, &def->forward) < 0)\n                return -1;\n        }\n\n        /* For now, hard-coded to at most 1 forward.pfs */\n        if (def->forward.npfs)\n            virBufferEscapeString(buf, \"<pf dev='%s'/>\\n\",\n                                  def->forward.pfs[0].dev);\n\n        if (def->forward.nifs &&\n            (!def->forward.npfs || !(flags & VIR_NETWORK_XML_INACTIVE))) {\n            for (i = 0; i < def->forward.nifs; i++) {\n                if (def->forward.ifs[i].type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV) {\n                    virBufferEscapeString(buf, \"<interface dev='%s'\",\n                                          def->forward.ifs[i].device.dev);\n                    if (!(flags & VIR_NETWORK_XML_INACTIVE) &&\n                        (def->forward.ifs[i].connections > 0)) {\n                        virBufferAsprintf(buf, \" connections='%d'\",\n                                          def->forward.ifs[i].connections);\n                    }\n                    virBufferAddLit(buf, \"/>\\n\");\n                } else {\n                    if (def->forward.ifs[i].type ==  VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI) {\n                        virPCIDeviceAddressFormat(buf,\n                                                  def->forward.ifs[i].device.pci,\n                                                  true);\n                    }\n                }\n            }\n        }\n        virBufferAdjustIndent(buf, -2);\n        if (!shortforward)\n            virBufferAddLit(buf, \"</forward>\\n\");\n    }\n\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        hasbridge = true;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        return -1;\n    }\n\n    if (hasbridge || def->bridge || def->macTableManager) {\n        virBufferAddLit(buf, \"<bridge\");\n        virBufferEscapeString(buf, \" name='%s'\", def->bridge);\n        virBufferEscapeString(buf, \" zone='%s'\", def->bridgeZone);\n        if (hasbridge)\n            virBufferAsprintf(buf, \" stp='%s' delay='%ld'\",\n                              def->stp ? \"on\" : \"off\", def->delay);\n        if (def->macTableManager) {\n            virBufferAsprintf(buf, \" macTableManager='%s'\",\n                             virNetworkBridgeMACTableManagerTypeToString(def->macTableManager));\n        }\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->mtu)\n        virBufferAsprintf(buf, \"<mtu size='%u'/>\\n\", def->mtu);\n\n    if (def->mac_specified) {\n        char macaddr[VIR_MAC_STRING_BUFLEN];\n        virMacAddrFormat(&def->mac, macaddr);\n        virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", macaddr);\n    }\n\n    if (def->domain) {\n        virBufferAsprintf(buf, \"<domain name='%s'\", def->domain);\n\n        /* default to \"no\", but don't format it in the XML */\n        if (def->domainLocalOnly) {\n            const char *local = virTristateBoolTypeToString(def->domainLocalOnly);\n\n            if (!local) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unknown localOnly type %d in network\"),\n                               def->domainLocalOnly);\n                return -1;\n            }\n            virBufferAsprintf(buf, \" localOnly='%s'\", local);\n        }\n\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (virNetworkDNSDefFormat(buf, &def->dns) < 0)\n        return -1;\n\n    if (virNetDevVlanFormat(&def->vlan, buf) < 0)\n        return -1;\n    if (virNetDevBandwidthFormat(def->bandwidth, 0, buf) < 0)\n        return -1;\n    virNetworkPortOptionsFormat(def->isolatedPort, buf);\n\n    for (i = 0; i < def->nips; i++) {\n        if (virNetworkIPDefFormat(buf, &def->ips[i]) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->nroutes; i++) {\n        if (virNetDevIPRouteFormat(buf, def->routes[i]) < 0)\n            return -1;\n    }\n\n    if (virNetDevVPortProfileFormat(def->virtPortProfile, buf) < 0)\n        return -1;\n\n    for (i = 0; i < def->nPortGroups; i++)\n        if (virPortGroupDefFormat(buf, &def->portGroups[i]) < 0)\n            return -1;\n\n    if (def->namespaceData && def->ns.format) {\n        if ((def->ns.format)(buf, def->namespaceData) < 0)\n            return -1;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</network>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkDefFormatBuf(virBufferPtr buf,\n                       const virNetworkDef *def,\n                       virNetworkXMLOptionPtr xmlopt G_GNUC_UNUSED,\n                       unsigned int flags)\n{\n    const unsigned char *uuid;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    size_t i;\n    bool shortforward;\n    bool hasbridge = false;\n\n    virBufferAddLit(buf, \"<network\");\n    if (def->namespaceData && def->ns.format)\n        virXMLNamespaceFormatNS(buf, &def->ns);\n    if (!(flags & VIR_NETWORK_XML_INACTIVE) && (def->connections > 0))\n        virBufferAsprintf(buf, \" connections='%d'\", def->connections);\n    if (def->ipv6nogw)\n        virBufferAddLit(buf, \" ipv6='yes'\");\n    if (def->trustGuestRxFilters)\n        virBufferAsprintf(buf, \" trustGuestRxFilters='%s'\",\n                          virTristateBoolTypeToString(def->trustGuestRxFilters));\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->name);\n\n    uuid = def->uuid;\n    virUUIDFormat(uuid, uuidstr);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n\n    if (def->metadata) {\n        xmlBufferPtr xmlbuf;\n        int oldIndentTreeOutput = xmlIndentTreeOutput;\n\n        /* Indentation on output requires that we previously set\n         * xmlKeepBlanksDefault to 0 when parsing; also, libxml does 2\n         * spaces per level of indentation of intermediate elements,\n         * but no leading indentation before the starting element.\n         * Thankfully, libxml maps what looks like globals into\n         * thread-local uses, so we are thread-safe.  */\n        xmlIndentTreeOutput = 1;\n        xmlbuf = xmlBufferCreate();\n        if (xmlNodeDump(xmlbuf, def->metadata->doc, def->metadata,\n                        virBufferGetIndent(buf) / 2, 1) < 0) {\n            xmlBufferFree(xmlbuf);\n            xmlIndentTreeOutput = oldIndentTreeOutput;\n            return -1;\n        }\n        virBufferAsprintf(buf, \"%s\\n\", (char *) xmlBufferContent(xmlbuf));\n        xmlBufferFree(xmlbuf);\n        xmlIndentTreeOutput = oldIndentTreeOutput;\n    }\n\n    if (def->forward.type != VIR_NETWORK_FORWARD_NONE) {\n        const char *dev = NULL;\n        if (!def->forward.npfs)\n            dev = virNetworkDefForwardIf(def, 0);\n        const char *mode = virNetworkForwardTypeToString(def->forward.type);\n\n        if (!mode) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown forward type %d in network '%s'\"),\n                           def->forward.type, def->name);\n            return -1;\n        }\n        virBufferAddLit(buf, \"<forward\");\n        virBufferEscapeString(buf, \" dev='%s'\", dev);\n        virBufferAsprintf(buf, \" mode='%s'\", mode);\n        if (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n            if (def->forward.managed)\n                virBufferAddLit(buf, \" managed='yes'\");\n            else\n                virBufferAddLit(buf, \" managed='no'\");\n        }\n        shortforward = !(def->forward.nifs || def->forward.npfs\n                         || VIR_SOCKET_ADDR_VALID(&def->forward.addr.start)\n                         || VIR_SOCKET_ADDR_VALID(&def->forward.addr.end)\n                         || def->forward.port.start\n                         || def->forward.port.end\n                         || (def->forward.driverName\n                             != VIR_NETWORK_FORWARD_DRIVER_NAME_DEFAULT));\n        virBufferAsprintf(buf, \"%s>\\n\", shortforward ? \"/\" : \"\");\n        virBufferAdjustIndent(buf, 2);\n\n        if (def->forward.driverName\n            != VIR_NETWORK_FORWARD_DRIVER_NAME_DEFAULT) {\n            const char *driverName\n                = virNetworkForwardDriverNameTypeToString(def->forward.driverName);\n            if (!driverName) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unexpected hostdev driver name type %d \"),\n                               def->forward.driverName);\n                return -1;\n            }\n            virBufferAsprintf(buf, \"<driver name='%s'/>\\n\", driverName);\n        }\n        if (def->forward.type == VIR_NETWORK_FORWARD_NAT) {\n            if (virNetworkForwardNatDefFormat(buf, &def->forward) < 0)\n                return -1;\n        }\n\n        /* For now, hard-coded to at most 1 forward.pfs */\n        if (def->forward.npfs)\n            virBufferEscapeString(buf, \"<pf dev='%s'/>\\n\",\n                                  def->forward.pfs[0].dev);\n\n        if (def->forward.nifs &&\n            (!def->forward.npfs || !(flags & VIR_NETWORK_XML_INACTIVE))) {\n            for (i = 0; i < def->forward.nifs; i++) {\n                if (def->forward.ifs[i].type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV) {\n                    virBufferEscapeString(buf, \"<interface dev='%s'\",\n                                          def->forward.ifs[i].device.dev);\n                    if (!(flags & VIR_NETWORK_XML_INACTIVE) &&\n                        (def->forward.ifs[i].connections > 0)) {\n                        virBufferAsprintf(buf, \" connections='%d'\",\n                                          def->forward.ifs[i].connections);\n                    }\n                    virBufferAddLit(buf, \"/>\\n\");\n                } else {\n                    if (def->forward.ifs[i].type ==  VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI) {\n                        virPCIDeviceAddressFormat(buf,\n                                                  def->forward.ifs[i].device.pci,\n                                                  true);\n                    }\n                }\n            }\n        }\n        virBufferAdjustIndent(buf, -2);\n        if (!shortforward)\n            virBufferAddLit(buf, \"</forward>\\n\");\n    }\n\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        hasbridge = true;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        return -1;\n    }\n\n    if (hasbridge || def->bridge || def->macTableManager) {\n        virBufferAddLit(buf, \"<bridge\");\n        virBufferEscapeString(buf, \" name='%s'\", def->bridge);\n        virBufferEscapeString(buf, \" zone='%s'\", def->bridgeZone);\n        if (hasbridge)\n            virBufferAsprintf(buf, \" stp='%s' delay='%ld'\",\n                              def->stp ? \"on\" : \"off\", def->delay);\n        if (def->macTableManager) {\n            virBufferAsprintf(buf, \" macTableManager='%s'\",\n                             virNetworkBridgeMACTableManagerTypeToString(def->macTableManager));\n        }\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->mtu)\n        virBufferAsprintf(buf, \"<mtu size='%u'/>\\n\", def->mtu);\n\n    if (def->mac_specified) {\n        char macaddr[VIR_MAC_STRING_BUFLEN];\n        virMacAddrFormat(&def->mac, macaddr);\n        virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", macaddr);\n    }\n\n    if (def->domain) {\n        virBufferAsprintf(buf, \"<domain name='%s'\", def->domain);\n\n        /* default to \"no\", but don't format it in the XML */\n        if (def->domainLocalOnly) {\n            const char *local = virTristateBoolTypeToString(def->domainLocalOnly);\n\n            if (!local) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unknown localOnly type %d in network\"),\n                               def->domainLocalOnly);\n                return -1;\n            }\n            virBufferAsprintf(buf, \" localOnly='%s'\", local);\n        }\n\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (virNetworkDNSDefFormat(buf, &def->dns) < 0)\n        return -1;\n\n    if (virNetDevVlanFormat(&def->vlan, buf) < 0)\n        return -1;\n    if (virNetDevBandwidthFormat(def->bandwidth, 0, buf) < 0)\n        return -1;\n    virNetworkPortOptionsFormat(def->isolatedPort, buf);\n\n    for (i = 0; i < def->nips; i++) {\n        if (virNetworkIPDefFormat(buf, &def->ips[i]) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->nroutes; i++) {\n        if (virNetDevIPRouteFormat(buf, def->routes[i]) < 0)\n            return -1;\n    }\n\n    if (virNetDevVPortProfileFormat(def->virtPortProfile, buf) < 0)\n        return -1;\n\n    for (i = 0; i < def->nPortGroups; i++)\n        if (virPortGroupDefFormat(buf, &def->portGroups[i]) < 0)\n            return -1;\n\n    if (def->namespaceData && def->ns.format) {\n        if ((def->ns.format)(buf, def->namespaceData) < 0)\n            return -1;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</network>\\n\");\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirNetworkDefFormat(const virNetworkDef *def,\n                    virNetworkXMLOptionPtr xmlopt,\n                    unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virNetworkDefFormatBuf(&buf, def, xmlopt, flags) < 0)\n        goto error;\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
  },
  {
    "function_name": "virNetworkDefFormatBuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2440-2670",
    "snippet": "int\nvirNetworkDefFormatBuf(virBufferPtr buf,\n                       const virNetworkDef *def,\n                       virNetworkXMLOptionPtr xmlopt G_GNUC_UNUSED,\n                       unsigned int flags)\n{\n    const unsigned char *uuid;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    size_t i;\n    bool shortforward;\n    bool hasbridge = false;\n\n    virBufferAddLit(buf, \"<network\");\n    if (def->namespaceData && def->ns.format)\n        virXMLNamespaceFormatNS(buf, &def->ns);\n    if (!(flags & VIR_NETWORK_XML_INACTIVE) && (def->connections > 0))\n        virBufferAsprintf(buf, \" connections='%d'\", def->connections);\n    if (def->ipv6nogw)\n        virBufferAddLit(buf, \" ipv6='yes'\");\n    if (def->trustGuestRxFilters)\n        virBufferAsprintf(buf, \" trustGuestRxFilters='%s'\",\n                          virTristateBoolTypeToString(def->trustGuestRxFilters));\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->name);\n\n    uuid = def->uuid;\n    virUUIDFormat(uuid, uuidstr);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n\n    if (def->metadata) {\n        xmlBufferPtr xmlbuf;\n        int oldIndentTreeOutput = xmlIndentTreeOutput;\n\n        /* Indentation on output requires that we previously set\n         * xmlKeepBlanksDefault to 0 when parsing; also, libxml does 2\n         * spaces per level of indentation of intermediate elements,\n         * but no leading indentation before the starting element.\n         * Thankfully, libxml maps what looks like globals into\n         * thread-local uses, so we are thread-safe.  */\n        xmlIndentTreeOutput = 1;\n        xmlbuf = xmlBufferCreate();\n        if (xmlNodeDump(xmlbuf, def->metadata->doc, def->metadata,\n                        virBufferGetIndent(buf) / 2, 1) < 0) {\n            xmlBufferFree(xmlbuf);\n            xmlIndentTreeOutput = oldIndentTreeOutput;\n            return -1;\n        }\n        virBufferAsprintf(buf, \"%s\\n\", (char *) xmlBufferContent(xmlbuf));\n        xmlBufferFree(xmlbuf);\n        xmlIndentTreeOutput = oldIndentTreeOutput;\n    }\n\n    if (def->forward.type != VIR_NETWORK_FORWARD_NONE) {\n        const char *dev = NULL;\n        if (!def->forward.npfs)\n            dev = virNetworkDefForwardIf(def, 0);\n        const char *mode = virNetworkForwardTypeToString(def->forward.type);\n\n        if (!mode) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown forward type %d in network '%s'\"),\n                           def->forward.type, def->name);\n            return -1;\n        }\n        virBufferAddLit(buf, \"<forward\");\n        virBufferEscapeString(buf, \" dev='%s'\", dev);\n        virBufferAsprintf(buf, \" mode='%s'\", mode);\n        if (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n            if (def->forward.managed)\n                virBufferAddLit(buf, \" managed='yes'\");\n            else\n                virBufferAddLit(buf, \" managed='no'\");\n        }\n        shortforward = !(def->forward.nifs || def->forward.npfs\n                         || VIR_SOCKET_ADDR_VALID(&def->forward.addr.start)\n                         || VIR_SOCKET_ADDR_VALID(&def->forward.addr.end)\n                         || def->forward.port.start\n                         || def->forward.port.end\n                         || (def->forward.driverName\n                             != VIR_NETWORK_FORWARD_DRIVER_NAME_DEFAULT));\n        virBufferAsprintf(buf, \"%s>\\n\", shortforward ? \"/\" : \"\");\n        virBufferAdjustIndent(buf, 2);\n\n        if (def->forward.driverName\n            != VIR_NETWORK_FORWARD_DRIVER_NAME_DEFAULT) {\n            const char *driverName\n                = virNetworkForwardDriverNameTypeToString(def->forward.driverName);\n            if (!driverName) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unexpected hostdev driver name type %d \"),\n                               def->forward.driverName);\n                return -1;\n            }\n            virBufferAsprintf(buf, \"<driver name='%s'/>\\n\", driverName);\n        }\n        if (def->forward.type == VIR_NETWORK_FORWARD_NAT) {\n            if (virNetworkForwardNatDefFormat(buf, &def->forward) < 0)\n                return -1;\n        }\n\n        /* For now, hard-coded to at most 1 forward.pfs */\n        if (def->forward.npfs)\n            virBufferEscapeString(buf, \"<pf dev='%s'/>\\n\",\n                                  def->forward.pfs[0].dev);\n\n        if (def->forward.nifs &&\n            (!def->forward.npfs || !(flags & VIR_NETWORK_XML_INACTIVE))) {\n            for (i = 0; i < def->forward.nifs; i++) {\n                if (def->forward.ifs[i].type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV) {\n                    virBufferEscapeString(buf, \"<interface dev='%s'\",\n                                          def->forward.ifs[i].device.dev);\n                    if (!(flags & VIR_NETWORK_XML_INACTIVE) &&\n                        (def->forward.ifs[i].connections > 0)) {\n                        virBufferAsprintf(buf, \" connections='%d'\",\n                                          def->forward.ifs[i].connections);\n                    }\n                    virBufferAddLit(buf, \"/>\\n\");\n                } else {\n                    if (def->forward.ifs[i].type ==  VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI) {\n                        virPCIDeviceAddressFormat(buf,\n                                                  def->forward.ifs[i].device.pci,\n                                                  true);\n                    }\n                }\n            }\n        }\n        virBufferAdjustIndent(buf, -2);\n        if (!shortforward)\n            virBufferAddLit(buf, \"</forward>\\n\");\n    }\n\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        hasbridge = true;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        return -1;\n    }\n\n    if (hasbridge || def->bridge || def->macTableManager) {\n        virBufferAddLit(buf, \"<bridge\");\n        virBufferEscapeString(buf, \" name='%s'\", def->bridge);\n        virBufferEscapeString(buf, \" zone='%s'\", def->bridgeZone);\n        if (hasbridge)\n            virBufferAsprintf(buf, \" stp='%s' delay='%ld'\",\n                              def->stp ? \"on\" : \"off\", def->delay);\n        if (def->macTableManager) {\n            virBufferAsprintf(buf, \" macTableManager='%s'\",\n                             virNetworkBridgeMACTableManagerTypeToString(def->macTableManager));\n        }\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->mtu)\n        virBufferAsprintf(buf, \"<mtu size='%u'/>\\n\", def->mtu);\n\n    if (def->mac_specified) {\n        char macaddr[VIR_MAC_STRING_BUFLEN];\n        virMacAddrFormat(&def->mac, macaddr);\n        virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", macaddr);\n    }\n\n    if (def->domain) {\n        virBufferAsprintf(buf, \"<domain name='%s'\", def->domain);\n\n        /* default to \"no\", but don't format it in the XML */\n        if (def->domainLocalOnly) {\n            const char *local = virTristateBoolTypeToString(def->domainLocalOnly);\n\n            if (!local) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unknown localOnly type %d in network\"),\n                               def->domainLocalOnly);\n                return -1;\n            }\n            virBufferAsprintf(buf, \" localOnly='%s'\", local);\n        }\n\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (virNetworkDNSDefFormat(buf, &def->dns) < 0)\n        return -1;\n\n    if (virNetDevVlanFormat(&def->vlan, buf) < 0)\n        return -1;\n    if (virNetDevBandwidthFormat(def->bandwidth, 0, buf) < 0)\n        return -1;\n    virNetworkPortOptionsFormat(def->isolatedPort, buf);\n\n    for (i = 0; i < def->nips; i++) {\n        if (virNetworkIPDefFormat(buf, &def->ips[i]) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->nroutes; i++) {\n        if (virNetDevIPRouteFormat(buf, def->routes[i]) < 0)\n            return -1;\n    }\n\n    if (virNetDevVPortProfileFormat(def->virtPortProfile, buf) < 0)\n        return -1;\n\n    for (i = 0; i < def->nPortGroups; i++)\n        if (virPortGroupDefFormat(buf, &def->portGroups[i]) < 0)\n            return -1;\n\n    if (def->namespaceData && def->ns.format) {\n        if ((def->ns.format)(buf, def->namespaceData) < 0)\n            return -1;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</network>\\n\");\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</network>\\n\""
          ],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 2666
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "buf",
            "def->namespaceData"
          ],
          "line": 2662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPortGroupDefFormat",
          "args": [
            "buf",
            "&def->portGroups[i]"
          ],
          "line": 2658
        },
        "resolved": true,
        "details": {
          "function_name": "virPortGroupDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2366-2386",
          "snippet": "static int\nvirPortGroupDefFormat(virBufferPtr buf,\n                      const virPortGroupDef *def)\n{\n    virBufferAsprintf(buf, \"<portgroup name='%s'\", def->name);\n    if (def->isDefault)\n        virBufferAddLit(buf, \" default='yes'\");\n    if (def->trustGuestRxFilters)\n        virBufferAsprintf(buf, \" trustGuestRxFilters='%s'\",\n                          virTristateBoolTypeToString(def->trustGuestRxFilters));\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (virNetDevVlanFormat(&def->vlan, buf) < 0)\n        return -1;\n    if (virNetDevVPortProfileFormat(def->virtPortProfile, buf) < 0)\n        return -1;\n    virNetDevBandwidthFormat(def->bandwidth, 0, buf);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</portgroup>\\n\");\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirPortGroupDefFormat(virBufferPtr buf,\n                      const virPortGroupDef *def)\n{\n    virBufferAsprintf(buf, \"<portgroup name='%s'\", def->name);\n    if (def->isDefault)\n        virBufferAddLit(buf, \" default='yes'\");\n    if (def->trustGuestRxFilters)\n        virBufferAsprintf(buf, \" trustGuestRxFilters='%s'\",\n                          virTristateBoolTypeToString(def->trustGuestRxFilters));\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (virNetDevVlanFormat(&def->vlan, buf) < 0)\n        return -1;\n    if (virNetDevVPortProfileFormat(def->virtPortProfile, buf) < 0)\n        return -1;\n    virNetDevBandwidthFormat(def->bandwidth, 0, buf);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</portgroup>\\n\");\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileFormat",
          "args": [
            "def->virtPortProfile",
            "buf"
          ],
          "line": 2654
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_vport_profile_conf.c",
          "lines": "199-278",
          "snippet": "int\nvirNetDevVPortProfileFormat(const virNetDevVPortProfile *virtPort,\n                            virBufferPtr buf)\n{\n    enum virNetDevVPortProfile type;\n    bool noParameters;\n\n    if (!virtPort)\n        return 0;\n\n    noParameters = !(virtPort->managerID_specified ||\n                     virtPort->typeID_specified ||\n                     virtPort->typeIDVersion_specified ||\n                     virtPort->instanceID_specified ||\n                     virtPort->profileID[0] ||\n                     virtPort->interfaceID_specified);\n\n    type = virtPort->virtPortType;\n    if (type == VIR_NETDEV_VPORT_PROFILE_NONE) {\n        if (noParameters)\n            return 0;\n        virBufferAddLit(buf, \"<virtualport>\\n\");\n    } else {\n        if (noParameters) {\n            virBufferAsprintf(buf, \"<virtualport type='%s'/>\\n\",\n                              virNetDevVPortTypeToString(type));\n            return 0;\n        } else {\n            virBufferAsprintf(buf, \"<virtualport type='%s'>\\n\",\n                              virNetDevVPortTypeToString(type));\n        }\n    }\n    virBufferAdjustIndent(buf, 2);\n    virBufferAddLit(buf, \"<parameters\");\n\n    if (virtPort->managerID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" managerid='%d'\", virtPort->managerID);\n    }\n    if (virtPort->typeID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" typeid='%d'\", virtPort->typeID);\n    }\n    if (virtPort->typeIDVersion_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" typeidversion='%d'\",\n                          virtPort->typeIDVersion);\n    }\n    if (virtPort->instanceID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(virtPort->instanceID, uuidstr);\n        virBufferAsprintf(buf, \" instanceid='%s'\", uuidstr);\n    }\n    if (virtPort->interfaceID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_MIDONET ||\n         type == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(virtPort->interfaceID, uuidstr);\n        virBufferAsprintf(buf, \" interfaceid='%s'\", uuidstr);\n    }\n    if (virtPort->profileID[0] &&\n        (type == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         type == VIR_NETDEV_VPORT_PROFILE_8021QBH ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" profileid='%s'\", virtPort->profileID);\n    }\n\n    virBufferAddLit(buf, \"/>\\n\");\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</virtualport>\\n\");\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include <config.h>\n\nint\nvirNetDevVPortProfileFormat(const virNetDevVPortProfile *virtPort,\n                            virBufferPtr buf)\n{\n    enum virNetDevVPortProfile type;\n    bool noParameters;\n\n    if (!virtPort)\n        return 0;\n\n    noParameters = !(virtPort->managerID_specified ||\n                     virtPort->typeID_specified ||\n                     virtPort->typeIDVersion_specified ||\n                     virtPort->instanceID_specified ||\n                     virtPort->profileID[0] ||\n                     virtPort->interfaceID_specified);\n\n    type = virtPort->virtPortType;\n    if (type == VIR_NETDEV_VPORT_PROFILE_NONE) {\n        if (noParameters)\n            return 0;\n        virBufferAddLit(buf, \"<virtualport>\\n\");\n    } else {\n        if (noParameters) {\n            virBufferAsprintf(buf, \"<virtualport type='%s'/>\\n\",\n                              virNetDevVPortTypeToString(type));\n            return 0;\n        } else {\n            virBufferAsprintf(buf, \"<virtualport type='%s'>\\n\",\n                              virNetDevVPortTypeToString(type));\n        }\n    }\n    virBufferAdjustIndent(buf, 2);\n    virBufferAddLit(buf, \"<parameters\");\n\n    if (virtPort->managerID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" managerid='%d'\", virtPort->managerID);\n    }\n    if (virtPort->typeID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" typeid='%d'\", virtPort->typeID);\n    }\n    if (virtPort->typeIDVersion_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" typeidversion='%d'\",\n                          virtPort->typeIDVersion);\n    }\n    if (virtPort->instanceID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(virtPort->instanceID, uuidstr);\n        virBufferAsprintf(buf, \" instanceid='%s'\", uuidstr);\n    }\n    if (virtPort->interfaceID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_MIDONET ||\n         type == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(virtPort->interfaceID, uuidstr);\n        virBufferAsprintf(buf, \" interfaceid='%s'\", uuidstr);\n    }\n    if (virtPort->profileID[0] &&\n        (type == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         type == VIR_NETDEV_VPORT_PROFILE_8021QBH ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" profileid='%s'\", virtPort->profileID);\n    }\n\n    virBufferAddLit(buf, \"/>\\n\");\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</virtualport>\\n\");\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteFormat",
          "args": [
            "buf",
            "def->routes[i]"
          ],
          "line": 2650
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/networkcommon_conf.c",
          "lines": "289-324",
          "snippet": "int\nvirNetDevIPRouteFormat(virBufferPtr buf,\n                       const virNetDevIPRoute *def)\n{\n    char *addr = NULL;\n\n    virBufferAddLit(buf, \"<route\");\n\n    if (def->family)\n        virBufferAsprintf(buf, \" family='%s'\", def->family);\n\n    if (!(addr = virSocketAddrFormat(&def->address)))\n        return -1;\n    virBufferAsprintf(buf, \" address='%s'\", addr);\n    VIR_FREE(addr);\n\n    if (VIR_SOCKET_ADDR_VALID(&def->netmask)) {\n        if (!(addr = virSocketAddrFormat(&def->netmask)))\n            return -1;\n        virBufferAsprintf(buf, \" netmask='%s'\", addr);\n        VIR_FREE(addr);\n    }\n    if (def->has_prefix)\n        virBufferAsprintf(buf, \" prefix='%u'\", def->prefix);\n\n    if (!(addr = virSocketAddrFormat(&def->gateway)))\n        return -1;\n    virBufferAsprintf(buf, \" gateway='%s'\", addr);\n    VIR_FREE(addr);\n\n    if (def->has_metric && def->metric > 0)\n        virBufferAsprintf(buf, \" metric='%u'\", def->metric);\n    virBufferAddLit(buf, \"/>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"networkcommon_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirNetDevIPRouteFormat(virBufferPtr buf,\n                       const virNetDevIPRoute *def)\n{\n    char *addr = NULL;\n\n    virBufferAddLit(buf, \"<route\");\n\n    if (def->family)\n        virBufferAsprintf(buf, \" family='%s'\", def->family);\n\n    if (!(addr = virSocketAddrFormat(&def->address)))\n        return -1;\n    virBufferAsprintf(buf, \" address='%s'\", addr);\n    VIR_FREE(addr);\n\n    if (VIR_SOCKET_ADDR_VALID(&def->netmask)) {\n        if (!(addr = virSocketAddrFormat(&def->netmask)))\n            return -1;\n        virBufferAsprintf(buf, \" netmask='%s'\", addr);\n        VIR_FREE(addr);\n    }\n    if (def->has_prefix)\n        virBufferAsprintf(buf, \" prefix='%u'\", def->prefix);\n\n    if (!(addr = virSocketAddrFormat(&def->gateway)))\n        return -1;\n    virBufferAsprintf(buf, \" gateway='%s'\", addr);\n    VIR_FREE(addr);\n\n    if (def->has_metric && def->metric > 0)\n        virBufferAsprintf(buf, \" metric='%u'\", def->metric);\n    virBufferAddLit(buf, \"/>\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefFormat",
          "args": [
            "buf",
            "&def->ips[i]"
          ],
          "line": 2645
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2260-2355",
          "snippet": "static int\nvirNetworkIPDefFormat(virBufferPtr buf,\n                      const virNetworkIPDef *def)\n{\n    virBufferAddLit(buf, \"<ip\");\n\n    if (def->family)\n        virBufferAsprintf(buf, \" family='%s'\", def->family);\n    if (VIR_SOCKET_ADDR_VALID(&def->address)) {\n        char *addr = virSocketAddrFormat(&def->address);\n        if (!addr)\n            return -1;\n        virBufferAsprintf(buf, \" address='%s'\", addr);\n        VIR_FREE(addr);\n    }\n    if (VIR_SOCKET_ADDR_VALID(&def->netmask)) {\n        char *addr = virSocketAddrFormat(&def->netmask);\n        if (!addr)\n            return -1;\n        virBufferAsprintf(buf, \" netmask='%s'\", addr);\n        VIR_FREE(addr);\n    }\n    if (def->prefix > 0)\n        virBufferAsprintf(buf, \" prefix='%u'\", def->prefix);\n\n    if (def->localPTR) {\n        virBufferAsprintf(buf, \" localPtr='%s'\",\n                          virTristateBoolTypeToString(def->localPTR));\n    }\n\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (def->tftproot) {\n        virBufferEscapeString(buf, \"<tftp root='%s'/>\\n\",\n                              def->tftproot);\n    }\n    if ((def->nranges || def->nhosts)) {\n        size_t i;\n        virBufferAddLit(buf, \"<dhcp>\\n\");\n        virBufferAdjustIndent(buf, 2);\n\n        for (i = 0; i < def->nranges; i++) {\n            char *saddr = virSocketAddrFormat(&def->ranges[i].start);\n            if (!saddr)\n                return -1;\n            char *eaddr = virSocketAddrFormat(&def->ranges[i].end);\n            if (!eaddr) {\n                VIR_FREE(saddr);\n                return -1;\n            }\n            virBufferAsprintf(buf, \"<range start='%s' end='%s'/>\\n\",\n                              saddr, eaddr);\n            VIR_FREE(saddr);\n            VIR_FREE(eaddr);\n        }\n        for (i = 0; i < def->nhosts; i++) {\n            virBufferAddLit(buf, \"<host\");\n            if (def->hosts[i].mac)\n                virBufferAsprintf(buf, \" mac='%s'\", def->hosts[i].mac);\n            if (def->hosts[i].id)\n                virBufferAsprintf(buf, \" id='%s'\", def->hosts[i].id);\n            if (def->hosts[i].name)\n                virBufferAsprintf(buf, \" name='%s'\", def->hosts[i].name);\n            if (VIR_SOCKET_ADDR_VALID(&def->hosts[i].ip)) {\n                char *ipaddr = virSocketAddrFormat(&def->hosts[i].ip);\n                if (!ipaddr)\n                    return -1;\n                virBufferAsprintf(buf, \" ip='%s'\", ipaddr);\n                VIR_FREE(ipaddr);\n            }\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n        if (def->bootfile) {\n            virBufferEscapeString(buf, \"<bootp file='%s'\",\n                                  def->bootfile);\n            if (VIR_SOCKET_ADDR_VALID(&def->bootserver)) {\n                char *ipaddr = virSocketAddrFormat(&def->bootserver);\n                if (!ipaddr)\n                    return -1;\n                virBufferEscapeString(buf, \" server='%s'\", ipaddr);\n                VIR_FREE(ipaddr);\n            }\n            virBufferAddLit(buf, \"/>\\n\");\n\n        }\n\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</dhcp>\\n\");\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</ip>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkIPDefFormat(virBufferPtr buf,\n                      const virNetworkIPDef *def)\n{\n    virBufferAddLit(buf, \"<ip\");\n\n    if (def->family)\n        virBufferAsprintf(buf, \" family='%s'\", def->family);\n    if (VIR_SOCKET_ADDR_VALID(&def->address)) {\n        char *addr = virSocketAddrFormat(&def->address);\n        if (!addr)\n            return -1;\n        virBufferAsprintf(buf, \" address='%s'\", addr);\n        VIR_FREE(addr);\n    }\n    if (VIR_SOCKET_ADDR_VALID(&def->netmask)) {\n        char *addr = virSocketAddrFormat(&def->netmask);\n        if (!addr)\n            return -1;\n        virBufferAsprintf(buf, \" netmask='%s'\", addr);\n        VIR_FREE(addr);\n    }\n    if (def->prefix > 0)\n        virBufferAsprintf(buf, \" prefix='%u'\", def->prefix);\n\n    if (def->localPTR) {\n        virBufferAsprintf(buf, \" localPtr='%s'\",\n                          virTristateBoolTypeToString(def->localPTR));\n    }\n\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (def->tftproot) {\n        virBufferEscapeString(buf, \"<tftp root='%s'/>\\n\",\n                              def->tftproot);\n    }\n    if ((def->nranges || def->nhosts)) {\n        size_t i;\n        virBufferAddLit(buf, \"<dhcp>\\n\");\n        virBufferAdjustIndent(buf, 2);\n\n        for (i = 0; i < def->nranges; i++) {\n            char *saddr = virSocketAddrFormat(&def->ranges[i].start);\n            if (!saddr)\n                return -1;\n            char *eaddr = virSocketAddrFormat(&def->ranges[i].end);\n            if (!eaddr) {\n                VIR_FREE(saddr);\n                return -1;\n            }\n            virBufferAsprintf(buf, \"<range start='%s' end='%s'/>\\n\",\n                              saddr, eaddr);\n            VIR_FREE(saddr);\n            VIR_FREE(eaddr);\n        }\n        for (i = 0; i < def->nhosts; i++) {\n            virBufferAddLit(buf, \"<host\");\n            if (def->hosts[i].mac)\n                virBufferAsprintf(buf, \" mac='%s'\", def->hosts[i].mac);\n            if (def->hosts[i].id)\n                virBufferAsprintf(buf, \" id='%s'\", def->hosts[i].id);\n            if (def->hosts[i].name)\n                virBufferAsprintf(buf, \" name='%s'\", def->hosts[i].name);\n            if (VIR_SOCKET_ADDR_VALID(&def->hosts[i].ip)) {\n                char *ipaddr = virSocketAddrFormat(&def->hosts[i].ip);\n                if (!ipaddr)\n                    return -1;\n                virBufferAsprintf(buf, \" ip='%s'\", ipaddr);\n                VIR_FREE(ipaddr);\n            }\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n        if (def->bootfile) {\n            virBufferEscapeString(buf, \"<bootp file='%s'\",\n                                  def->bootfile);\n            if (VIR_SOCKET_ADDR_VALID(&def->bootserver)) {\n                char *ipaddr = virSocketAddrFormat(&def->bootserver);\n                if (!ipaddr)\n                    return -1;\n                virBufferEscapeString(buf, \" server='%s'\", ipaddr);\n                VIR_FREE(ipaddr);\n            }\n            virBufferAddLit(buf, \"/>\\n\");\n\n        }\n\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</dhcp>\\n\");\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</ip>\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkPortOptionsFormat",
          "args": [
            "def->isolatedPort",
            "buf"
          ],
          "line": 2642
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkPortOptionsFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2357-2364",
          "snippet": "void\nvirNetworkPortOptionsFormat(virTristateBool isolatedPort,\n                            virBufferPtr buf)\n{\n    if (isolatedPort != VIR_TRISTATE_BOOL_ABSENT)\n        virBufferAsprintf(buf, \"<port isolated='%s'/>\\n\",\n                          virTristateBoolTypeToString(isolatedPort));\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetworkPortOptionsFormat(virTristateBool isolatedPort,\n                            virBufferPtr buf)\n{\n    if (isolatedPort != VIR_TRISTATE_BOOL_ABSENT)\n        virBufferAsprintf(buf, \"<port isolated='%s'/>\\n\",\n                          virTristateBoolTypeToString(isolatedPort));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthFormat",
          "args": [
            "def->bandwidth",
            "0",
            "buf"
          ],
          "line": 2640
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_bandwidth_conf.c",
          "lines": "262-285",
          "snippet": "int\nvirNetDevBandwidthFormat(const virNetDevBandwidth *def,\n                         unsigned int class_id,\n                         virBufferPtr buf)\n{\n    if (!buf)\n        return -1;\n\n    if (!def)\n        return 0;\n\n    virBufferAddLit(buf, \"<bandwidth\");\n    if (class_id)\n        virBufferAsprintf(buf, \" classID='%u'\", class_id);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (virNetDevBandwidthRateFormat(def->in, buf, \"inbound\") < 0 ||\n        virNetDevBandwidthRateFormat(def->out, buf, \"outbound\") < 0)\n        return -1;\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</bandwidth>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include <config.h>\n\nint\nvirNetDevBandwidthFormat(const virNetDevBandwidth *def,\n                         unsigned int class_id,\n                         virBufferPtr buf)\n{\n    if (!buf)\n        return -1;\n\n    if (!def)\n        return 0;\n\n    virBufferAddLit(buf, \"<bandwidth\");\n    if (class_id)\n        virBufferAsprintf(buf, \" classID='%u'\", class_id);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (virNetDevBandwidthRateFormat(def->in, buf, \"inbound\") < 0 ||\n        virNetDevBandwidthRateFormat(def->out, buf, \"outbound\") < 0)\n        return -1;\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</bandwidth>\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVlanFormat",
          "args": [
            "&def->vlan",
            "buf"
          ],
          "line": 2638
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVlanFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_vlan_conf.c",
          "lines": "140-174",
          "snippet": "int\nvirNetDevVlanFormat(const virNetDevVlan *def, virBufferPtr buf)\n{\n    size_t i;\n\n    if (!(def && def->nTags))\n        return 0;\n\n    if (!def->tag) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing vlan tag data\"));\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<vlan%s>\\n\", def->trunk ? \" trunk='yes'\" : \"\");\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < def->nTags; i++) {\n        if (def->nativeMode != VIR_NATIVE_VLAN_MODE_DEFAULT &&\n            def->nativeTag == def->tag[i]) {\n            /* check the nativeMode in case we get <tag id='0'/>*/\n            const char *mode = virNativeVlanModeTypeToString(def->nativeMode);\n            if (!mode) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Bad value for nativeMode\"));\n            }\n            virBufferAsprintf(buf, \"<tag id='%u' nativeMode='%s'/>\\n\",\n                              def->tag[i], mode);\n        } else {\n            virBufferAsprintf(buf, \"<tag id='%u'/>\\n\", def->tag[i]);\n        }\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</vlan>\\n\");\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_vlan_conf.h\"\n#include <config.h>\n\nint\nvirNetDevVlanFormat(const virNetDevVlan *def, virBufferPtr buf)\n{\n    size_t i;\n\n    if (!(def && def->nTags))\n        return 0;\n\n    if (!def->tag) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing vlan tag data\"));\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<vlan%s>\\n\", def->trunk ? \" trunk='yes'\" : \"\");\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < def->nTags; i++) {\n        if (def->nativeMode != VIR_NATIVE_VLAN_MODE_DEFAULT &&\n            def->nativeTag == def->tag[i]) {\n            /* check the nativeMode in case we get <tag id='0'/>*/\n            const char *mode = virNativeVlanModeTypeToString(def->nativeMode);\n            if (!mode) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Bad value for nativeMode\"));\n            }\n            virBufferAsprintf(buf, \"<tag id='%u' nativeMode='%s'/>\\n\",\n                              def->tag[i], mode);\n        } else {\n            virBufferAsprintf(buf, \"<tag id='%u'/>\\n\", def->tag[i]);\n        }\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</vlan>\\n\");\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDNSDefFormat",
          "args": [
            "buf",
            "&def->dns"
          ],
          "line": 2635
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDNSDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2153-2257",
          "snippet": "static int\nvirNetworkDNSDefFormat(virBufferPtr buf,\n                       const virNetworkDNSDef *def)\n{\n    size_t i, j;\n\n    if (!(def->enable || def->forwardPlainNames || def->nfwds || def->nhosts ||\n          def->nsrvs || def->ntxts))\n        return 0;\n\n    virBufferAddLit(buf, \"<dns\");\n    if (def->enable) {\n        const char *fwd = virTristateBoolTypeToString(def->enable);\n\n        if (!fwd) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown enable type %d in network\"),\n                           def->enable);\n            return -1;\n        }\n        virBufferAsprintf(buf, \" enable='%s'\", fwd);\n    }\n    if (def->forwardPlainNames) {\n        const char *fwd = virTristateBoolTypeToString(def->forwardPlainNames);\n\n        if (!fwd) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown forwardPlainNames type %d in network\"),\n                           def->forwardPlainNames);\n            return -1;\n        }\n        virBufferAsprintf(buf, \" forwardPlainNames='%s'\", fwd);\n    }\n    if (!(def->nfwds || def->nhosts || def->nsrvs || def->ntxts)) {\n        virBufferAddLit(buf, \"/>\\n\");\n        return 0;\n    }\n\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < def->nfwds; i++) {\n\n        virBufferAddLit(buf, \"<forwarder\");\n        if (def->forwarders[i].domain) {\n            virBufferEscapeString(buf, \" domain='%s'\",\n                                  def->forwarders[i].domain);\n        }\n        if (VIR_SOCKET_ADDR_VALID(&def->forwarders[i].addr)) {\n        char *addr = virSocketAddrFormat(&def->forwarders[i].addr);\n\n        if (!addr)\n            return -1;\n\n        virBufferAsprintf(buf, \" addr='%s'\", addr);\n        VIR_FREE(addr);\n        }\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    for (i = 0; i < def->ntxts; i++) {\n        virBufferEscapeString(buf, \"<txt name='%s' \", def->txts[i].name);\n        virBufferEscapeString(buf, \"value='%s'/>\\n\", def->txts[i].value);\n    }\n\n    for (i = 0; i < def->nsrvs; i++) {\n        if (def->srvs[i].service && def->srvs[i].protocol) {\n            virBufferEscapeString(buf, \"<srv service='%s' \",\n                                  def->srvs[i].service);\n            virBufferEscapeString(buf, \"protocol='%s'\", def->srvs[i].protocol);\n\n            if (def->srvs[i].domain)\n                virBufferEscapeString(buf, \" domain='%s'\", def->srvs[i].domain);\n            if (def->srvs[i].target)\n                virBufferEscapeString(buf, \" target='%s'\", def->srvs[i].target);\n            if (def->srvs[i].port)\n                virBufferAsprintf(buf, \" port='%d'\", def->srvs[i].port);\n            if (def->srvs[i].priority)\n                virBufferAsprintf(buf, \" priority='%d'\", def->srvs[i].priority);\n            if (def->srvs[i].weight)\n                virBufferAsprintf(buf, \" weight='%d'\", def->srvs[i].weight);\n\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n\n    if (def->nhosts) {\n        for (i = 0; i < def->nhosts; i++) {\n            char *ip = virSocketAddrFormat(&def->hosts[i].ip);\n\n            virBufferAsprintf(buf, \"<host ip='%s'>\\n\", ip);\n            virBufferAdjustIndent(buf, 2);\n            for (j = 0; j < def->hosts[i].nnames; j++)\n                virBufferEscapeString(buf, \"<hostname>%s</hostname>\\n\",\n                                      def->hosts[i].names[j]);\n\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</host>\\n\");\n            VIR_FREE(ip);\n        }\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</dns>\\n\");\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDNSDefFormat(virBufferPtr buf,\n                       const virNetworkDNSDef *def)\n{\n    size_t i, j;\n\n    if (!(def->enable || def->forwardPlainNames || def->nfwds || def->nhosts ||\n          def->nsrvs || def->ntxts))\n        return 0;\n\n    virBufferAddLit(buf, \"<dns\");\n    if (def->enable) {\n        const char *fwd = virTristateBoolTypeToString(def->enable);\n\n        if (!fwd) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown enable type %d in network\"),\n                           def->enable);\n            return -1;\n        }\n        virBufferAsprintf(buf, \" enable='%s'\", fwd);\n    }\n    if (def->forwardPlainNames) {\n        const char *fwd = virTristateBoolTypeToString(def->forwardPlainNames);\n\n        if (!fwd) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown forwardPlainNames type %d in network\"),\n                           def->forwardPlainNames);\n            return -1;\n        }\n        virBufferAsprintf(buf, \" forwardPlainNames='%s'\", fwd);\n    }\n    if (!(def->nfwds || def->nhosts || def->nsrvs || def->ntxts)) {\n        virBufferAddLit(buf, \"/>\\n\");\n        return 0;\n    }\n\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < def->nfwds; i++) {\n\n        virBufferAddLit(buf, \"<forwarder\");\n        if (def->forwarders[i].domain) {\n            virBufferEscapeString(buf, \" domain='%s'\",\n                                  def->forwarders[i].domain);\n        }\n        if (VIR_SOCKET_ADDR_VALID(&def->forwarders[i].addr)) {\n        char *addr = virSocketAddrFormat(&def->forwarders[i].addr);\n\n        if (!addr)\n            return -1;\n\n        virBufferAsprintf(buf, \" addr='%s'\", addr);\n        VIR_FREE(addr);\n        }\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    for (i = 0; i < def->ntxts; i++) {\n        virBufferEscapeString(buf, \"<txt name='%s' \", def->txts[i].name);\n        virBufferEscapeString(buf, \"value='%s'/>\\n\", def->txts[i].value);\n    }\n\n    for (i = 0; i < def->nsrvs; i++) {\n        if (def->srvs[i].service && def->srvs[i].protocol) {\n            virBufferEscapeString(buf, \"<srv service='%s' \",\n                                  def->srvs[i].service);\n            virBufferEscapeString(buf, \"protocol='%s'\", def->srvs[i].protocol);\n\n            if (def->srvs[i].domain)\n                virBufferEscapeString(buf, \" domain='%s'\", def->srvs[i].domain);\n            if (def->srvs[i].target)\n                virBufferEscapeString(buf, \" target='%s'\", def->srvs[i].target);\n            if (def->srvs[i].port)\n                virBufferAsprintf(buf, \" port='%d'\", def->srvs[i].port);\n            if (def->srvs[i].priority)\n                virBufferAsprintf(buf, \" priority='%d'\", def->srvs[i].priority);\n            if (def->srvs[i].weight)\n                virBufferAsprintf(buf, \" weight='%d'\", def->srvs[i].weight);\n\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n\n    if (def->nhosts) {\n        for (i = 0; i < def->nhosts; i++) {\n            char *ip = virSocketAddrFormat(&def->hosts[i].ip);\n\n            virBufferAsprintf(buf, \"<host ip='%s'>\\n\", ip);\n            virBufferAdjustIndent(buf, 2);\n            for (j = 0; j < def->hosts[i].nnames; j++)\n                virBufferEscapeString(buf, \"<hostname>%s</hostname>\\n\",\n                                      def->hosts[i].names[j]);\n\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</host>\\n\");\n            VIR_FREE(ip);\n        }\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</dns>\\n\");\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\" localOnly='%s'\"",
            "local"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown localOnly type %d in network\")",
            "def->domainLocalOnly"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown localOnly type %d in network\""
          ],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeToString",
          "args": [
            "def->domainLocalOnly"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "&def->mac",
            "macaddr"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkBridgeMACTableManagerTypeToString",
          "args": [
            "def->macTableManager"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\" zone='%s'\"",
            "def->bridgeZone"
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<bridge\""
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNetworkForwardType",
            "def->forward.type"
          ],
          "line": 2589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</forward>\\n\""
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressFormat",
          "args": [
            "buf",
            "def->forward.ifs[i].device.pci",
            "true"
          ],
          "line": 2560
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "293-305",
          "snippet": "void\nvirPCIDeviceAddressFormat(virBufferPtr buf,\n                          virPCIDeviceAddress addr,\n                          bool includeTypeInAddr)\n{\n    virBufferAsprintf(buf, \"<address %sdomain='0x%04x' bus='0x%02x' \"\n                      \"slot='0x%02x' function='0x%d'/>\\n\",\n                      includeTypeInAddr ? \"type='pci' \" : \"\",\n                      addr.domain,\n                      addr.bus,\n                      addr.slot,\n                      addr.function);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceAddressFormat(virBufferPtr buf,\n                          virPCIDeviceAddress addr,\n                          bool includeTypeInAddr)\n{\n    virBufferAsprintf(buf, \"<address %sdomain='0x%04x' bus='0x%02x' \"\n                      \"slot='0x%02x' function='0x%d'/>\\n\",\n                      includeTypeInAddr ? \"type='pci' \" : \"\",\n                      addr.domain,\n                      addr.bus,\n                      addr.slot,\n                      addr.function);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardNatDefFormat",
          "args": [
            "buf",
            "&def->forward"
          ],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkForwardNatDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2389-2437",
          "snippet": "static int\nvirNetworkForwardNatDefFormat(virBufferPtr buf,\n                              const virNetworkForwardDef *fwd)\n{\n    char *addrStart = NULL;\n    char *addrEnd = NULL;\n    int ret = -1;\n\n    if (VIR_SOCKET_ADDR_VALID(&fwd->addr.start)) {\n        addrStart = virSocketAddrFormat(&fwd->addr.start);\n        if (!addrStart)\n            goto cleanup;\n    }\n\n    if (VIR_SOCKET_ADDR_VALID(&fwd->addr.end)) {\n        addrEnd = virSocketAddrFormat(&fwd->addr.end);\n        if (!addrEnd)\n            goto cleanup;\n    }\n\n    if (!addrEnd && !addrStart && !fwd->port.start && !fwd->port.end)\n        return 0;\n\n    virBufferAddLit(buf, \"<nat>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (addrStart) {\n        virBufferAsprintf(buf, \"<address start='%s'\", addrStart);\n        if (addrEnd)\n            virBufferAsprintf(buf, \" end='%s'\", addrEnd);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (fwd->port.start || fwd->port.end) {\n        virBufferAsprintf(buf, \"<port start='%d'\", fwd->port.start);\n        if (fwd->port.end)\n            virBufferAsprintf(buf, \" end='%d'\", fwd->port.end);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</nat>\\n\");\n    ret = 0;\n\n cleanup:\n    VIR_FREE(addrStart);\n    VIR_FREE(addrEnd);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkForwardNatDefFormat(virBufferPtr buf,\n                              const virNetworkForwardDef *fwd)\n{\n    char *addrStart = NULL;\n    char *addrEnd = NULL;\n    int ret = -1;\n\n    if (VIR_SOCKET_ADDR_VALID(&fwd->addr.start)) {\n        addrStart = virSocketAddrFormat(&fwd->addr.start);\n        if (!addrStart)\n            goto cleanup;\n    }\n\n    if (VIR_SOCKET_ADDR_VALID(&fwd->addr.end)) {\n        addrEnd = virSocketAddrFormat(&fwd->addr.end);\n        if (!addrEnd)\n            goto cleanup;\n    }\n\n    if (!addrEnd && !addrStart && !fwd->port.start && !fwd->port.end)\n        return 0;\n\n    virBufferAddLit(buf, \"<nat>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (addrStart) {\n        virBufferAsprintf(buf, \"<address start='%s'\", addrStart);\n        if (addrEnd)\n            virBufferAsprintf(buf, \" end='%s'\", addrEnd);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (fwd->port.start || fwd->port.end) {\n        virBufferAsprintf(buf, \"<port start='%d'\", fwd->port.start);\n        if (fwd->port.end)\n            virBufferAsprintf(buf, \" end='%d'\", fwd->port.end);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</nat>\\n\");\n    ret = 0;\n\n cleanup:\n    VIR_FREE(addrStart);\n    VIR_FREE(addrEnd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected hostdev driver name type %d \")",
            "def->forward.driverName"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardDriverNameTypeToString",
          "args": [
            "def->forward.driverName"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&def->forward.addr.end"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&def->forward.addr.start"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" managed='no'\""
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" managed='yes'\""
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<forward\""
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown forward type %d in network '%s'\")",
            "def->forward.type",
            "def->name"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "def->forward.type"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefForwardIf",
          "args": [
            "def",
            "0"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefForwardIf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2691-2698",
          "snippet": "const char *\nvirNetworkDefForwardIf(const virNetworkDef *def,\n                       size_t n)\n{\n    return ((def->forward.ifs && (def->forward.nifs > n) &&\n             def->forward.ifs[n].type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n            ? def->forward.ifs[n].device.dev : NULL);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nconst char *\nvirNetworkDefForwardIf(const virNetworkDef *def,\n                       size_t n)\n{\n    return ((def->forward.ifs && (def->forward.nifs > n) &&\n             def->forward.ifs[n].type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n            ? def->forward.ifs[n].device.dev : NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlBufferFree",
          "args": [
            "xmlbuf"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlBufferContent",
          "args": [
            "xmlbuf"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlBufferFree",
          "args": [
            "xmlbuf"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNodeDump",
          "args": [
            "xmlbuf",
            "def->metadata->doc",
            "def->metadata",
            "virBufferGetIndent(buf) / 2",
            "1"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferGetIndent",
          "args": [
            "buf"
          ],
          "line": 2483
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferGetIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "89-93",
          "snippet": "size_t\nvirBufferGetIndent(const virBuffer *buf)\n{\n    return buf->indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nsize_t\nvirBufferGetIndent(const virBuffer *buf)\n{\n    return buf->indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlBufferCreate",
          "args": [],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "uuid",
            "uuidstr"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\">\\n\""
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeToString",
          "args": [
            "def->trustGuestRxFilters"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" ipv6='yes'\""
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLNamespaceFormatNS",
          "args": [
            "buf",
            "&def->ns"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNamespaceFormatNS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1412-1417",
          "snippet": "void\nvirXMLNamespaceFormatNS(virBufferPtr buf,\n                        virXMLNamespace const *ns)\n{\n    virBufferAsprintf(buf, \" xmlns:%s='%s'\", ns->prefix, ns->uri);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirXMLNamespaceFormatNS(virBufferPtr buf,\n                        virXMLNamespace const *ns)\n{\n    virBufferAsprintf(buf, \" xmlns:%s='%s'\", ns->prefix, ns->uri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<network\""
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkDefFormatBuf(virBufferPtr buf,\n                       const virNetworkDef *def,\n                       virNetworkXMLOptionPtr xmlopt G_GNUC_UNUSED,\n                       unsigned int flags)\n{\n    const unsigned char *uuid;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    size_t i;\n    bool shortforward;\n    bool hasbridge = false;\n\n    virBufferAddLit(buf, \"<network\");\n    if (def->namespaceData && def->ns.format)\n        virXMLNamespaceFormatNS(buf, &def->ns);\n    if (!(flags & VIR_NETWORK_XML_INACTIVE) && (def->connections > 0))\n        virBufferAsprintf(buf, \" connections='%d'\", def->connections);\n    if (def->ipv6nogw)\n        virBufferAddLit(buf, \" ipv6='yes'\");\n    if (def->trustGuestRxFilters)\n        virBufferAsprintf(buf, \" trustGuestRxFilters='%s'\",\n                          virTristateBoolTypeToString(def->trustGuestRxFilters));\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->name);\n\n    uuid = def->uuid;\n    virUUIDFormat(uuid, uuidstr);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n\n    if (def->metadata) {\n        xmlBufferPtr xmlbuf;\n        int oldIndentTreeOutput = xmlIndentTreeOutput;\n\n        /* Indentation on output requires that we previously set\n         * xmlKeepBlanksDefault to 0 when parsing; also, libxml does 2\n         * spaces per level of indentation of intermediate elements,\n         * but no leading indentation before the starting element.\n         * Thankfully, libxml maps what looks like globals into\n         * thread-local uses, so we are thread-safe.  */\n        xmlIndentTreeOutput = 1;\n        xmlbuf = xmlBufferCreate();\n        if (xmlNodeDump(xmlbuf, def->metadata->doc, def->metadata,\n                        virBufferGetIndent(buf) / 2, 1) < 0) {\n            xmlBufferFree(xmlbuf);\n            xmlIndentTreeOutput = oldIndentTreeOutput;\n            return -1;\n        }\n        virBufferAsprintf(buf, \"%s\\n\", (char *) xmlBufferContent(xmlbuf));\n        xmlBufferFree(xmlbuf);\n        xmlIndentTreeOutput = oldIndentTreeOutput;\n    }\n\n    if (def->forward.type != VIR_NETWORK_FORWARD_NONE) {\n        const char *dev = NULL;\n        if (!def->forward.npfs)\n            dev = virNetworkDefForwardIf(def, 0);\n        const char *mode = virNetworkForwardTypeToString(def->forward.type);\n\n        if (!mode) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown forward type %d in network '%s'\"),\n                           def->forward.type, def->name);\n            return -1;\n        }\n        virBufferAddLit(buf, \"<forward\");\n        virBufferEscapeString(buf, \" dev='%s'\", dev);\n        virBufferAsprintf(buf, \" mode='%s'\", mode);\n        if (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n            if (def->forward.managed)\n                virBufferAddLit(buf, \" managed='yes'\");\n            else\n                virBufferAddLit(buf, \" managed='no'\");\n        }\n        shortforward = !(def->forward.nifs || def->forward.npfs\n                         || VIR_SOCKET_ADDR_VALID(&def->forward.addr.start)\n                         || VIR_SOCKET_ADDR_VALID(&def->forward.addr.end)\n                         || def->forward.port.start\n                         || def->forward.port.end\n                         || (def->forward.driverName\n                             != VIR_NETWORK_FORWARD_DRIVER_NAME_DEFAULT));\n        virBufferAsprintf(buf, \"%s>\\n\", shortforward ? \"/\" : \"\");\n        virBufferAdjustIndent(buf, 2);\n\n        if (def->forward.driverName\n            != VIR_NETWORK_FORWARD_DRIVER_NAME_DEFAULT) {\n            const char *driverName\n                = virNetworkForwardDriverNameTypeToString(def->forward.driverName);\n            if (!driverName) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unexpected hostdev driver name type %d \"),\n                               def->forward.driverName);\n                return -1;\n            }\n            virBufferAsprintf(buf, \"<driver name='%s'/>\\n\", driverName);\n        }\n        if (def->forward.type == VIR_NETWORK_FORWARD_NAT) {\n            if (virNetworkForwardNatDefFormat(buf, &def->forward) < 0)\n                return -1;\n        }\n\n        /* For now, hard-coded to at most 1 forward.pfs */\n        if (def->forward.npfs)\n            virBufferEscapeString(buf, \"<pf dev='%s'/>\\n\",\n                                  def->forward.pfs[0].dev);\n\n        if (def->forward.nifs &&\n            (!def->forward.npfs || !(flags & VIR_NETWORK_XML_INACTIVE))) {\n            for (i = 0; i < def->forward.nifs; i++) {\n                if (def->forward.ifs[i].type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV) {\n                    virBufferEscapeString(buf, \"<interface dev='%s'\",\n                                          def->forward.ifs[i].device.dev);\n                    if (!(flags & VIR_NETWORK_XML_INACTIVE) &&\n                        (def->forward.ifs[i].connections > 0)) {\n                        virBufferAsprintf(buf, \" connections='%d'\",\n                                          def->forward.ifs[i].connections);\n                    }\n                    virBufferAddLit(buf, \"/>\\n\");\n                } else {\n                    if (def->forward.ifs[i].type ==  VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI) {\n                        virPCIDeviceAddressFormat(buf,\n                                                  def->forward.ifs[i].device.pci,\n                                                  true);\n                    }\n                }\n            }\n        }\n        virBufferAdjustIndent(buf, -2);\n        if (!shortforward)\n            virBufferAddLit(buf, \"</forward>\\n\");\n    }\n\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        hasbridge = true;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        return -1;\n    }\n\n    if (hasbridge || def->bridge || def->macTableManager) {\n        virBufferAddLit(buf, \"<bridge\");\n        virBufferEscapeString(buf, \" name='%s'\", def->bridge);\n        virBufferEscapeString(buf, \" zone='%s'\", def->bridgeZone);\n        if (hasbridge)\n            virBufferAsprintf(buf, \" stp='%s' delay='%ld'\",\n                              def->stp ? \"on\" : \"off\", def->delay);\n        if (def->macTableManager) {\n            virBufferAsprintf(buf, \" macTableManager='%s'\",\n                             virNetworkBridgeMACTableManagerTypeToString(def->macTableManager));\n        }\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->mtu)\n        virBufferAsprintf(buf, \"<mtu size='%u'/>\\n\", def->mtu);\n\n    if (def->mac_specified) {\n        char macaddr[VIR_MAC_STRING_BUFLEN];\n        virMacAddrFormat(&def->mac, macaddr);\n        virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", macaddr);\n    }\n\n    if (def->domain) {\n        virBufferAsprintf(buf, \"<domain name='%s'\", def->domain);\n\n        /* default to \"no\", but don't format it in the XML */\n        if (def->domainLocalOnly) {\n            const char *local = virTristateBoolTypeToString(def->domainLocalOnly);\n\n            if (!local) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unknown localOnly type %d in network\"),\n                               def->domainLocalOnly);\n                return -1;\n            }\n            virBufferAsprintf(buf, \" localOnly='%s'\", local);\n        }\n\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (virNetworkDNSDefFormat(buf, &def->dns) < 0)\n        return -1;\n\n    if (virNetDevVlanFormat(&def->vlan, buf) < 0)\n        return -1;\n    if (virNetDevBandwidthFormat(def->bandwidth, 0, buf) < 0)\n        return -1;\n    virNetworkPortOptionsFormat(def->isolatedPort, buf);\n\n    for (i = 0; i < def->nips; i++) {\n        if (virNetworkIPDefFormat(buf, &def->ips[i]) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->nroutes; i++) {\n        if (virNetDevIPRouteFormat(buf, def->routes[i]) < 0)\n            return -1;\n    }\n\n    if (virNetDevVPortProfileFormat(def->virtPortProfile, buf) < 0)\n        return -1;\n\n    for (i = 0; i < def->nPortGroups; i++)\n        if (virPortGroupDefFormat(buf, &def->portGroups[i]) < 0)\n            return -1;\n\n    if (def->namespaceData && def->ns.format) {\n        if ((def->ns.format)(buf, def->namespaceData) < 0)\n            return -1;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</network>\\n\");\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetworkForwardNatDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2389-2437",
    "snippet": "static int\nvirNetworkForwardNatDefFormat(virBufferPtr buf,\n                              const virNetworkForwardDef *fwd)\n{\n    char *addrStart = NULL;\n    char *addrEnd = NULL;\n    int ret = -1;\n\n    if (VIR_SOCKET_ADDR_VALID(&fwd->addr.start)) {\n        addrStart = virSocketAddrFormat(&fwd->addr.start);\n        if (!addrStart)\n            goto cleanup;\n    }\n\n    if (VIR_SOCKET_ADDR_VALID(&fwd->addr.end)) {\n        addrEnd = virSocketAddrFormat(&fwd->addr.end);\n        if (!addrEnd)\n            goto cleanup;\n    }\n\n    if (!addrEnd && !addrStart && !fwd->port.start && !fwd->port.end)\n        return 0;\n\n    virBufferAddLit(buf, \"<nat>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (addrStart) {\n        virBufferAsprintf(buf, \"<address start='%s'\", addrStart);\n        if (addrEnd)\n            virBufferAsprintf(buf, \" end='%s'\", addrEnd);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (fwd->port.start || fwd->port.end) {\n        virBufferAsprintf(buf, \"<port start='%d'\", fwd->port.start);\n        if (fwd->port.end)\n            virBufferAsprintf(buf, \" end='%d'\", fwd->port.end);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</nat>\\n\");\n    ret = 0;\n\n cleanup:\n    VIR_FREE(addrStart);\n    VIR_FREE(addrEnd);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addrEnd"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addrStart"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</nat>\\n\""
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 2429
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\" end='%d'\"",
            "fwd->port.end"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<nat>\\n\""
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "&fwd->addr.end"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&fwd->addr.end"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&fwd->addr.start"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkForwardNatDefFormat(virBufferPtr buf,\n                              const virNetworkForwardDef *fwd)\n{\n    char *addrStart = NULL;\n    char *addrEnd = NULL;\n    int ret = -1;\n\n    if (VIR_SOCKET_ADDR_VALID(&fwd->addr.start)) {\n        addrStart = virSocketAddrFormat(&fwd->addr.start);\n        if (!addrStart)\n            goto cleanup;\n    }\n\n    if (VIR_SOCKET_ADDR_VALID(&fwd->addr.end)) {\n        addrEnd = virSocketAddrFormat(&fwd->addr.end);\n        if (!addrEnd)\n            goto cleanup;\n    }\n\n    if (!addrEnd && !addrStart && !fwd->port.start && !fwd->port.end)\n        return 0;\n\n    virBufferAddLit(buf, \"<nat>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (addrStart) {\n        virBufferAsprintf(buf, \"<address start='%s'\", addrStart);\n        if (addrEnd)\n            virBufferAsprintf(buf, \" end='%s'\", addrEnd);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (fwd->port.start || fwd->port.end) {\n        virBufferAsprintf(buf, \"<port start='%d'\", fwd->port.start);\n        if (fwd->port.end)\n            virBufferAsprintf(buf, \" end='%d'\", fwd->port.end);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</nat>\\n\");\n    ret = 0;\n\n cleanup:\n    VIR_FREE(addrStart);\n    VIR_FREE(addrEnd);\n    return ret;\n}"
  },
  {
    "function_name": "virPortGroupDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2366-2386",
    "snippet": "static int\nvirPortGroupDefFormat(virBufferPtr buf,\n                      const virPortGroupDef *def)\n{\n    virBufferAsprintf(buf, \"<portgroup name='%s'\", def->name);\n    if (def->isDefault)\n        virBufferAddLit(buf, \" default='yes'\");\n    if (def->trustGuestRxFilters)\n        virBufferAsprintf(buf, \" trustGuestRxFilters='%s'\",\n                          virTristateBoolTypeToString(def->trustGuestRxFilters));\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (virNetDevVlanFormat(&def->vlan, buf) < 0)\n        return -1;\n    if (virNetDevVPortProfileFormat(def->virtPortProfile, buf) < 0)\n        return -1;\n    virNetDevBandwidthFormat(def->bandwidth, 0, buf);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</portgroup>\\n\");\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</portgroup>\\n\""
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 2383
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthFormat",
          "args": [
            "def->bandwidth",
            "0",
            "buf"
          ],
          "line": 2382
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_bandwidth_conf.c",
          "lines": "262-285",
          "snippet": "int\nvirNetDevBandwidthFormat(const virNetDevBandwidth *def,\n                         unsigned int class_id,\n                         virBufferPtr buf)\n{\n    if (!buf)\n        return -1;\n\n    if (!def)\n        return 0;\n\n    virBufferAddLit(buf, \"<bandwidth\");\n    if (class_id)\n        virBufferAsprintf(buf, \" classID='%u'\", class_id);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (virNetDevBandwidthRateFormat(def->in, buf, \"inbound\") < 0 ||\n        virNetDevBandwidthRateFormat(def->out, buf, \"outbound\") < 0)\n        return -1;\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</bandwidth>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include <config.h>\n\nint\nvirNetDevBandwidthFormat(const virNetDevBandwidth *def,\n                         unsigned int class_id,\n                         virBufferPtr buf)\n{\n    if (!buf)\n        return -1;\n\n    if (!def)\n        return 0;\n\n    virBufferAddLit(buf, \"<bandwidth\");\n    if (class_id)\n        virBufferAsprintf(buf, \" classID='%u'\", class_id);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (virNetDevBandwidthRateFormat(def->in, buf, \"inbound\") < 0 ||\n        virNetDevBandwidthRateFormat(def->out, buf, \"outbound\") < 0)\n        return -1;\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</bandwidth>\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileFormat",
          "args": [
            "def->virtPortProfile",
            "buf"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_vport_profile_conf.c",
          "lines": "199-278",
          "snippet": "int\nvirNetDevVPortProfileFormat(const virNetDevVPortProfile *virtPort,\n                            virBufferPtr buf)\n{\n    enum virNetDevVPortProfile type;\n    bool noParameters;\n\n    if (!virtPort)\n        return 0;\n\n    noParameters = !(virtPort->managerID_specified ||\n                     virtPort->typeID_specified ||\n                     virtPort->typeIDVersion_specified ||\n                     virtPort->instanceID_specified ||\n                     virtPort->profileID[0] ||\n                     virtPort->interfaceID_specified);\n\n    type = virtPort->virtPortType;\n    if (type == VIR_NETDEV_VPORT_PROFILE_NONE) {\n        if (noParameters)\n            return 0;\n        virBufferAddLit(buf, \"<virtualport>\\n\");\n    } else {\n        if (noParameters) {\n            virBufferAsprintf(buf, \"<virtualport type='%s'/>\\n\",\n                              virNetDevVPortTypeToString(type));\n            return 0;\n        } else {\n            virBufferAsprintf(buf, \"<virtualport type='%s'>\\n\",\n                              virNetDevVPortTypeToString(type));\n        }\n    }\n    virBufferAdjustIndent(buf, 2);\n    virBufferAddLit(buf, \"<parameters\");\n\n    if (virtPort->managerID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" managerid='%d'\", virtPort->managerID);\n    }\n    if (virtPort->typeID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" typeid='%d'\", virtPort->typeID);\n    }\n    if (virtPort->typeIDVersion_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" typeidversion='%d'\",\n                          virtPort->typeIDVersion);\n    }\n    if (virtPort->instanceID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(virtPort->instanceID, uuidstr);\n        virBufferAsprintf(buf, \" instanceid='%s'\", uuidstr);\n    }\n    if (virtPort->interfaceID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_MIDONET ||\n         type == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(virtPort->interfaceID, uuidstr);\n        virBufferAsprintf(buf, \" interfaceid='%s'\", uuidstr);\n    }\n    if (virtPort->profileID[0] &&\n        (type == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         type == VIR_NETDEV_VPORT_PROFILE_8021QBH ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" profileid='%s'\", virtPort->profileID);\n    }\n\n    virBufferAddLit(buf, \"/>\\n\");\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</virtualport>\\n\");\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include <config.h>\n\nint\nvirNetDevVPortProfileFormat(const virNetDevVPortProfile *virtPort,\n                            virBufferPtr buf)\n{\n    enum virNetDevVPortProfile type;\n    bool noParameters;\n\n    if (!virtPort)\n        return 0;\n\n    noParameters = !(virtPort->managerID_specified ||\n                     virtPort->typeID_specified ||\n                     virtPort->typeIDVersion_specified ||\n                     virtPort->instanceID_specified ||\n                     virtPort->profileID[0] ||\n                     virtPort->interfaceID_specified);\n\n    type = virtPort->virtPortType;\n    if (type == VIR_NETDEV_VPORT_PROFILE_NONE) {\n        if (noParameters)\n            return 0;\n        virBufferAddLit(buf, \"<virtualport>\\n\");\n    } else {\n        if (noParameters) {\n            virBufferAsprintf(buf, \"<virtualport type='%s'/>\\n\",\n                              virNetDevVPortTypeToString(type));\n            return 0;\n        } else {\n            virBufferAsprintf(buf, \"<virtualport type='%s'>\\n\",\n                              virNetDevVPortTypeToString(type));\n        }\n    }\n    virBufferAdjustIndent(buf, 2);\n    virBufferAddLit(buf, \"<parameters\");\n\n    if (virtPort->managerID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" managerid='%d'\", virtPort->managerID);\n    }\n    if (virtPort->typeID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" typeid='%d'\", virtPort->typeID);\n    }\n    if (virtPort->typeIDVersion_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" typeidversion='%d'\",\n                          virtPort->typeIDVersion);\n    }\n    if (virtPort->instanceID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(virtPort->instanceID, uuidstr);\n        virBufferAsprintf(buf, \" instanceid='%s'\", uuidstr);\n    }\n    if (virtPort->interfaceID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_MIDONET ||\n         type == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(virtPort->interfaceID, uuidstr);\n        virBufferAsprintf(buf, \" interfaceid='%s'\", uuidstr);\n    }\n    if (virtPort->profileID[0] &&\n        (type == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         type == VIR_NETDEV_VPORT_PROFILE_8021QBH ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" profileid='%s'\", virtPort->profileID);\n    }\n\n    virBufferAddLit(buf, \"/>\\n\");\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</virtualport>\\n\");\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVlanFormat",
          "args": [
            "&def->vlan",
            "buf"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVlanFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_vlan_conf.c",
          "lines": "140-174",
          "snippet": "int\nvirNetDevVlanFormat(const virNetDevVlan *def, virBufferPtr buf)\n{\n    size_t i;\n\n    if (!(def && def->nTags))\n        return 0;\n\n    if (!def->tag) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing vlan tag data\"));\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<vlan%s>\\n\", def->trunk ? \" trunk='yes'\" : \"\");\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < def->nTags; i++) {\n        if (def->nativeMode != VIR_NATIVE_VLAN_MODE_DEFAULT &&\n            def->nativeTag == def->tag[i]) {\n            /* check the nativeMode in case we get <tag id='0'/>*/\n            const char *mode = virNativeVlanModeTypeToString(def->nativeMode);\n            if (!mode) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Bad value for nativeMode\"));\n            }\n            virBufferAsprintf(buf, \"<tag id='%u' nativeMode='%s'/>\\n\",\n                              def->tag[i], mode);\n        } else {\n            virBufferAsprintf(buf, \"<tag id='%u'/>\\n\", def->tag[i]);\n        }\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</vlan>\\n\");\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_vlan_conf.h\"\n#include <config.h>\n\nint\nvirNetDevVlanFormat(const virNetDevVlan *def, virBufferPtr buf)\n{\n    size_t i;\n\n    if (!(def && def->nTags))\n        return 0;\n\n    if (!def->tag) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing vlan tag data\"));\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<vlan%s>\\n\", def->trunk ? \" trunk='yes'\" : \"\");\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < def->nTags; i++) {\n        if (def->nativeMode != VIR_NATIVE_VLAN_MODE_DEFAULT &&\n            def->nativeTag == def->tag[i]) {\n            /* check the nativeMode in case we get <tag id='0'/>*/\n            const char *mode = virNativeVlanModeTypeToString(def->nativeMode);\n            if (!mode) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Bad value for nativeMode\"));\n            }\n            virBufferAsprintf(buf, \"<tag id='%u' nativeMode='%s'/>\\n\",\n                              def->tag[i], mode);\n        } else {\n            virBufferAsprintf(buf, \"<tag id='%u'/>\\n\", def->tag[i]);\n        }\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</vlan>\\n\");\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\">\\n\""
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\" trustGuestRxFilters='%s'\"",
            "virTristateBoolTypeToString(def->trustGuestRxFilters)"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeToString",
          "args": [
            "def->trustGuestRxFilters"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" default='yes'\""
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirPortGroupDefFormat(virBufferPtr buf,\n                      const virPortGroupDef *def)\n{\n    virBufferAsprintf(buf, \"<portgroup name='%s'\", def->name);\n    if (def->isDefault)\n        virBufferAddLit(buf, \" default='yes'\");\n    if (def->trustGuestRxFilters)\n        virBufferAsprintf(buf, \" trustGuestRxFilters='%s'\",\n                          virTristateBoolTypeToString(def->trustGuestRxFilters));\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (virNetDevVlanFormat(&def->vlan, buf) < 0)\n        return -1;\n    if (virNetDevVPortProfileFormat(def->virtPortProfile, buf) < 0)\n        return -1;\n    virNetDevBandwidthFormat(def->bandwidth, 0, buf);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</portgroup>\\n\");\n    return 0;\n}"
  },
  {
    "function_name": "virNetworkPortOptionsFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2357-2364",
    "snippet": "void\nvirNetworkPortOptionsFormat(virTristateBool isolatedPort,\n                            virBufferPtr buf)\n{\n    if (isolatedPort != VIR_TRISTATE_BOOL_ABSENT)\n        virBufferAsprintf(buf, \"<port isolated='%s'/>\\n\",\n                          virTristateBoolTypeToString(isolatedPort));\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<port isolated='%s'/>\\n\"",
            "virTristateBoolTypeToString(isolatedPort)"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeToString",
          "args": [
            "isolatedPort"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetworkPortOptionsFormat(virTristateBool isolatedPort,\n                            virBufferPtr buf)\n{\n    if (isolatedPort != VIR_TRISTATE_BOOL_ABSENT)\n        virBufferAsprintf(buf, \"<port isolated='%s'/>\\n\",\n                          virTristateBoolTypeToString(isolatedPort));\n}"
  },
  {
    "function_name": "virNetworkIPDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2260-2355",
    "snippet": "static int\nvirNetworkIPDefFormat(virBufferPtr buf,\n                      const virNetworkIPDef *def)\n{\n    virBufferAddLit(buf, \"<ip\");\n\n    if (def->family)\n        virBufferAsprintf(buf, \" family='%s'\", def->family);\n    if (VIR_SOCKET_ADDR_VALID(&def->address)) {\n        char *addr = virSocketAddrFormat(&def->address);\n        if (!addr)\n            return -1;\n        virBufferAsprintf(buf, \" address='%s'\", addr);\n        VIR_FREE(addr);\n    }\n    if (VIR_SOCKET_ADDR_VALID(&def->netmask)) {\n        char *addr = virSocketAddrFormat(&def->netmask);\n        if (!addr)\n            return -1;\n        virBufferAsprintf(buf, \" netmask='%s'\", addr);\n        VIR_FREE(addr);\n    }\n    if (def->prefix > 0)\n        virBufferAsprintf(buf, \" prefix='%u'\", def->prefix);\n\n    if (def->localPTR) {\n        virBufferAsprintf(buf, \" localPtr='%s'\",\n                          virTristateBoolTypeToString(def->localPTR));\n    }\n\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (def->tftproot) {\n        virBufferEscapeString(buf, \"<tftp root='%s'/>\\n\",\n                              def->tftproot);\n    }\n    if ((def->nranges || def->nhosts)) {\n        size_t i;\n        virBufferAddLit(buf, \"<dhcp>\\n\");\n        virBufferAdjustIndent(buf, 2);\n\n        for (i = 0; i < def->nranges; i++) {\n            char *saddr = virSocketAddrFormat(&def->ranges[i].start);\n            if (!saddr)\n                return -1;\n            char *eaddr = virSocketAddrFormat(&def->ranges[i].end);\n            if (!eaddr) {\n                VIR_FREE(saddr);\n                return -1;\n            }\n            virBufferAsprintf(buf, \"<range start='%s' end='%s'/>\\n\",\n                              saddr, eaddr);\n            VIR_FREE(saddr);\n            VIR_FREE(eaddr);\n        }\n        for (i = 0; i < def->nhosts; i++) {\n            virBufferAddLit(buf, \"<host\");\n            if (def->hosts[i].mac)\n                virBufferAsprintf(buf, \" mac='%s'\", def->hosts[i].mac);\n            if (def->hosts[i].id)\n                virBufferAsprintf(buf, \" id='%s'\", def->hosts[i].id);\n            if (def->hosts[i].name)\n                virBufferAsprintf(buf, \" name='%s'\", def->hosts[i].name);\n            if (VIR_SOCKET_ADDR_VALID(&def->hosts[i].ip)) {\n                char *ipaddr = virSocketAddrFormat(&def->hosts[i].ip);\n                if (!ipaddr)\n                    return -1;\n                virBufferAsprintf(buf, \" ip='%s'\", ipaddr);\n                VIR_FREE(ipaddr);\n            }\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n        if (def->bootfile) {\n            virBufferEscapeString(buf, \"<bootp file='%s'\",\n                                  def->bootfile);\n            if (VIR_SOCKET_ADDR_VALID(&def->bootserver)) {\n                char *ipaddr = virSocketAddrFormat(&def->bootserver);\n                if (!ipaddr)\n                    return -1;\n                virBufferEscapeString(buf, \" server='%s'\", ipaddr);\n                VIR_FREE(ipaddr);\n            }\n            virBufferAddLit(buf, \"/>\\n\");\n\n        }\n\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</dhcp>\\n\");\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</ip>\\n\");\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</ip>\\n\""
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 2351
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</dhcp>\\n\""
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ipaddr"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\" server='%s'\"",
            "ipaddr"
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "&def->bootserver"
          ],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&def->bootserver"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ipaddr"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\" ip='%s'\"",
            "ipaddr"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&def->hosts[i].ip"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<host\""
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "eaddr"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "saddr"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "saddr"
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<dhcp>\\n\""
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\">\\n\""
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeToString",
          "args": [
            "def->localPTR"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addr"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&def->netmask"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addr"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&def->address"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<ip\""
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkIPDefFormat(virBufferPtr buf,\n                      const virNetworkIPDef *def)\n{\n    virBufferAddLit(buf, \"<ip\");\n\n    if (def->family)\n        virBufferAsprintf(buf, \" family='%s'\", def->family);\n    if (VIR_SOCKET_ADDR_VALID(&def->address)) {\n        char *addr = virSocketAddrFormat(&def->address);\n        if (!addr)\n            return -1;\n        virBufferAsprintf(buf, \" address='%s'\", addr);\n        VIR_FREE(addr);\n    }\n    if (VIR_SOCKET_ADDR_VALID(&def->netmask)) {\n        char *addr = virSocketAddrFormat(&def->netmask);\n        if (!addr)\n            return -1;\n        virBufferAsprintf(buf, \" netmask='%s'\", addr);\n        VIR_FREE(addr);\n    }\n    if (def->prefix > 0)\n        virBufferAsprintf(buf, \" prefix='%u'\", def->prefix);\n\n    if (def->localPTR) {\n        virBufferAsprintf(buf, \" localPtr='%s'\",\n                          virTristateBoolTypeToString(def->localPTR));\n    }\n\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (def->tftproot) {\n        virBufferEscapeString(buf, \"<tftp root='%s'/>\\n\",\n                              def->tftproot);\n    }\n    if ((def->nranges || def->nhosts)) {\n        size_t i;\n        virBufferAddLit(buf, \"<dhcp>\\n\");\n        virBufferAdjustIndent(buf, 2);\n\n        for (i = 0; i < def->nranges; i++) {\n            char *saddr = virSocketAddrFormat(&def->ranges[i].start);\n            if (!saddr)\n                return -1;\n            char *eaddr = virSocketAddrFormat(&def->ranges[i].end);\n            if (!eaddr) {\n                VIR_FREE(saddr);\n                return -1;\n            }\n            virBufferAsprintf(buf, \"<range start='%s' end='%s'/>\\n\",\n                              saddr, eaddr);\n            VIR_FREE(saddr);\n            VIR_FREE(eaddr);\n        }\n        for (i = 0; i < def->nhosts; i++) {\n            virBufferAddLit(buf, \"<host\");\n            if (def->hosts[i].mac)\n                virBufferAsprintf(buf, \" mac='%s'\", def->hosts[i].mac);\n            if (def->hosts[i].id)\n                virBufferAsprintf(buf, \" id='%s'\", def->hosts[i].id);\n            if (def->hosts[i].name)\n                virBufferAsprintf(buf, \" name='%s'\", def->hosts[i].name);\n            if (VIR_SOCKET_ADDR_VALID(&def->hosts[i].ip)) {\n                char *ipaddr = virSocketAddrFormat(&def->hosts[i].ip);\n                if (!ipaddr)\n                    return -1;\n                virBufferAsprintf(buf, \" ip='%s'\", ipaddr);\n                VIR_FREE(ipaddr);\n            }\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n        if (def->bootfile) {\n            virBufferEscapeString(buf, \"<bootp file='%s'\",\n                                  def->bootfile);\n            if (VIR_SOCKET_ADDR_VALID(&def->bootserver)) {\n                char *ipaddr = virSocketAddrFormat(&def->bootserver);\n                if (!ipaddr)\n                    return -1;\n                virBufferEscapeString(buf, \" server='%s'\", ipaddr);\n                VIR_FREE(ipaddr);\n            }\n            virBufferAddLit(buf, \"/>\\n\");\n\n        }\n\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</dhcp>\\n\");\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</ip>\\n\");\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetworkDNSDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2153-2257",
    "snippet": "static int\nvirNetworkDNSDefFormat(virBufferPtr buf,\n                       const virNetworkDNSDef *def)\n{\n    size_t i, j;\n\n    if (!(def->enable || def->forwardPlainNames || def->nfwds || def->nhosts ||\n          def->nsrvs || def->ntxts))\n        return 0;\n\n    virBufferAddLit(buf, \"<dns\");\n    if (def->enable) {\n        const char *fwd = virTristateBoolTypeToString(def->enable);\n\n        if (!fwd) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown enable type %d in network\"),\n                           def->enable);\n            return -1;\n        }\n        virBufferAsprintf(buf, \" enable='%s'\", fwd);\n    }\n    if (def->forwardPlainNames) {\n        const char *fwd = virTristateBoolTypeToString(def->forwardPlainNames);\n\n        if (!fwd) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown forwardPlainNames type %d in network\"),\n                           def->forwardPlainNames);\n            return -1;\n        }\n        virBufferAsprintf(buf, \" forwardPlainNames='%s'\", fwd);\n    }\n    if (!(def->nfwds || def->nhosts || def->nsrvs || def->ntxts)) {\n        virBufferAddLit(buf, \"/>\\n\");\n        return 0;\n    }\n\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < def->nfwds; i++) {\n\n        virBufferAddLit(buf, \"<forwarder\");\n        if (def->forwarders[i].domain) {\n            virBufferEscapeString(buf, \" domain='%s'\",\n                                  def->forwarders[i].domain);\n        }\n        if (VIR_SOCKET_ADDR_VALID(&def->forwarders[i].addr)) {\n        char *addr = virSocketAddrFormat(&def->forwarders[i].addr);\n\n        if (!addr)\n            return -1;\n\n        virBufferAsprintf(buf, \" addr='%s'\", addr);\n        VIR_FREE(addr);\n        }\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    for (i = 0; i < def->ntxts; i++) {\n        virBufferEscapeString(buf, \"<txt name='%s' \", def->txts[i].name);\n        virBufferEscapeString(buf, \"value='%s'/>\\n\", def->txts[i].value);\n    }\n\n    for (i = 0; i < def->nsrvs; i++) {\n        if (def->srvs[i].service && def->srvs[i].protocol) {\n            virBufferEscapeString(buf, \"<srv service='%s' \",\n                                  def->srvs[i].service);\n            virBufferEscapeString(buf, \"protocol='%s'\", def->srvs[i].protocol);\n\n            if (def->srvs[i].domain)\n                virBufferEscapeString(buf, \" domain='%s'\", def->srvs[i].domain);\n            if (def->srvs[i].target)\n                virBufferEscapeString(buf, \" target='%s'\", def->srvs[i].target);\n            if (def->srvs[i].port)\n                virBufferAsprintf(buf, \" port='%d'\", def->srvs[i].port);\n            if (def->srvs[i].priority)\n                virBufferAsprintf(buf, \" priority='%d'\", def->srvs[i].priority);\n            if (def->srvs[i].weight)\n                virBufferAsprintf(buf, \" weight='%d'\", def->srvs[i].weight);\n\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n\n    if (def->nhosts) {\n        for (i = 0; i < def->nhosts; i++) {\n            char *ip = virSocketAddrFormat(&def->hosts[i].ip);\n\n            virBufferAsprintf(buf, \"<host ip='%s'>\\n\", ip);\n            virBufferAdjustIndent(buf, 2);\n            for (j = 0; j < def->hosts[i].nnames; j++)\n                virBufferEscapeString(buf, \"<hostname>%s</hostname>\\n\",\n                                      def->hosts[i].names[j]);\n\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</host>\\n\");\n            VIR_FREE(ip);\n        }\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</dns>\\n\");\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</dns>\\n\""
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 2254
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ip"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</host>\\n\""
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<hostname>%s</hostname>\\n\"",
            "def->hosts[i].names[j]"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<host ip='%s'>\\n\"",
            "ip"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "&def->hosts[i].ip"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addr"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&def->forwarders[i].addr"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<forwarder\""
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\">\\n\""
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown forwardPlainNames type %d in network\")",
            "def->forwardPlainNames"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown forwardPlainNames type %d in network\""
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeToString",
          "args": [
            "def->forwardPlainNames"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown enable type %d in network\")",
            "def->enable"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeToString",
          "args": [
            "def->enable"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<dns\""
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDNSDefFormat(virBufferPtr buf,\n                       const virNetworkDNSDef *def)\n{\n    size_t i, j;\n\n    if (!(def->enable || def->forwardPlainNames || def->nfwds || def->nhosts ||\n          def->nsrvs || def->ntxts))\n        return 0;\n\n    virBufferAddLit(buf, \"<dns\");\n    if (def->enable) {\n        const char *fwd = virTristateBoolTypeToString(def->enable);\n\n        if (!fwd) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown enable type %d in network\"),\n                           def->enable);\n            return -1;\n        }\n        virBufferAsprintf(buf, \" enable='%s'\", fwd);\n    }\n    if (def->forwardPlainNames) {\n        const char *fwd = virTristateBoolTypeToString(def->forwardPlainNames);\n\n        if (!fwd) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown forwardPlainNames type %d in network\"),\n                           def->forwardPlainNames);\n            return -1;\n        }\n        virBufferAsprintf(buf, \" forwardPlainNames='%s'\", fwd);\n    }\n    if (!(def->nfwds || def->nhosts || def->nsrvs || def->ntxts)) {\n        virBufferAddLit(buf, \"/>\\n\");\n        return 0;\n    }\n\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < def->nfwds; i++) {\n\n        virBufferAddLit(buf, \"<forwarder\");\n        if (def->forwarders[i].domain) {\n            virBufferEscapeString(buf, \" domain='%s'\",\n                                  def->forwarders[i].domain);\n        }\n        if (VIR_SOCKET_ADDR_VALID(&def->forwarders[i].addr)) {\n        char *addr = virSocketAddrFormat(&def->forwarders[i].addr);\n\n        if (!addr)\n            return -1;\n\n        virBufferAsprintf(buf, \" addr='%s'\", addr);\n        VIR_FREE(addr);\n        }\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    for (i = 0; i < def->ntxts; i++) {\n        virBufferEscapeString(buf, \"<txt name='%s' \", def->txts[i].name);\n        virBufferEscapeString(buf, \"value='%s'/>\\n\", def->txts[i].value);\n    }\n\n    for (i = 0; i < def->nsrvs; i++) {\n        if (def->srvs[i].service && def->srvs[i].protocol) {\n            virBufferEscapeString(buf, \"<srv service='%s' \",\n                                  def->srvs[i].service);\n            virBufferEscapeString(buf, \"protocol='%s'\", def->srvs[i].protocol);\n\n            if (def->srvs[i].domain)\n                virBufferEscapeString(buf, \" domain='%s'\", def->srvs[i].domain);\n            if (def->srvs[i].target)\n                virBufferEscapeString(buf, \" target='%s'\", def->srvs[i].target);\n            if (def->srvs[i].port)\n                virBufferAsprintf(buf, \" port='%d'\", def->srvs[i].port);\n            if (def->srvs[i].priority)\n                virBufferAsprintf(buf, \" priority='%d'\", def->srvs[i].priority);\n            if (def->srvs[i].weight)\n                virBufferAsprintf(buf, \" weight='%d'\", def->srvs[i].weight);\n\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n\n    if (def->nhosts) {\n        for (i = 0; i < def->nhosts; i++) {\n            char *ip = virSocketAddrFormat(&def->hosts[i].ip);\n\n            virBufferAsprintf(buf, \"<host ip='%s'>\\n\", ip);\n            virBufferAdjustIndent(buf, 2);\n            for (j = 0; j < def->hosts[i].nnames; j++)\n                virBufferEscapeString(buf, \"<hostname>%s</hostname>\\n\",\n                                      def->hosts[i].names[j]);\n\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</host>\\n\");\n            VIR_FREE(ip);\n        }\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</dns>\\n\");\n    return 0;\n}"
  },
  {
    "function_name": "virNetworkDefParseNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2130-2150",
    "snippet": "virNetworkDefPtr\nvirNetworkDefParseNode(xmlDocPtr xml,\n                       xmlNodePtr root,\n                       virNetworkXMLOptionPtr xmlopt)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"network\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <network>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virNetworkDefParseXML(ctxt, xmlopt);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkDefParseXML",
          "args": [
            "ctxt",
            "xmlopt"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "1645-2092",
          "snippet": "virNetworkDefPtr\nvirNetworkDefParseXML(xmlXPathContextPtr ctxt,\n                      virNetworkXMLOptionPtr xmlopt)\n{\n    virNetworkDefPtr def;\n    char *tmp = NULL;\n    char *stp = NULL;\n    xmlNodePtr *ipNodes = NULL;\n    xmlNodePtr *routeNodes = NULL;\n    xmlNodePtr *portGroupNodes = NULL;\n    int nips, nPortGroups, nRoutes;\n    xmlNodePtr dnsNode = NULL;\n    xmlNodePtr virtPortNode = NULL;\n    xmlNodePtr forwardNode = NULL;\n    char *ipv6nogwStr = NULL;\n    char *trustGuestRxFilters = NULL;\n    xmlNodePtr save = ctxt->node;\n    xmlNodePtr bandwidthNode = NULL;\n    xmlNodePtr vlanNode;\n    xmlNodePtr metadataNode = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    /* Extract network name */\n    def->name = virXPathString(\"string(./name[1])\", ctxt);\n    if (!def->name) {\n        virReportError(VIR_ERR_NO_NAME, NULL);\n        goto error;\n    }\n\n    if (virXMLCheckIllegalChars(\"name\", def->name, \"/\") < 0)\n        goto error;\n\n    /* Extract network uuid */\n    tmp = virXPathString(\"string(./uuid[1])\", ctxt);\n    if (!tmp) {\n        if (virUUIDGenerate(def->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"Failed to generate UUID\"));\n            goto error;\n        }\n    } else {\n        if (virUUIDParse(tmp, def->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"malformed uuid element\"));\n            goto error;\n        }\n        VIR_FREE(tmp);\n        def->uuid_specified = true;\n    }\n\n    /* check if definitions with no IPv6 gateway addresses is to\n     * allow guest-to-guest communications.\n     */\n    ipv6nogwStr = virXPathString(\"string(./@ipv6)\", ctxt);\n    if (ipv6nogwStr) {\n        if (virStringParseYesNo(ipv6nogwStr, &def->ipv6nogw) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid ipv6 setting '%s' in network '%s'\"),\n                           ipv6nogwStr, def->name);\n            goto error;\n        }\n        VIR_FREE(ipv6nogwStr);\n    }\n\n    trustGuestRxFilters\n        = virXPathString(\"string(./@trustGuestRxFilters)\", ctxt);\n    if (trustGuestRxFilters) {\n        if ((def->trustGuestRxFilters\n             = virTristateBoolTypeFromString(trustGuestRxFilters)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid trustGuestRxFilters setting '%s' \"\n                             \"in network '%s'\"),\n                           trustGuestRxFilters, def->name);\n            goto error;\n        }\n        VIR_FREE(trustGuestRxFilters);\n    }\n\n    /* Parse network domain information */\n    def->domain = virXPathString(\"string(./domain[1]/@name)\", ctxt);\n    tmp = virXPathString(\"string(./domain[1]/@localOnly)\", ctxt);\n    if (tmp) {\n        def->domainLocalOnly = virTristateBoolTypeFromString(tmp);\n        if (def->domainLocalOnly <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid domain localOnly setting '%s' \"\n                             \"in network '%s'\"),\n                           tmp, def->name);\n            goto error;\n        }\n        VIR_FREE(tmp);\n    }\n\n    if ((bandwidthNode = virXPathNode(\"./bandwidth\", ctxt)) &&\n        virNetDevBandwidthParse(&def->bandwidth, NULL, bandwidthNode, false) < 0)\n        goto error;\n\n    vlanNode = virXPathNode(\"./vlan\", ctxt);\n    if (vlanNode && virNetDevVlanParse(vlanNode, ctxt, &def->vlan) < 0)\n        goto error;\n\n    if (virNetworkPortOptionsParseXML(ctxt, &def->isolatedPort) < 0)\n        goto error;\n\n    /* Parse bridge information */\n    def->bridge = virXPathString(\"string(./bridge[1]/@name)\", ctxt);\n    def->bridgeZone = virXPathString(\"string(./bridge[1]/@zone)\", ctxt);\n    stp = virXPathString(\"string(./bridge[1]/@stp)\", ctxt);\n    def->stp = (stp && STREQ(stp, \"off\")) ? false : true;\n\n    tmp = virXPathString(\"string(./bridge[1]/@delay)\", ctxt);\n    if (tmp) {\n        if (virStrToLong_ulp(tmp, NULL, 10, &def->delay) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid delay value in network '%s'\"),\n                           def->name);\n            goto error;\n        }\n    }\n    VIR_FREE(tmp);\n\n    tmp = virXPathString(\"string(./bridge[1]/@macTableManager)\", ctxt);\n    if (tmp) {\n        if ((def->macTableManager\n             = virNetworkBridgeMACTableManagerTypeFromString(tmp)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid macTableManager setting '%s' \"\n                             \"in network '%s'\"), tmp, def->name);\n            goto error;\n        }\n        VIR_FREE(tmp);\n    }\n\n    tmp = virXPathString(\"string(./mac[1]/@address)\", ctxt);\n    if (tmp) {\n        if (virMacAddrParse(tmp, &def->mac) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid bridge mac address '%s' in network '%s'\"),\n                           tmp, def->name);\n            goto error;\n        }\n        if (virMacAddrIsMulticast(&def->mac)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid multicast bridge mac address '%s' in network '%s'\"),\n                           tmp, def->name);\n            goto error;\n        }\n        VIR_FREE(tmp);\n        def->mac_specified = true;\n    }\n\n    tmp = virXPathString(\"string(./mtu/@size)\", ctxt);\n    if (tmp) {\n        if (virStrToLong_ui(tmp, NULL, 10, &def->mtu) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid mtu size '%s' in network '%s'\"),\n                           tmp, def->name);\n            goto error;\n        }\n    }\n    VIR_FREE(tmp);\n\n    dnsNode = virXPathNode(\"./dns\", ctxt);\n    if (dnsNode != NULL &&\n        virNetworkDNSDefParseXML(def->name, dnsNode, ctxt, &def->dns) < 0) {\n        goto error;\n    }\n\n    virtPortNode = virXPathNode(\"./virtualport\", ctxt);\n    if (virtPortNode &&\n        (!(def->virtPortProfile = virNetDevVPortProfileParse(virtPortNode,\n                                                             VIR_VPORT_XML_REQUIRE_TYPE)))) {\n        goto error;\n    }\n\n    nPortGroups = virXPathNodeSet(\"./portgroup\", ctxt, &portGroupNodes);\n    if (nPortGroups < 0)\n        goto error;\n\n    if (nPortGroups > 0) {\n        size_t i;\n\n        /* allocate array to hold all the portgroups */\n        if (VIR_ALLOC_N(def->portGroups, nPortGroups) < 0)\n            goto error;\n        /* parse each portgroup */\n        for (i = 0; i < nPortGroups; i++) {\n            if (virNetworkPortGroupParseXML(&def->portGroups[i],\n                                            portGroupNodes[i],\n                                            ctxt) < 0)\n                goto error;\n            def->nPortGroups++;\n        }\n    }\n    VIR_FREE(portGroupNodes);\n\n    nips = virXPathNodeSet(\"./ip\", ctxt, &ipNodes);\n    if (nips < 0)\n        goto error;\n\n    if (nips > 0) {\n        size_t i;\n\n        /* allocate array to hold all the addrs */\n        if (VIR_ALLOC_N(def->ips, nips) < 0)\n            goto error;\n        /* parse each addr */\n        for (i = 0; i < nips; i++) {\n            if (virNetworkIPDefParseXML(def->name,\n                                        ipNodes[i],\n                                        ctxt,\n                                        &def->ips[i]) < 0)\n                goto error;\n            def->nips++;\n        }\n    }\n    VIR_FREE(ipNodes);\n\n    nRoutes = virXPathNodeSet(\"./route\", ctxt, &routeNodes);\n    if (nRoutes < 0)\n        goto error;\n\n    if (nRoutes > 0) {\n        size_t i;\n\n        /* allocate array to hold all the route definitions */\n        if (VIR_ALLOC_N(def->routes, nRoutes) < 0)\n            goto error;\n        /* parse each definition */\n        for (i = 0; i < nRoutes; i++) {\n            virNetDevIPRoutePtr route = NULL;\n\n            if (!(route = virNetDevIPRouteParseXML(def->name,\n                                                   routeNodes[i],\n                                                   ctxt)))\n                goto error;\n            def->routes[i] = route;\n            def->nroutes++;\n        }\n\n        /* now validate the correctness of any static route gateways specified\n         *\n         * note: the parameters within each definition are verified/assumed valid;\n         * the question being asked and answered here is if the specified gateway\n         * is directly reachable from this bridge.\n         */\n        nRoutes = def->nroutes;\n        nips = def->nips;\n        for (i = 0; i < nRoutes; i++) {\n            size_t j;\n            virSocketAddr testAddr, testGw;\n            bool addrMatch;\n            virNetDevIPRoutePtr gwdef = def->routes[i];\n            virSocketAddrPtr gateway = virNetDevIPRouteGetGateway(gwdef);\n            addrMatch = false;\n            for (j = 0; j < nips; j++) {\n                virNetworkIPDefPtr def2 = &def->ips[j];\n                if (VIR_SOCKET_ADDR_FAMILY(gateway)\n                    != VIR_SOCKET_ADDR_FAMILY(&def2->address)) {\n                    continue;\n                }\n                int prefix = virNetworkIPDefPrefix(def2);\n                virSocketAddrMaskByPrefix(&def2->address, prefix, &testAddr);\n                virSocketAddrMaskByPrefix(gateway, prefix, &testGw);\n                if (VIR_SOCKET_ADDR_VALID(&testAddr) &&\n                    VIR_SOCKET_ADDR_VALID(&testGw) &&\n                    virSocketAddrEqual(&testAddr, &testGw)) {\n                    addrMatch = true;\n                    break;\n                }\n            }\n            if (!addrMatch) {\n                char *gw = virSocketAddrFormat(gateway);\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unreachable static route gateway '%s' specified for network '%s'\"),\n                               gw, def->name);\n                VIR_FREE(gw);\n                goto error;\n            }\n        }\n    }\n    VIR_FREE(routeNodes);\n\n    forwardNode = virXPathNode(\"./forward\", ctxt);\n    if (forwardNode &&\n        virNetworkForwardDefParseXML(def->name, forwardNode, ctxt, &def->forward) < 0) {\n        goto error;\n    }\n\n    /* Validate some items in the main NetworkDef that need to align\n     * with the chosen forward mode.\n     */\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n        break;\n\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_OPEN:\n        /* It's pointless to specify L3 forwarding without specifying\n         * the network we're on.\n         */\n        if (def->nips == 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"%s forwarding requested, \"\n                             \"but no IP address provided for network '%s'\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        if (def->forward.nifs > 1) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"multiple forwarding interfaces specified \"\n                             \"for network '%s', only one is supported\"),\n                           def->name);\n            goto error;\n        }\n\n        if (def->forward.type == VIR_NETWORK_FORWARD_OPEN && def->forward.nifs) {\n            /* an open network by definition can't place any restrictions\n             * on what traffic is allowed or where it goes, so specifying\n             * a forwarding device is nonsensical.\n             */\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"forward dev not allowed for \"\n                             \"network '%s' with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            goto error;\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        if (def->bridge) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge name not allowed in %s mode (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        if (def->bridgeZone) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge zone not allowed in %s mode (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        if (def->macTableManager) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge macTableManager setting not allowed \"\n                             \"in %s mode (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->delay || stp || def->bridgeZone) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge delay/stp/zone options only allowed in \"\n                             \"route, nat, and isolated mode, not in %s \"\n                             \"(network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        if (def->bridge && (def->forward.nifs || def->forward.npfs)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"A network with forward mode='%s' can specify \"\n                             \"a bridge name or a forward dev, but not \"\n                             \"both (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        goto error;\n    }\n\n    VIR_FREE(stp);\n\n    if (def->mtu) {\n        switch ((virNetworkForwardType) def->forward.type) {\n        case VIR_NETWORK_FORWARD_NONE:\n        case VIR_NETWORK_FORWARD_NAT:\n        case VIR_NETWORK_FORWARD_ROUTE:\n        case VIR_NETWORK_FORWARD_OPEN:\n            break;\n\n        case VIR_NETWORK_FORWARD_BRIDGE:\n        case VIR_NETWORK_FORWARD_PRIVATE:\n        case VIR_NETWORK_FORWARD_VEPA:\n        case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        case VIR_NETWORK_FORWARD_HOSTDEV:\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"mtu size only allowed in open, route, nat, \"\n                             \"and isolated mode, not in %s (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n\n        case VIR_NETWORK_FORWARD_LAST:\n        default:\n            virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n            goto error;\n        }\n    }\n\n    /* Extract custom metadata */\n    if ((metadataNode = virXPathNode(\"./metadata[1]\", ctxt)) != NULL) {\n        def->metadata = xmlCopyNode(metadataNode, 1);\n        virXMLNodeSanitizeNamespaces(def->metadata);\n    }\n\n    if (xmlopt)\n        def->ns = xmlopt->ns;\n    if (def->ns.parse) {\n        if (virXMLNamespaceRegister(ctxt, &def->ns) < 0)\n            goto error;\n        if ((def->ns.parse)(ctxt, &def->namespaceData) < 0)\n            goto error;\n    }\n\n    ctxt->node = save;\n    return def;\n\n error:\n    VIR_FREE(tmp);\n    VIR_FREE(routeNodes);\n    VIR_FREE(stp);\n    virNetworkDefFree(def);\n    VIR_FREE(ipNodes);\n    VIR_FREE(portGroupNodes);\n    VIR_FREE(ipv6nogwStr);\n    VIR_FREE(trustGuestRxFilters);\n    ctxt->node = save;\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkDefPtr\nvirNetworkDefParseXML(xmlXPathContextPtr ctxt,\n                      virNetworkXMLOptionPtr xmlopt)\n{\n    virNetworkDefPtr def;\n    char *tmp = NULL;\n    char *stp = NULL;\n    xmlNodePtr *ipNodes = NULL;\n    xmlNodePtr *routeNodes = NULL;\n    xmlNodePtr *portGroupNodes = NULL;\n    int nips, nPortGroups, nRoutes;\n    xmlNodePtr dnsNode = NULL;\n    xmlNodePtr virtPortNode = NULL;\n    xmlNodePtr forwardNode = NULL;\n    char *ipv6nogwStr = NULL;\n    char *trustGuestRxFilters = NULL;\n    xmlNodePtr save = ctxt->node;\n    xmlNodePtr bandwidthNode = NULL;\n    xmlNodePtr vlanNode;\n    xmlNodePtr metadataNode = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    /* Extract network name */\n    def->name = virXPathString(\"string(./name[1])\", ctxt);\n    if (!def->name) {\n        virReportError(VIR_ERR_NO_NAME, NULL);\n        goto error;\n    }\n\n    if (virXMLCheckIllegalChars(\"name\", def->name, \"/\") < 0)\n        goto error;\n\n    /* Extract network uuid */\n    tmp = virXPathString(\"string(./uuid[1])\", ctxt);\n    if (!tmp) {\n        if (virUUIDGenerate(def->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"Failed to generate UUID\"));\n            goto error;\n        }\n    } else {\n        if (virUUIDParse(tmp, def->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"malformed uuid element\"));\n            goto error;\n        }\n        VIR_FREE(tmp);\n        def->uuid_specified = true;\n    }\n\n    /* check if definitions with no IPv6 gateway addresses is to\n     * allow guest-to-guest communications.\n     */\n    ipv6nogwStr = virXPathString(\"string(./@ipv6)\", ctxt);\n    if (ipv6nogwStr) {\n        if (virStringParseYesNo(ipv6nogwStr, &def->ipv6nogw) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid ipv6 setting '%s' in network '%s'\"),\n                           ipv6nogwStr, def->name);\n            goto error;\n        }\n        VIR_FREE(ipv6nogwStr);\n    }\n\n    trustGuestRxFilters\n        = virXPathString(\"string(./@trustGuestRxFilters)\", ctxt);\n    if (trustGuestRxFilters) {\n        if ((def->trustGuestRxFilters\n             = virTristateBoolTypeFromString(trustGuestRxFilters)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid trustGuestRxFilters setting '%s' \"\n                             \"in network '%s'\"),\n                           trustGuestRxFilters, def->name);\n            goto error;\n        }\n        VIR_FREE(trustGuestRxFilters);\n    }\n\n    /* Parse network domain information */\n    def->domain = virXPathString(\"string(./domain[1]/@name)\", ctxt);\n    tmp = virXPathString(\"string(./domain[1]/@localOnly)\", ctxt);\n    if (tmp) {\n        def->domainLocalOnly = virTristateBoolTypeFromString(tmp);\n        if (def->domainLocalOnly <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid domain localOnly setting '%s' \"\n                             \"in network '%s'\"),\n                           tmp, def->name);\n            goto error;\n        }\n        VIR_FREE(tmp);\n    }\n\n    if ((bandwidthNode = virXPathNode(\"./bandwidth\", ctxt)) &&\n        virNetDevBandwidthParse(&def->bandwidth, NULL, bandwidthNode, false) < 0)\n        goto error;\n\n    vlanNode = virXPathNode(\"./vlan\", ctxt);\n    if (vlanNode && virNetDevVlanParse(vlanNode, ctxt, &def->vlan) < 0)\n        goto error;\n\n    if (virNetworkPortOptionsParseXML(ctxt, &def->isolatedPort) < 0)\n        goto error;\n\n    /* Parse bridge information */\n    def->bridge = virXPathString(\"string(./bridge[1]/@name)\", ctxt);\n    def->bridgeZone = virXPathString(\"string(./bridge[1]/@zone)\", ctxt);\n    stp = virXPathString(\"string(./bridge[1]/@stp)\", ctxt);\n    def->stp = (stp && STREQ(stp, \"off\")) ? false : true;\n\n    tmp = virXPathString(\"string(./bridge[1]/@delay)\", ctxt);\n    if (tmp) {\n        if (virStrToLong_ulp(tmp, NULL, 10, &def->delay) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid delay value in network '%s'\"),\n                           def->name);\n            goto error;\n        }\n    }\n    VIR_FREE(tmp);\n\n    tmp = virXPathString(\"string(./bridge[1]/@macTableManager)\", ctxt);\n    if (tmp) {\n        if ((def->macTableManager\n             = virNetworkBridgeMACTableManagerTypeFromString(tmp)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid macTableManager setting '%s' \"\n                             \"in network '%s'\"), tmp, def->name);\n            goto error;\n        }\n        VIR_FREE(tmp);\n    }\n\n    tmp = virXPathString(\"string(./mac[1]/@address)\", ctxt);\n    if (tmp) {\n        if (virMacAddrParse(tmp, &def->mac) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid bridge mac address '%s' in network '%s'\"),\n                           tmp, def->name);\n            goto error;\n        }\n        if (virMacAddrIsMulticast(&def->mac)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid multicast bridge mac address '%s' in network '%s'\"),\n                           tmp, def->name);\n            goto error;\n        }\n        VIR_FREE(tmp);\n        def->mac_specified = true;\n    }\n\n    tmp = virXPathString(\"string(./mtu/@size)\", ctxt);\n    if (tmp) {\n        if (virStrToLong_ui(tmp, NULL, 10, &def->mtu) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid mtu size '%s' in network '%s'\"),\n                           tmp, def->name);\n            goto error;\n        }\n    }\n    VIR_FREE(tmp);\n\n    dnsNode = virXPathNode(\"./dns\", ctxt);\n    if (dnsNode != NULL &&\n        virNetworkDNSDefParseXML(def->name, dnsNode, ctxt, &def->dns) < 0) {\n        goto error;\n    }\n\n    virtPortNode = virXPathNode(\"./virtualport\", ctxt);\n    if (virtPortNode &&\n        (!(def->virtPortProfile = virNetDevVPortProfileParse(virtPortNode,\n                                                             VIR_VPORT_XML_REQUIRE_TYPE)))) {\n        goto error;\n    }\n\n    nPortGroups = virXPathNodeSet(\"./portgroup\", ctxt, &portGroupNodes);\n    if (nPortGroups < 0)\n        goto error;\n\n    if (nPortGroups > 0) {\n        size_t i;\n\n        /* allocate array to hold all the portgroups */\n        if (VIR_ALLOC_N(def->portGroups, nPortGroups) < 0)\n            goto error;\n        /* parse each portgroup */\n        for (i = 0; i < nPortGroups; i++) {\n            if (virNetworkPortGroupParseXML(&def->portGroups[i],\n                                            portGroupNodes[i],\n                                            ctxt) < 0)\n                goto error;\n            def->nPortGroups++;\n        }\n    }\n    VIR_FREE(portGroupNodes);\n\n    nips = virXPathNodeSet(\"./ip\", ctxt, &ipNodes);\n    if (nips < 0)\n        goto error;\n\n    if (nips > 0) {\n        size_t i;\n\n        /* allocate array to hold all the addrs */\n        if (VIR_ALLOC_N(def->ips, nips) < 0)\n            goto error;\n        /* parse each addr */\n        for (i = 0; i < nips; i++) {\n            if (virNetworkIPDefParseXML(def->name,\n                                        ipNodes[i],\n                                        ctxt,\n                                        &def->ips[i]) < 0)\n                goto error;\n            def->nips++;\n        }\n    }\n    VIR_FREE(ipNodes);\n\n    nRoutes = virXPathNodeSet(\"./route\", ctxt, &routeNodes);\n    if (nRoutes < 0)\n        goto error;\n\n    if (nRoutes > 0) {\n        size_t i;\n\n        /* allocate array to hold all the route definitions */\n        if (VIR_ALLOC_N(def->routes, nRoutes) < 0)\n            goto error;\n        /* parse each definition */\n        for (i = 0; i < nRoutes; i++) {\n            virNetDevIPRoutePtr route = NULL;\n\n            if (!(route = virNetDevIPRouteParseXML(def->name,\n                                                   routeNodes[i],\n                                                   ctxt)))\n                goto error;\n            def->routes[i] = route;\n            def->nroutes++;\n        }\n\n        /* now validate the correctness of any static route gateways specified\n         *\n         * note: the parameters within each definition are verified/assumed valid;\n         * the question being asked and answered here is if the specified gateway\n         * is directly reachable from this bridge.\n         */\n        nRoutes = def->nroutes;\n        nips = def->nips;\n        for (i = 0; i < nRoutes; i++) {\n            size_t j;\n            virSocketAddr testAddr, testGw;\n            bool addrMatch;\n            virNetDevIPRoutePtr gwdef = def->routes[i];\n            virSocketAddrPtr gateway = virNetDevIPRouteGetGateway(gwdef);\n            addrMatch = false;\n            for (j = 0; j < nips; j++) {\n                virNetworkIPDefPtr def2 = &def->ips[j];\n                if (VIR_SOCKET_ADDR_FAMILY(gateway)\n                    != VIR_SOCKET_ADDR_FAMILY(&def2->address)) {\n                    continue;\n                }\n                int prefix = virNetworkIPDefPrefix(def2);\n                virSocketAddrMaskByPrefix(&def2->address, prefix, &testAddr);\n                virSocketAddrMaskByPrefix(gateway, prefix, &testGw);\n                if (VIR_SOCKET_ADDR_VALID(&testAddr) &&\n                    VIR_SOCKET_ADDR_VALID(&testGw) &&\n                    virSocketAddrEqual(&testAddr, &testGw)) {\n                    addrMatch = true;\n                    break;\n                }\n            }\n            if (!addrMatch) {\n                char *gw = virSocketAddrFormat(gateway);\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unreachable static route gateway '%s' specified for network '%s'\"),\n                               gw, def->name);\n                VIR_FREE(gw);\n                goto error;\n            }\n        }\n    }\n    VIR_FREE(routeNodes);\n\n    forwardNode = virXPathNode(\"./forward\", ctxt);\n    if (forwardNode &&\n        virNetworkForwardDefParseXML(def->name, forwardNode, ctxt, &def->forward) < 0) {\n        goto error;\n    }\n\n    /* Validate some items in the main NetworkDef that need to align\n     * with the chosen forward mode.\n     */\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n        break;\n\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_OPEN:\n        /* It's pointless to specify L3 forwarding without specifying\n         * the network we're on.\n         */\n        if (def->nips == 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"%s forwarding requested, \"\n                             \"but no IP address provided for network '%s'\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        if (def->forward.nifs > 1) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"multiple forwarding interfaces specified \"\n                             \"for network '%s', only one is supported\"),\n                           def->name);\n            goto error;\n        }\n\n        if (def->forward.type == VIR_NETWORK_FORWARD_OPEN && def->forward.nifs) {\n            /* an open network by definition can't place any restrictions\n             * on what traffic is allowed or where it goes, so specifying\n             * a forwarding device is nonsensical.\n             */\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"forward dev not allowed for \"\n                             \"network '%s' with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            goto error;\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        if (def->bridge) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge name not allowed in %s mode (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        if (def->bridgeZone) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge zone not allowed in %s mode (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        if (def->macTableManager) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge macTableManager setting not allowed \"\n                             \"in %s mode (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->delay || stp || def->bridgeZone) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge delay/stp/zone options only allowed in \"\n                             \"route, nat, and isolated mode, not in %s \"\n                             \"(network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        if (def->bridge && (def->forward.nifs || def->forward.npfs)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"A network with forward mode='%s' can specify \"\n                             \"a bridge name or a forward dev, but not \"\n                             \"both (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        goto error;\n    }\n\n    VIR_FREE(stp);\n\n    if (def->mtu) {\n        switch ((virNetworkForwardType) def->forward.type) {\n        case VIR_NETWORK_FORWARD_NONE:\n        case VIR_NETWORK_FORWARD_NAT:\n        case VIR_NETWORK_FORWARD_ROUTE:\n        case VIR_NETWORK_FORWARD_OPEN:\n            break;\n\n        case VIR_NETWORK_FORWARD_BRIDGE:\n        case VIR_NETWORK_FORWARD_PRIVATE:\n        case VIR_NETWORK_FORWARD_VEPA:\n        case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        case VIR_NETWORK_FORWARD_HOSTDEV:\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"mtu size only allowed in open, route, nat, \"\n                             \"and isolated mode, not in %s (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n\n        case VIR_NETWORK_FORWARD_LAST:\n        default:\n            virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n            goto error;\n        }\n    }\n\n    /* Extract custom metadata */\n    if ((metadataNode = virXPathNode(\"./metadata[1]\", ctxt)) != NULL) {\n        def->metadata = xmlCopyNode(metadataNode, 1);\n        virXMLNodeSanitizeNamespaces(def->metadata);\n    }\n\n    if (xmlopt)\n        def->ns = xmlopt->ns;\n    if (def->ns.parse) {\n        if (virXMLNamespaceRegister(ctxt, &def->ns) < 0)\n            goto error;\n        if ((def->ns.parse)(ctxt, &def->namespaceData) < 0)\n            goto error;\n    }\n\n    ctxt->node = save;\n    return def;\n\n error:\n    VIR_FREE(tmp);\n    VIR_FREE(routeNodes);\n    VIR_FREE(stp);\n    virNetworkDefFree(def);\n    VIR_FREE(ipNodes);\n    VIR_FREE(portGroupNodes);\n    VIR_FREE(ipv6nogwStr);\n    VIR_FREE(trustGuestRxFilters);\n    ctxt->node = save;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLXPathContextNew",
          "args": [
            "xml"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLXPathContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "48-59",
          "snippet": "xmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unexpected root element <%s>, \"\n                         \"expecting <network>\")",
            "root->name"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unexpected root element <%s>, \"\n                         \"expecting <network>\""
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLNodeNameEqual",
          "args": [
            "root",
            "\"network\""
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeNameEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1013-1018",
          "snippet": "bool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nbool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkDefPtr\nvirNetworkDefParseNode(xmlDocPtr xml,\n                       xmlNodePtr root,\n                       virNetworkXMLOptionPtr xmlopt)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"network\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <network>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virNetworkDefParseXML(ctxt, xmlopt);\n}"
  },
  {
    "function_name": "virNetworkDefParseFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2122-2127",
    "snippet": "virNetworkDefPtr\nvirNetworkDefParseFile(const char *filename,\n                       virNetworkXMLOptionPtr xmlopt)\n{\n    return virNetworkDefParse(NULL, filename, xmlopt);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkDefParse",
          "args": [
            "NULL",
            "filename",
            "xmlopt"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefParseNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2130-2150",
          "snippet": "virNetworkDefPtr\nvirNetworkDefParseNode(xmlDocPtr xml,\n                       xmlNodePtr root,\n                       virNetworkXMLOptionPtr xmlopt)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"network\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <network>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virNetworkDefParseXML(ctxt, xmlopt);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkDefPtr\nvirNetworkDefParseNode(xmlDocPtr xml,\n                       xmlNodePtr root,\n                       virNetworkXMLOptionPtr xmlopt)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"network\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <network>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virNetworkDefParseXML(ctxt, xmlopt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkDefPtr\nvirNetworkDefParseFile(const char *filename,\n                       virNetworkXMLOptionPtr xmlopt)\n{\n    return virNetworkDefParse(NULL, filename, xmlopt);\n}"
  },
  {
    "function_name": "virNetworkDefParseString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2114-2119",
    "snippet": "virNetworkDefPtr\nvirNetworkDefParseString(const char *xmlStr,\n                         virNetworkXMLOptionPtr xmlopt)\n{\n    return virNetworkDefParse(xmlStr, NULL, xmlopt);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkDefParse",
          "args": [
            "xmlStr",
            "NULL",
            "xmlopt"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefParseNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2130-2150",
          "snippet": "virNetworkDefPtr\nvirNetworkDefParseNode(xmlDocPtr xml,\n                       xmlNodePtr root,\n                       virNetworkXMLOptionPtr xmlopt)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"network\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <network>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virNetworkDefParseXML(ctxt, xmlopt);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkDefPtr\nvirNetworkDefParseNode(xmlDocPtr xml,\n                       xmlNodePtr root,\n                       virNetworkXMLOptionPtr xmlopt)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"network\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <network>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virNetworkDefParseXML(ctxt, xmlopt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkDefPtr\nvirNetworkDefParseString(const char *xmlStr,\n                         virNetworkXMLOptionPtr xmlopt)\n{\n    return virNetworkDefParse(xmlStr, NULL, xmlopt);\n}"
  },
  {
    "function_name": "virNetworkDefParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "2095-2111",
    "snippet": "static virNetworkDefPtr\nvirNetworkDefParse(const char *xmlStr,\n                   const char *filename,\n                   virNetworkXMLOptionPtr xmlopt)\n{\n    xmlDocPtr xml;\n    virNetworkDefPtr def = NULL;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(network_definition)\")))) {\n        def = virNetworkDefParseNode(xml, xmlDocGetRootElement(xml), xmlopt);\n        xmlFreeDoc(xml);\n    }\n\n    xmlKeepBlanksDefault(keepBlanksDefault);\n    return def;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlKeepBlanksDefault",
          "args": [
            "keepBlanksDefault"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "xml"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefParseNode",
          "args": [
            "xml",
            "xmlDocGetRootElement(xml)",
            "xmlopt"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefParseNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2130-2150",
          "snippet": "virNetworkDefPtr\nvirNetworkDefParseNode(xmlDocPtr xml,\n                       xmlNodePtr root,\n                       virNetworkXMLOptionPtr xmlopt)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"network\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <network>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virNetworkDefParseXML(ctxt, xmlopt);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkDefPtr\nvirNetworkDefParseNode(xmlDocPtr xml,\n                       xmlNodePtr root,\n                       virNetworkXMLOptionPtr xmlopt)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"network\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <network>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virNetworkDefParseXML(ctxt, xmlopt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlDocGetRootElement",
          "args": [
            "xml"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLParse",
          "args": [
            "filename",
            "xmlStr",
            "_(\"(network_definition)\")"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"(network_definition)\""
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlKeepBlanksDefault",
          "args": [
            "0"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virNetworkDefPtr\nvirNetworkDefParse(const char *xmlStr,\n                   const char *filename,\n                   virNetworkXMLOptionPtr xmlopt)\n{\n    xmlDocPtr xml;\n    virNetworkDefPtr def = NULL;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(network_definition)\")))) {\n        def = virNetworkDefParseNode(xml, xmlDocGetRootElement(xml), xmlopt);\n        xmlFreeDoc(xml);\n    }\n\n    xmlKeepBlanksDefault(keepBlanksDefault);\n    return def;\n}"
  },
  {
    "function_name": "virNetworkDefParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "1645-2092",
    "snippet": "virNetworkDefPtr\nvirNetworkDefParseXML(xmlXPathContextPtr ctxt,\n                      virNetworkXMLOptionPtr xmlopt)\n{\n    virNetworkDefPtr def;\n    char *tmp = NULL;\n    char *stp = NULL;\n    xmlNodePtr *ipNodes = NULL;\n    xmlNodePtr *routeNodes = NULL;\n    xmlNodePtr *portGroupNodes = NULL;\n    int nips, nPortGroups, nRoutes;\n    xmlNodePtr dnsNode = NULL;\n    xmlNodePtr virtPortNode = NULL;\n    xmlNodePtr forwardNode = NULL;\n    char *ipv6nogwStr = NULL;\n    char *trustGuestRxFilters = NULL;\n    xmlNodePtr save = ctxt->node;\n    xmlNodePtr bandwidthNode = NULL;\n    xmlNodePtr vlanNode;\n    xmlNodePtr metadataNode = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    /* Extract network name */\n    def->name = virXPathString(\"string(./name[1])\", ctxt);\n    if (!def->name) {\n        virReportError(VIR_ERR_NO_NAME, NULL);\n        goto error;\n    }\n\n    if (virXMLCheckIllegalChars(\"name\", def->name, \"/\") < 0)\n        goto error;\n\n    /* Extract network uuid */\n    tmp = virXPathString(\"string(./uuid[1])\", ctxt);\n    if (!tmp) {\n        if (virUUIDGenerate(def->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"Failed to generate UUID\"));\n            goto error;\n        }\n    } else {\n        if (virUUIDParse(tmp, def->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"malformed uuid element\"));\n            goto error;\n        }\n        VIR_FREE(tmp);\n        def->uuid_specified = true;\n    }\n\n    /* check if definitions with no IPv6 gateway addresses is to\n     * allow guest-to-guest communications.\n     */\n    ipv6nogwStr = virXPathString(\"string(./@ipv6)\", ctxt);\n    if (ipv6nogwStr) {\n        if (virStringParseYesNo(ipv6nogwStr, &def->ipv6nogw) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid ipv6 setting '%s' in network '%s'\"),\n                           ipv6nogwStr, def->name);\n            goto error;\n        }\n        VIR_FREE(ipv6nogwStr);\n    }\n\n    trustGuestRxFilters\n        = virXPathString(\"string(./@trustGuestRxFilters)\", ctxt);\n    if (trustGuestRxFilters) {\n        if ((def->trustGuestRxFilters\n             = virTristateBoolTypeFromString(trustGuestRxFilters)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid trustGuestRxFilters setting '%s' \"\n                             \"in network '%s'\"),\n                           trustGuestRxFilters, def->name);\n            goto error;\n        }\n        VIR_FREE(trustGuestRxFilters);\n    }\n\n    /* Parse network domain information */\n    def->domain = virXPathString(\"string(./domain[1]/@name)\", ctxt);\n    tmp = virXPathString(\"string(./domain[1]/@localOnly)\", ctxt);\n    if (tmp) {\n        def->domainLocalOnly = virTristateBoolTypeFromString(tmp);\n        if (def->domainLocalOnly <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid domain localOnly setting '%s' \"\n                             \"in network '%s'\"),\n                           tmp, def->name);\n            goto error;\n        }\n        VIR_FREE(tmp);\n    }\n\n    if ((bandwidthNode = virXPathNode(\"./bandwidth\", ctxt)) &&\n        virNetDevBandwidthParse(&def->bandwidth, NULL, bandwidthNode, false) < 0)\n        goto error;\n\n    vlanNode = virXPathNode(\"./vlan\", ctxt);\n    if (vlanNode && virNetDevVlanParse(vlanNode, ctxt, &def->vlan) < 0)\n        goto error;\n\n    if (virNetworkPortOptionsParseXML(ctxt, &def->isolatedPort) < 0)\n        goto error;\n\n    /* Parse bridge information */\n    def->bridge = virXPathString(\"string(./bridge[1]/@name)\", ctxt);\n    def->bridgeZone = virXPathString(\"string(./bridge[1]/@zone)\", ctxt);\n    stp = virXPathString(\"string(./bridge[1]/@stp)\", ctxt);\n    def->stp = (stp && STREQ(stp, \"off\")) ? false : true;\n\n    tmp = virXPathString(\"string(./bridge[1]/@delay)\", ctxt);\n    if (tmp) {\n        if (virStrToLong_ulp(tmp, NULL, 10, &def->delay) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid delay value in network '%s'\"),\n                           def->name);\n            goto error;\n        }\n    }\n    VIR_FREE(tmp);\n\n    tmp = virXPathString(\"string(./bridge[1]/@macTableManager)\", ctxt);\n    if (tmp) {\n        if ((def->macTableManager\n             = virNetworkBridgeMACTableManagerTypeFromString(tmp)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid macTableManager setting '%s' \"\n                             \"in network '%s'\"), tmp, def->name);\n            goto error;\n        }\n        VIR_FREE(tmp);\n    }\n\n    tmp = virXPathString(\"string(./mac[1]/@address)\", ctxt);\n    if (tmp) {\n        if (virMacAddrParse(tmp, &def->mac) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid bridge mac address '%s' in network '%s'\"),\n                           tmp, def->name);\n            goto error;\n        }\n        if (virMacAddrIsMulticast(&def->mac)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid multicast bridge mac address '%s' in network '%s'\"),\n                           tmp, def->name);\n            goto error;\n        }\n        VIR_FREE(tmp);\n        def->mac_specified = true;\n    }\n\n    tmp = virXPathString(\"string(./mtu/@size)\", ctxt);\n    if (tmp) {\n        if (virStrToLong_ui(tmp, NULL, 10, &def->mtu) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid mtu size '%s' in network '%s'\"),\n                           tmp, def->name);\n            goto error;\n        }\n    }\n    VIR_FREE(tmp);\n\n    dnsNode = virXPathNode(\"./dns\", ctxt);\n    if (dnsNode != NULL &&\n        virNetworkDNSDefParseXML(def->name, dnsNode, ctxt, &def->dns) < 0) {\n        goto error;\n    }\n\n    virtPortNode = virXPathNode(\"./virtualport\", ctxt);\n    if (virtPortNode &&\n        (!(def->virtPortProfile = virNetDevVPortProfileParse(virtPortNode,\n                                                             VIR_VPORT_XML_REQUIRE_TYPE)))) {\n        goto error;\n    }\n\n    nPortGroups = virXPathNodeSet(\"./portgroup\", ctxt, &portGroupNodes);\n    if (nPortGroups < 0)\n        goto error;\n\n    if (nPortGroups > 0) {\n        size_t i;\n\n        /* allocate array to hold all the portgroups */\n        if (VIR_ALLOC_N(def->portGroups, nPortGroups) < 0)\n            goto error;\n        /* parse each portgroup */\n        for (i = 0; i < nPortGroups; i++) {\n            if (virNetworkPortGroupParseXML(&def->portGroups[i],\n                                            portGroupNodes[i],\n                                            ctxt) < 0)\n                goto error;\n            def->nPortGroups++;\n        }\n    }\n    VIR_FREE(portGroupNodes);\n\n    nips = virXPathNodeSet(\"./ip\", ctxt, &ipNodes);\n    if (nips < 0)\n        goto error;\n\n    if (nips > 0) {\n        size_t i;\n\n        /* allocate array to hold all the addrs */\n        if (VIR_ALLOC_N(def->ips, nips) < 0)\n            goto error;\n        /* parse each addr */\n        for (i = 0; i < nips; i++) {\n            if (virNetworkIPDefParseXML(def->name,\n                                        ipNodes[i],\n                                        ctxt,\n                                        &def->ips[i]) < 0)\n                goto error;\n            def->nips++;\n        }\n    }\n    VIR_FREE(ipNodes);\n\n    nRoutes = virXPathNodeSet(\"./route\", ctxt, &routeNodes);\n    if (nRoutes < 0)\n        goto error;\n\n    if (nRoutes > 0) {\n        size_t i;\n\n        /* allocate array to hold all the route definitions */\n        if (VIR_ALLOC_N(def->routes, nRoutes) < 0)\n            goto error;\n        /* parse each definition */\n        for (i = 0; i < nRoutes; i++) {\n            virNetDevIPRoutePtr route = NULL;\n\n            if (!(route = virNetDevIPRouteParseXML(def->name,\n                                                   routeNodes[i],\n                                                   ctxt)))\n                goto error;\n            def->routes[i] = route;\n            def->nroutes++;\n        }\n\n        /* now validate the correctness of any static route gateways specified\n         *\n         * note: the parameters within each definition are verified/assumed valid;\n         * the question being asked and answered here is if the specified gateway\n         * is directly reachable from this bridge.\n         */\n        nRoutes = def->nroutes;\n        nips = def->nips;\n        for (i = 0; i < nRoutes; i++) {\n            size_t j;\n            virSocketAddr testAddr, testGw;\n            bool addrMatch;\n            virNetDevIPRoutePtr gwdef = def->routes[i];\n            virSocketAddrPtr gateway = virNetDevIPRouteGetGateway(gwdef);\n            addrMatch = false;\n            for (j = 0; j < nips; j++) {\n                virNetworkIPDefPtr def2 = &def->ips[j];\n                if (VIR_SOCKET_ADDR_FAMILY(gateway)\n                    != VIR_SOCKET_ADDR_FAMILY(&def2->address)) {\n                    continue;\n                }\n                int prefix = virNetworkIPDefPrefix(def2);\n                virSocketAddrMaskByPrefix(&def2->address, prefix, &testAddr);\n                virSocketAddrMaskByPrefix(gateway, prefix, &testGw);\n                if (VIR_SOCKET_ADDR_VALID(&testAddr) &&\n                    VIR_SOCKET_ADDR_VALID(&testGw) &&\n                    virSocketAddrEqual(&testAddr, &testGw)) {\n                    addrMatch = true;\n                    break;\n                }\n            }\n            if (!addrMatch) {\n                char *gw = virSocketAddrFormat(gateway);\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unreachable static route gateway '%s' specified for network '%s'\"),\n                               gw, def->name);\n                VIR_FREE(gw);\n                goto error;\n            }\n        }\n    }\n    VIR_FREE(routeNodes);\n\n    forwardNode = virXPathNode(\"./forward\", ctxt);\n    if (forwardNode &&\n        virNetworkForwardDefParseXML(def->name, forwardNode, ctxt, &def->forward) < 0) {\n        goto error;\n    }\n\n    /* Validate some items in the main NetworkDef that need to align\n     * with the chosen forward mode.\n     */\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n        break;\n\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_OPEN:\n        /* It's pointless to specify L3 forwarding without specifying\n         * the network we're on.\n         */\n        if (def->nips == 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"%s forwarding requested, \"\n                             \"but no IP address provided for network '%s'\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        if (def->forward.nifs > 1) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"multiple forwarding interfaces specified \"\n                             \"for network '%s', only one is supported\"),\n                           def->name);\n            goto error;\n        }\n\n        if (def->forward.type == VIR_NETWORK_FORWARD_OPEN && def->forward.nifs) {\n            /* an open network by definition can't place any restrictions\n             * on what traffic is allowed or where it goes, so specifying\n             * a forwarding device is nonsensical.\n             */\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"forward dev not allowed for \"\n                             \"network '%s' with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            goto error;\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        if (def->bridge) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge name not allowed in %s mode (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        if (def->bridgeZone) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge zone not allowed in %s mode (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        if (def->macTableManager) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge macTableManager setting not allowed \"\n                             \"in %s mode (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->delay || stp || def->bridgeZone) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge delay/stp/zone options only allowed in \"\n                             \"route, nat, and isolated mode, not in %s \"\n                             \"(network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        if (def->bridge && (def->forward.nifs || def->forward.npfs)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"A network with forward mode='%s' can specify \"\n                             \"a bridge name or a forward dev, but not \"\n                             \"both (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        goto error;\n    }\n\n    VIR_FREE(stp);\n\n    if (def->mtu) {\n        switch ((virNetworkForwardType) def->forward.type) {\n        case VIR_NETWORK_FORWARD_NONE:\n        case VIR_NETWORK_FORWARD_NAT:\n        case VIR_NETWORK_FORWARD_ROUTE:\n        case VIR_NETWORK_FORWARD_OPEN:\n            break;\n\n        case VIR_NETWORK_FORWARD_BRIDGE:\n        case VIR_NETWORK_FORWARD_PRIVATE:\n        case VIR_NETWORK_FORWARD_VEPA:\n        case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        case VIR_NETWORK_FORWARD_HOSTDEV:\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"mtu size only allowed in open, route, nat, \"\n                             \"and isolated mode, not in %s (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n\n        case VIR_NETWORK_FORWARD_LAST:\n        default:\n            virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n            goto error;\n        }\n    }\n\n    /* Extract custom metadata */\n    if ((metadataNode = virXPathNode(\"./metadata[1]\", ctxt)) != NULL) {\n        def->metadata = xmlCopyNode(metadataNode, 1);\n        virXMLNodeSanitizeNamespaces(def->metadata);\n    }\n\n    if (xmlopt)\n        def->ns = xmlopt->ns;\n    if (def->ns.parse) {\n        if (virXMLNamespaceRegister(ctxt, &def->ns) < 0)\n            goto error;\n        if ((def->ns.parse)(ctxt, &def->namespaceData) < 0)\n            goto error;\n    }\n\n    ctxt->node = save;\n    return def;\n\n error:\n    VIR_FREE(tmp);\n    VIR_FREE(routeNodes);\n    VIR_FREE(stp);\n    virNetworkDefFree(def);\n    VIR_FREE(ipNodes);\n    VIR_FREE(portGroupNodes);\n    VIR_FREE(ipv6nogwStr);\n    VIR_FREE(trustGuestRxFilters);\n    ctxt->node = save;\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "trustGuestRxFilters"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ipv6nogwStr"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "portGroupNodes"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ipNodes"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefFree",
          "args": [
            "def"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "235-274",
          "snippet": "void\nvirNetworkDefFree(virNetworkDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->bridge);\n    VIR_FREE(def->bridgeZone);\n    VIR_FREE(def->domain);\n\n    virNetworkForwardDefClear(&def->forward);\n\n    for (i = 0; i < def->nips && def->ips; i++)\n        virNetworkIPDefClear(&def->ips[i]);\n    VIR_FREE(def->ips);\n\n    for (i = 0; i < def->nroutes && def->routes; i++)\n        virNetDevIPRouteFree(def->routes[i]);\n    VIR_FREE(def->routes);\n\n    for (i = 0; i < def->nPortGroups && def->portGroups; i++)\n        virPortGroupDefClear(&def->portGroups[i]);\n    VIR_FREE(def->portGroups);\n\n    virNetworkDNSDefClear(&def->dns);\n\n    VIR_FREE(def->virtPortProfile);\n\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n\n    xmlFreeNode(def->metadata);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetworkDefFree(virNetworkDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->bridge);\n    VIR_FREE(def->bridgeZone);\n    VIR_FREE(def->domain);\n\n    virNetworkForwardDefClear(&def->forward);\n\n    for (i = 0; i < def->nips && def->ips; i++)\n        virNetworkIPDefClear(&def->ips[i]);\n    VIR_FREE(def->ips);\n\n    for (i = 0; i < def->nroutes && def->routes; i++)\n        virNetDevIPRouteFree(def->routes[i]);\n    VIR_FREE(def->routes);\n\n    for (i = 0; i < def->nPortGroups && def->portGroups; i++)\n        virPortGroupDefClear(&def->portGroups[i]);\n    VIR_FREE(def->portGroups);\n\n    virNetworkDNSDefClear(&def->dns);\n\n    VIR_FREE(def->virtPortProfile);\n\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n\n    xmlFreeNode(def->metadata);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "stp"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "routeNodes"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "ctxt",
            "&def->namespaceData"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLNamespaceRegister",
          "args": [
            "ctxt",
            "&def->ns"
          ],
          "line": 2072
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNamespaceRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1420-1434",
          "snippet": "int\nvirXMLNamespaceRegister(xmlXPathContextPtr ctxt,\n                        virXMLNamespace const *ns)\n{\n    if (xmlXPathRegisterNs(ctxt,\n                           BAD_CAST ns->prefix,\n                           BAD_CAST ns->uri) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to register xml namespace '%s'\"),\n                       ns->uri);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXMLNamespaceRegister(xmlXPathContextPtr ctxt,\n                        virXMLNamespace const *ns)\n{\n    if (xmlXPathRegisterNs(ctxt,\n                           BAD_CAST ns->prefix,\n                           BAD_CAST ns->uri) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to register xml namespace '%s'\"),\n                       ns->uri);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLNodeSanitizeNamespaces",
          "args": [
            "def->metadata"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeSanitizeNamespaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1189-1230",
          "snippet": "void\nvirXMLNodeSanitizeNamespaces(xmlNodePtr node)\n{\n    xmlNodePtr child;\n    xmlNodePtr next;\n    xmlNodePtr dupl;\n\n    if (!node)\n        return;\n\n    child = node->children;\n    while (child) {\n        /* remove subelements that don't have any namespace at all */\n        if (!child->ns || !child->ns->href) {\n            dupl = child;\n            child = child->next;\n\n            xmlUnlinkNode(dupl);\n            xmlFreeNode(dupl);\n            continue;\n        }\n\n        /* check that every other child of @root doesn't share the namespace of\n         * the current one and delete them possibly */\n        next = child->next;\n        while (next) {\n            dupl = NULL;\n\n            if (child->ns && next->ns &&\n                STREQ_NULLABLE((const char *) child->ns->href,\n                               (const char *) next->ns->href))\n                dupl = next;\n\n            next = next->next;\n            if (dupl) {\n                xmlUnlinkNode(dupl);\n                xmlFreeNode(dupl);\n            }\n        }\n        child = child->next;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirXMLNodeSanitizeNamespaces(xmlNodePtr node)\n{\n    xmlNodePtr child;\n    xmlNodePtr next;\n    xmlNodePtr dupl;\n\n    if (!node)\n        return;\n\n    child = node->children;\n    while (child) {\n        /* remove subelements that don't have any namespace at all */\n        if (!child->ns || !child->ns->href) {\n            dupl = child;\n            child = child->next;\n\n            xmlUnlinkNode(dupl);\n            xmlFreeNode(dupl);\n            continue;\n        }\n\n        /* check that every other child of @root doesn't share the namespace of\n         * the current one and delete them possibly */\n        next = child->next;\n        while (next) {\n            dupl = NULL;\n\n            if (child->ns && next->ns &&\n                STREQ_NULLABLE((const char *) child->ns->href,\n                               (const char *) next->ns->href))\n                dupl = next;\n\n            next = next->next;\n            if (dupl) {\n                xmlUnlinkNode(dupl);\n                xmlFreeNode(dupl);\n            }\n        }\n        child = child->next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlCopyNode",
          "args": [
            "metadataNode",
            "1"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./metadata[1]\"",
            "ctxt"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNetworkForwardType",
            "def->forward.type"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"mtu size only allowed in open, route, nat, \"\n                             \"and isolated mode, not in %s (network '%s')\")",
            "virNetworkForwardTypeToString(def->forward.type)",
            "def->name"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "def->forward.type"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"mtu size only allowed in open, route, nat, \"\n                             \"and isolated mode, not in %s (network '%s')\""
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "stp"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNetworkForwardType",
            "def->forward.type"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"A network with forward mode='%s' can specify \"\n                             \"a bridge name or a forward dev, but not \"\n                             \"both (network '%s')\")",
            "virNetworkForwardTypeToString(def->forward.type)",
            "def->name"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "def->forward.type"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"bridge delay/stp/zone options only allowed in \"\n                             \"route, nat, and isolated mode, not in %s \"\n                             \"(network '%s')\")",
            "virNetworkForwardTypeToString(def->forward.type)",
            "def->name"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "def->forward.type"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"bridge macTableManager setting not allowed \"\n                             \"in %s mode (network '%s')\")",
            "virNetworkForwardTypeToString(def->forward.type)",
            "def->name"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "def->forward.type"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"bridge zone not allowed in %s mode (network '%s')\")",
            "virNetworkForwardTypeToString(def->forward.type)",
            "def->name"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "def->forward.type"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"bridge name not allowed in %s mode (network '%s')\")",
            "virNetworkForwardTypeToString(def->forward.type)",
            "def->name"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "def->forward.type"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"forward dev not allowed for \"\n                             \"network '%s' with forward mode='%s'\")",
            "def->name",
            "virNetworkForwardTypeToString(def->forward.type)"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "def->forward.type"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"multiple forwarding interfaces specified \"\n                             \"for network '%s', only one is supported\")",
            "def->name"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"%s forwarding requested, \"\n                             \"but no IP address provided for network '%s'\")",
            "virNetworkForwardTypeToString(def->forward.type)",
            "def->name"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "def->forward.type"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardDefParseXML",
          "args": [
            "def->name",
            "forwardNode",
            "ctxt",
            "&def->forward"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkForwardDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "1396-1642",
          "snippet": "static int\nvirNetworkForwardDefParseXML(const char *networkName,\n                             xmlNodePtr node,\n                             xmlXPathContextPtr ctxt,\n                             virNetworkForwardDefPtr def)\n{\n    size_t i, j;\n    int ret = -1;\n    xmlNodePtr *forwardIfNodes = NULL;\n    xmlNodePtr *forwardPfNodes = NULL;\n    xmlNodePtr *forwardAddrNodes = NULL;\n    xmlNodePtr *forwardNatNodes = NULL;\n    int nForwardIfs, nForwardAddrs, nForwardPfs, nForwardNats;\n    char *forwardDev = NULL;\n    char *forwardManaged = NULL;\n    char *forwardDriverName = NULL;\n    char *type = NULL;\n    xmlNodePtr save = ctxt->node;\n\n    ctxt->node = node;\n\n    if (!(type = virXPathString(\"string(./@mode)\", ctxt))) {\n        def->type = VIR_NETWORK_FORWARD_NAT;\n    } else {\n        if ((def->type = virNetworkForwardTypeFromString(type)) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown forwarding type '%s'\"), type);\n            goto cleanup;\n        }\n        VIR_FREE(type);\n    }\n\n    forwardManaged = virXPathString(\"string(./@managed)\", ctxt);\n    if (forwardManaged != NULL &&\n        STRCASEEQ(forwardManaged, \"yes\")) {\n        def->managed = true;\n    }\n\n    forwardDriverName = virXPathString(\"string(./driver/@name)\", ctxt);\n    if (forwardDriverName) {\n        int driverName\n            = virNetworkForwardDriverNameTypeFromString(forwardDriverName);\n\n        if (driverName <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unknown forward <driver name='%s'/> \"\n                             \"in network %s\"),\n                           forwardDriverName, networkName);\n            goto cleanup;\n        }\n        def->driverName = driverName;\n    }\n\n    /* bridge and hostdev modes can use a pool of physical interfaces */\n    nForwardIfs = virXPathNodeSet(\"./interface\", ctxt, &forwardIfNodes);\n    if (nForwardIfs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <interface> element found in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    nForwardAddrs = virXPathNodeSet(\"./address\", ctxt, &forwardAddrNodes);\n    if (nForwardAddrs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <address> element found in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    nForwardPfs = virXPathNodeSet(\"./pf\", ctxt, &forwardPfNodes);\n    if (nForwardPfs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <pf> element found in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    nForwardNats = virXPathNodeSet(\"./nat\", ctxt, &forwardNatNodes);\n    if (nForwardNats < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <nat> element found in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    } else if (nForwardNats > 1) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Only one <nat> element is allowed in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    } else if (nForwardNats == 1) {\n        if (virNetworkForwardNatDefParseXML(networkName,\n                                            *forwardNatNodes,\n                                            ctxt, def) < 0)\n            goto cleanup;\n    }\n\n    forwardDev = virXPathString(\"string(./@dev)\", ctxt);\n    if (forwardDev && (nForwardAddrs > 0 || nForwardPfs > 0)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"the <forward> 'dev' attribute cannot be used when \"\n                         \"<address> or <pf> sub-elements are present \"\n                         \"in network %s\"));\n        goto cleanup;\n    }\n\n    if (nForwardIfs > 0 || forwardDev) {\n        if (VIR_ALLOC_N(def->ifs, MAX(nForwardIfs, 1)) < 0)\n            goto cleanup;\n\n        if (forwardDev) {\n            def->ifs[0].device.dev = forwardDev;\n            def->ifs[0].type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n            forwardDev = NULL;\n            def->nifs++;\n        }\n\n        /* parse each <interface> */\n        for (i = 0; i < nForwardIfs; i++) {\n            forwardDev = virXMLPropString(forwardIfNodes[i], \"dev\");\n            if (!forwardDev) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"Missing required dev attribute in \"\n                                 \"<forward> <interface> element of network %s\"),\n                               networkName);\n                goto cleanup;\n            }\n\n            if ((i == 0) && (def->nifs == 1)) {\n                /* both <forward dev='x'> and <interface dev='x'/> are\n                 * present.  If they don't match, it's an error.\n                 */\n                if (STRNEQ(forwardDev, def->ifs[0].device.dev)) {\n                    virReportError(VIR_ERR_XML_ERROR,\n                                   _(\"<forward dev='%s'> must match first \"\n                                     \"<interface dev='%s'/> in network %s\"),\n                                   def->ifs[0].device.dev,\n                                   forwardDev, networkName);\n                    goto cleanup;\n                }\n                VIR_FREE(forwardDev);\n                continue;\n            }\n\n            for (j = 0; j < i; j++) {\n                if (STREQ_NULLABLE(def->ifs[j].device.dev, forwardDev)) {\n                    virReportError(VIR_ERR_XML_ERROR,\n                                   _(\"interface '%s' can only be \"\n                                     \"listed once in network %s\"),\n                                   forwardDev, networkName);\n                    goto cleanup;\n                }\n            }\n\n            def->ifs[i].device.dev = forwardDev;\n            forwardDev = NULL;\n            def->ifs[i].type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n            def->nifs++;\n        }\n\n    } else if (nForwardAddrs > 0) {\n        if (VIR_ALLOC_N(def->ifs, nForwardAddrs) < 0)\n            goto cleanup;\n\n        for (i = 0; i < nForwardAddrs; i++) {\n            if (!(type = virXMLPropString(forwardAddrNodes[i], \"type\"))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"missing address type in network %s\"),\n                               networkName);\n                goto cleanup;\n            }\n\n            if ((def->ifs[i].type = virNetworkForwardHostdevDeviceTypeFromString(type)) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unknown address type '%s' in network %s\"),\n                               type, networkName);\n                goto cleanup;\n            }\n\n            switch (def->ifs[i].type) {\n            case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI:\n            {\n                virPCIDeviceAddressPtr addr = &def->ifs[i].device.pci;\n\n                if (virPCIDeviceAddressParseXML(forwardAddrNodes[i], addr) < 0)\n                    goto cleanup;\n\n                for (j = 0; j < i; j++) {\n                    if (virPCIDeviceAddressEqual(addr, &def->ifs[j].device.pci)) {\n                        virReportError(VIR_ERR_XML_ERROR,\n                                       _(\"PCI device '%04x:%02x:%02x.%x' can \"\n                                         \"only be listed once in network %s\"),\n                                       addr->domain, addr->bus,\n                                       addr->slot, addr->function,\n                                       networkName);\n                        goto cleanup;\n                    }\n                }\n                break;\n            }\n            /* Add USB case here if we ever find a reason to support it */\n\n            default:\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"unsupported address type '%s' in network %s\"),\n                               type, networkName);\n                goto cleanup;\n            }\n            VIR_FREE(type);\n            def->nifs++;\n        }\n\n    } else if (nForwardPfs > 1) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Only one <pf> element is allowed in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    } else if (nForwardPfs == 1) {\n        if (VIR_ALLOC_N(def->pfs, nForwardPfs) < 0)\n            goto cleanup;\n\n        forwardDev = virXMLPropString(*forwardPfNodes, \"dev\");\n        if (!forwardDev) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Missing required dev attribute \"\n                             \"in <pf> element of network '%s'\"),\n                           networkName);\n            goto cleanup;\n        }\n\n        def->pfs->dev = forwardDev;\n        forwardDev = NULL;\n        def->npfs++;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(type);\n    VIR_FREE(forwardDev);\n    VIR_FREE(forwardManaged);\n    VIR_FREE(forwardDriverName);\n    VIR_FREE(forwardPfNodes);\n    VIR_FREE(forwardIfNodes);\n    VIR_FREE(forwardAddrNodes);\n    VIR_FREE(forwardNatNodes);\n    ctxt->node = save;\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkForwardDefParseXML(const char *networkName,\n                             xmlNodePtr node,\n                             xmlXPathContextPtr ctxt,\n                             virNetworkForwardDefPtr def)\n{\n    size_t i, j;\n    int ret = -1;\n    xmlNodePtr *forwardIfNodes = NULL;\n    xmlNodePtr *forwardPfNodes = NULL;\n    xmlNodePtr *forwardAddrNodes = NULL;\n    xmlNodePtr *forwardNatNodes = NULL;\n    int nForwardIfs, nForwardAddrs, nForwardPfs, nForwardNats;\n    char *forwardDev = NULL;\n    char *forwardManaged = NULL;\n    char *forwardDriverName = NULL;\n    char *type = NULL;\n    xmlNodePtr save = ctxt->node;\n\n    ctxt->node = node;\n\n    if (!(type = virXPathString(\"string(./@mode)\", ctxt))) {\n        def->type = VIR_NETWORK_FORWARD_NAT;\n    } else {\n        if ((def->type = virNetworkForwardTypeFromString(type)) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown forwarding type '%s'\"), type);\n            goto cleanup;\n        }\n        VIR_FREE(type);\n    }\n\n    forwardManaged = virXPathString(\"string(./@managed)\", ctxt);\n    if (forwardManaged != NULL &&\n        STRCASEEQ(forwardManaged, \"yes\")) {\n        def->managed = true;\n    }\n\n    forwardDriverName = virXPathString(\"string(./driver/@name)\", ctxt);\n    if (forwardDriverName) {\n        int driverName\n            = virNetworkForwardDriverNameTypeFromString(forwardDriverName);\n\n        if (driverName <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unknown forward <driver name='%s'/> \"\n                             \"in network %s\"),\n                           forwardDriverName, networkName);\n            goto cleanup;\n        }\n        def->driverName = driverName;\n    }\n\n    /* bridge and hostdev modes can use a pool of physical interfaces */\n    nForwardIfs = virXPathNodeSet(\"./interface\", ctxt, &forwardIfNodes);\n    if (nForwardIfs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <interface> element found in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    nForwardAddrs = virXPathNodeSet(\"./address\", ctxt, &forwardAddrNodes);\n    if (nForwardAddrs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <address> element found in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    nForwardPfs = virXPathNodeSet(\"./pf\", ctxt, &forwardPfNodes);\n    if (nForwardPfs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <pf> element found in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    nForwardNats = virXPathNodeSet(\"./nat\", ctxt, &forwardNatNodes);\n    if (nForwardNats < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <nat> element found in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    } else if (nForwardNats > 1) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Only one <nat> element is allowed in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    } else if (nForwardNats == 1) {\n        if (virNetworkForwardNatDefParseXML(networkName,\n                                            *forwardNatNodes,\n                                            ctxt, def) < 0)\n            goto cleanup;\n    }\n\n    forwardDev = virXPathString(\"string(./@dev)\", ctxt);\n    if (forwardDev && (nForwardAddrs > 0 || nForwardPfs > 0)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"the <forward> 'dev' attribute cannot be used when \"\n                         \"<address> or <pf> sub-elements are present \"\n                         \"in network %s\"));\n        goto cleanup;\n    }\n\n    if (nForwardIfs > 0 || forwardDev) {\n        if (VIR_ALLOC_N(def->ifs, MAX(nForwardIfs, 1)) < 0)\n            goto cleanup;\n\n        if (forwardDev) {\n            def->ifs[0].device.dev = forwardDev;\n            def->ifs[0].type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n            forwardDev = NULL;\n            def->nifs++;\n        }\n\n        /* parse each <interface> */\n        for (i = 0; i < nForwardIfs; i++) {\n            forwardDev = virXMLPropString(forwardIfNodes[i], \"dev\");\n            if (!forwardDev) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"Missing required dev attribute in \"\n                                 \"<forward> <interface> element of network %s\"),\n                               networkName);\n                goto cleanup;\n            }\n\n            if ((i == 0) && (def->nifs == 1)) {\n                /* both <forward dev='x'> and <interface dev='x'/> are\n                 * present.  If they don't match, it's an error.\n                 */\n                if (STRNEQ(forwardDev, def->ifs[0].device.dev)) {\n                    virReportError(VIR_ERR_XML_ERROR,\n                                   _(\"<forward dev='%s'> must match first \"\n                                     \"<interface dev='%s'/> in network %s\"),\n                                   def->ifs[0].device.dev,\n                                   forwardDev, networkName);\n                    goto cleanup;\n                }\n                VIR_FREE(forwardDev);\n                continue;\n            }\n\n            for (j = 0; j < i; j++) {\n                if (STREQ_NULLABLE(def->ifs[j].device.dev, forwardDev)) {\n                    virReportError(VIR_ERR_XML_ERROR,\n                                   _(\"interface '%s' can only be \"\n                                     \"listed once in network %s\"),\n                                   forwardDev, networkName);\n                    goto cleanup;\n                }\n            }\n\n            def->ifs[i].device.dev = forwardDev;\n            forwardDev = NULL;\n            def->ifs[i].type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n            def->nifs++;\n        }\n\n    } else if (nForwardAddrs > 0) {\n        if (VIR_ALLOC_N(def->ifs, nForwardAddrs) < 0)\n            goto cleanup;\n\n        for (i = 0; i < nForwardAddrs; i++) {\n            if (!(type = virXMLPropString(forwardAddrNodes[i], \"type\"))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"missing address type in network %s\"),\n                               networkName);\n                goto cleanup;\n            }\n\n            if ((def->ifs[i].type = virNetworkForwardHostdevDeviceTypeFromString(type)) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unknown address type '%s' in network %s\"),\n                               type, networkName);\n                goto cleanup;\n            }\n\n            switch (def->ifs[i].type) {\n            case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI:\n            {\n                virPCIDeviceAddressPtr addr = &def->ifs[i].device.pci;\n\n                if (virPCIDeviceAddressParseXML(forwardAddrNodes[i], addr) < 0)\n                    goto cleanup;\n\n                for (j = 0; j < i; j++) {\n                    if (virPCIDeviceAddressEqual(addr, &def->ifs[j].device.pci)) {\n                        virReportError(VIR_ERR_XML_ERROR,\n                                       _(\"PCI device '%04x:%02x:%02x.%x' can \"\n                                         \"only be listed once in network %s\"),\n                                       addr->domain, addr->bus,\n                                       addr->slot, addr->function,\n                                       networkName);\n                        goto cleanup;\n                    }\n                }\n                break;\n            }\n            /* Add USB case here if we ever find a reason to support it */\n\n            default:\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"unsupported address type '%s' in network %s\"),\n                               type, networkName);\n                goto cleanup;\n            }\n            VIR_FREE(type);\n            def->nifs++;\n        }\n\n    } else if (nForwardPfs > 1) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Only one <pf> element is allowed in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    } else if (nForwardPfs == 1) {\n        if (VIR_ALLOC_N(def->pfs, nForwardPfs) < 0)\n            goto cleanup;\n\n        forwardDev = virXMLPropString(*forwardPfNodes, \"dev\");\n        if (!forwardDev) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Missing required dev attribute \"\n                             \"in <pf> element of network '%s'\"),\n                           networkName);\n            goto cleanup;\n        }\n\n        def->pfs->dev = forwardDev;\n        forwardDev = NULL;\n        def->npfs++;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(type);\n    VIR_FREE(forwardDev);\n    VIR_FREE(forwardManaged);\n    VIR_FREE(forwardDriverName);\n    VIR_FREE(forwardPfNodes);\n    VIR_FREE(forwardIfNodes);\n    VIR_FREE(forwardAddrNodes);\n    VIR_FREE(forwardNatNodes);\n    ctxt->node = save;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "routeNodes"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "gw"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unreachable static route gateway '%s' specified for network '%s'\")",
            "gw",
            "def->name"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "gateway"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrEqual",
          "args": [
            "&testAddr",
            "&testGw"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "359-378",
          "snippet": "bool\nvirSocketAddrEqual(const virSocketAddr *s1, const virSocketAddr *s2)\n{\n    if (s1->data.stor.ss_family != s2->data.stor.ss_family)\n        return false;\n\n    switch (s1->data.stor.ss_family) {\n    case AF_INET:\n        return (memcmp(&s1->data.inet4.sin_addr.s_addr,\n                       &s2->data.inet4.sin_addr.s_addr,\n                       sizeof(s1->data.inet4.sin_addr.s_addr)) == 0 &&\n                s1->data.inet4.sin_port == s2->data.inet4.sin_port);\n    case AF_INET6:\n        return (memcmp(&s1->data.inet6.sin6_addr.s6_addr,\n                       &s2->data.inet6.sin6_addr.s6_addr,\n                       sizeof(s1->data.inet6.sin6_addr.s6_addr)) == 0 &&\n                s1->data.inet6.sin6_port == s2->data.inet6.sin6_port);\n    }\n    return false;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nbool\nvirSocketAddrEqual(const virSocketAddr *s1, const virSocketAddr *s2)\n{\n    if (s1->data.stor.ss_family != s2->data.stor.ss_family)\n        return false;\n\n    switch (s1->data.stor.ss_family) {\n    case AF_INET:\n        return (memcmp(&s1->data.inet4.sin_addr.s_addr,\n                       &s2->data.inet4.sin_addr.s_addr,\n                       sizeof(s1->data.inet4.sin_addr.s_addr)) == 0 &&\n                s1->data.inet4.sin_port == s2->data.inet4.sin_port);\n    case AF_INET6:\n        return (memcmp(&s1->data.inet6.sin6_addr.s6_addr,\n                       &s2->data.inet6.sin6_addr.s6_addr,\n                       sizeof(s1->data.inet6.sin6_addr.s6_addr)) == 0 &&\n                s1->data.inet6.sin6_port == s2->data.inet6.sin6_port);\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&testGw"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&testAddr"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrMaskByPrefix",
          "args": [
            "gateway",
            "prefix",
            "&testGw"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrMaskByPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "679-693",
          "snippet": "int\nvirSocketAddrMaskByPrefix(const virSocketAddr *addr,\n                          unsigned int prefix,\n                          virSocketAddrPtr network)\n{\n    virSocketAddr netmask;\n\n    if (virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                     addr->data.stor.ss_family) < 0) {\n        network->data.stor.ss_family = AF_UNSPEC;\n        return -1;\n    }\n\n    return virSocketAddrMask(addr, &netmask, network);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrMaskByPrefix(const virSocketAddr *addr,\n                          unsigned int prefix,\n                          virSocketAddrPtr network)\n{\n    virSocketAddr netmask;\n\n    if (virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                     addr->data.stor.ss_family) < 0) {\n        network->data.stor.ss_family = AF_UNSPEC;\n        return -1;\n    }\n\n    return virSocketAddrMask(addr, &netmask, network);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefPrefix",
          "args": [
            "def2"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "367-373",
          "snippet": "int\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "&def2->address"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "gateway"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteGetGateway",
          "args": [
            "gwdef"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteGetGateway",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "1035-1041",
          "snippet": "virSocketAddrPtr\nvirNetDevIPRouteGetGateway(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->gateway;\n    return NULL;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nvirSocketAddrPtr\nvirNetDevIPRouteGetGateway(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->gateway;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteParseXML",
          "args": [
            "def->name",
            "routeNodes[i]",
            "ctxt"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/networkcommon_conf.c",
          "lines": "220-287",
          "snippet": "virNetDevIPRoutePtr\nvirNetDevIPRouteParseXML(const char *errorDetail,\n                         xmlNodePtr node,\n                         xmlXPathContextPtr ctxt)\n{\n    /*\n     * virNetDevIPRoute object is already allocated as part\n     * of an array.  On failure clear: it out, but don't free it.\n     */\n\n    virNetDevIPRoutePtr def = NULL;\n    xmlNodePtr save;\n    char *family = NULL;\n    char *address = NULL, *netmask = NULL;\n    char *gateway = NULL;\n    unsigned long prefix = 0, metric = 0;\n    int prefixRc, metricRc;\n    bool hasPrefix = false;\n    bool hasMetric = false;\n\n    save = ctxt->node;\n    ctxt->node = node;\n\n    /* grab raw data from XML */\n    family = virXPathString(\"string(./@family)\", ctxt);\n    address = virXPathString(\"string(./@address)\", ctxt);\n    netmask = virXPathString(\"string(./@netmask)\", ctxt);\n    gateway = virXPathString(\"string(./@gateway)\", ctxt);\n    prefixRc = virXPathULong(\"string(./@prefix)\", ctxt, &prefix);\n    if (prefixRc == -2) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"%s: Invalid prefix specified \"\n                         \"in route definition\"),\n                       errorDetail);\n        goto cleanup;\n    }\n    hasPrefix = (prefixRc == 0);\n    metricRc = virXPathULong(\"string(./@metric)\", ctxt, &metric);\n    if (metricRc == -2) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"%s: Invalid metric specified \"\n                         \"in route definition\"),\n                       errorDetail);\n        goto cleanup;\n    }\n    if (metricRc == 0) {\n        hasMetric = true;\n        if (metric == 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"%s: Invalid metric value, must be > 0 \"\n                             \"in route definition\"),\n                           errorDetail);\n            goto cleanup;\n        }\n    }\n\n    def = virNetDevIPRouteCreate(errorDetail, family, address, netmask,\n                                 gateway, prefix, hasPrefix, metric,\n                                 hasMetric);\n\n cleanup:\n    ctxt->node = save;\n    VIR_FREE(family);\n    VIR_FREE(address);\n    VIR_FREE(netmask);\n    VIR_FREE(gateway);\n    return def;\n}",
          "includes": [
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"networkcommon_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirNetDevIPRoutePtr\nvirNetDevIPRouteParseXML(const char *errorDetail,\n                         xmlNodePtr node,\n                         xmlXPathContextPtr ctxt)\n{\n    /*\n     * virNetDevIPRoute object is already allocated as part\n     * of an array.  On failure clear: it out, but don't free it.\n     */\n\n    virNetDevIPRoutePtr def = NULL;\n    xmlNodePtr save;\n    char *family = NULL;\n    char *address = NULL, *netmask = NULL;\n    char *gateway = NULL;\n    unsigned long prefix = 0, metric = 0;\n    int prefixRc, metricRc;\n    bool hasPrefix = false;\n    bool hasMetric = false;\n\n    save = ctxt->node;\n    ctxt->node = node;\n\n    /* grab raw data from XML */\n    family = virXPathString(\"string(./@family)\", ctxt);\n    address = virXPathString(\"string(./@address)\", ctxt);\n    netmask = virXPathString(\"string(./@netmask)\", ctxt);\n    gateway = virXPathString(\"string(./@gateway)\", ctxt);\n    prefixRc = virXPathULong(\"string(./@prefix)\", ctxt, &prefix);\n    if (prefixRc == -2) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"%s: Invalid prefix specified \"\n                         \"in route definition\"),\n                       errorDetail);\n        goto cleanup;\n    }\n    hasPrefix = (prefixRc == 0);\n    metricRc = virXPathULong(\"string(./@metric)\", ctxt, &metric);\n    if (metricRc == -2) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"%s: Invalid metric specified \"\n                         \"in route definition\"),\n                       errorDetail);\n        goto cleanup;\n    }\n    if (metricRc == 0) {\n        hasMetric = true;\n        if (metric == 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"%s: Invalid metric value, must be > 0 \"\n                             \"in route definition\"),\n                           errorDetail);\n            goto cleanup;\n        }\n    }\n\n    def = virNetDevIPRouteCreate(errorDetail, family, address, netmask,\n                                 gateway, prefix, hasPrefix, metric,\n                                 hasMetric);\n\n cleanup:\n    ctxt->node = save;\n    VIR_FREE(family);\n    VIR_FREE(address);\n    VIR_FREE(netmask);\n    VIR_FREE(gateway);\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->routes",
            "nRoutes"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./route\"",
            "ctxt",
            "&routeNodes"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ipNodes"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefParseXML",
          "args": [
            "def->name",
            "ipNodes[i]",
            "ctxt",
            "&def->ips[i]"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "1019-1172",
          "snippet": "static int\nvirNetworkIPDefParseXML(const char *networkName,\n                        xmlNodePtr node,\n                        xmlXPathContextPtr ctxt,\n                        virNetworkIPDefPtr def)\n{\n    /*\n     * virNetworkIPDef object is already allocated as part of an array.\n     * On failure clear it out, but don't free it.\n     */\n\n    xmlNodePtr save;\n    xmlNodePtr dhcp;\n    char *address = NULL, *netmask = NULL;\n    unsigned long prefix = 0;\n    int prefixRc;\n    int result = -1;\n    char *localPtr = NULL;\n\n    save = ctxt->node;\n    ctxt->node = node;\n\n    /* grab raw data from XML */\n    def->family = virXPathString(\"string(./@family)\", ctxt);\n\n    address = virXPathString(\"string(./@address)\", ctxt);\n    if (!address) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Missing required address attribute in network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (virSocketAddrParse(&def->address, address, AF_UNSPEC) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid address '%s' in network '%s'\"),\n                       address, networkName);\n        goto cleanup;\n    }\n\n    netmask = virXPathString(\"string(./@netmask)\", ctxt);\n    if (netmask &&\n        (virSocketAddrParse(&def->netmask, netmask, AF_UNSPEC) < 0)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid netmask '%s' in network '%s'\"),\n                       netmask, networkName);\n        goto cleanup;\n    }\n\n    prefixRc = virXPathULong(\"string(./@prefix)\", ctxt, &prefix);\n    if (prefixRc == -2) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid ULong value specified for prefix in definition of network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (prefixRc < 0)\n        def->prefix = 0;\n    else\n        def->prefix = prefix;\n\n    localPtr = virXPathString(\"string(./@localPtr)\", ctxt);\n    if (localPtr) {\n        def->localPTR = virTristateBoolTypeFromString(localPtr);\n        if (def->localPTR <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid localPtr value '%s' in network '%s'\"),\n                           localPtr, networkName);\n            goto cleanup;\n        }\n    }\n\n    /* validate address, etc. for each family */\n    if ((def->family == NULL) || (STREQ(def->family, \"ipv4\"))) {\n        if (!(VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET) ||\n              VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_UNSPEC))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"%s family specified for non-IPv4 address '%s' in network '%s'\"),\n                           def->family == NULL? \"no\" : \"ipv4\", address, networkName);\n            goto cleanup;\n        }\n        if (netmask) {\n            if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid netmask '%s' for address '%s' \"\n                                 \"in network '%s' (both must be IPv4)\"),\n                               netmask, address, networkName);\n                goto cleanup;\n            }\n            if (def->prefix > 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Network '%s' IP address cannot have \"\n                                 \"both a prefix and a netmask\"), networkName);\n                goto cleanup;\n            }\n        } else if (def->prefix > 32) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Invalid IPv4 prefix '%lu' in network '%s'\"),\n                           prefix, networkName);\n            goto cleanup;\n        }\n    } else if (STREQ(def->family, \"ipv6\")) {\n        if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET6)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Family 'ipv6' specified for non-IPv6 address '%s' in network '%s'\"),\n                           address, networkName);\n            goto cleanup;\n        }\n        if (netmask) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"netmask not allowed for IPv6 address '%s' in network '%s'\"),\n                           address, networkName);\n            goto cleanup;\n        }\n        if (def->prefix > 128) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Invalid IPv6 prefix '%lu' in network '%s'\"),\n                           prefix, networkName);\n            goto cleanup;\n        }\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Unrecognized family '%s' in network '%s'\"),\n                       def->family, networkName);\n        goto cleanup;\n    }\n\n    if ((dhcp = virXPathNode(\"./dhcp[1]\", ctxt)) &&\n        virNetworkDHCPDefParseXML(networkName, dhcp, def) < 0)\n        goto cleanup;\n\n    if (virXPathNode(\"./tftp[1]\", ctxt)) {\n        if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <tftp> element in an IPv6 element \"\n                             \"in network '%s'\"),\n                           networkName);\n            goto cleanup;\n        }\n\n        def->tftproot = virXPathString(\"string(./tftp[1]/@root)\", ctxt);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        virNetworkIPDefClear(def);\n    VIR_FREE(address);\n    VIR_FREE(netmask);\n    VIR_FREE(localPtr);\n\n    ctxt->node = save;\n    return result;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkIPDefParseXML(const char *networkName,\n                        xmlNodePtr node,\n                        xmlXPathContextPtr ctxt,\n                        virNetworkIPDefPtr def)\n{\n    /*\n     * virNetworkIPDef object is already allocated as part of an array.\n     * On failure clear it out, but don't free it.\n     */\n\n    xmlNodePtr save;\n    xmlNodePtr dhcp;\n    char *address = NULL, *netmask = NULL;\n    unsigned long prefix = 0;\n    int prefixRc;\n    int result = -1;\n    char *localPtr = NULL;\n\n    save = ctxt->node;\n    ctxt->node = node;\n\n    /* grab raw data from XML */\n    def->family = virXPathString(\"string(./@family)\", ctxt);\n\n    address = virXPathString(\"string(./@address)\", ctxt);\n    if (!address) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Missing required address attribute in network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (virSocketAddrParse(&def->address, address, AF_UNSPEC) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid address '%s' in network '%s'\"),\n                       address, networkName);\n        goto cleanup;\n    }\n\n    netmask = virXPathString(\"string(./@netmask)\", ctxt);\n    if (netmask &&\n        (virSocketAddrParse(&def->netmask, netmask, AF_UNSPEC) < 0)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid netmask '%s' in network '%s'\"),\n                       netmask, networkName);\n        goto cleanup;\n    }\n\n    prefixRc = virXPathULong(\"string(./@prefix)\", ctxt, &prefix);\n    if (prefixRc == -2) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid ULong value specified for prefix in definition of network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (prefixRc < 0)\n        def->prefix = 0;\n    else\n        def->prefix = prefix;\n\n    localPtr = virXPathString(\"string(./@localPtr)\", ctxt);\n    if (localPtr) {\n        def->localPTR = virTristateBoolTypeFromString(localPtr);\n        if (def->localPTR <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid localPtr value '%s' in network '%s'\"),\n                           localPtr, networkName);\n            goto cleanup;\n        }\n    }\n\n    /* validate address, etc. for each family */\n    if ((def->family == NULL) || (STREQ(def->family, \"ipv4\"))) {\n        if (!(VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET) ||\n              VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_UNSPEC))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"%s family specified for non-IPv4 address '%s' in network '%s'\"),\n                           def->family == NULL? \"no\" : \"ipv4\", address, networkName);\n            goto cleanup;\n        }\n        if (netmask) {\n            if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid netmask '%s' for address '%s' \"\n                                 \"in network '%s' (both must be IPv4)\"),\n                               netmask, address, networkName);\n                goto cleanup;\n            }\n            if (def->prefix > 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Network '%s' IP address cannot have \"\n                                 \"both a prefix and a netmask\"), networkName);\n                goto cleanup;\n            }\n        } else if (def->prefix > 32) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Invalid IPv4 prefix '%lu' in network '%s'\"),\n                           prefix, networkName);\n            goto cleanup;\n        }\n    } else if (STREQ(def->family, \"ipv6\")) {\n        if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET6)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Family 'ipv6' specified for non-IPv6 address '%s' in network '%s'\"),\n                           address, networkName);\n            goto cleanup;\n        }\n        if (netmask) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"netmask not allowed for IPv6 address '%s' in network '%s'\"),\n                           address, networkName);\n            goto cleanup;\n        }\n        if (def->prefix > 128) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Invalid IPv6 prefix '%lu' in network '%s'\"),\n                           prefix, networkName);\n            goto cleanup;\n        }\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Unrecognized family '%s' in network '%s'\"),\n                       def->family, networkName);\n        goto cleanup;\n    }\n\n    if ((dhcp = virXPathNode(\"./dhcp[1]\", ctxt)) &&\n        virNetworkDHCPDefParseXML(networkName, dhcp, def) < 0)\n        goto cleanup;\n\n    if (virXPathNode(\"./tftp[1]\", ctxt)) {\n        if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <tftp> element in an IPv6 element \"\n                             \"in network '%s'\"),\n                           networkName);\n            goto cleanup;\n        }\n\n        def->tftproot = virXPathString(\"string(./tftp[1]/@root)\", ctxt);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        virNetworkIPDefClear(def);\n    VIR_FREE(address);\n    VIR_FREE(netmask);\n    VIR_FREE(localPtr);\n\n    ctxt->node = save;\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->ips",
            "nips"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "portGroupNodes"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkPortGroupParseXML",
          "args": [
            "&def->portGroups[i]",
            "portGroupNodes[i]",
            "ctxt"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkPortGroupParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "1195-1264",
          "snippet": "static int\nvirNetworkPortGroupParseXML(virPortGroupDefPtr def,\n                            xmlNodePtr node,\n                            xmlXPathContextPtr ctxt)\n{\n    /*\n     * virPortGroupDef object is already allocated as part of an array.\n     * On failure clear it out, but don't free it.\n     */\n\n    xmlNodePtr save;\n    xmlNodePtr virtPortNode;\n    xmlNodePtr vlanNode;\n    xmlNodePtr bandwidth_node;\n    char *isDefault = NULL;\n    char *trustGuestRxFilters = NULL;\n\n    int result = -1;\n\n    save = ctxt->node;\n    ctxt->node = node;\n\n    /* grab raw data from XML */\n    def->name = virXPathString(\"string(./@name)\", ctxt);\n    if (!def->name) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Missing required name attribute in portgroup\"));\n        goto cleanup;\n    }\n\n    isDefault = virXPathString(\"string(./@default)\", ctxt);\n    def->isDefault = isDefault && STRCASEEQ(isDefault, \"yes\");\n\n    trustGuestRxFilters\n        = virXPathString(\"string(./@trustGuestRxFilters)\", ctxt);\n    if (trustGuestRxFilters) {\n        if ((def->trustGuestRxFilters\n             = virTristateBoolTypeFromString(trustGuestRxFilters)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid trustGuestRxFilters setting '%s' \"\n                             \"in portgroup\"), trustGuestRxFilters);\n            goto cleanup;\n        }\n    }\n\n    virtPortNode = virXPathNode(\"./virtualport\", ctxt);\n    if (virtPortNode &&\n        (!(def->virtPortProfile = virNetDevVPortProfileParse(virtPortNode, 0)))) {\n        goto cleanup;\n    }\n\n    bandwidth_node = virXPathNode(\"./bandwidth\", ctxt);\n    if (bandwidth_node &&\n        virNetDevBandwidthParse(&def->bandwidth, NULL, bandwidth_node, false) < 0)\n        goto cleanup;\n\n    vlanNode = virXPathNode(\"./vlan\", ctxt);\n    if (vlanNode && virNetDevVlanParse(vlanNode, ctxt, &def->vlan) < 0)\n        goto cleanup;\n\n    result = 0;\n cleanup:\n    if (result < 0)\n        virPortGroupDefClear(def);\n    VIR_FREE(isDefault);\n    VIR_FREE(trustGuestRxFilters);\n\n    ctxt->node = save;\n    return result;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkPortGroupParseXML(virPortGroupDefPtr def,\n                            xmlNodePtr node,\n                            xmlXPathContextPtr ctxt)\n{\n    /*\n     * virPortGroupDef object is already allocated as part of an array.\n     * On failure clear it out, but don't free it.\n     */\n\n    xmlNodePtr save;\n    xmlNodePtr virtPortNode;\n    xmlNodePtr vlanNode;\n    xmlNodePtr bandwidth_node;\n    char *isDefault = NULL;\n    char *trustGuestRxFilters = NULL;\n\n    int result = -1;\n\n    save = ctxt->node;\n    ctxt->node = node;\n\n    /* grab raw data from XML */\n    def->name = virXPathString(\"string(./@name)\", ctxt);\n    if (!def->name) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Missing required name attribute in portgroup\"));\n        goto cleanup;\n    }\n\n    isDefault = virXPathString(\"string(./@default)\", ctxt);\n    def->isDefault = isDefault && STRCASEEQ(isDefault, \"yes\");\n\n    trustGuestRxFilters\n        = virXPathString(\"string(./@trustGuestRxFilters)\", ctxt);\n    if (trustGuestRxFilters) {\n        if ((def->trustGuestRxFilters\n             = virTristateBoolTypeFromString(trustGuestRxFilters)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid trustGuestRxFilters setting '%s' \"\n                             \"in portgroup\"), trustGuestRxFilters);\n            goto cleanup;\n        }\n    }\n\n    virtPortNode = virXPathNode(\"./virtualport\", ctxt);\n    if (virtPortNode &&\n        (!(def->virtPortProfile = virNetDevVPortProfileParse(virtPortNode, 0)))) {\n        goto cleanup;\n    }\n\n    bandwidth_node = virXPathNode(\"./bandwidth\", ctxt);\n    if (bandwidth_node &&\n        virNetDevBandwidthParse(&def->bandwidth, NULL, bandwidth_node, false) < 0)\n        goto cleanup;\n\n    vlanNode = virXPathNode(\"./vlan\", ctxt);\n    if (vlanNode && virNetDevVlanParse(vlanNode, ctxt, &def->vlan) < 0)\n        goto cleanup;\n\n    result = 0;\n cleanup:\n    if (result < 0)\n        virPortGroupDefClear(def);\n    VIR_FREE(isDefault);\n    VIR_FREE(trustGuestRxFilters);\n\n    ctxt->node = save;\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->portGroups",
            "nPortGroups"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileParse",
          "args": [
            "virtPortNode",
            "VIR_VPORT_XML_REQUIRE_TYPE"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_vport_profile_conf.c",
          "lines": "29-196",
          "snippet": "virNetDevVPortProfilePtr\nvirNetDevVPortProfileParse(xmlNodePtr node, unsigned int flags)\n{\n    char *virtPortType;\n    char *virtPortManagerID = NULL;\n    char *virtPortTypeID = NULL;\n    char *virtPortTypeIDVersion = NULL;\n    char *virtPortInstanceID = NULL;\n    char *virtPortProfileID = NULL;\n    char *virtPortInterfaceID = NULL;\n    virNetDevVPortProfilePtr virtPort = NULL;\n    xmlNodePtr cur = node->children;\n\n    if (VIR_ALLOC(virtPort) < 0)\n        return NULL;\n\n    if ((virtPortType = virXMLPropString(node, \"type\")) &&\n        (virtPort->virtPortType = virNetDevVPortTypeFromString(virtPortType)) <= 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown virtualport type %s\"), virtPortType);\n        goto error;\n    }\n\n    if ((virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE) &&\n        (flags & VIR_VPORT_XML_REQUIRE_TYPE)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing required virtualport type\"));\n        goto error;\n    }\n\n    while (cur != NULL) {\n        if (virXMLNodeNameEqual(cur, \"parameters\")) {\n            virtPortManagerID = virXMLPropString(cur, \"managerid\");\n            virtPortTypeID = virXMLPropString(cur, \"typeid\");\n            virtPortTypeIDVersion = virXMLPropString(cur, \"typeidversion\");\n            virtPortInstanceID = virXMLPropString(cur, \"instanceid\");\n            virtPortProfileID = virXMLPropString(cur, \"profileid\");\n            virtPortInterfaceID = virXMLPropString(cur, \"interfaceid\");\n            break;\n        }\n        cur = cur->next;\n    }\n\n    if (virtPortManagerID) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortManagerID, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of managerid parameter\"));\n            goto error;\n        }\n        if (val > 0xff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value of managerid out of range\"));\n            goto error;\n        }\n        virtPort->managerID = (uint8_t)val;\n        virtPort->managerID_specified = true;\n    }\n\n    if (virtPortTypeID) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortTypeID, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of typeid parameter\"));\n            goto error;\n        }\n        if (val > 0xffffff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value for typeid out of range\"));\n            goto error;\n        }\n        virtPort->typeID = (uint32_t)val;\n        virtPort->typeID_specified = true;\n    }\n\n    if (virtPortTypeIDVersion) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortTypeIDVersion, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of typeidversion parameter\"));\n            goto error;\n        }\n        if (val > 0xff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value of typeidversion out of range\"));\n            goto error;\n        }\n        virtPort->typeIDVersion = (uint8_t)val;\n        virtPort->typeIDVersion_specified = true;\n    }\n\n    if (virtPortInstanceID) {\n        if (virUUIDParse(virtPortInstanceID, virtPort->instanceID) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse instanceid parameter as a uuid\"));\n            goto error;\n        }\n        virtPort->instanceID_specified = true;\n    }\n\n    if (virtPortProfileID &&\n        virStrcpyStatic(virtPort->profileID, virtPortProfileID) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"profileid parameter too long\"));\n        goto error;\n    }\n\n    if (virtPortInterfaceID) {\n        if (virUUIDParse(virtPortInterfaceID, virtPort->interfaceID) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse interfaceid parameter as a uuid\"));\n            goto error;\n        }\n        virtPort->interfaceID_specified = true;\n    }\n\n    /* generate default instanceID/interfaceID if appropriate */\n    if (flags & VIR_VPORT_XML_GENERATE_MISSING_DEFAULTS) {\n        if (!virtPort->instanceID_specified &&\n            (virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n             virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n            if (virUUIDGenerate(virtPort->instanceID) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot generate a random uuid for instanceid\"));\n                goto error;\n            }\n            virtPort->instanceID_specified = true;\n        }\n        if (!virtPort->interfaceID_specified &&\n            (virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n             virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n            if (virUUIDGenerate(virtPort->interfaceID) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot generate a random uuid for interfaceid\"));\n                goto error;\n            }\n            virtPort->interfaceID_specified = true;\n        }\n    }\n\n    /* check for required/unsupported attributes */\n\n    if ((flags & VIR_VPORT_XML_REQUIRE_ALL_ATTRIBUTES) &&\n        (virNetDevVPortProfileCheckComplete(virtPort, false) < 0)) {\n        goto error;\n    }\n\n    if (virNetDevVPortProfileCheckNoExtras(virtPort) < 0)\n        goto error;\n\n cleanup:\n    VIR_FREE(virtPortManagerID);\n    VIR_FREE(virtPortTypeID);\n    VIR_FREE(virtPortTypeIDVersion);\n    VIR_FREE(virtPortInstanceID);\n    VIR_FREE(virtPortProfileID);\n    VIR_FREE(virtPortType);\n    VIR_FREE(virtPortInterfaceID);\n\n    return virtPort;\n\n error:\n    VIR_FREE(virtPort);\n    goto cleanup;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include <config.h>\n\nvirNetDevVPortProfilePtr\nvirNetDevVPortProfileParse(xmlNodePtr node, unsigned int flags)\n{\n    char *virtPortType;\n    char *virtPortManagerID = NULL;\n    char *virtPortTypeID = NULL;\n    char *virtPortTypeIDVersion = NULL;\n    char *virtPortInstanceID = NULL;\n    char *virtPortProfileID = NULL;\n    char *virtPortInterfaceID = NULL;\n    virNetDevVPortProfilePtr virtPort = NULL;\n    xmlNodePtr cur = node->children;\n\n    if (VIR_ALLOC(virtPort) < 0)\n        return NULL;\n\n    if ((virtPortType = virXMLPropString(node, \"type\")) &&\n        (virtPort->virtPortType = virNetDevVPortTypeFromString(virtPortType)) <= 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown virtualport type %s\"), virtPortType);\n        goto error;\n    }\n\n    if ((virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE) &&\n        (flags & VIR_VPORT_XML_REQUIRE_TYPE)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing required virtualport type\"));\n        goto error;\n    }\n\n    while (cur != NULL) {\n        if (virXMLNodeNameEqual(cur, \"parameters\")) {\n            virtPortManagerID = virXMLPropString(cur, \"managerid\");\n            virtPortTypeID = virXMLPropString(cur, \"typeid\");\n            virtPortTypeIDVersion = virXMLPropString(cur, \"typeidversion\");\n            virtPortInstanceID = virXMLPropString(cur, \"instanceid\");\n            virtPortProfileID = virXMLPropString(cur, \"profileid\");\n            virtPortInterfaceID = virXMLPropString(cur, \"interfaceid\");\n            break;\n        }\n        cur = cur->next;\n    }\n\n    if (virtPortManagerID) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortManagerID, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of managerid parameter\"));\n            goto error;\n        }\n        if (val > 0xff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value of managerid out of range\"));\n            goto error;\n        }\n        virtPort->managerID = (uint8_t)val;\n        virtPort->managerID_specified = true;\n    }\n\n    if (virtPortTypeID) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortTypeID, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of typeid parameter\"));\n            goto error;\n        }\n        if (val > 0xffffff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value for typeid out of range\"));\n            goto error;\n        }\n        virtPort->typeID = (uint32_t)val;\n        virtPort->typeID_specified = true;\n    }\n\n    if (virtPortTypeIDVersion) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortTypeIDVersion, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of typeidversion parameter\"));\n            goto error;\n        }\n        if (val > 0xff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value of typeidversion out of range\"));\n            goto error;\n        }\n        virtPort->typeIDVersion = (uint8_t)val;\n        virtPort->typeIDVersion_specified = true;\n    }\n\n    if (virtPortInstanceID) {\n        if (virUUIDParse(virtPortInstanceID, virtPort->instanceID) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse instanceid parameter as a uuid\"));\n            goto error;\n        }\n        virtPort->instanceID_specified = true;\n    }\n\n    if (virtPortProfileID &&\n        virStrcpyStatic(virtPort->profileID, virtPortProfileID) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"profileid parameter too long\"));\n        goto error;\n    }\n\n    if (virtPortInterfaceID) {\n        if (virUUIDParse(virtPortInterfaceID, virtPort->interfaceID) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse interfaceid parameter as a uuid\"));\n            goto error;\n        }\n        virtPort->interfaceID_specified = true;\n    }\n\n    /* generate default instanceID/interfaceID if appropriate */\n    if (flags & VIR_VPORT_XML_GENERATE_MISSING_DEFAULTS) {\n        if (!virtPort->instanceID_specified &&\n            (virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n             virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n            if (virUUIDGenerate(virtPort->instanceID) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot generate a random uuid for instanceid\"));\n                goto error;\n            }\n            virtPort->instanceID_specified = true;\n        }\n        if (!virtPort->interfaceID_specified &&\n            (virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n             virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n            if (virUUIDGenerate(virtPort->interfaceID) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot generate a random uuid for interfaceid\"));\n                goto error;\n            }\n            virtPort->interfaceID_specified = true;\n        }\n    }\n\n    /* check for required/unsupported attributes */\n\n    if ((flags & VIR_VPORT_XML_REQUIRE_ALL_ATTRIBUTES) &&\n        (virNetDevVPortProfileCheckComplete(virtPort, false) < 0)) {\n        goto error;\n    }\n\n    if (virNetDevVPortProfileCheckNoExtras(virtPort) < 0)\n        goto error;\n\n cleanup:\n    VIR_FREE(virtPortManagerID);\n    VIR_FREE(virtPortTypeID);\n    VIR_FREE(virtPortTypeIDVersion);\n    VIR_FREE(virtPortInstanceID);\n    VIR_FREE(virtPortProfileID);\n    VIR_FREE(virtPortType);\n    VIR_FREE(virtPortInterfaceID);\n\n    return virtPort;\n\n error:\n    VIR_FREE(virtPort);\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDNSDefParseXML",
          "args": [
            "def->name",
            "dnsNode",
            "ctxt",
            "&def->dns"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDNSDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "860-1016",
          "snippet": "static int\nvirNetworkDNSDefParseXML(const char *networkName,\n                         xmlNodePtr node,\n                         xmlXPathContextPtr ctxt,\n                         virNetworkDNSDefPtr def)\n{\n    xmlNodePtr *hostNodes = NULL;\n    xmlNodePtr *srvNodes = NULL;\n    xmlNodePtr *txtNodes = NULL;\n    xmlNodePtr *fwdNodes = NULL;\n    char *forwardPlainNames = NULL;\n    char *enable = NULL;\n    int nhosts, nsrvs, ntxts, nfwds;\n    size_t i;\n    int ret = -1;\n    xmlNodePtr save = ctxt->node;\n\n    ctxt->node = node;\n\n    enable = virXPathString(\"string(./@enable)\", ctxt);\n    if (enable) {\n        def->enable = virTristateBoolTypeFromString(enable);\n        if (def->enable <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid dns enable setting '%s' \"\n                             \"in network '%s'\"),\n                           enable, networkName);\n            goto cleanup;\n        }\n    }\n\n    forwardPlainNames = virXPathString(\"string(./@forwardPlainNames)\", ctxt);\n    if (forwardPlainNames) {\n        def->forwardPlainNames = virTristateBoolTypeFromString(forwardPlainNames);\n        if (def->forwardPlainNames <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid dns forwardPlainNames setting '%s' \"\n                             \"in network '%s'\"),\n                           forwardPlainNames, networkName);\n            goto cleanup;\n        }\n    }\n\n    nfwds = virXPathNodeSet(\"./forwarder\", ctxt, &fwdNodes);\n    if (nfwds < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <forwarder> element found in <dns> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (nfwds > 0) {\n        if (VIR_ALLOC_N(def->forwarders, nfwds) < 0)\n            goto cleanup;\n\n        for (i = 0; i < nfwds; i++) {\n            char *addr = virXMLPropString(fwdNodes[i], \"addr\");\n\n            if (addr && virSocketAddrParse(&def->forwarders[i].addr,\n                                           addr, AF_UNSPEC) < 0) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"Invalid forwarder IP address '%s' \"\n                                 \"in network '%s'\"),\n                               addr, networkName);\n                VIR_FREE(addr);\n                goto cleanup;\n            }\n            def->forwarders[i].domain = virXMLPropString(fwdNodes[i], \"domain\");\n            if (!(addr || def->forwarders[i].domain)) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"Invalid forwarder element, must contain \"\n                                 \"at least one of addr or domain\"));\n                goto cleanup;\n            }\n            VIR_FREE(addr);\n            def->nfwds++;\n        }\n    }\n\n    nhosts = virXPathNodeSet(\"./host\", ctxt, &hostNodes);\n    if (nhosts < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <host> element found in <dns> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (nhosts > 0) {\n        if (VIR_ALLOC_N(def->hosts, nhosts) < 0)\n            goto cleanup;\n\n        for (i = 0; i < nhosts; i++) {\n            if (virNetworkDNSHostDefParseXML(networkName, hostNodes[i],\n                                             &def->hosts[def->nhosts], false) < 0) {\n                goto cleanup;\n            }\n            def->nhosts++;\n        }\n    }\n\n    nsrvs = virXPathNodeSet(\"./srv\", ctxt, &srvNodes);\n    if (nsrvs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <srv> element found in <dns> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (nsrvs > 0) {\n        if (VIR_ALLOC_N(def->srvs, nsrvs) < 0)\n            goto cleanup;\n\n        for (i = 0; i < nsrvs; i++) {\n            if (virNetworkDNSSrvDefParseXML(networkName, srvNodes[i], ctxt,\n                                            &def->srvs[def->nsrvs], false) < 0) {\n                goto cleanup;\n            }\n            def->nsrvs++;\n        }\n    }\n\n    ntxts = virXPathNodeSet(\"./txt\", ctxt, &txtNodes);\n    if (ntxts < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <txt> element found in <dns> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (ntxts > 0) {\n        if (VIR_ALLOC_N(def->txts, ntxts) < 0)\n            goto cleanup;\n\n        for (i = 0; i < ntxts; i++) {\n            if (virNetworkDNSTxtDefParseXML(networkName, txtNodes[i],\n                                            &def->txts[def->ntxts], false) < 0) {\n                goto cleanup;\n            }\n            def->ntxts++;\n        }\n    }\n\n    if (def->enable == VIR_TRISTATE_BOOL_NO &&\n        (nfwds || nhosts || nsrvs || ntxts)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Extra data in disabled network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(enable);\n    VIR_FREE(forwardPlainNames);\n    VIR_FREE(fwdNodes);\n    VIR_FREE(hostNodes);\n    VIR_FREE(srvNodes);\n    VIR_FREE(txtNodes);\n    ctxt->node = save;\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDNSDefParseXML(const char *networkName,\n                         xmlNodePtr node,\n                         xmlXPathContextPtr ctxt,\n                         virNetworkDNSDefPtr def)\n{\n    xmlNodePtr *hostNodes = NULL;\n    xmlNodePtr *srvNodes = NULL;\n    xmlNodePtr *txtNodes = NULL;\n    xmlNodePtr *fwdNodes = NULL;\n    char *forwardPlainNames = NULL;\n    char *enable = NULL;\n    int nhosts, nsrvs, ntxts, nfwds;\n    size_t i;\n    int ret = -1;\n    xmlNodePtr save = ctxt->node;\n\n    ctxt->node = node;\n\n    enable = virXPathString(\"string(./@enable)\", ctxt);\n    if (enable) {\n        def->enable = virTristateBoolTypeFromString(enable);\n        if (def->enable <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid dns enable setting '%s' \"\n                             \"in network '%s'\"),\n                           enable, networkName);\n            goto cleanup;\n        }\n    }\n\n    forwardPlainNames = virXPathString(\"string(./@forwardPlainNames)\", ctxt);\n    if (forwardPlainNames) {\n        def->forwardPlainNames = virTristateBoolTypeFromString(forwardPlainNames);\n        if (def->forwardPlainNames <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid dns forwardPlainNames setting '%s' \"\n                             \"in network '%s'\"),\n                           forwardPlainNames, networkName);\n            goto cleanup;\n        }\n    }\n\n    nfwds = virXPathNodeSet(\"./forwarder\", ctxt, &fwdNodes);\n    if (nfwds < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <forwarder> element found in <dns> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (nfwds > 0) {\n        if (VIR_ALLOC_N(def->forwarders, nfwds) < 0)\n            goto cleanup;\n\n        for (i = 0; i < nfwds; i++) {\n            char *addr = virXMLPropString(fwdNodes[i], \"addr\");\n\n            if (addr && virSocketAddrParse(&def->forwarders[i].addr,\n                                           addr, AF_UNSPEC) < 0) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"Invalid forwarder IP address '%s' \"\n                                 \"in network '%s'\"),\n                               addr, networkName);\n                VIR_FREE(addr);\n                goto cleanup;\n            }\n            def->forwarders[i].domain = virXMLPropString(fwdNodes[i], \"domain\");\n            if (!(addr || def->forwarders[i].domain)) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"Invalid forwarder element, must contain \"\n                                 \"at least one of addr or domain\"));\n                goto cleanup;\n            }\n            VIR_FREE(addr);\n            def->nfwds++;\n        }\n    }\n\n    nhosts = virXPathNodeSet(\"./host\", ctxt, &hostNodes);\n    if (nhosts < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <host> element found in <dns> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (nhosts > 0) {\n        if (VIR_ALLOC_N(def->hosts, nhosts) < 0)\n            goto cleanup;\n\n        for (i = 0; i < nhosts; i++) {\n            if (virNetworkDNSHostDefParseXML(networkName, hostNodes[i],\n                                             &def->hosts[def->nhosts], false) < 0) {\n                goto cleanup;\n            }\n            def->nhosts++;\n        }\n    }\n\n    nsrvs = virXPathNodeSet(\"./srv\", ctxt, &srvNodes);\n    if (nsrvs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <srv> element found in <dns> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (nsrvs > 0) {\n        if (VIR_ALLOC_N(def->srvs, nsrvs) < 0)\n            goto cleanup;\n\n        for (i = 0; i < nsrvs; i++) {\n            if (virNetworkDNSSrvDefParseXML(networkName, srvNodes[i], ctxt,\n                                            &def->srvs[def->nsrvs], false) < 0) {\n                goto cleanup;\n            }\n            def->nsrvs++;\n        }\n    }\n\n    ntxts = virXPathNodeSet(\"./txt\", ctxt, &txtNodes);\n    if (ntxts < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <txt> element found in <dns> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (ntxts > 0) {\n        if (VIR_ALLOC_N(def->txts, ntxts) < 0)\n            goto cleanup;\n\n        for (i = 0; i < ntxts; i++) {\n            if (virNetworkDNSTxtDefParseXML(networkName, txtNodes[i],\n                                            &def->txts[def->ntxts], false) < 0) {\n                goto cleanup;\n            }\n            def->ntxts++;\n        }\n    }\n\n    if (def->enable == VIR_TRISTATE_BOOL_NO &&\n        (nfwds || nhosts || nsrvs || ntxts)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Extra data in disabled network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(enable);\n    VIR_FREE(forwardPlainNames);\n    VIR_FREE(fwdNodes);\n    VIR_FREE(hostNodes);\n    VIR_FREE(srvNodes);\n    VIR_FREE(txtNodes);\n    ctxt->node = save;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid mtu size '%s' in network '%s'\")",
            "tmp",
            "def->name"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "tmp",
            "NULL",
            "10",
            "&def->mtu"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./mtu/@size)\"",
            "ctxt"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid multicast bridge mac address '%s' in network '%s'\")",
            "tmp",
            "def->name"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrIsMulticast",
          "args": [
            "&def->mac"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrIsMulticast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "232-236",
          "snippet": "bool\nvirMacAddrIsMulticast(const virMacAddr *mac)\n{\n    return !!(mac->addr[0] & 1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nbool\nvirMacAddrIsMulticast(const virMacAddr *mac)\n{\n    return !!(mac->addr[0] & 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid bridge mac address '%s' in network '%s'\")",
            "tmp",
            "def->name"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrParse",
          "args": [
            "tmp",
            "&def->mac"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "205-218",
          "snippet": "int\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid macTableManager setting '%s' \"\n                             \"in network '%s'\")",
            "tmp",
            "def->name"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkBridgeMACTableManagerTypeFromString",
          "args": [
            "tmp"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid delay value in network '%s'\")",
            "def->name"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ulp",
          "args": [
            "tmp",
            "NULL",
            "10",
            "&def->delay"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ulp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "505-523",
          "snippet": "int\nvirStrToLong_ulp(char const *s, char **end_ptr, int base,\n                 unsigned long *result)\n{\n    unsigned long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ulp(char const *s, char **end_ptr, int base,\n                 unsigned long *result)\n{\n    unsigned long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "stp",
            "\"off\""
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkPortOptionsParseXML",
          "args": [
            "ctxt",
            "&def->isolatedPort"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkPortOptionsParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "1175-1192",
          "snippet": "int\nvirNetworkPortOptionsParseXML(xmlXPathContextPtr ctxt,\n                              virTristateBool *isolatedPort)\n{\n    g_autofree char *str = NULL;\n    int tmp = VIR_TRISTATE_BOOL_ABSENT;\n\n    if ((str = virXPathString(\"string(./port/@isolated)\", ctxt))) {\n        if ((tmp = virTristateBoolTypeFromString(str)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown port isolated value '%s'\"), str);\n            return -1;\n        }\n    }\n\n    *isolatedPort = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkPortOptionsParseXML(xmlXPathContextPtr ctxt,\n                              virTristateBool *isolatedPort)\n{\n    g_autofree char *str = NULL;\n    int tmp = VIR_TRISTATE_BOOL_ABSENT;\n\n    if ((str = virXPathString(\"string(./port/@isolated)\", ctxt))) {\n        if ((tmp = virTristateBoolTypeFromString(str)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown port isolated value '%s'\"), str);\n            return -1;\n        }\n    }\n\n    *isolatedPort = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVlanParse",
          "args": [
            "vlanNode",
            "ctxt",
            "&def->vlan"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVlanParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_vlan_conf.c",
          "lines": "32-138",
          "snippet": "int\nvirNetDevVlanParse(xmlNodePtr node, xmlXPathContextPtr ctxt, virNetDevVlanPtr def)\n{\n    int ret = -1;\n    xmlNodePtr save = ctxt->node;\n    char *trunk = NULL;\n    char *nativeMode = NULL;\n    xmlNodePtr *tagNodes = NULL;\n    int nTags;\n    size_t i;\n\n    ctxt->node = node;\n\n    nTags = virXPathNodeSet(\"./tag\", ctxt, &tagNodes);\n    if (nTags < 0)\n        goto cleanup;\n\n    if (nTags == 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing tag id - each <vlan> must have \"\n                         \"at least one <tag id='n'/> subelement\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(def->tag, nTags) < 0)\n        goto cleanup;\n\n    def->nativeMode = 0;\n    def->nativeTag = 0;\n    for (i = 0; i < nTags; i++) {\n        unsigned long id;\n\n        ctxt->node = tagNodes[i];\n        if (virXPathULong(\"string(./@id)\", ctxt, &id) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing or invalid vlan tag id attribute\"));\n            goto cleanup;\n        }\n        if (id > 4095) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"vlan tag id %lu too large (maximum 4095)\"), id);\n            goto cleanup;\n        }\n        if ((nativeMode = virXPathString(\"string(./@nativeMode)\", ctxt))) {\n            if (def->nativeMode != 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"duplicate native vlan setting\"));\n                goto cleanup;\n            }\n            if ((def->nativeMode\n                 = virNativeVlanModeTypeFromString(nativeMode)) <= 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid \\\"nativeMode='%s'\\\" \"\n                                 \"in vlan <tag> element\"),\n                               nativeMode);\n                goto cleanup;\n            }\n            VIR_FREE(nativeMode);\n            def->nativeTag = id;\n        }\n        def->tag[i] = id;\n    }\n\n    def->nTags = nTags;\n\n    /* now that we know how many tags there are, look for an explicit\n     * trunk setting.\n     */\n    if (nTags > 1)\n        def->trunk = true;\n\n    ctxt->node = node;\n    if ((trunk = virXPathString(\"string(./@trunk)\", ctxt)) != NULL) {\n        def->trunk = STRCASEEQ(trunk, \"yes\");\n        if (!def->trunk) {\n            if (nTags > 1) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"invalid \\\"trunk='%s'\\\" in <vlan> - trunk='yes' \"\n                                 \"is required for more than one vlan tag\"), trunk);\n                goto cleanup;\n            }\n            if (def->nativeMode != 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"invalid configuration in <vlan> - \\\"trunk='no'\\\" is \"\n                                 \"not allowed with a native vlan id\"));\n                goto cleanup;\n            }\n            /* allow (but discard) \"trunk='no' if there is a single tag */\n            if (STRCASENEQ(trunk, \"no\")) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"invalid \\\"trunk='%s'\\\" in <vlan> \"\n                                 \"- must be yes or no\"), trunk);\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    ctxt->node = save;\n    VIR_FREE(tagNodes);\n    VIR_FREE(trunk);\n    VIR_FREE(nativeMode);\n    if (ret < 0)\n        virNetDevVlanClear(def);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_vlan_conf.h\"\n#include <config.h>\n\nint\nvirNetDevVlanParse(xmlNodePtr node, xmlXPathContextPtr ctxt, virNetDevVlanPtr def)\n{\n    int ret = -1;\n    xmlNodePtr save = ctxt->node;\n    char *trunk = NULL;\n    char *nativeMode = NULL;\n    xmlNodePtr *tagNodes = NULL;\n    int nTags;\n    size_t i;\n\n    ctxt->node = node;\n\n    nTags = virXPathNodeSet(\"./tag\", ctxt, &tagNodes);\n    if (nTags < 0)\n        goto cleanup;\n\n    if (nTags == 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing tag id - each <vlan> must have \"\n                         \"at least one <tag id='n'/> subelement\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(def->tag, nTags) < 0)\n        goto cleanup;\n\n    def->nativeMode = 0;\n    def->nativeTag = 0;\n    for (i = 0; i < nTags; i++) {\n        unsigned long id;\n\n        ctxt->node = tagNodes[i];\n        if (virXPathULong(\"string(./@id)\", ctxt, &id) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing or invalid vlan tag id attribute\"));\n            goto cleanup;\n        }\n        if (id > 4095) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"vlan tag id %lu too large (maximum 4095)\"), id);\n            goto cleanup;\n        }\n        if ((nativeMode = virXPathString(\"string(./@nativeMode)\", ctxt))) {\n            if (def->nativeMode != 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"duplicate native vlan setting\"));\n                goto cleanup;\n            }\n            if ((def->nativeMode\n                 = virNativeVlanModeTypeFromString(nativeMode)) <= 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid \\\"nativeMode='%s'\\\" \"\n                                 \"in vlan <tag> element\"),\n                               nativeMode);\n                goto cleanup;\n            }\n            VIR_FREE(nativeMode);\n            def->nativeTag = id;\n        }\n        def->tag[i] = id;\n    }\n\n    def->nTags = nTags;\n\n    /* now that we know how many tags there are, look for an explicit\n     * trunk setting.\n     */\n    if (nTags > 1)\n        def->trunk = true;\n\n    ctxt->node = node;\n    if ((trunk = virXPathString(\"string(./@trunk)\", ctxt)) != NULL) {\n        def->trunk = STRCASEEQ(trunk, \"yes\");\n        if (!def->trunk) {\n            if (nTags > 1) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"invalid \\\"trunk='%s'\\\" in <vlan> - trunk='yes' \"\n                                 \"is required for more than one vlan tag\"), trunk);\n                goto cleanup;\n            }\n            if (def->nativeMode != 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"invalid configuration in <vlan> - \\\"trunk='no'\\\" is \"\n                                 \"not allowed with a native vlan id\"));\n                goto cleanup;\n            }\n            /* allow (but discard) \"trunk='no' if there is a single tag */\n            if (STRCASENEQ(trunk, \"no\")) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"invalid \\\"trunk='%s'\\\" in <vlan> \"\n                                 \"- must be yes or no\"), trunk);\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    ctxt->node = save;\n    VIR_FREE(tagNodes);\n    VIR_FREE(trunk);\n    VIR_FREE(nativeMode);\n    if (ret < 0)\n        virNetDevVlanClear(def);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthParse",
          "args": [
            "&def->bandwidth",
            "NULL",
            "bandwidthNode",
            "false"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_bandwidth_conf.c",
          "lines": "112-219",
          "snippet": "int\nvirNetDevBandwidthParse(virNetDevBandwidthPtr *bandwidth,\n                        unsigned int *class_id,\n                        xmlNodePtr node,\n                        bool allowFloor)\n{\n    int ret = -1;\n    virNetDevBandwidthPtr def = NULL;\n    xmlNodePtr cur;\n    xmlNodePtr in = NULL, out = NULL;\n    char *class_id_prop = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return ret;\n\n    if (!node || !virXMLNodeNameEqual(node, \"bandwidth\")) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"invalid argument supplied\"));\n        goto cleanup;\n    }\n\n    class_id_prop = virXMLPropString(node, \"classID\");\n    if (class_id_prop) {\n        if (!class_id) {\n            virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                           _(\"classID attribute not supported on <bandwidth> \"\n                             \"in this usage context\"));\n            goto cleanup;\n        }\n        if (virStrToLong_ui(class_id_prop, NULL, 10, class_id) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to parse class id '%s'\"),\n                           class_id_prop);\n            goto cleanup;\n        }\n    }\n\n    cur = node->children;\n\n    while (cur) {\n        if (cur->type == XML_ELEMENT_NODE) {\n            if (virXMLNodeNameEqual(cur, \"inbound\")) {\n                if (in) {\n                    virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                                   _(\"Only one child <inbound> \"\n                                     \"element allowed\"));\n                    goto cleanup;\n                }\n                in = cur;\n            } else if (virXMLNodeNameEqual(cur, \"outbound\")) {\n                if (out) {\n                    virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                                   _(\"Only one child <outbound> \"\n                                     \"element allowed\"));\n                    goto cleanup;\n                }\n                out = cur;\n            }\n            /* Silently ignore unknown elements */\n        }\n        cur = cur->next;\n    }\n\n    if (in) {\n        if (VIR_ALLOC(def->in) < 0)\n            goto cleanup;\n\n        if (virNetDevBandwidthParseRate(in, def->in) < 0) {\n            /* helper reported error for us */\n            goto cleanup;\n        }\n\n        if (def->in->floor && !allowFloor) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"floor attribute is not supported for this config\"));\n            goto cleanup;\n        }\n    }\n\n    if (out) {\n        if (VIR_ALLOC(def->out) < 0)\n            goto cleanup;\n\n        if (virNetDevBandwidthParseRate(out, def->out) < 0) {\n            /* helper reported error for us */\n            goto cleanup;\n        }\n\n        if (def->out->floor) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"'floor' attribute allowed \"\n                             \"only in <inbound> element\"));\n            goto cleanup;\n        }\n    }\n\n    if (!def->in && !def->out)\n        VIR_FREE(def);\n\n    *bandwidth = def;\n    def = NULL;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(class_id_prop);\n    virNetDevBandwidthFree(def);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include <config.h>\n\nint\nvirNetDevBandwidthParse(virNetDevBandwidthPtr *bandwidth,\n                        unsigned int *class_id,\n                        xmlNodePtr node,\n                        bool allowFloor)\n{\n    int ret = -1;\n    virNetDevBandwidthPtr def = NULL;\n    xmlNodePtr cur;\n    xmlNodePtr in = NULL, out = NULL;\n    char *class_id_prop = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return ret;\n\n    if (!node || !virXMLNodeNameEqual(node, \"bandwidth\")) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"invalid argument supplied\"));\n        goto cleanup;\n    }\n\n    class_id_prop = virXMLPropString(node, \"classID\");\n    if (class_id_prop) {\n        if (!class_id) {\n            virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                           _(\"classID attribute not supported on <bandwidth> \"\n                             \"in this usage context\"));\n            goto cleanup;\n        }\n        if (virStrToLong_ui(class_id_prop, NULL, 10, class_id) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to parse class id '%s'\"),\n                           class_id_prop);\n            goto cleanup;\n        }\n    }\n\n    cur = node->children;\n\n    while (cur) {\n        if (cur->type == XML_ELEMENT_NODE) {\n            if (virXMLNodeNameEqual(cur, \"inbound\")) {\n                if (in) {\n                    virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                                   _(\"Only one child <inbound> \"\n                                     \"element allowed\"));\n                    goto cleanup;\n                }\n                in = cur;\n            } else if (virXMLNodeNameEqual(cur, \"outbound\")) {\n                if (out) {\n                    virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                                   _(\"Only one child <outbound> \"\n                                     \"element allowed\"));\n                    goto cleanup;\n                }\n                out = cur;\n            }\n            /* Silently ignore unknown elements */\n        }\n        cur = cur->next;\n    }\n\n    if (in) {\n        if (VIR_ALLOC(def->in) < 0)\n            goto cleanup;\n\n        if (virNetDevBandwidthParseRate(in, def->in) < 0) {\n            /* helper reported error for us */\n            goto cleanup;\n        }\n\n        if (def->in->floor && !allowFloor) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"floor attribute is not supported for this config\"));\n            goto cleanup;\n        }\n    }\n\n    if (out) {\n        if (VIR_ALLOC(def->out) < 0)\n            goto cleanup;\n\n        if (virNetDevBandwidthParseRate(out, def->out) < 0) {\n            /* helper reported error for us */\n            goto cleanup;\n        }\n\n        if (def->out->floor) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"'floor' attribute allowed \"\n                             \"only in <inbound> element\"));\n            goto cleanup;\n        }\n    }\n\n    if (!def->in && !def->out)\n        VIR_FREE(def);\n\n    *bandwidth = def;\n    def = NULL;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(class_id_prop);\n    virNetDevBandwidthFree(def);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid domain localOnly setting '%s' \"\n                             \"in network '%s'\")",
            "tmp",
            "def->name"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeFromString",
          "args": [
            "tmp"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "trustGuestRxFilters"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid trustGuestRxFilters setting '%s' \"\n                             \"in network '%s'\")",
            "trustGuestRxFilters",
            "def->name"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeFromString",
          "args": [
            "trustGuestRxFilters"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ipv6nogwStr"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid ipv6 setting '%s' in network '%s'\")",
            "ipv6nogwStr",
            "def->name"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringParseYesNo",
          "args": [
            "ipv6nogwStr",
            "&def->ipv6nogw"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "virStringParseYesNo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1396-1406",
          "snippet": "int virStringParseYesNo(const char *str, bool *result)\n{\n    if (STREQ(str, \"yes\"))\n        *result = true;\n    else if (STREQ(str, \"no\"))\n        *result = false;\n    else\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint virStringParseYesNo(const char *str, bool *result)\n{\n    if (STREQ(str, \"yes\"))\n        *result = true;\n    else if (STREQ(str, \"no\"))\n        *result = false;\n    else\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed uuid element\")"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "tmp",
            "def->uuid"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to generate UUID\")"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDGenerate",
          "args": [
            "def->uuid"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDGenerate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "50-79",
          "snippet": "int\nvirUUIDGenerate(unsigned char *uuid)\n{\n    if (uuid == NULL)\n        return -1;\n\n    if (virRandomBytes(uuid, VIR_UUID_BUFLEN) < 0)\n        return -1;\n\n    /*\n     * Make UUID RFC 4122 compliant. Following form will be used:\n     *\n     * xxxxxxxx-xxxx-Axxx-Bxxx-xxxxxxxxxxxx\n     *\n     * where\n     * A is version defined in 4.1.3 of RFC\n     *  Msb0  Msb1  Msb2  Msb3   Version  Description\n     *   0     1     0     0        4     The randomly or pseudo-\n     *                                    randomly generated version\n     *                                    specified in this document.\n     *\n     * B is variant defined in 4.1.1 of RFC\n     *  Msb0  Msb1  Msb2  Description\n     *   1     0     x    The variant specified in this document.\n     */\n    uuid[6] = (uuid[6] & 0x0F) | (4 << 4);\n    uuid[8] = (uuid[8] & 0x3F) | (2 << 6);\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDGenerate(unsigned char *uuid)\n{\n    if (uuid == NULL)\n        return -1;\n\n    if (virRandomBytes(uuid, VIR_UUID_BUFLEN) < 0)\n        return -1;\n\n    /*\n     * Make UUID RFC 4122 compliant. Following form will be used:\n     *\n     * xxxxxxxx-xxxx-Axxx-Bxxx-xxxxxxxxxxxx\n     *\n     * where\n     * A is version defined in 4.1.3 of RFC\n     *  Msb0  Msb1  Msb2  Msb3   Version  Description\n     *   0     1     0     0        4     The randomly or pseudo-\n     *                                    randomly generated version\n     *                                    specified in this document.\n     *\n     * B is variant defined in 4.1.1 of RFC\n     *  Msb0  Msb1  Msb2  Description\n     *   1     0     x    The variant specified in this document.\n     */\n    uuid[6] = (uuid[6] & 0x0F) | (4 << 4);\n    uuid[8] = (uuid[8] & 0x3F) | (2 << 6);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLCheckIllegalChars",
          "args": [
            "\"name\"",
            "def->name",
            "\"/\""
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLCheckIllegalChars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "490-502",
          "snippet": "int\nvirXMLCheckIllegalChars(const char *nodeName,\n                        const char *str,\n                        const char *illegal)\n{\n    char *c;\n    if ((c = strpbrk(str, illegal))) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"invalid char in %s: %c\"), nodeName, *c);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXMLCheckIllegalChars(const char *nodeName,\n                        const char *str,\n                        const char *illegal)\n{\n    char *c;\n    if ((c = strpbrk(str, illegal))) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"invalid char in %s: %c\"), nodeName, *c);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_NAME",
            "NULL"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkDefPtr\nvirNetworkDefParseXML(xmlXPathContextPtr ctxt,\n                      virNetworkXMLOptionPtr xmlopt)\n{\n    virNetworkDefPtr def;\n    char *tmp = NULL;\n    char *stp = NULL;\n    xmlNodePtr *ipNodes = NULL;\n    xmlNodePtr *routeNodes = NULL;\n    xmlNodePtr *portGroupNodes = NULL;\n    int nips, nPortGroups, nRoutes;\n    xmlNodePtr dnsNode = NULL;\n    xmlNodePtr virtPortNode = NULL;\n    xmlNodePtr forwardNode = NULL;\n    char *ipv6nogwStr = NULL;\n    char *trustGuestRxFilters = NULL;\n    xmlNodePtr save = ctxt->node;\n    xmlNodePtr bandwidthNode = NULL;\n    xmlNodePtr vlanNode;\n    xmlNodePtr metadataNode = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    /* Extract network name */\n    def->name = virXPathString(\"string(./name[1])\", ctxt);\n    if (!def->name) {\n        virReportError(VIR_ERR_NO_NAME, NULL);\n        goto error;\n    }\n\n    if (virXMLCheckIllegalChars(\"name\", def->name, \"/\") < 0)\n        goto error;\n\n    /* Extract network uuid */\n    tmp = virXPathString(\"string(./uuid[1])\", ctxt);\n    if (!tmp) {\n        if (virUUIDGenerate(def->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"Failed to generate UUID\"));\n            goto error;\n        }\n    } else {\n        if (virUUIDParse(tmp, def->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"malformed uuid element\"));\n            goto error;\n        }\n        VIR_FREE(tmp);\n        def->uuid_specified = true;\n    }\n\n    /* check if definitions with no IPv6 gateway addresses is to\n     * allow guest-to-guest communications.\n     */\n    ipv6nogwStr = virXPathString(\"string(./@ipv6)\", ctxt);\n    if (ipv6nogwStr) {\n        if (virStringParseYesNo(ipv6nogwStr, &def->ipv6nogw) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid ipv6 setting '%s' in network '%s'\"),\n                           ipv6nogwStr, def->name);\n            goto error;\n        }\n        VIR_FREE(ipv6nogwStr);\n    }\n\n    trustGuestRxFilters\n        = virXPathString(\"string(./@trustGuestRxFilters)\", ctxt);\n    if (trustGuestRxFilters) {\n        if ((def->trustGuestRxFilters\n             = virTristateBoolTypeFromString(trustGuestRxFilters)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid trustGuestRxFilters setting '%s' \"\n                             \"in network '%s'\"),\n                           trustGuestRxFilters, def->name);\n            goto error;\n        }\n        VIR_FREE(trustGuestRxFilters);\n    }\n\n    /* Parse network domain information */\n    def->domain = virXPathString(\"string(./domain[1]/@name)\", ctxt);\n    tmp = virXPathString(\"string(./domain[1]/@localOnly)\", ctxt);\n    if (tmp) {\n        def->domainLocalOnly = virTristateBoolTypeFromString(tmp);\n        if (def->domainLocalOnly <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid domain localOnly setting '%s' \"\n                             \"in network '%s'\"),\n                           tmp, def->name);\n            goto error;\n        }\n        VIR_FREE(tmp);\n    }\n\n    if ((bandwidthNode = virXPathNode(\"./bandwidth\", ctxt)) &&\n        virNetDevBandwidthParse(&def->bandwidth, NULL, bandwidthNode, false) < 0)\n        goto error;\n\n    vlanNode = virXPathNode(\"./vlan\", ctxt);\n    if (vlanNode && virNetDevVlanParse(vlanNode, ctxt, &def->vlan) < 0)\n        goto error;\n\n    if (virNetworkPortOptionsParseXML(ctxt, &def->isolatedPort) < 0)\n        goto error;\n\n    /* Parse bridge information */\n    def->bridge = virXPathString(\"string(./bridge[1]/@name)\", ctxt);\n    def->bridgeZone = virXPathString(\"string(./bridge[1]/@zone)\", ctxt);\n    stp = virXPathString(\"string(./bridge[1]/@stp)\", ctxt);\n    def->stp = (stp && STREQ(stp, \"off\")) ? false : true;\n\n    tmp = virXPathString(\"string(./bridge[1]/@delay)\", ctxt);\n    if (tmp) {\n        if (virStrToLong_ulp(tmp, NULL, 10, &def->delay) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid delay value in network '%s'\"),\n                           def->name);\n            goto error;\n        }\n    }\n    VIR_FREE(tmp);\n\n    tmp = virXPathString(\"string(./bridge[1]/@macTableManager)\", ctxt);\n    if (tmp) {\n        if ((def->macTableManager\n             = virNetworkBridgeMACTableManagerTypeFromString(tmp)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid macTableManager setting '%s' \"\n                             \"in network '%s'\"), tmp, def->name);\n            goto error;\n        }\n        VIR_FREE(tmp);\n    }\n\n    tmp = virXPathString(\"string(./mac[1]/@address)\", ctxt);\n    if (tmp) {\n        if (virMacAddrParse(tmp, &def->mac) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid bridge mac address '%s' in network '%s'\"),\n                           tmp, def->name);\n            goto error;\n        }\n        if (virMacAddrIsMulticast(&def->mac)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid multicast bridge mac address '%s' in network '%s'\"),\n                           tmp, def->name);\n            goto error;\n        }\n        VIR_FREE(tmp);\n        def->mac_specified = true;\n    }\n\n    tmp = virXPathString(\"string(./mtu/@size)\", ctxt);\n    if (tmp) {\n        if (virStrToLong_ui(tmp, NULL, 10, &def->mtu) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid mtu size '%s' in network '%s'\"),\n                           tmp, def->name);\n            goto error;\n        }\n    }\n    VIR_FREE(tmp);\n\n    dnsNode = virXPathNode(\"./dns\", ctxt);\n    if (dnsNode != NULL &&\n        virNetworkDNSDefParseXML(def->name, dnsNode, ctxt, &def->dns) < 0) {\n        goto error;\n    }\n\n    virtPortNode = virXPathNode(\"./virtualport\", ctxt);\n    if (virtPortNode &&\n        (!(def->virtPortProfile = virNetDevVPortProfileParse(virtPortNode,\n                                                             VIR_VPORT_XML_REQUIRE_TYPE)))) {\n        goto error;\n    }\n\n    nPortGroups = virXPathNodeSet(\"./portgroup\", ctxt, &portGroupNodes);\n    if (nPortGroups < 0)\n        goto error;\n\n    if (nPortGroups > 0) {\n        size_t i;\n\n        /* allocate array to hold all the portgroups */\n        if (VIR_ALLOC_N(def->portGroups, nPortGroups) < 0)\n            goto error;\n        /* parse each portgroup */\n        for (i = 0; i < nPortGroups; i++) {\n            if (virNetworkPortGroupParseXML(&def->portGroups[i],\n                                            portGroupNodes[i],\n                                            ctxt) < 0)\n                goto error;\n            def->nPortGroups++;\n        }\n    }\n    VIR_FREE(portGroupNodes);\n\n    nips = virXPathNodeSet(\"./ip\", ctxt, &ipNodes);\n    if (nips < 0)\n        goto error;\n\n    if (nips > 0) {\n        size_t i;\n\n        /* allocate array to hold all the addrs */\n        if (VIR_ALLOC_N(def->ips, nips) < 0)\n            goto error;\n        /* parse each addr */\n        for (i = 0; i < nips; i++) {\n            if (virNetworkIPDefParseXML(def->name,\n                                        ipNodes[i],\n                                        ctxt,\n                                        &def->ips[i]) < 0)\n                goto error;\n            def->nips++;\n        }\n    }\n    VIR_FREE(ipNodes);\n\n    nRoutes = virXPathNodeSet(\"./route\", ctxt, &routeNodes);\n    if (nRoutes < 0)\n        goto error;\n\n    if (nRoutes > 0) {\n        size_t i;\n\n        /* allocate array to hold all the route definitions */\n        if (VIR_ALLOC_N(def->routes, nRoutes) < 0)\n            goto error;\n        /* parse each definition */\n        for (i = 0; i < nRoutes; i++) {\n            virNetDevIPRoutePtr route = NULL;\n\n            if (!(route = virNetDevIPRouteParseXML(def->name,\n                                                   routeNodes[i],\n                                                   ctxt)))\n                goto error;\n            def->routes[i] = route;\n            def->nroutes++;\n        }\n\n        /* now validate the correctness of any static route gateways specified\n         *\n         * note: the parameters within each definition are verified/assumed valid;\n         * the question being asked and answered here is if the specified gateway\n         * is directly reachable from this bridge.\n         */\n        nRoutes = def->nroutes;\n        nips = def->nips;\n        for (i = 0; i < nRoutes; i++) {\n            size_t j;\n            virSocketAddr testAddr, testGw;\n            bool addrMatch;\n            virNetDevIPRoutePtr gwdef = def->routes[i];\n            virSocketAddrPtr gateway = virNetDevIPRouteGetGateway(gwdef);\n            addrMatch = false;\n            for (j = 0; j < nips; j++) {\n                virNetworkIPDefPtr def2 = &def->ips[j];\n                if (VIR_SOCKET_ADDR_FAMILY(gateway)\n                    != VIR_SOCKET_ADDR_FAMILY(&def2->address)) {\n                    continue;\n                }\n                int prefix = virNetworkIPDefPrefix(def2);\n                virSocketAddrMaskByPrefix(&def2->address, prefix, &testAddr);\n                virSocketAddrMaskByPrefix(gateway, prefix, &testGw);\n                if (VIR_SOCKET_ADDR_VALID(&testAddr) &&\n                    VIR_SOCKET_ADDR_VALID(&testGw) &&\n                    virSocketAddrEqual(&testAddr, &testGw)) {\n                    addrMatch = true;\n                    break;\n                }\n            }\n            if (!addrMatch) {\n                char *gw = virSocketAddrFormat(gateway);\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unreachable static route gateway '%s' specified for network '%s'\"),\n                               gw, def->name);\n                VIR_FREE(gw);\n                goto error;\n            }\n        }\n    }\n    VIR_FREE(routeNodes);\n\n    forwardNode = virXPathNode(\"./forward\", ctxt);\n    if (forwardNode &&\n        virNetworkForwardDefParseXML(def->name, forwardNode, ctxt, &def->forward) < 0) {\n        goto error;\n    }\n\n    /* Validate some items in the main NetworkDef that need to align\n     * with the chosen forward mode.\n     */\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n        break;\n\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_OPEN:\n        /* It's pointless to specify L3 forwarding without specifying\n         * the network we're on.\n         */\n        if (def->nips == 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"%s forwarding requested, \"\n                             \"but no IP address provided for network '%s'\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        if (def->forward.nifs > 1) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"multiple forwarding interfaces specified \"\n                             \"for network '%s', only one is supported\"),\n                           def->name);\n            goto error;\n        }\n\n        if (def->forward.type == VIR_NETWORK_FORWARD_OPEN && def->forward.nifs) {\n            /* an open network by definition can't place any restrictions\n             * on what traffic is allowed or where it goes, so specifying\n             * a forwarding device is nonsensical.\n             */\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"forward dev not allowed for \"\n                             \"network '%s' with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            goto error;\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        if (def->bridge) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge name not allowed in %s mode (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        if (def->bridgeZone) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge zone not allowed in %s mode (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        if (def->macTableManager) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge macTableManager setting not allowed \"\n                             \"in %s mode (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->delay || stp || def->bridgeZone) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge delay/stp/zone options only allowed in \"\n                             \"route, nat, and isolated mode, not in %s \"\n                             \"(network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        if (def->bridge && (def->forward.nifs || def->forward.npfs)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"A network with forward mode='%s' can specify \"\n                             \"a bridge name or a forward dev, but not \"\n                             \"both (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        goto error;\n    }\n\n    VIR_FREE(stp);\n\n    if (def->mtu) {\n        switch ((virNetworkForwardType) def->forward.type) {\n        case VIR_NETWORK_FORWARD_NONE:\n        case VIR_NETWORK_FORWARD_NAT:\n        case VIR_NETWORK_FORWARD_ROUTE:\n        case VIR_NETWORK_FORWARD_OPEN:\n            break;\n\n        case VIR_NETWORK_FORWARD_BRIDGE:\n        case VIR_NETWORK_FORWARD_PRIVATE:\n        case VIR_NETWORK_FORWARD_VEPA:\n        case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        case VIR_NETWORK_FORWARD_HOSTDEV:\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"mtu size only allowed in open, route, nat, \"\n                             \"and isolated mode, not in %s (network '%s')\"),\n                           virNetworkForwardTypeToString(def->forward.type),\n                           def->name);\n            goto error;\n\n        case VIR_NETWORK_FORWARD_LAST:\n        default:\n            virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n            goto error;\n        }\n    }\n\n    /* Extract custom metadata */\n    if ((metadataNode = virXPathNode(\"./metadata[1]\", ctxt)) != NULL) {\n        def->metadata = xmlCopyNode(metadataNode, 1);\n        virXMLNodeSanitizeNamespaces(def->metadata);\n    }\n\n    if (xmlopt)\n        def->ns = xmlopt->ns;\n    if (def->ns.parse) {\n        if (virXMLNamespaceRegister(ctxt, &def->ns) < 0)\n            goto error;\n        if ((def->ns.parse)(ctxt, &def->namespaceData) < 0)\n            goto error;\n    }\n\n    ctxt->node = save;\n    return def;\n\n error:\n    VIR_FREE(tmp);\n    VIR_FREE(routeNodes);\n    VIR_FREE(stp);\n    virNetworkDefFree(def);\n    VIR_FREE(ipNodes);\n    VIR_FREE(portGroupNodes);\n    VIR_FREE(ipv6nogwStr);\n    VIR_FREE(trustGuestRxFilters);\n    ctxt->node = save;\n    return NULL;\n}"
  },
  {
    "function_name": "virNetworkForwardDefParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "1396-1642",
    "snippet": "static int\nvirNetworkForwardDefParseXML(const char *networkName,\n                             xmlNodePtr node,\n                             xmlXPathContextPtr ctxt,\n                             virNetworkForwardDefPtr def)\n{\n    size_t i, j;\n    int ret = -1;\n    xmlNodePtr *forwardIfNodes = NULL;\n    xmlNodePtr *forwardPfNodes = NULL;\n    xmlNodePtr *forwardAddrNodes = NULL;\n    xmlNodePtr *forwardNatNodes = NULL;\n    int nForwardIfs, nForwardAddrs, nForwardPfs, nForwardNats;\n    char *forwardDev = NULL;\n    char *forwardManaged = NULL;\n    char *forwardDriverName = NULL;\n    char *type = NULL;\n    xmlNodePtr save = ctxt->node;\n\n    ctxt->node = node;\n\n    if (!(type = virXPathString(\"string(./@mode)\", ctxt))) {\n        def->type = VIR_NETWORK_FORWARD_NAT;\n    } else {\n        if ((def->type = virNetworkForwardTypeFromString(type)) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown forwarding type '%s'\"), type);\n            goto cleanup;\n        }\n        VIR_FREE(type);\n    }\n\n    forwardManaged = virXPathString(\"string(./@managed)\", ctxt);\n    if (forwardManaged != NULL &&\n        STRCASEEQ(forwardManaged, \"yes\")) {\n        def->managed = true;\n    }\n\n    forwardDriverName = virXPathString(\"string(./driver/@name)\", ctxt);\n    if (forwardDriverName) {\n        int driverName\n            = virNetworkForwardDriverNameTypeFromString(forwardDriverName);\n\n        if (driverName <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unknown forward <driver name='%s'/> \"\n                             \"in network %s\"),\n                           forwardDriverName, networkName);\n            goto cleanup;\n        }\n        def->driverName = driverName;\n    }\n\n    /* bridge and hostdev modes can use a pool of physical interfaces */\n    nForwardIfs = virXPathNodeSet(\"./interface\", ctxt, &forwardIfNodes);\n    if (nForwardIfs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <interface> element found in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    nForwardAddrs = virXPathNodeSet(\"./address\", ctxt, &forwardAddrNodes);\n    if (nForwardAddrs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <address> element found in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    nForwardPfs = virXPathNodeSet(\"./pf\", ctxt, &forwardPfNodes);\n    if (nForwardPfs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <pf> element found in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    nForwardNats = virXPathNodeSet(\"./nat\", ctxt, &forwardNatNodes);\n    if (nForwardNats < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <nat> element found in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    } else if (nForwardNats > 1) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Only one <nat> element is allowed in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    } else if (nForwardNats == 1) {\n        if (virNetworkForwardNatDefParseXML(networkName,\n                                            *forwardNatNodes,\n                                            ctxt, def) < 0)\n            goto cleanup;\n    }\n\n    forwardDev = virXPathString(\"string(./@dev)\", ctxt);\n    if (forwardDev && (nForwardAddrs > 0 || nForwardPfs > 0)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"the <forward> 'dev' attribute cannot be used when \"\n                         \"<address> or <pf> sub-elements are present \"\n                         \"in network %s\"));\n        goto cleanup;\n    }\n\n    if (nForwardIfs > 0 || forwardDev) {\n        if (VIR_ALLOC_N(def->ifs, MAX(nForwardIfs, 1)) < 0)\n            goto cleanup;\n\n        if (forwardDev) {\n            def->ifs[0].device.dev = forwardDev;\n            def->ifs[0].type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n            forwardDev = NULL;\n            def->nifs++;\n        }\n\n        /* parse each <interface> */\n        for (i = 0; i < nForwardIfs; i++) {\n            forwardDev = virXMLPropString(forwardIfNodes[i], \"dev\");\n            if (!forwardDev) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"Missing required dev attribute in \"\n                                 \"<forward> <interface> element of network %s\"),\n                               networkName);\n                goto cleanup;\n            }\n\n            if ((i == 0) && (def->nifs == 1)) {\n                /* both <forward dev='x'> and <interface dev='x'/> are\n                 * present.  If they don't match, it's an error.\n                 */\n                if (STRNEQ(forwardDev, def->ifs[0].device.dev)) {\n                    virReportError(VIR_ERR_XML_ERROR,\n                                   _(\"<forward dev='%s'> must match first \"\n                                     \"<interface dev='%s'/> in network %s\"),\n                                   def->ifs[0].device.dev,\n                                   forwardDev, networkName);\n                    goto cleanup;\n                }\n                VIR_FREE(forwardDev);\n                continue;\n            }\n\n            for (j = 0; j < i; j++) {\n                if (STREQ_NULLABLE(def->ifs[j].device.dev, forwardDev)) {\n                    virReportError(VIR_ERR_XML_ERROR,\n                                   _(\"interface '%s' can only be \"\n                                     \"listed once in network %s\"),\n                                   forwardDev, networkName);\n                    goto cleanup;\n                }\n            }\n\n            def->ifs[i].device.dev = forwardDev;\n            forwardDev = NULL;\n            def->ifs[i].type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n            def->nifs++;\n        }\n\n    } else if (nForwardAddrs > 0) {\n        if (VIR_ALLOC_N(def->ifs, nForwardAddrs) < 0)\n            goto cleanup;\n\n        for (i = 0; i < nForwardAddrs; i++) {\n            if (!(type = virXMLPropString(forwardAddrNodes[i], \"type\"))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"missing address type in network %s\"),\n                               networkName);\n                goto cleanup;\n            }\n\n            if ((def->ifs[i].type = virNetworkForwardHostdevDeviceTypeFromString(type)) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unknown address type '%s' in network %s\"),\n                               type, networkName);\n                goto cleanup;\n            }\n\n            switch (def->ifs[i].type) {\n            case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI:\n            {\n                virPCIDeviceAddressPtr addr = &def->ifs[i].device.pci;\n\n                if (virPCIDeviceAddressParseXML(forwardAddrNodes[i], addr) < 0)\n                    goto cleanup;\n\n                for (j = 0; j < i; j++) {\n                    if (virPCIDeviceAddressEqual(addr, &def->ifs[j].device.pci)) {\n                        virReportError(VIR_ERR_XML_ERROR,\n                                       _(\"PCI device '%04x:%02x:%02x.%x' can \"\n                                         \"only be listed once in network %s\"),\n                                       addr->domain, addr->bus,\n                                       addr->slot, addr->function,\n                                       networkName);\n                        goto cleanup;\n                    }\n                }\n                break;\n            }\n            /* Add USB case here if we ever find a reason to support it */\n\n            default:\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"unsupported address type '%s' in network %s\"),\n                               type, networkName);\n                goto cleanup;\n            }\n            VIR_FREE(type);\n            def->nifs++;\n        }\n\n    } else if (nForwardPfs > 1) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Only one <pf> element is allowed in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    } else if (nForwardPfs == 1) {\n        if (VIR_ALLOC_N(def->pfs, nForwardPfs) < 0)\n            goto cleanup;\n\n        forwardDev = virXMLPropString(*forwardPfNodes, \"dev\");\n        if (!forwardDev) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Missing required dev attribute \"\n                             \"in <pf> element of network '%s'\"),\n                           networkName);\n            goto cleanup;\n        }\n\n        def->pfs->dev = forwardDev;\n        forwardDev = NULL;\n        def->npfs++;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(type);\n    VIR_FREE(forwardDev);\n    VIR_FREE(forwardManaged);\n    VIR_FREE(forwardDriverName);\n    VIR_FREE(forwardPfNodes);\n    VIR_FREE(forwardIfNodes);\n    VIR_FREE(forwardAddrNodes);\n    VIR_FREE(forwardNatNodes);\n    ctxt->node = save;\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "forwardNatNodes"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "forwardAddrNodes"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "forwardIfNodes"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "forwardPfNodes"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "forwardDriverName"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "forwardManaged"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "forwardDev"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Missing required dev attribute \"\n                             \"in <pf> element of network '%s'\")",
            "networkName"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing required dev attribute \"\n                             \"in <pf> element of network '%s'\""
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "*forwardPfNodes",
            "\"dev\""
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->pfs",
            "nForwardPfs"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Only one <pf> element is allowed in <forward> of network %s\")",
            "networkName"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unsupported address type '%s' in network %s\")",
            "type",
            "networkName"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"PCI device '%04x:%02x:%02x.%x' can \"\n                                         \"only be listed once in network %s\")",
            "addr->domain",
            "addr->bus",
            "addr->slot",
            "addr->function",
            "networkName"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressEqual",
          "args": [
            "addr",
            "&def->ifs[j].device.pci"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1324-1335",
          "snippet": "bool\nvirPCIDeviceAddressEqual(const virPCIDeviceAddress *addr1,\n                         const virPCIDeviceAddress *addr2)\n{\n    if (addr1->domain == addr2->domain &&\n        addr1->bus == addr2->bus &&\n        addr1->slot == addr2->slot &&\n        addr1->function == addr2->function) {\n        return true;\n    }\n    return false;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceAddressEqual(const virPCIDeviceAddress *addr1,\n                         const virPCIDeviceAddress *addr2)\n{\n    if (addr1->domain == addr2->domain &&\n        addr1->bus == addr2->bus &&\n        addr1->slot == addr2->slot &&\n        addr1->function == addr2->function) {\n        return true;\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressParseXML",
          "args": [
            "forwardAddrNodes[i]",
            "addr"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "214-291",
          "snippet": "int\nvirPCIDeviceAddressParseXML(xmlNodePtr node,\n                            virPCIDeviceAddressPtr addr)\n{\n    char *domain, *slot, *bus, *function, *multi;\n    xmlNodePtr cur;\n    xmlNodePtr zpci = NULL;\n    int ret = -1;\n\n    memset(addr, 0, sizeof(*addr));\n\n    domain   = virXMLPropString(node, \"domain\");\n    bus      = virXMLPropString(node, \"bus\");\n    slot     = virXMLPropString(node, \"slot\");\n    function = virXMLPropString(node, \"function\");\n    multi    = virXMLPropString(node, \"multifunction\");\n\n    if (domain &&\n        virStrToLong_uip(domain, NULL, 0, &addr->domain) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'domain' attribute\"));\n        goto cleanup;\n    }\n\n    if (bus &&\n        virStrToLong_uip(bus, NULL, 0, &addr->bus) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'bus' attribute\"));\n        goto cleanup;\n    }\n\n    if (slot &&\n        virStrToLong_uip(slot, NULL, 0, &addr->slot) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'slot' attribute\"));\n        goto cleanup;\n    }\n\n    if (function &&\n        virStrToLong_uip(function, NULL, 0, &addr->function) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'function' attribute\"));\n        goto cleanup;\n    }\n\n    if (multi &&\n        ((addr->multi = virTristateSwitchTypeFromString(multi)) <= 0)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unknown value '%s' for <address> 'multifunction' attribute\"),\n                       multi);\n        goto cleanup;\n\n    }\n    if (!virPCIDeviceAddressIsEmpty(addr) && !virPCIDeviceAddressIsValid(addr, true))\n        goto cleanup;\n\n    cur = node->children;\n    while (cur) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"zpci\")) {\n            zpci = cur;\n        }\n        cur = cur->next;\n    }\n\n    if (zpci && virZPCIDeviceAddressParseXML(zpci, addr) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(domain);\n    VIR_FREE(bus);\n    VIR_FREE(slot);\n    VIR_FREE(function);\n    VIR_FREE(multi);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirPCIDeviceAddressParseXML(xmlNodePtr node,\n                            virPCIDeviceAddressPtr addr)\n{\n    char *domain, *slot, *bus, *function, *multi;\n    xmlNodePtr cur;\n    xmlNodePtr zpci = NULL;\n    int ret = -1;\n\n    memset(addr, 0, sizeof(*addr));\n\n    domain   = virXMLPropString(node, \"domain\");\n    bus      = virXMLPropString(node, \"bus\");\n    slot     = virXMLPropString(node, \"slot\");\n    function = virXMLPropString(node, \"function\");\n    multi    = virXMLPropString(node, \"multifunction\");\n\n    if (domain &&\n        virStrToLong_uip(domain, NULL, 0, &addr->domain) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'domain' attribute\"));\n        goto cleanup;\n    }\n\n    if (bus &&\n        virStrToLong_uip(bus, NULL, 0, &addr->bus) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'bus' attribute\"));\n        goto cleanup;\n    }\n\n    if (slot &&\n        virStrToLong_uip(slot, NULL, 0, &addr->slot) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'slot' attribute\"));\n        goto cleanup;\n    }\n\n    if (function &&\n        virStrToLong_uip(function, NULL, 0, &addr->function) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'function' attribute\"));\n        goto cleanup;\n    }\n\n    if (multi &&\n        ((addr->multi = virTristateSwitchTypeFromString(multi)) <= 0)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unknown value '%s' for <address> 'multifunction' attribute\"),\n                       multi);\n        goto cleanup;\n\n    }\n    if (!virPCIDeviceAddressIsEmpty(addr) && !virPCIDeviceAddressIsValid(addr, true))\n        goto cleanup;\n\n    cur = node->children;\n    while (cur) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"zpci\")) {\n            zpci = cur;\n        }\n        cur = cur->next;\n    }\n\n    if (zpci && virZPCIDeviceAddressParseXML(zpci, addr) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(domain);\n    VIR_FREE(bus);\n    VIR_FREE(slot);\n    VIR_FREE(function);\n    VIR_FREE(multi);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unknown address type '%s' in network %s\")",
            "type",
            "networkName"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardHostdevDeviceTypeFromString",
          "args": [
            "type"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"missing address type in network %s\")",
            "networkName"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->ifs",
            "nForwardAddrs"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"interface '%s' can only be \"\n                                     \"listed once in network %s\")",
            "forwardDev",
            "networkName"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "def->ifs[j].device.dev",
            "forwardDev"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "forwardDev"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"<forward dev='%s'> must match first \"\n                                     \"<interface dev='%s'/> in network %s\")",
            "def->ifs[0].device.dev",
            "forwardDev",
            "networkName"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "forwardDev",
            "def->ifs[0].device.dev"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Missing required dev attribute in \"\n                                 \"<forward> <interface> element of network %s\")",
            "networkName"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->ifs",
            "MAX(nForwardIfs, 1)"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "nForwardIfs",
            "1"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"the <forward> 'dev' attribute cannot be used when \"\n                         \"<address> or <pf> sub-elements are present \"\n                         \"in network %s\")"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./@dev)\"",
            "ctxt"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkForwardNatDefParseXML",
          "args": [
            "networkName",
            "*forwardNatNodes",
            "ctxt",
            "def"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkForwardNatDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "1267-1393",
          "snippet": "static int\nvirNetworkForwardNatDefParseXML(const char *networkName,\n                                xmlNodePtr node,\n                                xmlXPathContextPtr ctxt,\n                                virNetworkForwardDefPtr def)\n{\n    int ret = -1;\n    xmlNodePtr *natAddrNodes = NULL;\n    xmlNodePtr *natPortNodes = NULL;\n    int nNatAddrs, nNatPorts;\n    char *addrStart = NULL;\n    char *addrEnd = NULL;\n    xmlNodePtr save = ctxt->node;\n\n    ctxt->node = node;\n\n    if (def->type != VIR_NETWORK_FORWARD_NAT) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"The <nat> element can only be used when <forward> 'mode' is 'nat' in network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    /* addresses for SNAT */\n    nNatAddrs = virXPathNodeSet(\"./address\", ctxt, &natAddrNodes);\n    if (nNatAddrs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <address> element found in <forward> of \"\n                         \"network %s\"), networkName);\n        goto cleanup;\n    } else if (nNatAddrs > 1) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Only one <address> element is allowed in <nat> in \"\n                         \"<forward> in network %s\"), networkName);\n        goto cleanup;\n    } else if (nNatAddrs == 1) {\n        addrStart = virXMLPropString(*natAddrNodes, \"start\");\n        if (addrStart == NULL) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"missing 'start' attribute in <address> element in <nat> in \"\n                             \"<forward> in network %s\"), networkName);\n            goto cleanup;\n        }\n        addrEnd = virXMLPropString(*natAddrNodes, \"end\");\n        if (addrEnd == NULL) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"missing 'end' attribute in <address> element in <nat> in \"\n                             \"<forward> in network %s\"), networkName);\n            goto cleanup;\n        }\n    }\n\n    if (addrStart && virSocketAddrParse(&def->addr.start, addrStart, AF_INET) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Bad ipv4 start address '%s' in <nat> in <forward> in \"\n                         \"network '%s'\"), addrStart, networkName);\n        goto cleanup;\n    }\n\n    if (addrEnd && virSocketAddrParse(&def->addr.end, addrEnd, AF_INET) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Bad ipv4 end address '%s' in <nat> in <forward> in \"\n                         \"network '%s'\"), addrEnd, networkName);\n        goto cleanup;\n    }\n\n    if (addrStart && addrEnd) {\n        /* verify that start <= end */\n        if (virSocketAddrGetRange(&def->addr.start, &def->addr.end, NULL, 0) < 0)\n            goto cleanup;\n    } else {\n        if (addrStart) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Only start address '%s' specified in <nat> in \"\n                             \"<forward> in network '%s'\"),\n                           addrStart, networkName);\n            goto cleanup;\n        }\n        if (addrEnd) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Only end address '%s' specified in <nat> in \"\n                             \"<forward> in network '%s'\"),\n                           addrEnd, networkName);\n            goto cleanup;\n        }\n    }\n\n    /* ports for SNAT and MASQUERADE */\n    nNatPorts = virXPathNodeSet(\"./port\", ctxt, &natPortNodes);\n    if (nNatPorts < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <port> element found in <forward> of \"\n                         \"network %s\"), networkName);\n        goto cleanup;\n    } else if (nNatPorts > 1) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Only one <port> element is allowed in <nat> in \"\n                         \"<forward> in network %s\"), networkName);\n        goto cleanup;\n    } else if (nNatPorts == 1) {\n        if (virXPathUInt(\"string(./port[1]/@start)\", ctxt, &def->port.start) < 0\n            || def->port.start > 65535) {\n\n            virReportError(VIR_ERR_XML_DETAIL,\n                           _(\"Missing or invalid 'start' attribute in <port> \"\n                             \"in <nat> in <forward> in network %s\"),\n                             networkName);\n            goto cleanup;\n        }\n        if (virXPathUInt(\"string(./port[1]/@end)\", ctxt, &def->port.end) < 0\n            || def->port.end > 65535 || def->port.end < def->port.start) {\n            virReportError(VIR_ERR_XML_DETAIL,\n                           _(\"Missing or invalid 'end' attribute in <port> in \"\n                             \"<nat> in <forward> in network %s\"), networkName);\n            goto cleanup;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    VIR_FREE(addrStart);\n    VIR_FREE(addrEnd);\n    VIR_FREE(natAddrNodes);\n    VIR_FREE(natPortNodes);\n    ctxt->node = save;\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkForwardNatDefParseXML(const char *networkName,\n                                xmlNodePtr node,\n                                xmlXPathContextPtr ctxt,\n                                virNetworkForwardDefPtr def)\n{\n    int ret = -1;\n    xmlNodePtr *natAddrNodes = NULL;\n    xmlNodePtr *natPortNodes = NULL;\n    int nNatAddrs, nNatPorts;\n    char *addrStart = NULL;\n    char *addrEnd = NULL;\n    xmlNodePtr save = ctxt->node;\n\n    ctxt->node = node;\n\n    if (def->type != VIR_NETWORK_FORWARD_NAT) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"The <nat> element can only be used when <forward> 'mode' is 'nat' in network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    /* addresses for SNAT */\n    nNatAddrs = virXPathNodeSet(\"./address\", ctxt, &natAddrNodes);\n    if (nNatAddrs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <address> element found in <forward> of \"\n                         \"network %s\"), networkName);\n        goto cleanup;\n    } else if (nNatAddrs > 1) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Only one <address> element is allowed in <nat> in \"\n                         \"<forward> in network %s\"), networkName);\n        goto cleanup;\n    } else if (nNatAddrs == 1) {\n        addrStart = virXMLPropString(*natAddrNodes, \"start\");\n        if (addrStart == NULL) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"missing 'start' attribute in <address> element in <nat> in \"\n                             \"<forward> in network %s\"), networkName);\n            goto cleanup;\n        }\n        addrEnd = virXMLPropString(*natAddrNodes, \"end\");\n        if (addrEnd == NULL) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"missing 'end' attribute in <address> element in <nat> in \"\n                             \"<forward> in network %s\"), networkName);\n            goto cleanup;\n        }\n    }\n\n    if (addrStart && virSocketAddrParse(&def->addr.start, addrStart, AF_INET) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Bad ipv4 start address '%s' in <nat> in <forward> in \"\n                         \"network '%s'\"), addrStart, networkName);\n        goto cleanup;\n    }\n\n    if (addrEnd && virSocketAddrParse(&def->addr.end, addrEnd, AF_INET) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Bad ipv4 end address '%s' in <nat> in <forward> in \"\n                         \"network '%s'\"), addrEnd, networkName);\n        goto cleanup;\n    }\n\n    if (addrStart && addrEnd) {\n        /* verify that start <= end */\n        if (virSocketAddrGetRange(&def->addr.start, &def->addr.end, NULL, 0) < 0)\n            goto cleanup;\n    } else {\n        if (addrStart) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Only start address '%s' specified in <nat> in \"\n                             \"<forward> in network '%s'\"),\n                           addrStart, networkName);\n            goto cleanup;\n        }\n        if (addrEnd) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Only end address '%s' specified in <nat> in \"\n                             \"<forward> in network '%s'\"),\n                           addrEnd, networkName);\n            goto cleanup;\n        }\n    }\n\n    /* ports for SNAT and MASQUERADE */\n    nNatPorts = virXPathNodeSet(\"./port\", ctxt, &natPortNodes);\n    if (nNatPorts < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <port> element found in <forward> of \"\n                         \"network %s\"), networkName);\n        goto cleanup;\n    } else if (nNatPorts > 1) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Only one <port> element is allowed in <nat> in \"\n                         \"<forward> in network %s\"), networkName);\n        goto cleanup;\n    } else if (nNatPorts == 1) {\n        if (virXPathUInt(\"string(./port[1]/@start)\", ctxt, &def->port.start) < 0\n            || def->port.start > 65535) {\n\n            virReportError(VIR_ERR_XML_DETAIL,\n                           _(\"Missing or invalid 'start' attribute in <port> \"\n                             \"in <nat> in <forward> in network %s\"),\n                             networkName);\n            goto cleanup;\n        }\n        if (virXPathUInt(\"string(./port[1]/@end)\", ctxt, &def->port.end) < 0\n            || def->port.end > 65535 || def->port.end < def->port.start) {\n            virReportError(VIR_ERR_XML_DETAIL,\n                           _(\"Missing or invalid 'end' attribute in <port> in \"\n                             \"<nat> in <forward> in network %s\"), networkName);\n            goto cleanup;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    VIR_FREE(addrStart);\n    VIR_FREE(addrEnd);\n    VIR_FREE(natAddrNodes);\n    VIR_FREE(natPortNodes);\n    ctxt->node = save;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Only one <nat> element is allowed in <forward> of network %s\")",
            "networkName"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"invalid <nat> element found in <forward> of network %s\")",
            "networkName"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./nat\"",
            "ctxt",
            "&forwardNatNodes"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"invalid <pf> element found in <forward> of network %s\")",
            "networkName"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"invalid <address> element found in <forward> of network %s\")",
            "networkName"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"invalid <interface> element found in <forward> of network %s\")",
            "networkName"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unknown forward <driver name='%s'/> \"\n                             \"in network %s\")",
            "forwardDriverName",
            "networkName"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardDriverNameTypeFromString",
          "args": [
            "forwardDriverName"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "forwardManaged",
            "\"yes\""
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unknown forwarding type '%s'\")",
            "type"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeFromString",
          "args": [
            "type"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkForwardDefParseXML(const char *networkName,\n                             xmlNodePtr node,\n                             xmlXPathContextPtr ctxt,\n                             virNetworkForwardDefPtr def)\n{\n    size_t i, j;\n    int ret = -1;\n    xmlNodePtr *forwardIfNodes = NULL;\n    xmlNodePtr *forwardPfNodes = NULL;\n    xmlNodePtr *forwardAddrNodes = NULL;\n    xmlNodePtr *forwardNatNodes = NULL;\n    int nForwardIfs, nForwardAddrs, nForwardPfs, nForwardNats;\n    char *forwardDev = NULL;\n    char *forwardManaged = NULL;\n    char *forwardDriverName = NULL;\n    char *type = NULL;\n    xmlNodePtr save = ctxt->node;\n\n    ctxt->node = node;\n\n    if (!(type = virXPathString(\"string(./@mode)\", ctxt))) {\n        def->type = VIR_NETWORK_FORWARD_NAT;\n    } else {\n        if ((def->type = virNetworkForwardTypeFromString(type)) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown forwarding type '%s'\"), type);\n            goto cleanup;\n        }\n        VIR_FREE(type);\n    }\n\n    forwardManaged = virXPathString(\"string(./@managed)\", ctxt);\n    if (forwardManaged != NULL &&\n        STRCASEEQ(forwardManaged, \"yes\")) {\n        def->managed = true;\n    }\n\n    forwardDriverName = virXPathString(\"string(./driver/@name)\", ctxt);\n    if (forwardDriverName) {\n        int driverName\n            = virNetworkForwardDriverNameTypeFromString(forwardDriverName);\n\n        if (driverName <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unknown forward <driver name='%s'/> \"\n                             \"in network %s\"),\n                           forwardDriverName, networkName);\n            goto cleanup;\n        }\n        def->driverName = driverName;\n    }\n\n    /* bridge and hostdev modes can use a pool of physical interfaces */\n    nForwardIfs = virXPathNodeSet(\"./interface\", ctxt, &forwardIfNodes);\n    if (nForwardIfs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <interface> element found in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    nForwardAddrs = virXPathNodeSet(\"./address\", ctxt, &forwardAddrNodes);\n    if (nForwardAddrs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <address> element found in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    nForwardPfs = virXPathNodeSet(\"./pf\", ctxt, &forwardPfNodes);\n    if (nForwardPfs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <pf> element found in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    nForwardNats = virXPathNodeSet(\"./nat\", ctxt, &forwardNatNodes);\n    if (nForwardNats < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <nat> element found in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    } else if (nForwardNats > 1) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Only one <nat> element is allowed in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    } else if (nForwardNats == 1) {\n        if (virNetworkForwardNatDefParseXML(networkName,\n                                            *forwardNatNodes,\n                                            ctxt, def) < 0)\n            goto cleanup;\n    }\n\n    forwardDev = virXPathString(\"string(./@dev)\", ctxt);\n    if (forwardDev && (nForwardAddrs > 0 || nForwardPfs > 0)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"the <forward> 'dev' attribute cannot be used when \"\n                         \"<address> or <pf> sub-elements are present \"\n                         \"in network %s\"));\n        goto cleanup;\n    }\n\n    if (nForwardIfs > 0 || forwardDev) {\n        if (VIR_ALLOC_N(def->ifs, MAX(nForwardIfs, 1)) < 0)\n            goto cleanup;\n\n        if (forwardDev) {\n            def->ifs[0].device.dev = forwardDev;\n            def->ifs[0].type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n            forwardDev = NULL;\n            def->nifs++;\n        }\n\n        /* parse each <interface> */\n        for (i = 0; i < nForwardIfs; i++) {\n            forwardDev = virXMLPropString(forwardIfNodes[i], \"dev\");\n            if (!forwardDev) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"Missing required dev attribute in \"\n                                 \"<forward> <interface> element of network %s\"),\n                               networkName);\n                goto cleanup;\n            }\n\n            if ((i == 0) && (def->nifs == 1)) {\n                /* both <forward dev='x'> and <interface dev='x'/> are\n                 * present.  If they don't match, it's an error.\n                 */\n                if (STRNEQ(forwardDev, def->ifs[0].device.dev)) {\n                    virReportError(VIR_ERR_XML_ERROR,\n                                   _(\"<forward dev='%s'> must match first \"\n                                     \"<interface dev='%s'/> in network %s\"),\n                                   def->ifs[0].device.dev,\n                                   forwardDev, networkName);\n                    goto cleanup;\n                }\n                VIR_FREE(forwardDev);\n                continue;\n            }\n\n            for (j = 0; j < i; j++) {\n                if (STREQ_NULLABLE(def->ifs[j].device.dev, forwardDev)) {\n                    virReportError(VIR_ERR_XML_ERROR,\n                                   _(\"interface '%s' can only be \"\n                                     \"listed once in network %s\"),\n                                   forwardDev, networkName);\n                    goto cleanup;\n                }\n            }\n\n            def->ifs[i].device.dev = forwardDev;\n            forwardDev = NULL;\n            def->ifs[i].type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n            def->nifs++;\n        }\n\n    } else if (nForwardAddrs > 0) {\n        if (VIR_ALLOC_N(def->ifs, nForwardAddrs) < 0)\n            goto cleanup;\n\n        for (i = 0; i < nForwardAddrs; i++) {\n            if (!(type = virXMLPropString(forwardAddrNodes[i], \"type\"))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"missing address type in network %s\"),\n                               networkName);\n                goto cleanup;\n            }\n\n            if ((def->ifs[i].type = virNetworkForwardHostdevDeviceTypeFromString(type)) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unknown address type '%s' in network %s\"),\n                               type, networkName);\n                goto cleanup;\n            }\n\n            switch (def->ifs[i].type) {\n            case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI:\n            {\n                virPCIDeviceAddressPtr addr = &def->ifs[i].device.pci;\n\n                if (virPCIDeviceAddressParseXML(forwardAddrNodes[i], addr) < 0)\n                    goto cleanup;\n\n                for (j = 0; j < i; j++) {\n                    if (virPCIDeviceAddressEqual(addr, &def->ifs[j].device.pci)) {\n                        virReportError(VIR_ERR_XML_ERROR,\n                                       _(\"PCI device '%04x:%02x:%02x.%x' can \"\n                                         \"only be listed once in network %s\"),\n                                       addr->domain, addr->bus,\n                                       addr->slot, addr->function,\n                                       networkName);\n                        goto cleanup;\n                    }\n                }\n                break;\n            }\n            /* Add USB case here if we ever find a reason to support it */\n\n            default:\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"unsupported address type '%s' in network %s\"),\n                               type, networkName);\n                goto cleanup;\n            }\n            VIR_FREE(type);\n            def->nifs++;\n        }\n\n    } else if (nForwardPfs > 1) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Only one <pf> element is allowed in <forward> of network %s\"),\n                       networkName);\n        goto cleanup;\n    } else if (nForwardPfs == 1) {\n        if (VIR_ALLOC_N(def->pfs, nForwardPfs) < 0)\n            goto cleanup;\n\n        forwardDev = virXMLPropString(*forwardPfNodes, \"dev\");\n        if (!forwardDev) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Missing required dev attribute \"\n                             \"in <pf> element of network '%s'\"),\n                           networkName);\n            goto cleanup;\n        }\n\n        def->pfs->dev = forwardDev;\n        forwardDev = NULL;\n        def->npfs++;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(type);\n    VIR_FREE(forwardDev);\n    VIR_FREE(forwardManaged);\n    VIR_FREE(forwardDriverName);\n    VIR_FREE(forwardPfNodes);\n    VIR_FREE(forwardIfNodes);\n    VIR_FREE(forwardAddrNodes);\n    VIR_FREE(forwardNatNodes);\n    ctxt->node = save;\n    return ret;\n}"
  },
  {
    "function_name": "virNetworkForwardNatDefParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "1267-1393",
    "snippet": "static int\nvirNetworkForwardNatDefParseXML(const char *networkName,\n                                xmlNodePtr node,\n                                xmlXPathContextPtr ctxt,\n                                virNetworkForwardDefPtr def)\n{\n    int ret = -1;\n    xmlNodePtr *natAddrNodes = NULL;\n    xmlNodePtr *natPortNodes = NULL;\n    int nNatAddrs, nNatPorts;\n    char *addrStart = NULL;\n    char *addrEnd = NULL;\n    xmlNodePtr save = ctxt->node;\n\n    ctxt->node = node;\n\n    if (def->type != VIR_NETWORK_FORWARD_NAT) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"The <nat> element can only be used when <forward> 'mode' is 'nat' in network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    /* addresses for SNAT */\n    nNatAddrs = virXPathNodeSet(\"./address\", ctxt, &natAddrNodes);\n    if (nNatAddrs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <address> element found in <forward> of \"\n                         \"network %s\"), networkName);\n        goto cleanup;\n    } else if (nNatAddrs > 1) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Only one <address> element is allowed in <nat> in \"\n                         \"<forward> in network %s\"), networkName);\n        goto cleanup;\n    } else if (nNatAddrs == 1) {\n        addrStart = virXMLPropString(*natAddrNodes, \"start\");\n        if (addrStart == NULL) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"missing 'start' attribute in <address> element in <nat> in \"\n                             \"<forward> in network %s\"), networkName);\n            goto cleanup;\n        }\n        addrEnd = virXMLPropString(*natAddrNodes, \"end\");\n        if (addrEnd == NULL) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"missing 'end' attribute in <address> element in <nat> in \"\n                             \"<forward> in network %s\"), networkName);\n            goto cleanup;\n        }\n    }\n\n    if (addrStart && virSocketAddrParse(&def->addr.start, addrStart, AF_INET) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Bad ipv4 start address '%s' in <nat> in <forward> in \"\n                         \"network '%s'\"), addrStart, networkName);\n        goto cleanup;\n    }\n\n    if (addrEnd && virSocketAddrParse(&def->addr.end, addrEnd, AF_INET) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Bad ipv4 end address '%s' in <nat> in <forward> in \"\n                         \"network '%s'\"), addrEnd, networkName);\n        goto cleanup;\n    }\n\n    if (addrStart && addrEnd) {\n        /* verify that start <= end */\n        if (virSocketAddrGetRange(&def->addr.start, &def->addr.end, NULL, 0) < 0)\n            goto cleanup;\n    } else {\n        if (addrStart) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Only start address '%s' specified in <nat> in \"\n                             \"<forward> in network '%s'\"),\n                           addrStart, networkName);\n            goto cleanup;\n        }\n        if (addrEnd) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Only end address '%s' specified in <nat> in \"\n                             \"<forward> in network '%s'\"),\n                           addrEnd, networkName);\n            goto cleanup;\n        }\n    }\n\n    /* ports for SNAT and MASQUERADE */\n    nNatPorts = virXPathNodeSet(\"./port\", ctxt, &natPortNodes);\n    if (nNatPorts < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <port> element found in <forward> of \"\n                         \"network %s\"), networkName);\n        goto cleanup;\n    } else if (nNatPorts > 1) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Only one <port> element is allowed in <nat> in \"\n                         \"<forward> in network %s\"), networkName);\n        goto cleanup;\n    } else if (nNatPorts == 1) {\n        if (virXPathUInt(\"string(./port[1]/@start)\", ctxt, &def->port.start) < 0\n            || def->port.start > 65535) {\n\n            virReportError(VIR_ERR_XML_DETAIL,\n                           _(\"Missing or invalid 'start' attribute in <port> \"\n                             \"in <nat> in <forward> in network %s\"),\n                             networkName);\n            goto cleanup;\n        }\n        if (virXPathUInt(\"string(./port[1]/@end)\", ctxt, &def->port.end) < 0\n            || def->port.end > 65535 || def->port.end < def->port.start) {\n            virReportError(VIR_ERR_XML_DETAIL,\n                           _(\"Missing or invalid 'end' attribute in <port> in \"\n                             \"<nat> in <forward> in network %s\"), networkName);\n            goto cleanup;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    VIR_FREE(addrStart);\n    VIR_FREE(addrEnd);\n    VIR_FREE(natAddrNodes);\n    VIR_FREE(natPortNodes);\n    ctxt->node = save;\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "natPortNodes"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "natAddrNodes"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addrEnd"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addrStart"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_DETAIL",
            "_(\"Missing or invalid 'end' attribute in <port> in \"\n                             \"<nat> in <forward> in network %s\")",
            "networkName"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing or invalid 'end' attribute in <port> in \"\n                             \"<nat> in <forward> in network %s\""
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathUInt",
          "args": [
            "\"string(./port[1]/@end)\"",
            "ctxt",
            "&def->port.end"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathUInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "328-343",
          "snippet": "int\nvirXPathUInt(const char *xpath,\n             xmlXPathContextPtr ctxt,\n             unsigned int *value)\n{\n    unsigned long tmp;\n    int ret;\n\n    ret = virXPathULongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((unsigned int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathUInt(const char *xpath,\n             xmlXPathContextPtr ctxt,\n             unsigned int *value)\n{\n    unsigned long tmp;\n    int ret;\n\n    ret = virXPathULongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((unsigned int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_DETAIL",
            "_(\"Missing or invalid 'start' attribute in <port> \"\n                             \"in <nat> in <forward> in network %s\")",
            "networkName"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Only one <port> element is allowed in <nat> in \"\n                         \"<forward> in network %s\")",
            "networkName"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"invalid <port> element found in <forward> of \"\n                         \"network %s\")",
            "networkName"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./port\"",
            "ctxt",
            "&natPortNodes"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Only end address '%s' specified in <nat> in \"\n                             \"<forward> in network '%s'\")",
            "addrEnd",
            "networkName"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Only start address '%s' specified in <nat> in \"\n                             \"<forward> in network '%s'\")",
            "addrStart",
            "networkName"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrGetRange",
          "args": [
            "&def->addr.start",
            "&def->addr.end",
            "NULL",
            "0"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetRange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "825-997",
          "snippet": "int\nvirSocketAddrGetRange(virSocketAddrPtr start, virSocketAddrPtr end,\n                      virSocketAddrPtr network, int prefix)\n{\n    int ret = 0;\n    size_t i;\n    virSocketAddr netmask;\n    g_autofree char *startStr = NULL;\n    g_autofree char *endStr = NULL;\n    g_autofree char *netStr = NULL;\n\n    if (start == NULL || end == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NULL argument - %p %p\"), start, end);\n        return -1;\n    }\n\n    startStr = virSocketAddrFormat(start);\n    endStr = virSocketAddrFormat(end);\n    if (!startStr || !endStr)\n        return -1; /*error already reported */\n\n    if (VIR_SOCKET_ADDR_FAMILY(start) != VIR_SOCKET_ADDR_FAMILY(end)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"mismatch of address family in range %s - %s\"),\n                       startStr, endStr);\n        return -1;\n    }\n\n    if (network) {\n        /* some checks can only be done if we have details of the\n         * network the range should be within\n         */\n        if (!(netStr = virSocketAddrFormat(network)))\n            return -1;\n\n        if (VIR_SOCKET_ADDR_FAMILY(start) != VIR_SOCKET_ADDR_FAMILY(network)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"mismatch of address family in \"\n                             \"range %s - %s for network %s\"),\n                           startStr, endStr, netStr);\n            return -1;\n        }\n\n        if (prefix < 0 ||\n            virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                         VIR_SOCKET_ADDR_FAMILY(network)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"bad prefix %d for network %s when \"\n                             \" checking range %s - %s\"),\n                           prefix, netStr, startStr, endStr);\n            return -1;\n        }\n\n        /* both start and end of range need to be within network */\n        if (virSocketAddrCheckNetmask(start, network, &netmask) <= 0 ||\n            virSocketAddrCheckNetmask(end, network, &netmask) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s is not entirely within \"\n                             \"network %s/%d\"),\n                           startStr, endStr, netStr, prefix);\n            return -1;\n        }\n\n        if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET)) {\n            virSocketAddr netaddr, broadcast;\n\n            if (virSocketAddrBroadcast(network, &netmask, &broadcast) < 0 ||\n                virSocketAddrMask(network, &netmask, &netaddr) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"failed to construct broadcast or network \"\n                                 \"address for network %s/%d\"),\n                               netStr, prefix);\n                return -1;\n            }\n\n            /* Don't allow the start of the range to be the network\n             * address (usually \"...0\") or the end of the range to be the\n             * broadcast address (usually \"...255\"). (the opposite also\n             * isn't allowed, but checking for that is implicit in all the\n             * other combined checks) (IPv6 doesn't have broadcast and\n             * network addresses, so this check is only done for IPv4)\n             */\n            if (virSocketAddrEqual(start, &netaddr)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"start of range %s - %s in network %s/%d \"\n                                 \"is the network address\"),\n                               startStr, endStr, netStr, prefix);\n                return -1;\n            }\n\n            if (virSocketAddrEqual(end, &broadcast)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"end of range %s - %s in network %s/%d \"\n                                 \"is the broadcast address\"),\n                               startStr, endStr, netStr, prefix);\n                return -1;\n            }\n        }\n    }\n\n    if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET)) {\n        virSocketAddrIPv4 t1, t2;\n\n        if (virSocketAddrGetIPv4Addr(start, &t1) < 0 ||\n            virSocketAddrGetIPv4Addr(end, &t2) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to get IPv4 address \"\n                             \"for start or end of range %s - %s\"),\n                           startStr, endStr);\n            return -1;\n        }\n\n        /* legacy check that everything except the last two bytes\n         * are the same\n         */\n        for (i = 0; i < 2; i++) {\n            if (t1[i] != t2[i]) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"range %s - %s is too large (> 65535)\"),\n                               startStr, endStr);\n                return -1;\n            }\n        }\n        ret = (t2[2] - t1[2]) * 256 + (t2[3] - t1[3]);\n        if (ret < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s is reversed \"),\n                           startStr, endStr);\n            return -1;\n        }\n        ret++;\n    } else if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET6)) {\n        virSocketAddrIPv6 t1, t2;\n\n        if (virSocketAddrGetIPv6Addr(start, &t1) < 0 ||\n            virSocketAddrGetIPv6Addr(end, &t2) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to get IPv6 address \"\n                             \"for start or end of range %s - %s\"),\n                           startStr, endStr);\n            return -1;\n        }\n\n        /* legacy check that everything except the last two bytes are\n         * the same\n         */\n        for (i = 0; i < 7; i++) {\n            if (t1[i] != t2[i]) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"range %s - %s is too large (> 65535)\"),\n                               startStr, endStr);\n                return -1;\n            }\n        }\n        ret = t2[7] - t1[7];\n        if (ret < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s start larger than end\"),\n                           startStr, endStr);\n            return -1;\n        }\n        ret++;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unsupported address family \"\n                         \"for range %s - %s, must be ipv4 or ipv6\"),\n                       startStr, endStr);\n        return -1;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrGetRange(virSocketAddrPtr start, virSocketAddrPtr end,\n                      virSocketAddrPtr network, int prefix)\n{\n    int ret = 0;\n    size_t i;\n    virSocketAddr netmask;\n    g_autofree char *startStr = NULL;\n    g_autofree char *endStr = NULL;\n    g_autofree char *netStr = NULL;\n\n    if (start == NULL || end == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NULL argument - %p %p\"), start, end);\n        return -1;\n    }\n\n    startStr = virSocketAddrFormat(start);\n    endStr = virSocketAddrFormat(end);\n    if (!startStr || !endStr)\n        return -1; /*error already reported */\n\n    if (VIR_SOCKET_ADDR_FAMILY(start) != VIR_SOCKET_ADDR_FAMILY(end)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"mismatch of address family in range %s - %s\"),\n                       startStr, endStr);\n        return -1;\n    }\n\n    if (network) {\n        /* some checks can only be done if we have details of the\n         * network the range should be within\n         */\n        if (!(netStr = virSocketAddrFormat(network)))\n            return -1;\n\n        if (VIR_SOCKET_ADDR_FAMILY(start) != VIR_SOCKET_ADDR_FAMILY(network)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"mismatch of address family in \"\n                             \"range %s - %s for network %s\"),\n                           startStr, endStr, netStr);\n            return -1;\n        }\n\n        if (prefix < 0 ||\n            virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                         VIR_SOCKET_ADDR_FAMILY(network)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"bad prefix %d for network %s when \"\n                             \" checking range %s - %s\"),\n                           prefix, netStr, startStr, endStr);\n            return -1;\n        }\n\n        /* both start and end of range need to be within network */\n        if (virSocketAddrCheckNetmask(start, network, &netmask) <= 0 ||\n            virSocketAddrCheckNetmask(end, network, &netmask) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s is not entirely within \"\n                             \"network %s/%d\"),\n                           startStr, endStr, netStr, prefix);\n            return -1;\n        }\n\n        if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET)) {\n            virSocketAddr netaddr, broadcast;\n\n            if (virSocketAddrBroadcast(network, &netmask, &broadcast) < 0 ||\n                virSocketAddrMask(network, &netmask, &netaddr) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"failed to construct broadcast or network \"\n                                 \"address for network %s/%d\"),\n                               netStr, prefix);\n                return -1;\n            }\n\n            /* Don't allow the start of the range to be the network\n             * address (usually \"...0\") or the end of the range to be the\n             * broadcast address (usually \"...255\"). (the opposite also\n             * isn't allowed, but checking for that is implicit in all the\n             * other combined checks) (IPv6 doesn't have broadcast and\n             * network addresses, so this check is only done for IPv4)\n             */\n            if (virSocketAddrEqual(start, &netaddr)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"start of range %s - %s in network %s/%d \"\n                                 \"is the network address\"),\n                               startStr, endStr, netStr, prefix);\n                return -1;\n            }\n\n            if (virSocketAddrEqual(end, &broadcast)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"end of range %s - %s in network %s/%d \"\n                                 \"is the broadcast address\"),\n                               startStr, endStr, netStr, prefix);\n                return -1;\n            }\n        }\n    }\n\n    if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET)) {\n        virSocketAddrIPv4 t1, t2;\n\n        if (virSocketAddrGetIPv4Addr(start, &t1) < 0 ||\n            virSocketAddrGetIPv4Addr(end, &t2) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to get IPv4 address \"\n                             \"for start or end of range %s - %s\"),\n                           startStr, endStr);\n            return -1;\n        }\n\n        /* legacy check that everything except the last two bytes\n         * are the same\n         */\n        for (i = 0; i < 2; i++) {\n            if (t1[i] != t2[i]) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"range %s - %s is too large (> 65535)\"),\n                               startStr, endStr);\n                return -1;\n            }\n        }\n        ret = (t2[2] - t1[2]) * 256 + (t2[3] - t1[3]);\n        if (ret < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s is reversed \"),\n                           startStr, endStr);\n            return -1;\n        }\n        ret++;\n    } else if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET6)) {\n        virSocketAddrIPv6 t1, t2;\n\n        if (virSocketAddrGetIPv6Addr(start, &t1) < 0 ||\n            virSocketAddrGetIPv6Addr(end, &t2) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to get IPv6 address \"\n                             \"for start or end of range %s - %s\"),\n                           startStr, endStr);\n            return -1;\n        }\n\n        /* legacy check that everything except the last two bytes are\n         * the same\n         */\n        for (i = 0; i < 7; i++) {\n            if (t1[i] != t2[i]) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"range %s - %s is too large (> 65535)\"),\n                               startStr, endStr);\n                return -1;\n            }\n        }\n        ret = t2[7] - t1[7];\n        if (ret < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s start larger than end\"),\n                           startStr, endStr);\n            return -1;\n        }\n        ret++;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unsupported address family \"\n                         \"for range %s - %s, must be ipv4 or ipv6\"),\n                       startStr, endStr);\n        return -1;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Bad ipv4 end address '%s' in <nat> in <forward> in \"\n                         \"network '%s'\")",
            "addrEnd",
            "networkName"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrParse",
          "args": [
            "&def->addr.end",
            "addrEnd",
            "AF_INET"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "135-158",
          "snippet": "int virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Bad ipv4 start address '%s' in <nat> in <forward> in \"\n                         \"network '%s'\")",
            "addrStart",
            "networkName"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"missing 'end' attribute in <address> element in <nat> in \"\n                             \"<forward> in network %s\")",
            "networkName"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "*natAddrNodes",
            "\"end\""
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"missing 'start' attribute in <address> element in <nat> in \"\n                             \"<forward> in network %s\")",
            "networkName"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Only one <address> element is allowed in <nat> in \"\n                         \"<forward> in network %s\")",
            "networkName"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"invalid <address> element found in <forward> of \"\n                         \"network %s\")",
            "networkName"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"The <nat> element can only be used when <forward> 'mode' is 'nat' in network %s\")",
            "networkName"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkForwardNatDefParseXML(const char *networkName,\n                                xmlNodePtr node,\n                                xmlXPathContextPtr ctxt,\n                                virNetworkForwardDefPtr def)\n{\n    int ret = -1;\n    xmlNodePtr *natAddrNodes = NULL;\n    xmlNodePtr *natPortNodes = NULL;\n    int nNatAddrs, nNatPorts;\n    char *addrStart = NULL;\n    char *addrEnd = NULL;\n    xmlNodePtr save = ctxt->node;\n\n    ctxt->node = node;\n\n    if (def->type != VIR_NETWORK_FORWARD_NAT) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"The <nat> element can only be used when <forward> 'mode' is 'nat' in network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    /* addresses for SNAT */\n    nNatAddrs = virXPathNodeSet(\"./address\", ctxt, &natAddrNodes);\n    if (nNatAddrs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <address> element found in <forward> of \"\n                         \"network %s\"), networkName);\n        goto cleanup;\n    } else if (nNatAddrs > 1) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Only one <address> element is allowed in <nat> in \"\n                         \"<forward> in network %s\"), networkName);\n        goto cleanup;\n    } else if (nNatAddrs == 1) {\n        addrStart = virXMLPropString(*natAddrNodes, \"start\");\n        if (addrStart == NULL) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"missing 'start' attribute in <address> element in <nat> in \"\n                             \"<forward> in network %s\"), networkName);\n            goto cleanup;\n        }\n        addrEnd = virXMLPropString(*natAddrNodes, \"end\");\n        if (addrEnd == NULL) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"missing 'end' attribute in <address> element in <nat> in \"\n                             \"<forward> in network %s\"), networkName);\n            goto cleanup;\n        }\n    }\n\n    if (addrStart && virSocketAddrParse(&def->addr.start, addrStart, AF_INET) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Bad ipv4 start address '%s' in <nat> in <forward> in \"\n                         \"network '%s'\"), addrStart, networkName);\n        goto cleanup;\n    }\n\n    if (addrEnd && virSocketAddrParse(&def->addr.end, addrEnd, AF_INET) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Bad ipv4 end address '%s' in <nat> in <forward> in \"\n                         \"network '%s'\"), addrEnd, networkName);\n        goto cleanup;\n    }\n\n    if (addrStart && addrEnd) {\n        /* verify that start <= end */\n        if (virSocketAddrGetRange(&def->addr.start, &def->addr.end, NULL, 0) < 0)\n            goto cleanup;\n    } else {\n        if (addrStart) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Only start address '%s' specified in <nat> in \"\n                             \"<forward> in network '%s'\"),\n                           addrStart, networkName);\n            goto cleanup;\n        }\n        if (addrEnd) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Only end address '%s' specified in <nat> in \"\n                             \"<forward> in network '%s'\"),\n                           addrEnd, networkName);\n            goto cleanup;\n        }\n    }\n\n    /* ports for SNAT and MASQUERADE */\n    nNatPorts = virXPathNodeSet(\"./port\", ctxt, &natPortNodes);\n    if (nNatPorts < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <port> element found in <forward> of \"\n                         \"network %s\"), networkName);\n        goto cleanup;\n    } else if (nNatPorts > 1) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Only one <port> element is allowed in <nat> in \"\n                         \"<forward> in network %s\"), networkName);\n        goto cleanup;\n    } else if (nNatPorts == 1) {\n        if (virXPathUInt(\"string(./port[1]/@start)\", ctxt, &def->port.start) < 0\n            || def->port.start > 65535) {\n\n            virReportError(VIR_ERR_XML_DETAIL,\n                           _(\"Missing or invalid 'start' attribute in <port> \"\n                             \"in <nat> in <forward> in network %s\"),\n                             networkName);\n            goto cleanup;\n        }\n        if (virXPathUInt(\"string(./port[1]/@end)\", ctxt, &def->port.end) < 0\n            || def->port.end > 65535 || def->port.end < def->port.start) {\n            virReportError(VIR_ERR_XML_DETAIL,\n                           _(\"Missing or invalid 'end' attribute in <port> in \"\n                             \"<nat> in <forward> in network %s\"), networkName);\n            goto cleanup;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    VIR_FREE(addrStart);\n    VIR_FREE(addrEnd);\n    VIR_FREE(natAddrNodes);\n    VIR_FREE(natPortNodes);\n    ctxt->node = save;\n    return ret;\n}"
  },
  {
    "function_name": "virNetworkPortGroupParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "1195-1264",
    "snippet": "static int\nvirNetworkPortGroupParseXML(virPortGroupDefPtr def,\n                            xmlNodePtr node,\n                            xmlXPathContextPtr ctxt)\n{\n    /*\n     * virPortGroupDef object is already allocated as part of an array.\n     * On failure clear it out, but don't free it.\n     */\n\n    xmlNodePtr save;\n    xmlNodePtr virtPortNode;\n    xmlNodePtr vlanNode;\n    xmlNodePtr bandwidth_node;\n    char *isDefault = NULL;\n    char *trustGuestRxFilters = NULL;\n\n    int result = -1;\n\n    save = ctxt->node;\n    ctxt->node = node;\n\n    /* grab raw data from XML */\n    def->name = virXPathString(\"string(./@name)\", ctxt);\n    if (!def->name) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Missing required name attribute in portgroup\"));\n        goto cleanup;\n    }\n\n    isDefault = virXPathString(\"string(./@default)\", ctxt);\n    def->isDefault = isDefault && STRCASEEQ(isDefault, \"yes\");\n\n    trustGuestRxFilters\n        = virXPathString(\"string(./@trustGuestRxFilters)\", ctxt);\n    if (trustGuestRxFilters) {\n        if ((def->trustGuestRxFilters\n             = virTristateBoolTypeFromString(trustGuestRxFilters)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid trustGuestRxFilters setting '%s' \"\n                             \"in portgroup\"), trustGuestRxFilters);\n            goto cleanup;\n        }\n    }\n\n    virtPortNode = virXPathNode(\"./virtualport\", ctxt);\n    if (virtPortNode &&\n        (!(def->virtPortProfile = virNetDevVPortProfileParse(virtPortNode, 0)))) {\n        goto cleanup;\n    }\n\n    bandwidth_node = virXPathNode(\"./bandwidth\", ctxt);\n    if (bandwidth_node &&\n        virNetDevBandwidthParse(&def->bandwidth, NULL, bandwidth_node, false) < 0)\n        goto cleanup;\n\n    vlanNode = virXPathNode(\"./vlan\", ctxt);\n    if (vlanNode && virNetDevVlanParse(vlanNode, ctxt, &def->vlan) < 0)\n        goto cleanup;\n\n    result = 0;\n cleanup:\n    if (result < 0)\n        virPortGroupDefClear(def);\n    VIR_FREE(isDefault);\n    VIR_FREE(trustGuestRxFilters);\n\n    ctxt->node = save;\n    return result;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "trustGuestRxFilters"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "isDefault"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPortGroupDefClear",
          "args": [
            "def"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "virPortGroupDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "109-117",
          "snippet": "static void\nvirPortGroupDefClear(virPortGroupDefPtr def)\n{\n    VIR_FREE(def->name);\n    VIR_FREE(def->virtPortProfile);\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n    def->bandwidth = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirPortGroupDefClear(virPortGroupDefPtr def)\n{\n    VIR_FREE(def->name);\n    VIR_FREE(def->virtPortProfile);\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n    def->bandwidth = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVlanParse",
          "args": [
            "vlanNode",
            "ctxt",
            "&def->vlan"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVlanParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_vlan_conf.c",
          "lines": "32-138",
          "snippet": "int\nvirNetDevVlanParse(xmlNodePtr node, xmlXPathContextPtr ctxt, virNetDevVlanPtr def)\n{\n    int ret = -1;\n    xmlNodePtr save = ctxt->node;\n    char *trunk = NULL;\n    char *nativeMode = NULL;\n    xmlNodePtr *tagNodes = NULL;\n    int nTags;\n    size_t i;\n\n    ctxt->node = node;\n\n    nTags = virXPathNodeSet(\"./tag\", ctxt, &tagNodes);\n    if (nTags < 0)\n        goto cleanup;\n\n    if (nTags == 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing tag id - each <vlan> must have \"\n                         \"at least one <tag id='n'/> subelement\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(def->tag, nTags) < 0)\n        goto cleanup;\n\n    def->nativeMode = 0;\n    def->nativeTag = 0;\n    for (i = 0; i < nTags; i++) {\n        unsigned long id;\n\n        ctxt->node = tagNodes[i];\n        if (virXPathULong(\"string(./@id)\", ctxt, &id) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing or invalid vlan tag id attribute\"));\n            goto cleanup;\n        }\n        if (id > 4095) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"vlan tag id %lu too large (maximum 4095)\"), id);\n            goto cleanup;\n        }\n        if ((nativeMode = virXPathString(\"string(./@nativeMode)\", ctxt))) {\n            if (def->nativeMode != 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"duplicate native vlan setting\"));\n                goto cleanup;\n            }\n            if ((def->nativeMode\n                 = virNativeVlanModeTypeFromString(nativeMode)) <= 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid \\\"nativeMode='%s'\\\" \"\n                                 \"in vlan <tag> element\"),\n                               nativeMode);\n                goto cleanup;\n            }\n            VIR_FREE(nativeMode);\n            def->nativeTag = id;\n        }\n        def->tag[i] = id;\n    }\n\n    def->nTags = nTags;\n\n    /* now that we know how many tags there are, look for an explicit\n     * trunk setting.\n     */\n    if (nTags > 1)\n        def->trunk = true;\n\n    ctxt->node = node;\n    if ((trunk = virXPathString(\"string(./@trunk)\", ctxt)) != NULL) {\n        def->trunk = STRCASEEQ(trunk, \"yes\");\n        if (!def->trunk) {\n            if (nTags > 1) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"invalid \\\"trunk='%s'\\\" in <vlan> - trunk='yes' \"\n                                 \"is required for more than one vlan tag\"), trunk);\n                goto cleanup;\n            }\n            if (def->nativeMode != 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"invalid configuration in <vlan> - \\\"trunk='no'\\\" is \"\n                                 \"not allowed with a native vlan id\"));\n                goto cleanup;\n            }\n            /* allow (but discard) \"trunk='no' if there is a single tag */\n            if (STRCASENEQ(trunk, \"no\")) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"invalid \\\"trunk='%s'\\\" in <vlan> \"\n                                 \"- must be yes or no\"), trunk);\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    ctxt->node = save;\n    VIR_FREE(tagNodes);\n    VIR_FREE(trunk);\n    VIR_FREE(nativeMode);\n    if (ret < 0)\n        virNetDevVlanClear(def);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_vlan_conf.h\"\n#include <config.h>\n\nint\nvirNetDevVlanParse(xmlNodePtr node, xmlXPathContextPtr ctxt, virNetDevVlanPtr def)\n{\n    int ret = -1;\n    xmlNodePtr save = ctxt->node;\n    char *trunk = NULL;\n    char *nativeMode = NULL;\n    xmlNodePtr *tagNodes = NULL;\n    int nTags;\n    size_t i;\n\n    ctxt->node = node;\n\n    nTags = virXPathNodeSet(\"./tag\", ctxt, &tagNodes);\n    if (nTags < 0)\n        goto cleanup;\n\n    if (nTags == 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing tag id - each <vlan> must have \"\n                         \"at least one <tag id='n'/> subelement\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(def->tag, nTags) < 0)\n        goto cleanup;\n\n    def->nativeMode = 0;\n    def->nativeTag = 0;\n    for (i = 0; i < nTags; i++) {\n        unsigned long id;\n\n        ctxt->node = tagNodes[i];\n        if (virXPathULong(\"string(./@id)\", ctxt, &id) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing or invalid vlan tag id attribute\"));\n            goto cleanup;\n        }\n        if (id > 4095) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"vlan tag id %lu too large (maximum 4095)\"), id);\n            goto cleanup;\n        }\n        if ((nativeMode = virXPathString(\"string(./@nativeMode)\", ctxt))) {\n            if (def->nativeMode != 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"duplicate native vlan setting\"));\n                goto cleanup;\n            }\n            if ((def->nativeMode\n                 = virNativeVlanModeTypeFromString(nativeMode)) <= 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid \\\"nativeMode='%s'\\\" \"\n                                 \"in vlan <tag> element\"),\n                               nativeMode);\n                goto cleanup;\n            }\n            VIR_FREE(nativeMode);\n            def->nativeTag = id;\n        }\n        def->tag[i] = id;\n    }\n\n    def->nTags = nTags;\n\n    /* now that we know how many tags there are, look for an explicit\n     * trunk setting.\n     */\n    if (nTags > 1)\n        def->trunk = true;\n\n    ctxt->node = node;\n    if ((trunk = virXPathString(\"string(./@trunk)\", ctxt)) != NULL) {\n        def->trunk = STRCASEEQ(trunk, \"yes\");\n        if (!def->trunk) {\n            if (nTags > 1) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"invalid \\\"trunk='%s'\\\" in <vlan> - trunk='yes' \"\n                                 \"is required for more than one vlan tag\"), trunk);\n                goto cleanup;\n            }\n            if (def->nativeMode != 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"invalid configuration in <vlan> - \\\"trunk='no'\\\" is \"\n                                 \"not allowed with a native vlan id\"));\n                goto cleanup;\n            }\n            /* allow (but discard) \"trunk='no' if there is a single tag */\n            if (STRCASENEQ(trunk, \"no\")) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"invalid \\\"trunk='%s'\\\" in <vlan> \"\n                                 \"- must be yes or no\"), trunk);\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    ctxt->node = save;\n    VIR_FREE(tagNodes);\n    VIR_FREE(trunk);\n    VIR_FREE(nativeMode);\n    if (ret < 0)\n        virNetDevVlanClear(def);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./vlan\"",
            "ctxt"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthParse",
          "args": [
            "&def->bandwidth",
            "NULL",
            "bandwidth_node",
            "false"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_bandwidth_conf.c",
          "lines": "112-219",
          "snippet": "int\nvirNetDevBandwidthParse(virNetDevBandwidthPtr *bandwidth,\n                        unsigned int *class_id,\n                        xmlNodePtr node,\n                        bool allowFloor)\n{\n    int ret = -1;\n    virNetDevBandwidthPtr def = NULL;\n    xmlNodePtr cur;\n    xmlNodePtr in = NULL, out = NULL;\n    char *class_id_prop = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return ret;\n\n    if (!node || !virXMLNodeNameEqual(node, \"bandwidth\")) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"invalid argument supplied\"));\n        goto cleanup;\n    }\n\n    class_id_prop = virXMLPropString(node, \"classID\");\n    if (class_id_prop) {\n        if (!class_id) {\n            virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                           _(\"classID attribute not supported on <bandwidth> \"\n                             \"in this usage context\"));\n            goto cleanup;\n        }\n        if (virStrToLong_ui(class_id_prop, NULL, 10, class_id) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to parse class id '%s'\"),\n                           class_id_prop);\n            goto cleanup;\n        }\n    }\n\n    cur = node->children;\n\n    while (cur) {\n        if (cur->type == XML_ELEMENT_NODE) {\n            if (virXMLNodeNameEqual(cur, \"inbound\")) {\n                if (in) {\n                    virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                                   _(\"Only one child <inbound> \"\n                                     \"element allowed\"));\n                    goto cleanup;\n                }\n                in = cur;\n            } else if (virXMLNodeNameEqual(cur, \"outbound\")) {\n                if (out) {\n                    virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                                   _(\"Only one child <outbound> \"\n                                     \"element allowed\"));\n                    goto cleanup;\n                }\n                out = cur;\n            }\n            /* Silently ignore unknown elements */\n        }\n        cur = cur->next;\n    }\n\n    if (in) {\n        if (VIR_ALLOC(def->in) < 0)\n            goto cleanup;\n\n        if (virNetDevBandwidthParseRate(in, def->in) < 0) {\n            /* helper reported error for us */\n            goto cleanup;\n        }\n\n        if (def->in->floor && !allowFloor) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"floor attribute is not supported for this config\"));\n            goto cleanup;\n        }\n    }\n\n    if (out) {\n        if (VIR_ALLOC(def->out) < 0)\n            goto cleanup;\n\n        if (virNetDevBandwidthParseRate(out, def->out) < 0) {\n            /* helper reported error for us */\n            goto cleanup;\n        }\n\n        if (def->out->floor) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"'floor' attribute allowed \"\n                             \"only in <inbound> element\"));\n            goto cleanup;\n        }\n    }\n\n    if (!def->in && !def->out)\n        VIR_FREE(def);\n\n    *bandwidth = def;\n    def = NULL;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(class_id_prop);\n    virNetDevBandwidthFree(def);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include <config.h>\n\nint\nvirNetDevBandwidthParse(virNetDevBandwidthPtr *bandwidth,\n                        unsigned int *class_id,\n                        xmlNodePtr node,\n                        bool allowFloor)\n{\n    int ret = -1;\n    virNetDevBandwidthPtr def = NULL;\n    xmlNodePtr cur;\n    xmlNodePtr in = NULL, out = NULL;\n    char *class_id_prop = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return ret;\n\n    if (!node || !virXMLNodeNameEqual(node, \"bandwidth\")) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"invalid argument supplied\"));\n        goto cleanup;\n    }\n\n    class_id_prop = virXMLPropString(node, \"classID\");\n    if (class_id_prop) {\n        if (!class_id) {\n            virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                           _(\"classID attribute not supported on <bandwidth> \"\n                             \"in this usage context\"));\n            goto cleanup;\n        }\n        if (virStrToLong_ui(class_id_prop, NULL, 10, class_id) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to parse class id '%s'\"),\n                           class_id_prop);\n            goto cleanup;\n        }\n    }\n\n    cur = node->children;\n\n    while (cur) {\n        if (cur->type == XML_ELEMENT_NODE) {\n            if (virXMLNodeNameEqual(cur, \"inbound\")) {\n                if (in) {\n                    virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                                   _(\"Only one child <inbound> \"\n                                     \"element allowed\"));\n                    goto cleanup;\n                }\n                in = cur;\n            } else if (virXMLNodeNameEqual(cur, \"outbound\")) {\n                if (out) {\n                    virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                                   _(\"Only one child <outbound> \"\n                                     \"element allowed\"));\n                    goto cleanup;\n                }\n                out = cur;\n            }\n            /* Silently ignore unknown elements */\n        }\n        cur = cur->next;\n    }\n\n    if (in) {\n        if (VIR_ALLOC(def->in) < 0)\n            goto cleanup;\n\n        if (virNetDevBandwidthParseRate(in, def->in) < 0) {\n            /* helper reported error for us */\n            goto cleanup;\n        }\n\n        if (def->in->floor && !allowFloor) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"floor attribute is not supported for this config\"));\n            goto cleanup;\n        }\n    }\n\n    if (out) {\n        if (VIR_ALLOC(def->out) < 0)\n            goto cleanup;\n\n        if (virNetDevBandwidthParseRate(out, def->out) < 0) {\n            /* helper reported error for us */\n            goto cleanup;\n        }\n\n        if (def->out->floor) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"'floor' attribute allowed \"\n                             \"only in <inbound> element\"));\n            goto cleanup;\n        }\n    }\n\n    if (!def->in && !def->out)\n        VIR_FREE(def);\n\n    *bandwidth = def;\n    def = NULL;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(class_id_prop);\n    virNetDevBandwidthFree(def);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileParse",
          "args": [
            "virtPortNode",
            "0"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_vport_profile_conf.c",
          "lines": "29-196",
          "snippet": "virNetDevVPortProfilePtr\nvirNetDevVPortProfileParse(xmlNodePtr node, unsigned int flags)\n{\n    char *virtPortType;\n    char *virtPortManagerID = NULL;\n    char *virtPortTypeID = NULL;\n    char *virtPortTypeIDVersion = NULL;\n    char *virtPortInstanceID = NULL;\n    char *virtPortProfileID = NULL;\n    char *virtPortInterfaceID = NULL;\n    virNetDevVPortProfilePtr virtPort = NULL;\n    xmlNodePtr cur = node->children;\n\n    if (VIR_ALLOC(virtPort) < 0)\n        return NULL;\n\n    if ((virtPortType = virXMLPropString(node, \"type\")) &&\n        (virtPort->virtPortType = virNetDevVPortTypeFromString(virtPortType)) <= 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown virtualport type %s\"), virtPortType);\n        goto error;\n    }\n\n    if ((virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE) &&\n        (flags & VIR_VPORT_XML_REQUIRE_TYPE)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing required virtualport type\"));\n        goto error;\n    }\n\n    while (cur != NULL) {\n        if (virXMLNodeNameEqual(cur, \"parameters\")) {\n            virtPortManagerID = virXMLPropString(cur, \"managerid\");\n            virtPortTypeID = virXMLPropString(cur, \"typeid\");\n            virtPortTypeIDVersion = virXMLPropString(cur, \"typeidversion\");\n            virtPortInstanceID = virXMLPropString(cur, \"instanceid\");\n            virtPortProfileID = virXMLPropString(cur, \"profileid\");\n            virtPortInterfaceID = virXMLPropString(cur, \"interfaceid\");\n            break;\n        }\n        cur = cur->next;\n    }\n\n    if (virtPortManagerID) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortManagerID, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of managerid parameter\"));\n            goto error;\n        }\n        if (val > 0xff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value of managerid out of range\"));\n            goto error;\n        }\n        virtPort->managerID = (uint8_t)val;\n        virtPort->managerID_specified = true;\n    }\n\n    if (virtPortTypeID) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortTypeID, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of typeid parameter\"));\n            goto error;\n        }\n        if (val > 0xffffff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value for typeid out of range\"));\n            goto error;\n        }\n        virtPort->typeID = (uint32_t)val;\n        virtPort->typeID_specified = true;\n    }\n\n    if (virtPortTypeIDVersion) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortTypeIDVersion, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of typeidversion parameter\"));\n            goto error;\n        }\n        if (val > 0xff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value of typeidversion out of range\"));\n            goto error;\n        }\n        virtPort->typeIDVersion = (uint8_t)val;\n        virtPort->typeIDVersion_specified = true;\n    }\n\n    if (virtPortInstanceID) {\n        if (virUUIDParse(virtPortInstanceID, virtPort->instanceID) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse instanceid parameter as a uuid\"));\n            goto error;\n        }\n        virtPort->instanceID_specified = true;\n    }\n\n    if (virtPortProfileID &&\n        virStrcpyStatic(virtPort->profileID, virtPortProfileID) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"profileid parameter too long\"));\n        goto error;\n    }\n\n    if (virtPortInterfaceID) {\n        if (virUUIDParse(virtPortInterfaceID, virtPort->interfaceID) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse interfaceid parameter as a uuid\"));\n            goto error;\n        }\n        virtPort->interfaceID_specified = true;\n    }\n\n    /* generate default instanceID/interfaceID if appropriate */\n    if (flags & VIR_VPORT_XML_GENERATE_MISSING_DEFAULTS) {\n        if (!virtPort->instanceID_specified &&\n            (virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n             virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n            if (virUUIDGenerate(virtPort->instanceID) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot generate a random uuid for instanceid\"));\n                goto error;\n            }\n            virtPort->instanceID_specified = true;\n        }\n        if (!virtPort->interfaceID_specified &&\n            (virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n             virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n            if (virUUIDGenerate(virtPort->interfaceID) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot generate a random uuid for interfaceid\"));\n                goto error;\n            }\n            virtPort->interfaceID_specified = true;\n        }\n    }\n\n    /* check for required/unsupported attributes */\n\n    if ((flags & VIR_VPORT_XML_REQUIRE_ALL_ATTRIBUTES) &&\n        (virNetDevVPortProfileCheckComplete(virtPort, false) < 0)) {\n        goto error;\n    }\n\n    if (virNetDevVPortProfileCheckNoExtras(virtPort) < 0)\n        goto error;\n\n cleanup:\n    VIR_FREE(virtPortManagerID);\n    VIR_FREE(virtPortTypeID);\n    VIR_FREE(virtPortTypeIDVersion);\n    VIR_FREE(virtPortInstanceID);\n    VIR_FREE(virtPortProfileID);\n    VIR_FREE(virtPortType);\n    VIR_FREE(virtPortInterfaceID);\n\n    return virtPort;\n\n error:\n    VIR_FREE(virtPort);\n    goto cleanup;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include <config.h>\n\nvirNetDevVPortProfilePtr\nvirNetDevVPortProfileParse(xmlNodePtr node, unsigned int flags)\n{\n    char *virtPortType;\n    char *virtPortManagerID = NULL;\n    char *virtPortTypeID = NULL;\n    char *virtPortTypeIDVersion = NULL;\n    char *virtPortInstanceID = NULL;\n    char *virtPortProfileID = NULL;\n    char *virtPortInterfaceID = NULL;\n    virNetDevVPortProfilePtr virtPort = NULL;\n    xmlNodePtr cur = node->children;\n\n    if (VIR_ALLOC(virtPort) < 0)\n        return NULL;\n\n    if ((virtPortType = virXMLPropString(node, \"type\")) &&\n        (virtPort->virtPortType = virNetDevVPortTypeFromString(virtPortType)) <= 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown virtualport type %s\"), virtPortType);\n        goto error;\n    }\n\n    if ((virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE) &&\n        (flags & VIR_VPORT_XML_REQUIRE_TYPE)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing required virtualport type\"));\n        goto error;\n    }\n\n    while (cur != NULL) {\n        if (virXMLNodeNameEqual(cur, \"parameters\")) {\n            virtPortManagerID = virXMLPropString(cur, \"managerid\");\n            virtPortTypeID = virXMLPropString(cur, \"typeid\");\n            virtPortTypeIDVersion = virXMLPropString(cur, \"typeidversion\");\n            virtPortInstanceID = virXMLPropString(cur, \"instanceid\");\n            virtPortProfileID = virXMLPropString(cur, \"profileid\");\n            virtPortInterfaceID = virXMLPropString(cur, \"interfaceid\");\n            break;\n        }\n        cur = cur->next;\n    }\n\n    if (virtPortManagerID) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortManagerID, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of managerid parameter\"));\n            goto error;\n        }\n        if (val > 0xff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value of managerid out of range\"));\n            goto error;\n        }\n        virtPort->managerID = (uint8_t)val;\n        virtPort->managerID_specified = true;\n    }\n\n    if (virtPortTypeID) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortTypeID, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of typeid parameter\"));\n            goto error;\n        }\n        if (val > 0xffffff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value for typeid out of range\"));\n            goto error;\n        }\n        virtPort->typeID = (uint32_t)val;\n        virtPort->typeID_specified = true;\n    }\n\n    if (virtPortTypeIDVersion) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortTypeIDVersion, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of typeidversion parameter\"));\n            goto error;\n        }\n        if (val > 0xff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value of typeidversion out of range\"));\n            goto error;\n        }\n        virtPort->typeIDVersion = (uint8_t)val;\n        virtPort->typeIDVersion_specified = true;\n    }\n\n    if (virtPortInstanceID) {\n        if (virUUIDParse(virtPortInstanceID, virtPort->instanceID) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse instanceid parameter as a uuid\"));\n            goto error;\n        }\n        virtPort->instanceID_specified = true;\n    }\n\n    if (virtPortProfileID &&\n        virStrcpyStatic(virtPort->profileID, virtPortProfileID) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"profileid parameter too long\"));\n        goto error;\n    }\n\n    if (virtPortInterfaceID) {\n        if (virUUIDParse(virtPortInterfaceID, virtPort->interfaceID) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse interfaceid parameter as a uuid\"));\n            goto error;\n        }\n        virtPort->interfaceID_specified = true;\n    }\n\n    /* generate default instanceID/interfaceID if appropriate */\n    if (flags & VIR_VPORT_XML_GENERATE_MISSING_DEFAULTS) {\n        if (!virtPort->instanceID_specified &&\n            (virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n             virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n            if (virUUIDGenerate(virtPort->instanceID) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot generate a random uuid for instanceid\"));\n                goto error;\n            }\n            virtPort->instanceID_specified = true;\n        }\n        if (!virtPort->interfaceID_specified &&\n            (virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n             virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n            if (virUUIDGenerate(virtPort->interfaceID) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot generate a random uuid for interfaceid\"));\n                goto error;\n            }\n            virtPort->interfaceID_specified = true;\n        }\n    }\n\n    /* check for required/unsupported attributes */\n\n    if ((flags & VIR_VPORT_XML_REQUIRE_ALL_ATTRIBUTES) &&\n        (virNetDevVPortProfileCheckComplete(virtPort, false) < 0)) {\n        goto error;\n    }\n\n    if (virNetDevVPortProfileCheckNoExtras(virtPort) < 0)\n        goto error;\n\n cleanup:\n    VIR_FREE(virtPortManagerID);\n    VIR_FREE(virtPortTypeID);\n    VIR_FREE(virtPortTypeIDVersion);\n    VIR_FREE(virtPortInstanceID);\n    VIR_FREE(virtPortProfileID);\n    VIR_FREE(virtPortType);\n    VIR_FREE(virtPortInterfaceID);\n\n    return virtPort;\n\n error:\n    VIR_FREE(virtPort);\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid trustGuestRxFilters setting '%s' \"\n                             \"in portgroup\")",
            "trustGuestRxFilters"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid trustGuestRxFilters setting '%s' \"\n                             \"in portgroup\""
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeFromString",
          "args": [
            "trustGuestRxFilters"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./@trustGuestRxFilters)\"",
            "ctxt"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "isDefault",
            "\"yes\""
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Missing required name attribute in portgroup\")"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkPortGroupParseXML(virPortGroupDefPtr def,\n                            xmlNodePtr node,\n                            xmlXPathContextPtr ctxt)\n{\n    /*\n     * virPortGroupDef object is already allocated as part of an array.\n     * On failure clear it out, but don't free it.\n     */\n\n    xmlNodePtr save;\n    xmlNodePtr virtPortNode;\n    xmlNodePtr vlanNode;\n    xmlNodePtr bandwidth_node;\n    char *isDefault = NULL;\n    char *trustGuestRxFilters = NULL;\n\n    int result = -1;\n\n    save = ctxt->node;\n    ctxt->node = node;\n\n    /* grab raw data from XML */\n    def->name = virXPathString(\"string(./@name)\", ctxt);\n    if (!def->name) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Missing required name attribute in portgroup\"));\n        goto cleanup;\n    }\n\n    isDefault = virXPathString(\"string(./@default)\", ctxt);\n    def->isDefault = isDefault && STRCASEEQ(isDefault, \"yes\");\n\n    trustGuestRxFilters\n        = virXPathString(\"string(./@trustGuestRxFilters)\", ctxt);\n    if (trustGuestRxFilters) {\n        if ((def->trustGuestRxFilters\n             = virTristateBoolTypeFromString(trustGuestRxFilters)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid trustGuestRxFilters setting '%s' \"\n                             \"in portgroup\"), trustGuestRxFilters);\n            goto cleanup;\n        }\n    }\n\n    virtPortNode = virXPathNode(\"./virtualport\", ctxt);\n    if (virtPortNode &&\n        (!(def->virtPortProfile = virNetDevVPortProfileParse(virtPortNode, 0)))) {\n        goto cleanup;\n    }\n\n    bandwidth_node = virXPathNode(\"./bandwidth\", ctxt);\n    if (bandwidth_node &&\n        virNetDevBandwidthParse(&def->bandwidth, NULL, bandwidth_node, false) < 0)\n        goto cleanup;\n\n    vlanNode = virXPathNode(\"./vlan\", ctxt);\n    if (vlanNode && virNetDevVlanParse(vlanNode, ctxt, &def->vlan) < 0)\n        goto cleanup;\n\n    result = 0;\n cleanup:\n    if (result < 0)\n        virPortGroupDefClear(def);\n    VIR_FREE(isDefault);\n    VIR_FREE(trustGuestRxFilters);\n\n    ctxt->node = save;\n    return result;\n}"
  },
  {
    "function_name": "virNetworkPortOptionsParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "1175-1192",
    "snippet": "int\nvirNetworkPortOptionsParseXML(xmlXPathContextPtr ctxt,\n                              virTristateBool *isolatedPort)\n{\n    g_autofree char *str = NULL;\n    int tmp = VIR_TRISTATE_BOOL_ABSENT;\n\n    if ((str = virXPathString(\"string(./port/@isolated)\", ctxt))) {\n        if ((tmp = virTristateBoolTypeFromString(str)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown port isolated value '%s'\"), str);\n            return -1;\n        }\n    }\n\n    *isolatedPort = tmp;\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unknown port isolated value '%s'\")",
            "str"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown port isolated value '%s'\""
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeFromString",
          "args": [
            "str"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./port/@isolated)\"",
            "ctxt"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkPortOptionsParseXML(xmlXPathContextPtr ctxt,\n                              virTristateBool *isolatedPort)\n{\n    g_autofree char *str = NULL;\n    int tmp = VIR_TRISTATE_BOOL_ABSENT;\n\n    if ((str = virXPathString(\"string(./port/@isolated)\", ctxt))) {\n        if ((tmp = virTristateBoolTypeFromString(str)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown port isolated value '%s'\"), str);\n            return -1;\n        }\n    }\n\n    *isolatedPort = tmp;\n    return 0;\n}"
  },
  {
    "function_name": "virNetworkIPDefParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "1019-1172",
    "snippet": "static int\nvirNetworkIPDefParseXML(const char *networkName,\n                        xmlNodePtr node,\n                        xmlXPathContextPtr ctxt,\n                        virNetworkIPDefPtr def)\n{\n    /*\n     * virNetworkIPDef object is already allocated as part of an array.\n     * On failure clear it out, but don't free it.\n     */\n\n    xmlNodePtr save;\n    xmlNodePtr dhcp;\n    char *address = NULL, *netmask = NULL;\n    unsigned long prefix = 0;\n    int prefixRc;\n    int result = -1;\n    char *localPtr = NULL;\n\n    save = ctxt->node;\n    ctxt->node = node;\n\n    /* grab raw data from XML */\n    def->family = virXPathString(\"string(./@family)\", ctxt);\n\n    address = virXPathString(\"string(./@address)\", ctxt);\n    if (!address) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Missing required address attribute in network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (virSocketAddrParse(&def->address, address, AF_UNSPEC) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid address '%s' in network '%s'\"),\n                       address, networkName);\n        goto cleanup;\n    }\n\n    netmask = virXPathString(\"string(./@netmask)\", ctxt);\n    if (netmask &&\n        (virSocketAddrParse(&def->netmask, netmask, AF_UNSPEC) < 0)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid netmask '%s' in network '%s'\"),\n                       netmask, networkName);\n        goto cleanup;\n    }\n\n    prefixRc = virXPathULong(\"string(./@prefix)\", ctxt, &prefix);\n    if (prefixRc == -2) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid ULong value specified for prefix in definition of network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (prefixRc < 0)\n        def->prefix = 0;\n    else\n        def->prefix = prefix;\n\n    localPtr = virXPathString(\"string(./@localPtr)\", ctxt);\n    if (localPtr) {\n        def->localPTR = virTristateBoolTypeFromString(localPtr);\n        if (def->localPTR <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid localPtr value '%s' in network '%s'\"),\n                           localPtr, networkName);\n            goto cleanup;\n        }\n    }\n\n    /* validate address, etc. for each family */\n    if ((def->family == NULL) || (STREQ(def->family, \"ipv4\"))) {\n        if (!(VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET) ||\n              VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_UNSPEC))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"%s family specified for non-IPv4 address '%s' in network '%s'\"),\n                           def->family == NULL? \"no\" : \"ipv4\", address, networkName);\n            goto cleanup;\n        }\n        if (netmask) {\n            if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid netmask '%s' for address '%s' \"\n                                 \"in network '%s' (both must be IPv4)\"),\n                               netmask, address, networkName);\n                goto cleanup;\n            }\n            if (def->prefix > 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Network '%s' IP address cannot have \"\n                                 \"both a prefix and a netmask\"), networkName);\n                goto cleanup;\n            }\n        } else if (def->prefix > 32) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Invalid IPv4 prefix '%lu' in network '%s'\"),\n                           prefix, networkName);\n            goto cleanup;\n        }\n    } else if (STREQ(def->family, \"ipv6\")) {\n        if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET6)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Family 'ipv6' specified for non-IPv6 address '%s' in network '%s'\"),\n                           address, networkName);\n            goto cleanup;\n        }\n        if (netmask) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"netmask not allowed for IPv6 address '%s' in network '%s'\"),\n                           address, networkName);\n            goto cleanup;\n        }\n        if (def->prefix > 128) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Invalid IPv6 prefix '%lu' in network '%s'\"),\n                           prefix, networkName);\n            goto cleanup;\n        }\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Unrecognized family '%s' in network '%s'\"),\n                       def->family, networkName);\n        goto cleanup;\n    }\n\n    if ((dhcp = virXPathNode(\"./dhcp[1]\", ctxt)) &&\n        virNetworkDHCPDefParseXML(networkName, dhcp, def) < 0)\n        goto cleanup;\n\n    if (virXPathNode(\"./tftp[1]\", ctxt)) {\n        if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <tftp> element in an IPv6 element \"\n                             \"in network '%s'\"),\n                           networkName);\n            goto cleanup;\n        }\n\n        def->tftproot = virXPathString(\"string(./tftp[1]/@root)\", ctxt);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        virNetworkIPDefClear(def);\n    VIR_FREE(address);\n    VIR_FREE(netmask);\n    VIR_FREE(localPtr);\n\n    ctxt->node = save;\n    return result;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "localPtr"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "netmask"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "address"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefClear",
          "args": [
            "def"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "144-156",
          "snippet": "static void\nvirNetworkIPDefClear(virNetworkIPDefPtr def)\n{\n    VIR_FREE(def->family);\n    VIR_FREE(def->ranges);\n\n    while (def->nhosts)\n        virNetworkDHCPHostDefClear(&def->hosts[--def->nhosts]);\n\n    VIR_FREE(def->hosts);\n    VIR_FREE(def->tftproot);\n    VIR_FREE(def->bootfile);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkIPDefClear(virNetworkIPDefPtr def)\n{\n    VIR_FREE(def->family);\n    VIR_FREE(def->ranges);\n\n    while (def->nhosts)\n        virNetworkDHCPHostDefClear(&def->hosts[--def->nhosts]);\n\n    VIR_FREE(def->hosts);\n    VIR_FREE(def->tftproot);\n    VIR_FREE(def->bootfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./tftp[1]/@root)\"",
            "ctxt"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported <tftp> element in an IPv6 element \"\n                             \"in network '%s'\")",
            "networkName"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported <tftp> element in an IPv6 element \"\n                             \"in network '%s'\""
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&def->address",
            "AF_INET"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./tftp[1]\"",
            "ctxt"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDHCPDefParseXML",
          "args": [
            "networkName",
            "dhcp",
            "def"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDHCPDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "555-620",
          "snippet": "static int\nvirNetworkDHCPDefParseXML(const char *networkName,\n                          xmlNodePtr node,\n                          virNetworkIPDefPtr def)\n{\n    int ret = -1;\n    xmlNodePtr cur;\n    virSocketAddrRange range;\n    virNetworkDHCPHostDef host;\n\n    memset(&range, 0, sizeof(range));\n    memset(&host, 0, sizeof(host));\n\n    cur = node->children;\n    while (cur != NULL) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"range\")) {\n\n            if (virSocketAddrRangeParseXML(networkName, def, cur, &range) < 0)\n                goto cleanup;\n            if (VIR_APPEND_ELEMENT(def->ranges, def->nranges, range) < 0)\n                goto cleanup;\n\n        } else if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"host\")) {\n\n            if (virNetworkDHCPHostDefParseXML(networkName, def, cur,\n                                              &host, false) < 0)\n                goto cleanup;\n            if (VIR_APPEND_ELEMENT(def->hosts, def->nhosts, host) < 0)\n                goto cleanup;\n\n        } else if (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET) &&\n                   cur->type == XML_ELEMENT_NODE &&\n                   virXMLNodeNameEqual(cur, \"bootp\")) {\n            char *file;\n            char *server;\n            virSocketAddr inaddr;\n            memset(&inaddr, 0, sizeof(inaddr));\n\n            if (!(file = virXMLPropString(cur, \"file\"))) {\n                cur = cur->next;\n                continue;\n            }\n            server = virXMLPropString(cur, \"server\");\n\n            if (server &&\n                virSocketAddrParse(&inaddr, server, AF_UNSPEC) < 0) {\n                VIR_FREE(file);\n                VIR_FREE(server);\n                goto cleanup;\n            }\n\n            def->bootfile = file;\n            def->bootserver = inaddr;\n            VIR_FREE(server);\n        }\n\n        cur = cur->next;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDHCPHostDefClear(&host);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDHCPDefParseXML(const char *networkName,\n                          xmlNodePtr node,\n                          virNetworkIPDefPtr def)\n{\n    int ret = -1;\n    xmlNodePtr cur;\n    virSocketAddrRange range;\n    virNetworkDHCPHostDef host;\n\n    memset(&range, 0, sizeof(range));\n    memset(&host, 0, sizeof(host));\n\n    cur = node->children;\n    while (cur != NULL) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"range\")) {\n\n            if (virSocketAddrRangeParseXML(networkName, def, cur, &range) < 0)\n                goto cleanup;\n            if (VIR_APPEND_ELEMENT(def->ranges, def->nranges, range) < 0)\n                goto cleanup;\n\n        } else if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"host\")) {\n\n            if (virNetworkDHCPHostDefParseXML(networkName, def, cur,\n                                              &host, false) < 0)\n                goto cleanup;\n            if (VIR_APPEND_ELEMENT(def->hosts, def->nhosts, host) < 0)\n                goto cleanup;\n\n        } else if (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET) &&\n                   cur->type == XML_ELEMENT_NODE &&\n                   virXMLNodeNameEqual(cur, \"bootp\")) {\n            char *file;\n            char *server;\n            virSocketAddr inaddr;\n            memset(&inaddr, 0, sizeof(inaddr));\n\n            if (!(file = virXMLPropString(cur, \"file\"))) {\n                cur = cur->next;\n                continue;\n            }\n            server = virXMLPropString(cur, \"server\");\n\n            if (server &&\n                virSocketAddrParse(&inaddr, server, AF_UNSPEC) < 0) {\n                VIR_FREE(file);\n                VIR_FREE(server);\n                goto cleanup;\n            }\n\n            def->bootfile = file;\n            def->bootserver = inaddr;\n            VIR_FREE(server);\n        }\n\n        cur = cur->next;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDHCPHostDefClear(&host);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Unrecognized family '%s' in network '%s'\")",
            "def->family",
            "networkName"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Invalid IPv6 prefix '%lu' in network '%s'\")",
            "prefix",
            "networkName"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"netmask not allowed for IPv6 address '%s' in network '%s'\")",
            "address",
            "networkName"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Family 'ipv6' specified for non-IPv6 address '%s' in network '%s'\")",
            "address",
            "networkName"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&def->address",
            "AF_INET6"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->family",
            "\"ipv6\""
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Invalid IPv4 prefix '%lu' in network '%s'\")",
            "prefix",
            "networkName"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Network '%s' IP address cannot have \"\n                                 \"both a prefix and a netmask\")",
            "networkName"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Invalid netmask '%s' for address '%s' \"\n                                 \"in network '%s' (both must be IPv4)\")",
            "netmask",
            "address",
            "networkName"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&def->netmask",
            "AF_INET"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"%s family specified for non-IPv4 address '%s' in network '%s'\")",
            "def->family == NULL? \"no\" : \"ipv4\"",
            "address",
            "networkName"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&def->address",
            "AF_UNSPEC"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&def->address",
            "AF_INET"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->family",
            "\"ipv4\""
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid localPtr value '%s' in network '%s'\")",
            "localPtr",
            "networkName"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeFromString",
          "args": [
            "localPtr"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid ULong value specified for prefix in definition of network '%s'\")",
            "networkName"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathULong",
          "args": [
            "\"string(./@prefix)\"",
            "ctxt",
            "&prefix"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "398-430",
          "snippet": "int\nvirXPathULongLong(const char *xpath,\n                  xmlXPathContextPtr ctxt,\n                  unsigned long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathULong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ull((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (unsigned long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathULongLong(const char *xpath,\n                  xmlXPathContextPtr ctxt,\n                  unsigned long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathULong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ull((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (unsigned long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid netmask '%s' in network '%s'\")",
            "netmask",
            "networkName"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrParse",
          "args": [
            "&def->netmask",
            "netmask",
            "AF_UNSPEC"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "135-158",
          "snippet": "int virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid address '%s' in network '%s'\")",
            "address",
            "networkName"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Missing required address attribute in network '%s'\")",
            "networkName"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkIPDefParseXML(const char *networkName,\n                        xmlNodePtr node,\n                        xmlXPathContextPtr ctxt,\n                        virNetworkIPDefPtr def)\n{\n    /*\n     * virNetworkIPDef object is already allocated as part of an array.\n     * On failure clear it out, but don't free it.\n     */\n\n    xmlNodePtr save;\n    xmlNodePtr dhcp;\n    char *address = NULL, *netmask = NULL;\n    unsigned long prefix = 0;\n    int prefixRc;\n    int result = -1;\n    char *localPtr = NULL;\n\n    save = ctxt->node;\n    ctxt->node = node;\n\n    /* grab raw data from XML */\n    def->family = virXPathString(\"string(./@family)\", ctxt);\n\n    address = virXPathString(\"string(./@address)\", ctxt);\n    if (!address) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Missing required address attribute in network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (virSocketAddrParse(&def->address, address, AF_UNSPEC) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid address '%s' in network '%s'\"),\n                       address, networkName);\n        goto cleanup;\n    }\n\n    netmask = virXPathString(\"string(./@netmask)\", ctxt);\n    if (netmask &&\n        (virSocketAddrParse(&def->netmask, netmask, AF_UNSPEC) < 0)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid netmask '%s' in network '%s'\"),\n                       netmask, networkName);\n        goto cleanup;\n    }\n\n    prefixRc = virXPathULong(\"string(./@prefix)\", ctxt, &prefix);\n    if (prefixRc == -2) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid ULong value specified for prefix in definition of network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (prefixRc < 0)\n        def->prefix = 0;\n    else\n        def->prefix = prefix;\n\n    localPtr = virXPathString(\"string(./@localPtr)\", ctxt);\n    if (localPtr) {\n        def->localPTR = virTristateBoolTypeFromString(localPtr);\n        if (def->localPTR <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid localPtr value '%s' in network '%s'\"),\n                           localPtr, networkName);\n            goto cleanup;\n        }\n    }\n\n    /* validate address, etc. for each family */\n    if ((def->family == NULL) || (STREQ(def->family, \"ipv4\"))) {\n        if (!(VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET) ||\n              VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_UNSPEC))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"%s family specified for non-IPv4 address '%s' in network '%s'\"),\n                           def->family == NULL? \"no\" : \"ipv4\", address, networkName);\n            goto cleanup;\n        }\n        if (netmask) {\n            if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid netmask '%s' for address '%s' \"\n                                 \"in network '%s' (both must be IPv4)\"),\n                               netmask, address, networkName);\n                goto cleanup;\n            }\n            if (def->prefix > 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Network '%s' IP address cannot have \"\n                                 \"both a prefix and a netmask\"), networkName);\n                goto cleanup;\n            }\n        } else if (def->prefix > 32) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Invalid IPv4 prefix '%lu' in network '%s'\"),\n                           prefix, networkName);\n            goto cleanup;\n        }\n    } else if (STREQ(def->family, \"ipv6\")) {\n        if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET6)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Family 'ipv6' specified for non-IPv6 address '%s' in network '%s'\"),\n                           address, networkName);\n            goto cleanup;\n        }\n        if (netmask) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"netmask not allowed for IPv6 address '%s' in network '%s'\"),\n                           address, networkName);\n            goto cleanup;\n        }\n        if (def->prefix > 128) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Invalid IPv6 prefix '%lu' in network '%s'\"),\n                           prefix, networkName);\n            goto cleanup;\n        }\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Unrecognized family '%s' in network '%s'\"),\n                       def->family, networkName);\n        goto cleanup;\n    }\n\n    if ((dhcp = virXPathNode(\"./dhcp[1]\", ctxt)) &&\n        virNetworkDHCPDefParseXML(networkName, dhcp, def) < 0)\n        goto cleanup;\n\n    if (virXPathNode(\"./tftp[1]\", ctxt)) {\n        if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <tftp> element in an IPv6 element \"\n                             \"in network '%s'\"),\n                           networkName);\n            goto cleanup;\n        }\n\n        def->tftproot = virXPathString(\"string(./tftp[1]/@root)\", ctxt);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        virNetworkIPDefClear(def);\n    VIR_FREE(address);\n    VIR_FREE(netmask);\n    VIR_FREE(localPtr);\n\n    ctxt->node = save;\n    return result;\n}"
  },
  {
    "function_name": "virNetworkDNSDefParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "860-1016",
    "snippet": "static int\nvirNetworkDNSDefParseXML(const char *networkName,\n                         xmlNodePtr node,\n                         xmlXPathContextPtr ctxt,\n                         virNetworkDNSDefPtr def)\n{\n    xmlNodePtr *hostNodes = NULL;\n    xmlNodePtr *srvNodes = NULL;\n    xmlNodePtr *txtNodes = NULL;\n    xmlNodePtr *fwdNodes = NULL;\n    char *forwardPlainNames = NULL;\n    char *enable = NULL;\n    int nhosts, nsrvs, ntxts, nfwds;\n    size_t i;\n    int ret = -1;\n    xmlNodePtr save = ctxt->node;\n\n    ctxt->node = node;\n\n    enable = virXPathString(\"string(./@enable)\", ctxt);\n    if (enable) {\n        def->enable = virTristateBoolTypeFromString(enable);\n        if (def->enable <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid dns enable setting '%s' \"\n                             \"in network '%s'\"),\n                           enable, networkName);\n            goto cleanup;\n        }\n    }\n\n    forwardPlainNames = virXPathString(\"string(./@forwardPlainNames)\", ctxt);\n    if (forwardPlainNames) {\n        def->forwardPlainNames = virTristateBoolTypeFromString(forwardPlainNames);\n        if (def->forwardPlainNames <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid dns forwardPlainNames setting '%s' \"\n                             \"in network '%s'\"),\n                           forwardPlainNames, networkName);\n            goto cleanup;\n        }\n    }\n\n    nfwds = virXPathNodeSet(\"./forwarder\", ctxt, &fwdNodes);\n    if (nfwds < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <forwarder> element found in <dns> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (nfwds > 0) {\n        if (VIR_ALLOC_N(def->forwarders, nfwds) < 0)\n            goto cleanup;\n\n        for (i = 0; i < nfwds; i++) {\n            char *addr = virXMLPropString(fwdNodes[i], \"addr\");\n\n            if (addr && virSocketAddrParse(&def->forwarders[i].addr,\n                                           addr, AF_UNSPEC) < 0) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"Invalid forwarder IP address '%s' \"\n                                 \"in network '%s'\"),\n                               addr, networkName);\n                VIR_FREE(addr);\n                goto cleanup;\n            }\n            def->forwarders[i].domain = virXMLPropString(fwdNodes[i], \"domain\");\n            if (!(addr || def->forwarders[i].domain)) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"Invalid forwarder element, must contain \"\n                                 \"at least one of addr or domain\"));\n                goto cleanup;\n            }\n            VIR_FREE(addr);\n            def->nfwds++;\n        }\n    }\n\n    nhosts = virXPathNodeSet(\"./host\", ctxt, &hostNodes);\n    if (nhosts < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <host> element found in <dns> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (nhosts > 0) {\n        if (VIR_ALLOC_N(def->hosts, nhosts) < 0)\n            goto cleanup;\n\n        for (i = 0; i < nhosts; i++) {\n            if (virNetworkDNSHostDefParseXML(networkName, hostNodes[i],\n                                             &def->hosts[def->nhosts], false) < 0) {\n                goto cleanup;\n            }\n            def->nhosts++;\n        }\n    }\n\n    nsrvs = virXPathNodeSet(\"./srv\", ctxt, &srvNodes);\n    if (nsrvs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <srv> element found in <dns> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (nsrvs > 0) {\n        if (VIR_ALLOC_N(def->srvs, nsrvs) < 0)\n            goto cleanup;\n\n        for (i = 0; i < nsrvs; i++) {\n            if (virNetworkDNSSrvDefParseXML(networkName, srvNodes[i], ctxt,\n                                            &def->srvs[def->nsrvs], false) < 0) {\n                goto cleanup;\n            }\n            def->nsrvs++;\n        }\n    }\n\n    ntxts = virXPathNodeSet(\"./txt\", ctxt, &txtNodes);\n    if (ntxts < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <txt> element found in <dns> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (ntxts > 0) {\n        if (VIR_ALLOC_N(def->txts, ntxts) < 0)\n            goto cleanup;\n\n        for (i = 0; i < ntxts; i++) {\n            if (virNetworkDNSTxtDefParseXML(networkName, txtNodes[i],\n                                            &def->txts[def->ntxts], false) < 0) {\n                goto cleanup;\n            }\n            def->ntxts++;\n        }\n    }\n\n    if (def->enable == VIR_TRISTATE_BOOL_NO &&\n        (nfwds || nhosts || nsrvs || ntxts)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Extra data in disabled network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(enable);\n    VIR_FREE(forwardPlainNames);\n    VIR_FREE(fwdNodes);\n    VIR_FREE(hostNodes);\n    VIR_FREE(srvNodes);\n    VIR_FREE(txtNodes);\n    ctxt->node = save;\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "txtNodes"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "srvNodes"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "hostNodes"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fwdNodes"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "forwardPlainNames"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "enable"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Extra data in disabled network '%s'\")",
            "networkName"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Extra data in disabled network '%s'\""
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDNSTxtDefParseXML",
          "args": [
            "networkName",
            "txtNodes[i]",
            "&def->txts[def->ntxts]",
            "false"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDNSTxtDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "819-857",
          "snippet": "static int\nvirNetworkDNSTxtDefParseXML(const char *networkName,\n                            xmlNodePtr node,\n                            virNetworkDNSTxtDefPtr def,\n                            bool partialOkay)\n{\n    const char *bad = \" ,\";\n\n    if (!(def->name = virXMLPropString(node, \"name\"))) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"missing required name attribute in DNS TXT record \"\n                         \"of network %s\"), networkName);\n        goto error;\n    }\n    if (strcspn(def->name, bad) != strlen(def->name)) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"prohibited character in DNS TXT record \"\n                         \"name '%s' of network %s\"), def->name, networkName);\n        goto error;\n    }\n    if (!(def->value = virXMLPropString(node, \"value\")) && !partialOkay) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"missing required value attribute in DNS TXT record \"\n                         \"named '%s' of network %s\"), def->name, networkName);\n        goto error;\n    }\n\n    if (!(def->name || def->value)) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing required name or value \"\n                         \"in DNS TXT record of network %s\"), networkName);\n        goto error;\n    }\n    return 0;\n\n error:\n    virNetworkDNSTxtDefClear(def);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDNSTxtDefParseXML(const char *networkName,\n                            xmlNodePtr node,\n                            virNetworkDNSTxtDefPtr def,\n                            bool partialOkay)\n{\n    const char *bad = \" ,\";\n\n    if (!(def->name = virXMLPropString(node, \"name\"))) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"missing required name attribute in DNS TXT record \"\n                         \"of network %s\"), networkName);\n        goto error;\n    }\n    if (strcspn(def->name, bad) != strlen(def->name)) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"prohibited character in DNS TXT record \"\n                         \"name '%s' of network %s\"), def->name, networkName);\n        goto error;\n    }\n    if (!(def->value = virXMLPropString(node, \"value\")) && !partialOkay) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"missing required value attribute in DNS TXT record \"\n                         \"named '%s' of network %s\"), def->name, networkName);\n        goto error;\n    }\n\n    if (!(def->name || def->value)) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing required name or value \"\n                         \"in DNS TXT record of network %s\"), networkName);\n        goto error;\n    }\n    return 0;\n\n error:\n    virNetworkDNSTxtDefClear(def);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->txts",
            "ntxts"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"invalid <txt> element found in <dns> of network %s\")",
            "networkName"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./txt\"",
            "ctxt",
            "&txtNodes"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDNSSrvDefParseXML",
          "args": [
            "networkName",
            "srvNodes[i]",
            "ctxt",
            "&def->srvs[def->nsrvs]",
            "false"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->srvs",
            "nsrvs"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"invalid <srv> element found in <dns> of network %s\")",
            "networkName"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDNSHostDefParseXML",
          "args": [
            "networkName",
            "hostNodes[i]",
            "&def->hosts[def->nhosts]",
            "false"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDNSHostDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "623-688",
          "snippet": "static int\nvirNetworkDNSHostDefParseXML(const char *networkName,\n                             xmlNodePtr node,\n                             virNetworkDNSHostDefPtr def,\n                             bool partialOkay)\n{\n    xmlNodePtr cur;\n    char *ip;\n\n    if (!(ip = virXMLPropString(node, \"ip\")) && !partialOkay) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing IP address in network '%s' DNS HOST record\"),\n                       networkName);\n        goto error;\n    }\n\n    if (ip && (virSocketAddrParse(&def->ip, ip, AF_UNSPEC) < 0)) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Invalid IP address in network '%s' DNS HOST record\"),\n                       networkName);\n        VIR_FREE(ip);\n        goto error;\n    }\n    VIR_FREE(ip);\n\n    cur = node->children;\n    while (cur != NULL) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"hostname\")) {\n              if (cur->children != NULL) {\n                  char *name = (char *) xmlNodeGetContent(cur);\n\n                  if (!name) {\n                      virReportError(VIR_ERR_XML_DETAIL,\n                                     _(\"Missing hostname in network '%s' DNS HOST record\"),\n                                     networkName);\n                      goto error;\n                  }\n                  if (VIR_APPEND_ELEMENT(def->names, def->nnames, name) < 0) {\n                      VIR_FREE(name);\n                      goto error;\n                  }\n              }\n        }\n        cur = cur->next;\n    }\n    if (def->nnames == 0 && !partialOkay) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing hostname in network '%s' DNS HOST record\"),\n                       networkName);\n        goto error;\n    }\n\n    if (!VIR_SOCKET_ADDR_VALID(&def->ip) && def->nnames == 0) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing ip and hostname in network '%s' DNS HOST record\"),\n                       networkName);\n        goto error;\n    }\n\n    return 0;\n\n error:\n    virNetworkDNSHostDefClear(def);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDNSHostDefParseXML(const char *networkName,\n                             xmlNodePtr node,\n                             virNetworkDNSHostDefPtr def,\n                             bool partialOkay)\n{\n    xmlNodePtr cur;\n    char *ip;\n\n    if (!(ip = virXMLPropString(node, \"ip\")) && !partialOkay) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing IP address in network '%s' DNS HOST record\"),\n                       networkName);\n        goto error;\n    }\n\n    if (ip && (virSocketAddrParse(&def->ip, ip, AF_UNSPEC) < 0)) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Invalid IP address in network '%s' DNS HOST record\"),\n                       networkName);\n        VIR_FREE(ip);\n        goto error;\n    }\n    VIR_FREE(ip);\n\n    cur = node->children;\n    while (cur != NULL) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"hostname\")) {\n              if (cur->children != NULL) {\n                  char *name = (char *) xmlNodeGetContent(cur);\n\n                  if (!name) {\n                      virReportError(VIR_ERR_XML_DETAIL,\n                                     _(\"Missing hostname in network '%s' DNS HOST record\"),\n                                     networkName);\n                      goto error;\n                  }\n                  if (VIR_APPEND_ELEMENT(def->names, def->nnames, name) < 0) {\n                      VIR_FREE(name);\n                      goto error;\n                  }\n              }\n        }\n        cur = cur->next;\n    }\n    if (def->nnames == 0 && !partialOkay) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing hostname in network '%s' DNS HOST record\"),\n                       networkName);\n        goto error;\n    }\n\n    if (!VIR_SOCKET_ADDR_VALID(&def->ip) && def->nnames == 0) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing ip and hostname in network '%s' DNS HOST record\"),\n                       networkName);\n        goto error;\n    }\n\n    return 0;\n\n error:\n    virNetworkDNSHostDefClear(def);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->hosts",
            "nhosts"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"invalid <host> element found in <dns> of network %s\")",
            "networkName"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addr"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Invalid forwarder element, must contain \"\n                                 \"at least one of addr or domain\")"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "fwdNodes[i]",
            "\"domain\""
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addr"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid forwarder IP address '%s' \"\n                                 \"in network '%s'\")",
            "addr",
            "networkName"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrParse",
          "args": [
            "&def->forwarders[i].addr",
            "addr",
            "AF_UNSPEC"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "135-158",
          "snippet": "int virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->forwarders",
            "nfwds"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"invalid <forwarder> element found in <dns> of network %s\")",
            "networkName"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid dns forwardPlainNames setting '%s' \"\n                             \"in network '%s'\")",
            "forwardPlainNames",
            "networkName"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeFromString",
          "args": [
            "forwardPlainNames"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./@forwardPlainNames)\"",
            "ctxt"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid dns enable setting '%s' \"\n                             \"in network '%s'\")",
            "enable",
            "networkName"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeFromString",
          "args": [
            "enable"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDNSDefParseXML(const char *networkName,\n                         xmlNodePtr node,\n                         xmlXPathContextPtr ctxt,\n                         virNetworkDNSDefPtr def)\n{\n    xmlNodePtr *hostNodes = NULL;\n    xmlNodePtr *srvNodes = NULL;\n    xmlNodePtr *txtNodes = NULL;\n    xmlNodePtr *fwdNodes = NULL;\n    char *forwardPlainNames = NULL;\n    char *enable = NULL;\n    int nhosts, nsrvs, ntxts, nfwds;\n    size_t i;\n    int ret = -1;\n    xmlNodePtr save = ctxt->node;\n\n    ctxt->node = node;\n\n    enable = virXPathString(\"string(./@enable)\", ctxt);\n    if (enable) {\n        def->enable = virTristateBoolTypeFromString(enable);\n        if (def->enable <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid dns enable setting '%s' \"\n                             \"in network '%s'\"),\n                           enable, networkName);\n            goto cleanup;\n        }\n    }\n\n    forwardPlainNames = virXPathString(\"string(./@forwardPlainNames)\", ctxt);\n    if (forwardPlainNames) {\n        def->forwardPlainNames = virTristateBoolTypeFromString(forwardPlainNames);\n        if (def->forwardPlainNames <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid dns forwardPlainNames setting '%s' \"\n                             \"in network '%s'\"),\n                           forwardPlainNames, networkName);\n            goto cleanup;\n        }\n    }\n\n    nfwds = virXPathNodeSet(\"./forwarder\", ctxt, &fwdNodes);\n    if (nfwds < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <forwarder> element found in <dns> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (nfwds > 0) {\n        if (VIR_ALLOC_N(def->forwarders, nfwds) < 0)\n            goto cleanup;\n\n        for (i = 0; i < nfwds; i++) {\n            char *addr = virXMLPropString(fwdNodes[i], \"addr\");\n\n            if (addr && virSocketAddrParse(&def->forwarders[i].addr,\n                                           addr, AF_UNSPEC) < 0) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"Invalid forwarder IP address '%s' \"\n                                 \"in network '%s'\"),\n                               addr, networkName);\n                VIR_FREE(addr);\n                goto cleanup;\n            }\n            def->forwarders[i].domain = virXMLPropString(fwdNodes[i], \"domain\");\n            if (!(addr || def->forwarders[i].domain)) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"Invalid forwarder element, must contain \"\n                                 \"at least one of addr or domain\"));\n                goto cleanup;\n            }\n            VIR_FREE(addr);\n            def->nfwds++;\n        }\n    }\n\n    nhosts = virXPathNodeSet(\"./host\", ctxt, &hostNodes);\n    if (nhosts < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <host> element found in <dns> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (nhosts > 0) {\n        if (VIR_ALLOC_N(def->hosts, nhosts) < 0)\n            goto cleanup;\n\n        for (i = 0; i < nhosts; i++) {\n            if (virNetworkDNSHostDefParseXML(networkName, hostNodes[i],\n                                             &def->hosts[def->nhosts], false) < 0) {\n                goto cleanup;\n            }\n            def->nhosts++;\n        }\n    }\n\n    nsrvs = virXPathNodeSet(\"./srv\", ctxt, &srvNodes);\n    if (nsrvs < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <srv> element found in <dns> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (nsrvs > 0) {\n        if (VIR_ALLOC_N(def->srvs, nsrvs) < 0)\n            goto cleanup;\n\n        for (i = 0; i < nsrvs; i++) {\n            if (virNetworkDNSSrvDefParseXML(networkName, srvNodes[i], ctxt,\n                                            &def->srvs[def->nsrvs], false) < 0) {\n                goto cleanup;\n            }\n            def->nsrvs++;\n        }\n    }\n\n    ntxts = virXPathNodeSet(\"./txt\", ctxt, &txtNodes);\n    if (ntxts < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid <txt> element found in <dns> of network %s\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (ntxts > 0) {\n        if (VIR_ALLOC_N(def->txts, ntxts) < 0)\n            goto cleanup;\n\n        for (i = 0; i < ntxts; i++) {\n            if (virNetworkDNSTxtDefParseXML(networkName, txtNodes[i],\n                                            &def->txts[def->ntxts], false) < 0) {\n                goto cleanup;\n            }\n            def->ntxts++;\n        }\n    }\n\n    if (def->enable == VIR_TRISTATE_BOOL_NO &&\n        (nfwds || nhosts || nsrvs || ntxts)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Extra data in disabled network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(enable);\n    VIR_FREE(forwardPlainNames);\n    VIR_FREE(fwdNodes);\n    VIR_FREE(hostNodes);\n    VIR_FREE(srvNodes);\n    VIR_FREE(txtNodes);\n    ctxt->node = save;\n    return ret;\n}"
  },
  {
    "function_name": "virNetworkDNSTxtDefParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "819-857",
    "snippet": "static int\nvirNetworkDNSTxtDefParseXML(const char *networkName,\n                            xmlNodePtr node,\n                            virNetworkDNSTxtDefPtr def,\n                            bool partialOkay)\n{\n    const char *bad = \" ,\";\n\n    if (!(def->name = virXMLPropString(node, \"name\"))) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"missing required name attribute in DNS TXT record \"\n                         \"of network %s\"), networkName);\n        goto error;\n    }\n    if (strcspn(def->name, bad) != strlen(def->name)) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"prohibited character in DNS TXT record \"\n                         \"name '%s' of network %s\"), def->name, networkName);\n        goto error;\n    }\n    if (!(def->value = virXMLPropString(node, \"value\")) && !partialOkay) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"missing required value attribute in DNS TXT record \"\n                         \"named '%s' of network %s\"), def->name, networkName);\n        goto error;\n    }\n\n    if (!(def->name || def->value)) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing required name or value \"\n                         \"in DNS TXT record of network %s\"), networkName);\n        goto error;\n    }\n    return 0;\n\n error:\n    virNetworkDNSTxtDefClear(def);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkDNSTxtDefClear",
          "args": [
            "def"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDNSTxtDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "159-164",
          "snippet": "static void\nvirNetworkDNSTxtDefClear(virNetworkDNSTxtDefPtr def)\n{\n    VIR_FREE(def->name);\n    VIR_FREE(def->value);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDNSTxtDefClear(virNetworkDNSTxtDefPtr def)\n{\n    VIR_FREE(def->name);\n    VIR_FREE(def->value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_DETAIL",
            "_(\"Missing required name or value \"\n                         \"in DNS TXT record of network %s\")",
            "networkName"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing required name or value \"\n                         \"in DNS TXT record of network %s\""
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_DETAIL",
            "_(\"missing required value attribute in DNS TXT record \"\n                         \"named '%s' of network %s\")",
            "def->name",
            "networkName"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "node",
            "\"value\""
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_DETAIL",
            "_(\"prohibited character in DNS TXT record \"\n                         \"name '%s' of network %s\")",
            "def->name",
            "networkName"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "def->name"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "def->name",
            "bad"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_DETAIL",
            "_(\"missing required name attribute in DNS TXT record \"\n                         \"of network %s\")",
            "networkName"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDNSTxtDefParseXML(const char *networkName,\n                            xmlNodePtr node,\n                            virNetworkDNSTxtDefPtr def,\n                            bool partialOkay)\n{\n    const char *bad = \" ,\";\n\n    if (!(def->name = virXMLPropString(node, \"name\"))) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"missing required name attribute in DNS TXT record \"\n                         \"of network %s\"), networkName);\n        goto error;\n    }\n    if (strcspn(def->name, bad) != strlen(def->name)) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"prohibited character in DNS TXT record \"\n                         \"name '%s' of network %s\"), def->name, networkName);\n        goto error;\n    }\n    if (!(def->value = virXMLPropString(node, \"value\")) && !partialOkay) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"missing required value attribute in DNS TXT record \"\n                         \"named '%s' of network %s\"), def->name, networkName);\n        goto error;\n    }\n\n    if (!(def->name || def->value)) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing required name or value \"\n                         \"in DNS TXT record of network %s\"), networkName);\n        goto error;\n    }\n    return 0;\n\n error:\n    virNetworkDNSTxtDefClear(def);\n    return -1;\n}"
  },
  {
    "function_name": "virNetworkDNSHostDefParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "623-688",
    "snippet": "static int\nvirNetworkDNSHostDefParseXML(const char *networkName,\n                             xmlNodePtr node,\n                             virNetworkDNSHostDefPtr def,\n                             bool partialOkay)\n{\n    xmlNodePtr cur;\n    char *ip;\n\n    if (!(ip = virXMLPropString(node, \"ip\")) && !partialOkay) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing IP address in network '%s' DNS HOST record\"),\n                       networkName);\n        goto error;\n    }\n\n    if (ip && (virSocketAddrParse(&def->ip, ip, AF_UNSPEC) < 0)) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Invalid IP address in network '%s' DNS HOST record\"),\n                       networkName);\n        VIR_FREE(ip);\n        goto error;\n    }\n    VIR_FREE(ip);\n\n    cur = node->children;\n    while (cur != NULL) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"hostname\")) {\n              if (cur->children != NULL) {\n                  char *name = (char *) xmlNodeGetContent(cur);\n\n                  if (!name) {\n                      virReportError(VIR_ERR_XML_DETAIL,\n                                     _(\"Missing hostname in network '%s' DNS HOST record\"),\n                                     networkName);\n                      goto error;\n                  }\n                  if (VIR_APPEND_ELEMENT(def->names, def->nnames, name) < 0) {\n                      VIR_FREE(name);\n                      goto error;\n                  }\n              }\n        }\n        cur = cur->next;\n    }\n    if (def->nnames == 0 && !partialOkay) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing hostname in network '%s' DNS HOST record\"),\n                       networkName);\n        goto error;\n    }\n\n    if (!VIR_SOCKET_ADDR_VALID(&def->ip) && def->nnames == 0) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing ip and hostname in network '%s' DNS HOST record\"),\n                       networkName);\n        goto error;\n    }\n\n    return 0;\n\n error:\n    virNetworkDNSHostDefClear(def);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkDNSHostDefClear",
          "args": [
            "def"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDNSHostDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "167-173",
          "snippet": "static void\nvirNetworkDNSHostDefClear(virNetworkDNSHostDefPtr def)\n{\n    while (def->nnames)\n        VIR_FREE(def->names[--def->nnames]);\n    VIR_FREE(def->names);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDNSHostDefClear(virNetworkDNSHostDefPtr def)\n{\n    while (def->nnames)\n        VIR_FREE(def->names[--def->nnames]);\n    VIR_FREE(def->names);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_DETAIL",
            "_(\"Missing ip and hostname in network '%s' DNS HOST record\")",
            "networkName"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing ip and hostname in network '%s' DNS HOST record\""
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&def->ip"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_DETAIL",
            "_(\"Missing hostname in network '%s' DNS HOST record\")",
            "networkName"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->names",
            "def->nnames",
            "name"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_DETAIL",
            "_(\"Missing hostname in network '%s' DNS HOST record\")",
            "networkName"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNodeGetContent",
          "args": [
            "cur"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLNodeNameEqual",
          "args": [
            "cur",
            "\"hostname\""
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeNameEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1013-1018",
          "snippet": "bool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nbool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ip"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ip"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_DETAIL",
            "_(\"Invalid IP address in network '%s' DNS HOST record\")",
            "networkName"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrParse",
          "args": [
            "&def->ip",
            "ip",
            "AF_UNSPEC"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "135-158",
          "snippet": "int virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_DETAIL",
            "_(\"Missing IP address in network '%s' DNS HOST record\")",
            "networkName"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "node",
            "\"ip\""
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDNSHostDefParseXML(const char *networkName,\n                             xmlNodePtr node,\n                             virNetworkDNSHostDefPtr def,\n                             bool partialOkay)\n{\n    xmlNodePtr cur;\n    char *ip;\n\n    if (!(ip = virXMLPropString(node, \"ip\")) && !partialOkay) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing IP address in network '%s' DNS HOST record\"),\n                       networkName);\n        goto error;\n    }\n\n    if (ip && (virSocketAddrParse(&def->ip, ip, AF_UNSPEC) < 0)) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Invalid IP address in network '%s' DNS HOST record\"),\n                       networkName);\n        VIR_FREE(ip);\n        goto error;\n    }\n    VIR_FREE(ip);\n\n    cur = node->children;\n    while (cur != NULL) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"hostname\")) {\n              if (cur->children != NULL) {\n                  char *name = (char *) xmlNodeGetContent(cur);\n\n                  if (!name) {\n                      virReportError(VIR_ERR_XML_DETAIL,\n                                     _(\"Missing hostname in network '%s' DNS HOST record\"),\n                                     networkName);\n                      goto error;\n                  }\n                  if (VIR_APPEND_ELEMENT(def->names, def->nnames, name) < 0) {\n                      VIR_FREE(name);\n                      goto error;\n                  }\n              }\n        }\n        cur = cur->next;\n    }\n    if (def->nnames == 0 && !partialOkay) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing hostname in network '%s' DNS HOST record\"),\n                       networkName);\n        goto error;\n    }\n\n    if (!VIR_SOCKET_ADDR_VALID(&def->ip) && def->nnames == 0) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"Missing ip and hostname in network '%s' DNS HOST record\"),\n                       networkName);\n        goto error;\n    }\n\n    return 0;\n\n error:\n    virNetworkDNSHostDefClear(def);\n    return -1;\n}"
  },
  {
    "function_name": "virNetworkDHCPDefParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "555-620",
    "snippet": "static int\nvirNetworkDHCPDefParseXML(const char *networkName,\n                          xmlNodePtr node,\n                          virNetworkIPDefPtr def)\n{\n    int ret = -1;\n    xmlNodePtr cur;\n    virSocketAddrRange range;\n    virNetworkDHCPHostDef host;\n\n    memset(&range, 0, sizeof(range));\n    memset(&host, 0, sizeof(host));\n\n    cur = node->children;\n    while (cur != NULL) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"range\")) {\n\n            if (virSocketAddrRangeParseXML(networkName, def, cur, &range) < 0)\n                goto cleanup;\n            if (VIR_APPEND_ELEMENT(def->ranges, def->nranges, range) < 0)\n                goto cleanup;\n\n        } else if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"host\")) {\n\n            if (virNetworkDHCPHostDefParseXML(networkName, def, cur,\n                                              &host, false) < 0)\n                goto cleanup;\n            if (VIR_APPEND_ELEMENT(def->hosts, def->nhosts, host) < 0)\n                goto cleanup;\n\n        } else if (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET) &&\n                   cur->type == XML_ELEMENT_NODE &&\n                   virXMLNodeNameEqual(cur, \"bootp\")) {\n            char *file;\n            char *server;\n            virSocketAddr inaddr;\n            memset(&inaddr, 0, sizeof(inaddr));\n\n            if (!(file = virXMLPropString(cur, \"file\"))) {\n                cur = cur->next;\n                continue;\n            }\n            server = virXMLPropString(cur, \"server\");\n\n            if (server &&\n                virSocketAddrParse(&inaddr, server, AF_UNSPEC) < 0) {\n                VIR_FREE(file);\n                VIR_FREE(server);\n                goto cleanup;\n            }\n\n            def->bootfile = file;\n            def->bootserver = inaddr;\n            VIR_FREE(server);\n        }\n\n        cur = cur->next;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDHCPHostDefClear(&host);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkDHCPHostDefClear",
          "args": [
            "&host"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDHCPHostDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "135-141",
          "snippet": "static void\nvirNetworkDHCPHostDefClear(virNetworkDHCPHostDefPtr def)\n{\n    VIR_FREE(def->mac);\n    VIR_FREE(def->id);\n    VIR_FREE(def->name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDHCPHostDefClear(virNetworkDHCPHostDefPtr def)\n{\n    VIR_FREE(def->mac);\n    VIR_FREE(def->id);\n    VIR_FREE(def->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "server"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "server"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "file"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrParse",
          "args": [
            "&inaddr",
            "server",
            "AF_UNSPEC"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "135-158",
          "snippet": "int virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "cur",
            "\"server\""
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inaddr",
            "0",
            "sizeof(inaddr)"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLNodeNameEqual",
          "args": [
            "cur",
            "\"bootp\""
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeNameEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1013-1018",
          "snippet": "bool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nbool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&def->address",
            "AF_INET"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->hosts",
            "def->nhosts",
            "host"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDHCPHostDefParseXML",
          "args": [
            "networkName",
            "def",
            "cur",
            "&host",
            "false"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDHCPHostDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "434-552",
          "snippet": "static int\nvirNetworkDHCPHostDefParseXML(const char *networkName,\n                              virNetworkIPDefPtr def,\n                              xmlNodePtr node,\n                              virNetworkDHCPHostDefPtr host,\n                              bool partialOkay)\n{\n    char *mac = NULL, *name = NULL, *ip = NULL, *id = NULL;\n    virMacAddr addr;\n    virSocketAddr inaddr;\n    int ret = -1;\n\n    mac = virXMLPropString(node, \"mac\");\n    if (mac != NULL) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET6)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid to specify MAC address '%s' \"\n                             \"in network '%s' IPv6 static host definition\"),\n                           mac, networkName);\n            goto cleanup;\n        }\n        if (virMacAddrParse(mac, &addr) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Cannot parse MAC address '%s' in network '%s'\"),\n                           mac, networkName);\n            goto cleanup;\n        }\n        if (virMacAddrIsMulticast(&addr)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"expected unicast mac address, found \"\n                             \"multicast '%s' in network '%s'\"),\n                           (const char *)mac, networkName);\n            goto cleanup;\n        }\n    }\n\n    id = virXMLPropString(node, \"id\");\n    if (id) {\n        char *cp = id + strspn(id, \"0123456789abcdefABCDEF:\");\n        if (*cp) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid character '%c' in id '%s' of network '%s'\"),\n                           *cp, id, networkName);\n            goto cleanup;\n        }\n    }\n\n    name = virXMLPropString(node, \"name\");\n    if (name && (!g_ascii_isalpha(name[0]))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Cannot use host name '%s' in network '%s'\"),\n                       name, networkName);\n        goto cleanup;\n    }\n\n    ip = virXMLPropString(node, \"ip\");\n    if (ip && (virSocketAddrParse(&inaddr, ip, AF_UNSPEC) < 0)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid IP address in static host definition \"\n                         \"for network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    if (partialOkay) {\n        /* for search/match, you just need one of the three */\n        if (!(mac || name || ip)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"At least one of name, mac, or ip attribute \"\n                             \"must be specified for static host definition \"\n                             \"in network '%s' \"),\n                           networkName);\n            goto cleanup;\n        }\n    } else {\n        /* normal usage - you need at least name (IPv6) or one of MAC\n         * address or name (IPv4)\n         */\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET6)) {\n            if (!(id || name)) {\n                virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Static host definition in IPv6 network '%s' \"\n                             \"must have id or name attribute\"),\n                           networkName);\n                goto cleanup;\n            }\n        } else if (!(mac || name)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Static host definition in IPv4 network '%s' \"\n                             \"must have mac or name attribute\"),\n                           networkName);\n            goto cleanup;\n        }\n        if (!ip) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Missing IP address in static host definition \"\n                             \"for network '%s'\"),\n                           networkName);\n            goto cleanup;\n        }\n    }\n\n    host->mac = mac;\n    mac = NULL;\n    host->id = id;\n    id = NULL;\n    host->name = name;\n    name = NULL;\n    if (ip)\n        host->ip = inaddr;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(mac);\n    VIR_FREE(id);\n    VIR_FREE(name);\n    VIR_FREE(ip);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDHCPHostDefParseXML(const char *networkName,\n                              virNetworkIPDefPtr def,\n                              xmlNodePtr node,\n                              virNetworkDHCPHostDefPtr host,\n                              bool partialOkay)\n{\n    char *mac = NULL, *name = NULL, *ip = NULL, *id = NULL;\n    virMacAddr addr;\n    virSocketAddr inaddr;\n    int ret = -1;\n\n    mac = virXMLPropString(node, \"mac\");\n    if (mac != NULL) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET6)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid to specify MAC address '%s' \"\n                             \"in network '%s' IPv6 static host definition\"),\n                           mac, networkName);\n            goto cleanup;\n        }\n        if (virMacAddrParse(mac, &addr) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Cannot parse MAC address '%s' in network '%s'\"),\n                           mac, networkName);\n            goto cleanup;\n        }\n        if (virMacAddrIsMulticast(&addr)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"expected unicast mac address, found \"\n                             \"multicast '%s' in network '%s'\"),\n                           (const char *)mac, networkName);\n            goto cleanup;\n        }\n    }\n\n    id = virXMLPropString(node, \"id\");\n    if (id) {\n        char *cp = id + strspn(id, \"0123456789abcdefABCDEF:\");\n        if (*cp) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid character '%c' in id '%s' of network '%s'\"),\n                           *cp, id, networkName);\n            goto cleanup;\n        }\n    }\n\n    name = virXMLPropString(node, \"name\");\n    if (name && (!g_ascii_isalpha(name[0]))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Cannot use host name '%s' in network '%s'\"),\n                       name, networkName);\n        goto cleanup;\n    }\n\n    ip = virXMLPropString(node, \"ip\");\n    if (ip && (virSocketAddrParse(&inaddr, ip, AF_UNSPEC) < 0)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid IP address in static host definition \"\n                         \"for network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    if (partialOkay) {\n        /* for search/match, you just need one of the three */\n        if (!(mac || name || ip)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"At least one of name, mac, or ip attribute \"\n                             \"must be specified for static host definition \"\n                             \"in network '%s' \"),\n                           networkName);\n            goto cleanup;\n        }\n    } else {\n        /* normal usage - you need at least name (IPv6) or one of MAC\n         * address or name (IPv4)\n         */\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET6)) {\n            if (!(id || name)) {\n                virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Static host definition in IPv6 network '%s' \"\n                             \"must have id or name attribute\"),\n                           networkName);\n                goto cleanup;\n            }\n        } else if (!(mac || name)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Static host definition in IPv4 network '%s' \"\n                             \"must have mac or name attribute\"),\n                           networkName);\n            goto cleanup;\n        }\n        if (!ip) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Missing IP address in static host definition \"\n                             \"for network '%s'\"),\n                           networkName);\n            goto cleanup;\n        }\n    }\n\n    host->mac = mac;\n    mac = NULL;\n    host->id = id;\n    id = NULL;\n    host->name = name;\n    name = NULL;\n    if (ip)\n        host->ip = inaddr;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(mac);\n    VIR_FREE(id);\n    VIR_FREE(name);\n    VIR_FREE(ip);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->ranges",
            "def->nranges",
            "range"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrRangeParseXML",
          "args": [
            "networkName",
            "def",
            "cur",
            "&range"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrRangeParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "393-431",
          "snippet": "static int\nvirSocketAddrRangeParseXML(const char *networkName,\n                           virNetworkIPDefPtr ipdef,\n                           xmlNodePtr node,\n                           virSocketAddrRangePtr range)\n{\n    char *start = NULL, *end = NULL;\n    int ret = -1;\n\n    if (!(start = virXMLPropString(node, \"start\"))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Missing 'start' attribute in dhcp range for network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (virSocketAddrParse(&range->start, start, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    if (!(end = virXMLPropString(node, \"end\"))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Missing 'end' attribute in dhcp range for network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (virSocketAddrParse(&range->end, end, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    /* do a sanity check of the range */\n    if (virSocketAddrGetRange(&range->start, &range->end, &ipdef->address,\n                              virNetworkIPDefPrefix(ipdef)) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(start);\n    VIR_FREE(end);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirSocketAddrRangeParseXML(const char *networkName,\n                           virNetworkIPDefPtr ipdef,\n                           xmlNodePtr node,\n                           virSocketAddrRangePtr range)\n{\n    char *start = NULL, *end = NULL;\n    int ret = -1;\n\n    if (!(start = virXMLPropString(node, \"start\"))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Missing 'start' attribute in dhcp range for network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (virSocketAddrParse(&range->start, start, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    if (!(end = virXMLPropString(node, \"end\"))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Missing 'end' attribute in dhcp range for network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (virSocketAddrParse(&range->end, end, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    /* do a sanity check of the range */\n    if (virSocketAddrGetRange(&range->start, &range->end, &ipdef->address,\n                              virNetworkIPDefPrefix(ipdef)) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(start);\n    VIR_FREE(end);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&host",
            "0",
            "sizeof(host)"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&range",
            "0",
            "sizeof(range)"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDHCPDefParseXML(const char *networkName,\n                          xmlNodePtr node,\n                          virNetworkIPDefPtr def)\n{\n    int ret = -1;\n    xmlNodePtr cur;\n    virSocketAddrRange range;\n    virNetworkDHCPHostDef host;\n\n    memset(&range, 0, sizeof(range));\n    memset(&host, 0, sizeof(host));\n\n    cur = node->children;\n    while (cur != NULL) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"range\")) {\n\n            if (virSocketAddrRangeParseXML(networkName, def, cur, &range) < 0)\n                goto cleanup;\n            if (VIR_APPEND_ELEMENT(def->ranges, def->nranges, range) < 0)\n                goto cleanup;\n\n        } else if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"host\")) {\n\n            if (virNetworkDHCPHostDefParseXML(networkName, def, cur,\n                                              &host, false) < 0)\n                goto cleanup;\n            if (VIR_APPEND_ELEMENT(def->hosts, def->nhosts, host) < 0)\n                goto cleanup;\n\n        } else if (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET) &&\n                   cur->type == XML_ELEMENT_NODE &&\n                   virXMLNodeNameEqual(cur, \"bootp\")) {\n            char *file;\n            char *server;\n            virSocketAddr inaddr;\n            memset(&inaddr, 0, sizeof(inaddr));\n\n            if (!(file = virXMLPropString(cur, \"file\"))) {\n                cur = cur->next;\n                continue;\n            }\n            server = virXMLPropString(cur, \"server\");\n\n            if (server &&\n                virSocketAddrParse(&inaddr, server, AF_UNSPEC) < 0) {\n                VIR_FREE(file);\n                VIR_FREE(server);\n                goto cleanup;\n            }\n\n            def->bootfile = file;\n            def->bootserver = inaddr;\n            VIR_FREE(server);\n        }\n\n        cur = cur->next;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDHCPHostDefClear(&host);\n    return ret;\n}"
  },
  {
    "function_name": "virNetworkDHCPHostDefParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "434-552",
    "snippet": "static int\nvirNetworkDHCPHostDefParseXML(const char *networkName,\n                              virNetworkIPDefPtr def,\n                              xmlNodePtr node,\n                              virNetworkDHCPHostDefPtr host,\n                              bool partialOkay)\n{\n    char *mac = NULL, *name = NULL, *ip = NULL, *id = NULL;\n    virMacAddr addr;\n    virSocketAddr inaddr;\n    int ret = -1;\n\n    mac = virXMLPropString(node, \"mac\");\n    if (mac != NULL) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET6)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid to specify MAC address '%s' \"\n                             \"in network '%s' IPv6 static host definition\"),\n                           mac, networkName);\n            goto cleanup;\n        }\n        if (virMacAddrParse(mac, &addr) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Cannot parse MAC address '%s' in network '%s'\"),\n                           mac, networkName);\n            goto cleanup;\n        }\n        if (virMacAddrIsMulticast(&addr)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"expected unicast mac address, found \"\n                             \"multicast '%s' in network '%s'\"),\n                           (const char *)mac, networkName);\n            goto cleanup;\n        }\n    }\n\n    id = virXMLPropString(node, \"id\");\n    if (id) {\n        char *cp = id + strspn(id, \"0123456789abcdefABCDEF:\");\n        if (*cp) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid character '%c' in id '%s' of network '%s'\"),\n                           *cp, id, networkName);\n            goto cleanup;\n        }\n    }\n\n    name = virXMLPropString(node, \"name\");\n    if (name && (!g_ascii_isalpha(name[0]))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Cannot use host name '%s' in network '%s'\"),\n                       name, networkName);\n        goto cleanup;\n    }\n\n    ip = virXMLPropString(node, \"ip\");\n    if (ip && (virSocketAddrParse(&inaddr, ip, AF_UNSPEC) < 0)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid IP address in static host definition \"\n                         \"for network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    if (partialOkay) {\n        /* for search/match, you just need one of the three */\n        if (!(mac || name || ip)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"At least one of name, mac, or ip attribute \"\n                             \"must be specified for static host definition \"\n                             \"in network '%s' \"),\n                           networkName);\n            goto cleanup;\n        }\n    } else {\n        /* normal usage - you need at least name (IPv6) or one of MAC\n         * address or name (IPv4)\n         */\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET6)) {\n            if (!(id || name)) {\n                virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Static host definition in IPv6 network '%s' \"\n                             \"must have id or name attribute\"),\n                           networkName);\n                goto cleanup;\n            }\n        } else if (!(mac || name)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Static host definition in IPv4 network '%s' \"\n                             \"must have mac or name attribute\"),\n                           networkName);\n            goto cleanup;\n        }\n        if (!ip) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Missing IP address in static host definition \"\n                             \"for network '%s'\"),\n                           networkName);\n            goto cleanup;\n        }\n    }\n\n    host->mac = mac;\n    mac = NULL;\n    host->id = id;\n    id = NULL;\n    host->name = name;\n    name = NULL;\n    if (ip)\n        host->ip = inaddr;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(mac);\n    VIR_FREE(id);\n    VIR_FREE(name);\n    VIR_FREE(ip);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ip"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "id"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mac"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Missing IP address in static host definition \"\n                             \"for network '%s'\")",
            "networkName"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing IP address in static host definition \"\n                             \"for network '%s'\""
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Static host definition in IPv4 network '%s' \"\n                             \"must have mac or name attribute\")",
            "networkName"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Static host definition in IPv6 network '%s' \"\n                             \"must have id or name attribute\")",
            "networkName"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&def->address",
            "AF_INET6"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"At least one of name, mac, or ip attribute \"\n                             \"must be specified for static host definition \"\n                             \"in network '%s' \")",
            "networkName"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid IP address in static host definition \"\n                         \"for network '%s'\")",
            "networkName"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrParse",
          "args": [
            "&inaddr",
            "ip",
            "AF_UNSPEC"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "135-158",
          "snippet": "int virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "node",
            "\"ip\""
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Cannot use host name '%s' in network '%s'\")",
            "name",
            "networkName"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ascii_isalpha",
          "args": [
            "name[0]"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid character '%c' in id '%s' of network '%s'\")",
            "*cp",
            "id",
            "networkName"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "id",
            "\"0123456789abcdefABCDEF:\""
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"expected unicast mac address, found \"\n                             \"multicast '%s' in network '%s'\")",
            "(const char *)mac",
            "networkName"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrIsMulticast",
          "args": [
            "&addr"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrIsMulticast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "232-236",
          "snippet": "bool\nvirMacAddrIsMulticast(const virMacAddr *mac)\n{\n    return !!(mac->addr[0] & 1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nbool\nvirMacAddrIsMulticast(const virMacAddr *mac)\n{\n    return !!(mac->addr[0] & 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Cannot parse MAC address '%s' in network '%s'\")",
            "mac",
            "networkName"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrParse",
          "args": [
            "mac",
            "&addr"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "205-218",
          "snippet": "int\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid to specify MAC address '%s' \"\n                             \"in network '%s' IPv6 static host definition\")",
            "mac",
            "networkName"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&def->address",
            "AF_INET6"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkDHCPHostDefParseXML(const char *networkName,\n                              virNetworkIPDefPtr def,\n                              xmlNodePtr node,\n                              virNetworkDHCPHostDefPtr host,\n                              bool partialOkay)\n{\n    char *mac = NULL, *name = NULL, *ip = NULL, *id = NULL;\n    virMacAddr addr;\n    virSocketAddr inaddr;\n    int ret = -1;\n\n    mac = virXMLPropString(node, \"mac\");\n    if (mac != NULL) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET6)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid to specify MAC address '%s' \"\n                             \"in network '%s' IPv6 static host definition\"),\n                           mac, networkName);\n            goto cleanup;\n        }\n        if (virMacAddrParse(mac, &addr) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Cannot parse MAC address '%s' in network '%s'\"),\n                           mac, networkName);\n            goto cleanup;\n        }\n        if (virMacAddrIsMulticast(&addr)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"expected unicast mac address, found \"\n                             \"multicast '%s' in network '%s'\"),\n                           (const char *)mac, networkName);\n            goto cleanup;\n        }\n    }\n\n    id = virXMLPropString(node, \"id\");\n    if (id) {\n        char *cp = id + strspn(id, \"0123456789abcdefABCDEF:\");\n        if (*cp) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid character '%c' in id '%s' of network '%s'\"),\n                           *cp, id, networkName);\n            goto cleanup;\n        }\n    }\n\n    name = virXMLPropString(node, \"name\");\n    if (name && (!g_ascii_isalpha(name[0]))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Cannot use host name '%s' in network '%s'\"),\n                       name, networkName);\n        goto cleanup;\n    }\n\n    ip = virXMLPropString(node, \"ip\");\n    if (ip && (virSocketAddrParse(&inaddr, ip, AF_UNSPEC) < 0)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid IP address in static host definition \"\n                         \"for network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n\n    if (partialOkay) {\n        /* for search/match, you just need one of the three */\n        if (!(mac || name || ip)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"At least one of name, mac, or ip attribute \"\n                             \"must be specified for static host definition \"\n                             \"in network '%s' \"),\n                           networkName);\n            goto cleanup;\n        }\n    } else {\n        /* normal usage - you need at least name (IPv6) or one of MAC\n         * address or name (IPv4)\n         */\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET6)) {\n            if (!(id || name)) {\n                virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Static host definition in IPv6 network '%s' \"\n                             \"must have id or name attribute\"),\n                           networkName);\n                goto cleanup;\n            }\n        } else if (!(mac || name)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Static host definition in IPv4 network '%s' \"\n                             \"must have mac or name attribute\"),\n                           networkName);\n            goto cleanup;\n        }\n        if (!ip) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Missing IP address in static host definition \"\n                             \"for network '%s'\"),\n                           networkName);\n            goto cleanup;\n        }\n    }\n\n    host->mac = mac;\n    mac = NULL;\n    host->id = id;\n    id = NULL;\n    host->name = name;\n    name = NULL;\n    if (ip)\n        host->ip = inaddr;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(mac);\n    VIR_FREE(id);\n    VIR_FREE(name);\n    VIR_FREE(ip);\n    return ret;\n}"
  },
  {
    "function_name": "virSocketAddrRangeParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "393-431",
    "snippet": "static int\nvirSocketAddrRangeParseXML(const char *networkName,\n                           virNetworkIPDefPtr ipdef,\n                           xmlNodePtr node,\n                           virSocketAddrRangePtr range)\n{\n    char *start = NULL, *end = NULL;\n    int ret = -1;\n\n    if (!(start = virXMLPropString(node, \"start\"))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Missing 'start' attribute in dhcp range for network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (virSocketAddrParse(&range->start, start, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    if (!(end = virXMLPropString(node, \"end\"))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Missing 'end' attribute in dhcp range for network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (virSocketAddrParse(&range->end, end, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    /* do a sanity check of the range */\n    if (virSocketAddrGetRange(&range->start, &range->end, &ipdef->address,\n                              virNetworkIPDefPrefix(ipdef)) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(start);\n    VIR_FREE(end);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "end"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "start"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrGetRange",
          "args": [
            "&range->start",
            "&range->end",
            "&ipdef->address",
            "virNetworkIPDefPrefix(ipdef)"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetRange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "825-997",
          "snippet": "int\nvirSocketAddrGetRange(virSocketAddrPtr start, virSocketAddrPtr end,\n                      virSocketAddrPtr network, int prefix)\n{\n    int ret = 0;\n    size_t i;\n    virSocketAddr netmask;\n    g_autofree char *startStr = NULL;\n    g_autofree char *endStr = NULL;\n    g_autofree char *netStr = NULL;\n\n    if (start == NULL || end == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NULL argument - %p %p\"), start, end);\n        return -1;\n    }\n\n    startStr = virSocketAddrFormat(start);\n    endStr = virSocketAddrFormat(end);\n    if (!startStr || !endStr)\n        return -1; /*error already reported */\n\n    if (VIR_SOCKET_ADDR_FAMILY(start) != VIR_SOCKET_ADDR_FAMILY(end)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"mismatch of address family in range %s - %s\"),\n                       startStr, endStr);\n        return -1;\n    }\n\n    if (network) {\n        /* some checks can only be done if we have details of the\n         * network the range should be within\n         */\n        if (!(netStr = virSocketAddrFormat(network)))\n            return -1;\n\n        if (VIR_SOCKET_ADDR_FAMILY(start) != VIR_SOCKET_ADDR_FAMILY(network)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"mismatch of address family in \"\n                             \"range %s - %s for network %s\"),\n                           startStr, endStr, netStr);\n            return -1;\n        }\n\n        if (prefix < 0 ||\n            virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                         VIR_SOCKET_ADDR_FAMILY(network)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"bad prefix %d for network %s when \"\n                             \" checking range %s - %s\"),\n                           prefix, netStr, startStr, endStr);\n            return -1;\n        }\n\n        /* both start and end of range need to be within network */\n        if (virSocketAddrCheckNetmask(start, network, &netmask) <= 0 ||\n            virSocketAddrCheckNetmask(end, network, &netmask) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s is not entirely within \"\n                             \"network %s/%d\"),\n                           startStr, endStr, netStr, prefix);\n            return -1;\n        }\n\n        if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET)) {\n            virSocketAddr netaddr, broadcast;\n\n            if (virSocketAddrBroadcast(network, &netmask, &broadcast) < 0 ||\n                virSocketAddrMask(network, &netmask, &netaddr) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"failed to construct broadcast or network \"\n                                 \"address for network %s/%d\"),\n                               netStr, prefix);\n                return -1;\n            }\n\n            /* Don't allow the start of the range to be the network\n             * address (usually \"...0\") or the end of the range to be the\n             * broadcast address (usually \"...255\"). (the opposite also\n             * isn't allowed, but checking for that is implicit in all the\n             * other combined checks) (IPv6 doesn't have broadcast and\n             * network addresses, so this check is only done for IPv4)\n             */\n            if (virSocketAddrEqual(start, &netaddr)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"start of range %s - %s in network %s/%d \"\n                                 \"is the network address\"),\n                               startStr, endStr, netStr, prefix);\n                return -1;\n            }\n\n            if (virSocketAddrEqual(end, &broadcast)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"end of range %s - %s in network %s/%d \"\n                                 \"is the broadcast address\"),\n                               startStr, endStr, netStr, prefix);\n                return -1;\n            }\n        }\n    }\n\n    if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET)) {\n        virSocketAddrIPv4 t1, t2;\n\n        if (virSocketAddrGetIPv4Addr(start, &t1) < 0 ||\n            virSocketAddrGetIPv4Addr(end, &t2) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to get IPv4 address \"\n                             \"for start or end of range %s - %s\"),\n                           startStr, endStr);\n            return -1;\n        }\n\n        /* legacy check that everything except the last two bytes\n         * are the same\n         */\n        for (i = 0; i < 2; i++) {\n            if (t1[i] != t2[i]) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"range %s - %s is too large (> 65535)\"),\n                               startStr, endStr);\n                return -1;\n            }\n        }\n        ret = (t2[2] - t1[2]) * 256 + (t2[3] - t1[3]);\n        if (ret < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s is reversed \"),\n                           startStr, endStr);\n            return -1;\n        }\n        ret++;\n    } else if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET6)) {\n        virSocketAddrIPv6 t1, t2;\n\n        if (virSocketAddrGetIPv6Addr(start, &t1) < 0 ||\n            virSocketAddrGetIPv6Addr(end, &t2) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to get IPv6 address \"\n                             \"for start or end of range %s - %s\"),\n                           startStr, endStr);\n            return -1;\n        }\n\n        /* legacy check that everything except the last two bytes are\n         * the same\n         */\n        for (i = 0; i < 7; i++) {\n            if (t1[i] != t2[i]) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"range %s - %s is too large (> 65535)\"),\n                               startStr, endStr);\n                return -1;\n            }\n        }\n        ret = t2[7] - t1[7];\n        if (ret < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s start larger than end\"),\n                           startStr, endStr);\n            return -1;\n        }\n        ret++;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unsupported address family \"\n                         \"for range %s - %s, must be ipv4 or ipv6\"),\n                       startStr, endStr);\n        return -1;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrGetRange(virSocketAddrPtr start, virSocketAddrPtr end,\n                      virSocketAddrPtr network, int prefix)\n{\n    int ret = 0;\n    size_t i;\n    virSocketAddr netmask;\n    g_autofree char *startStr = NULL;\n    g_autofree char *endStr = NULL;\n    g_autofree char *netStr = NULL;\n\n    if (start == NULL || end == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NULL argument - %p %p\"), start, end);\n        return -1;\n    }\n\n    startStr = virSocketAddrFormat(start);\n    endStr = virSocketAddrFormat(end);\n    if (!startStr || !endStr)\n        return -1; /*error already reported */\n\n    if (VIR_SOCKET_ADDR_FAMILY(start) != VIR_SOCKET_ADDR_FAMILY(end)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"mismatch of address family in range %s - %s\"),\n                       startStr, endStr);\n        return -1;\n    }\n\n    if (network) {\n        /* some checks can only be done if we have details of the\n         * network the range should be within\n         */\n        if (!(netStr = virSocketAddrFormat(network)))\n            return -1;\n\n        if (VIR_SOCKET_ADDR_FAMILY(start) != VIR_SOCKET_ADDR_FAMILY(network)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"mismatch of address family in \"\n                             \"range %s - %s for network %s\"),\n                           startStr, endStr, netStr);\n            return -1;\n        }\n\n        if (prefix < 0 ||\n            virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                         VIR_SOCKET_ADDR_FAMILY(network)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"bad prefix %d for network %s when \"\n                             \" checking range %s - %s\"),\n                           prefix, netStr, startStr, endStr);\n            return -1;\n        }\n\n        /* both start and end of range need to be within network */\n        if (virSocketAddrCheckNetmask(start, network, &netmask) <= 0 ||\n            virSocketAddrCheckNetmask(end, network, &netmask) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s is not entirely within \"\n                             \"network %s/%d\"),\n                           startStr, endStr, netStr, prefix);\n            return -1;\n        }\n\n        if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET)) {\n            virSocketAddr netaddr, broadcast;\n\n            if (virSocketAddrBroadcast(network, &netmask, &broadcast) < 0 ||\n                virSocketAddrMask(network, &netmask, &netaddr) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"failed to construct broadcast or network \"\n                                 \"address for network %s/%d\"),\n                               netStr, prefix);\n                return -1;\n            }\n\n            /* Don't allow the start of the range to be the network\n             * address (usually \"...0\") or the end of the range to be the\n             * broadcast address (usually \"...255\"). (the opposite also\n             * isn't allowed, but checking for that is implicit in all the\n             * other combined checks) (IPv6 doesn't have broadcast and\n             * network addresses, so this check is only done for IPv4)\n             */\n            if (virSocketAddrEqual(start, &netaddr)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"start of range %s - %s in network %s/%d \"\n                                 \"is the network address\"),\n                               startStr, endStr, netStr, prefix);\n                return -1;\n            }\n\n            if (virSocketAddrEqual(end, &broadcast)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"end of range %s - %s in network %s/%d \"\n                                 \"is the broadcast address\"),\n                               startStr, endStr, netStr, prefix);\n                return -1;\n            }\n        }\n    }\n\n    if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET)) {\n        virSocketAddrIPv4 t1, t2;\n\n        if (virSocketAddrGetIPv4Addr(start, &t1) < 0 ||\n            virSocketAddrGetIPv4Addr(end, &t2) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to get IPv4 address \"\n                             \"for start or end of range %s - %s\"),\n                           startStr, endStr);\n            return -1;\n        }\n\n        /* legacy check that everything except the last two bytes\n         * are the same\n         */\n        for (i = 0; i < 2; i++) {\n            if (t1[i] != t2[i]) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"range %s - %s is too large (> 65535)\"),\n                               startStr, endStr);\n                return -1;\n            }\n        }\n        ret = (t2[2] - t1[2]) * 256 + (t2[3] - t1[3]);\n        if (ret < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s is reversed \"),\n                           startStr, endStr);\n            return -1;\n        }\n        ret++;\n    } else if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET6)) {\n        virSocketAddrIPv6 t1, t2;\n\n        if (virSocketAddrGetIPv6Addr(start, &t1) < 0 ||\n            virSocketAddrGetIPv6Addr(end, &t2) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to get IPv6 address \"\n                             \"for start or end of range %s - %s\"),\n                           startStr, endStr);\n            return -1;\n        }\n\n        /* legacy check that everything except the last two bytes are\n         * the same\n         */\n        for (i = 0; i < 7; i++) {\n            if (t1[i] != t2[i]) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"range %s - %s is too large (> 65535)\"),\n                               startStr, endStr);\n                return -1;\n            }\n        }\n        ret = t2[7] - t1[7];\n        if (ret < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s start larger than end\"),\n                           startStr, endStr);\n            return -1;\n        }\n        ret++;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unsupported address family \"\n                         \"for range %s - %s, must be ipv4 or ipv6\"),\n                       startStr, endStr);\n        return -1;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefPrefix",
          "args": [
            "ipdef"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "367-373",
          "snippet": "int\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrParse",
          "args": [
            "&range->end",
            "end",
            "AF_UNSPEC"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "135-158",
          "snippet": "int virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Missing 'end' attribute in dhcp range for network '%s'\")",
            "networkName"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing 'end' attribute in dhcp range for network '%s'\""
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "node",
            "\"end\""
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Missing 'start' attribute in dhcp range for network '%s'\")",
            "networkName"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirSocketAddrRangeParseXML(const char *networkName,\n                           virNetworkIPDefPtr ipdef,\n                           xmlNodePtr node,\n                           virSocketAddrRangePtr range)\n{\n    char *start = NULL, *end = NULL;\n    int ret = -1;\n\n    if (!(start = virXMLPropString(node, \"start\"))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Missing 'start' attribute in dhcp range for network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (virSocketAddrParse(&range->start, start, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    if (!(end = virXMLPropString(node, \"end\"))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Missing 'end' attribute in dhcp range for network '%s'\"),\n                       networkName);\n        goto cleanup;\n    }\n    if (virSocketAddrParse(&range->end, end, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    /* do a sanity check of the range */\n    if (virSocketAddrGetRange(&range->start, &range->end, &ipdef->address,\n                              virNetworkIPDefPrefix(ipdef)) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(start);\n    VIR_FREE(end);\n    return ret;\n}"
  },
  {
    "function_name": "virNetworkIPDefNetmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "380-390",
    "snippet": "int virNetworkIPDefNetmask(const virNetworkIPDef *def,\n                           virSocketAddrPtr netmask)\n{\n    if (VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET)) {\n        *netmask = def->netmask;\n        return 0;\n    }\n\n    return virSocketAddrPrefixToNetmask(virNetworkIPDefPrefix(def), netmask,\n                                        VIR_SOCKET_ADDR_FAMILY(&def->address));\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSocketAddrPrefixToNetmask",
          "args": [
            "virNetworkIPDefPrefix(def)",
            "netmask",
            "VIR_SOCKET_ADDR_FAMILY(&def->address)"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrPrefixToNetmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1098-1141",
          "snippet": "int\nvirSocketAddrPrefixToNetmask(unsigned int prefix,\n                             virSocketAddrPtr netmask,\n                             int family)\n{\n    netmask->data.stor.ss_family = AF_UNSPEC; /* assume failure */\n\n    if (family == AF_INET) {\n        int ip;\n\n        if (prefix > 32)\n            return -1;\n\n        ip = prefix ? ~((1 << (32 - prefix)) - 1) : 0;\n        netmask->data.inet4.sin_addr.s_addr = htonl(ip);\n        netmask->data.stor.ss_family = AF_INET;\n        netmask->len = sizeof(struct sockaddr_in);\n\n    } else if (family == AF_INET6) {\n        size_t i = 0;\n\n        if (prefix > 128)\n            return -1;\n\n        while (prefix >= 8) {\n            /* do as much as possible an entire byte at a time */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0xff;\n            prefix -= 8;\n        }\n        if (prefix > 0) {\n            /* final partial byte */\n            netmask->data.inet6.sin6_addr.s6_addr[i++]\n                = ~((1 << (8 - prefix)) -1);\n        }\n        while (i < 16) {\n            /* zerofill remainder in case it wasn't initialized */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0;\n        }\n        netmask->data.stor.ss_family = AF_INET6;\n        netmask->len = sizeof(struct sockaddr_in6);\n    }\n\n    return 0;\n }",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrPrefixToNetmask(unsigned int prefix,\n                             virSocketAddrPtr netmask,\n                             int family)\n{\n    netmask->data.stor.ss_family = AF_UNSPEC; /* assume failure */\n\n    if (family == AF_INET) {\n        int ip;\n\n        if (prefix > 32)\n            return -1;\n\n        ip = prefix ? ~((1 << (32 - prefix)) - 1) : 0;\n        netmask->data.inet4.sin_addr.s_addr = htonl(ip);\n        netmask->data.stor.ss_family = AF_INET;\n        netmask->len = sizeof(struct sockaddr_in);\n\n    } else if (family == AF_INET6) {\n        size_t i = 0;\n\n        if (prefix > 128)\n            return -1;\n\n        while (prefix >= 8) {\n            /* do as much as possible an entire byte at a time */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0xff;\n            prefix -= 8;\n        }\n        if (prefix > 0) {\n            /* final partial byte */\n            netmask->data.inet6.sin6_addr.s6_addr[i++]\n                = ~((1 << (8 - prefix)) -1);\n        }\n        while (i < 16) {\n            /* zerofill remainder in case it wasn't initialized */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0;\n        }\n        netmask->data.stor.ss_family = AF_INET6;\n        netmask->len = sizeof(struct sockaddr_in6);\n    }\n\n    return 0;\n }"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "&def->address"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefPrefix",
          "args": [
            "def"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "367-373",
          "snippet": "int\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&def->netmask",
            "AF_INET"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetworkIPDefNetmask(const virNetworkIPDef *def,\n                           virSocketAddrPtr netmask)\n{\n    if (VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET)) {\n        *netmask = def->netmask;\n        return 0;\n    }\n\n    return virSocketAddrPrefixToNetmask(virNetworkIPDefPrefix(def), netmask,\n                                        VIR_SOCKET_ADDR_FAMILY(&def->address));\n}"
  },
  {
    "function_name": "virNetworkIPDefPrefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "367-373",
    "snippet": "int\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSocketAddrGetIPPrefix",
          "args": [
            "&def->address",
            "&def->netmask",
            "def->prefix"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetIPPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1152-1198",
          "snippet": "int\nvirSocketAddrGetIPPrefix(const virSocketAddr *address,\n                         const virSocketAddr *netmask,\n                         int prefix)\n{\n    if (prefix > 0) {\n        return prefix;\n    } else if (netmask && VIR_SOCKET_ADDR_VALID(netmask)) {\n        return virSocketAddrGetNumNetmaskBits(netmask);\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET)) {\n        /* Return the natural prefix for the network's ip address.\n         * On Linux we could use the IN_CLASSx() macros, but those\n         * aren't guaranteed on all platforms, so we just deal with\n         * the bits ourselves.\n         */\n        unsigned char octet\n            = ntohl(address->data.inet4.sin_addr.s_addr) >> 24;\n\n        /* If address is 0.0.0.0, we surely want to have 0 prefix for\n         * the default route. */\n        if (address->data.inet4.sin_addr.s_addr == 0)\n            return 0;\n\n        if ((octet & 0x80) == 0) {\n            /* Class A network */\n            return 8;\n        } else if ((octet & 0xC0) == 0x80) {\n            /* Class B network */\n            return 16;\n        } else if ((octet & 0xE0) == 0xC0) {\n            /* Class C network */\n            return 24;\n        }\n        return -1;\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET6)) {\n        if (virSocketAddrIsWildcard(address))\n            return 0;\n        return 64;\n    }\n\n    /* When none of the three (address/netmask/prefix) is given, 0 is\n     * returned rather than error, because this is a valid\n     * expectation, e.g. for the address/prefix used for a default\n     * route (the destination of a default route is 0.0.0.0/0).\n     */\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrGetIPPrefix(const virSocketAddr *address,\n                         const virSocketAddr *netmask,\n                         int prefix)\n{\n    if (prefix > 0) {\n        return prefix;\n    } else if (netmask && VIR_SOCKET_ADDR_VALID(netmask)) {\n        return virSocketAddrGetNumNetmaskBits(netmask);\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET)) {\n        /* Return the natural prefix for the network's ip address.\n         * On Linux we could use the IN_CLASSx() macros, but those\n         * aren't guaranteed on all platforms, so we just deal with\n         * the bits ourselves.\n         */\n        unsigned char octet\n            = ntohl(address->data.inet4.sin_addr.s_addr) >> 24;\n\n        /* If address is 0.0.0.0, we surely want to have 0 prefix for\n         * the default route. */\n        if (address->data.inet4.sin_addr.s_addr == 0)\n            return 0;\n\n        if ((octet & 0x80) == 0) {\n            /* Class A network */\n            return 8;\n        } else if ((octet & 0xC0) == 0x80) {\n            /* Class B network */\n            return 16;\n        } else if ((octet & 0xE0) == 0xC0) {\n            /* Class C network */\n            return 24;\n        }\n        return -1;\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET6)) {\n        if (virSocketAddrIsWildcard(address))\n            return 0;\n        return 64;\n    }\n\n    /* When none of the three (address/netmask/prefix) is given, 0 is\n     * returned rather than error, because this is a valid\n     * expectation, e.g. for the address/prefix used for a default\n     * route (the destination of a default route is 0.0.0.0/0).\n     */\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}"
  },
  {
    "function_name": "virNetworkDefGetRouteByIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "337-361",
    "snippet": "virNetDevIPRoutePtr\nvirNetworkDefGetRouteByIndex(const virNetworkDef *def,\n                             int family,\n                             size_t n)\n{\n    size_t i;\n\n    if (!def->routes || n >= def->nroutes)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return def->routes[n];\n\n    /* find the nth route of type \"family\" */\n    for (i = 0; i < def->nroutes; i++) {\n        virSocketAddrPtr addr = virNetDevIPRouteGetAddress(def->routes[i]);\n        if (VIR_SOCKET_ADDR_IS_FAMILY(addr, family)\n            && (n-- <= 0)) {\n            return def->routes[i];\n        }\n    }\n\n    /* failed to find enough of the right family */\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "addr",
            "family"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteGetAddress",
          "args": [
            "def->routes[i]"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteGetAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "984-991",
          "snippet": "virSocketAddrPtr\nvirNetDevIPRouteGetAddress(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->address;\n\n    return NULL;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nvirSocketAddrPtr\nvirNetDevIPRouteGetAddress(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->address;\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetDevIPRoutePtr\nvirNetworkDefGetRouteByIndex(const virNetworkDef *def,\n                             int family,\n                             size_t n)\n{\n    size_t i;\n\n    if (!def->routes || n >= def->nroutes)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return def->routes[n];\n\n    /* find the nth route of type \"family\" */\n    for (i = 0; i < def->nroutes; i++) {\n        virSocketAddrPtr addr = virNetDevIPRouteGetAddress(def->routes[i]);\n        if (VIR_SOCKET_ADDR_IS_FAMILY(addr, family)\n            && (n-- <= 0)) {\n            return def->routes[i];\n        }\n    }\n\n    /* failed to find enough of the right family */\n    return NULL;\n}"
  },
  {
    "function_name": "virNetworkDefGetIPByIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "311-333",
    "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&def->ips[i].address",
            "family"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
  },
  {
    "function_name": "virNetworkDefCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "286-307",
    "snippet": "virNetworkDefPtr\nvirNetworkDefCopy(virNetworkDefPtr def,\n                  virNetworkXMLOptionPtr xmlopt,\n                  unsigned int flags)\n{\n    char *xml = NULL;\n    virNetworkDefPtr newDef = NULL;\n\n    if (!def) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"NULL NetworkDef\"));\n        return NULL;\n    }\n\n    /* deep copy with a format/parse cycle */\n    if (!(xml = virNetworkDefFormat(def, xmlopt, flags)))\n        goto cleanup;\n    newDef = virNetworkDefParseString(xml, xmlopt);\n cleanup:\n    VIR_FREE(xml);\n    return newDef;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefParseString",
          "args": [
            "xml",
            "xmlopt"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2114-2119",
          "snippet": "virNetworkDefPtr\nvirNetworkDefParseString(const char *xmlStr,\n                         virNetworkXMLOptionPtr xmlopt)\n{\n    return virNetworkDefParse(xmlStr, NULL, xmlopt);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkDefPtr\nvirNetworkDefParseString(const char *xmlStr,\n                         virNetworkXMLOptionPtr xmlopt)\n{\n    return virNetworkDefParse(xmlStr, NULL, xmlopt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefFormat",
          "args": [
            "def",
            "xmlopt",
            "flags"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2673-2688",
          "snippet": "char *\nvirNetworkDefFormat(const virNetworkDef *def,\n                    virNetworkXMLOptionPtr xmlopt,\n                    unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virNetworkDefFormatBuf(&buf, def, xmlopt, flags) < 0)\n        goto error;\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirNetworkDefFormat(const virNetworkDef *def,\n                    virNetworkXMLOptionPtr xmlopt,\n                    unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virNetworkDefFormatBuf(&buf, def, xmlopt, flags) < 0)\n        goto error;\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"NULL NetworkDef\")"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"NULL NetworkDef\""
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkDefPtr\nvirNetworkDefCopy(virNetworkDefPtr def,\n                  virNetworkXMLOptionPtr xmlopt,\n                  unsigned int flags)\n{\n    char *xml = NULL;\n    virNetworkDefPtr newDef = NULL;\n\n    if (!def) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"NULL NetworkDef\"));\n        return NULL;\n    }\n\n    /* deep copy with a format/parse cycle */\n    if (!(xml = virNetworkDefFormat(def, xmlopt, flags)))\n        goto cleanup;\n    newDef = virNetworkDefParseString(xml, xmlopt);\n cleanup:\n    VIR_FREE(xml);\n    return newDef;\n}"
  },
  {
    "function_name": "virNetworkDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "235-274",
    "snippet": "void\nvirNetworkDefFree(virNetworkDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->bridge);\n    VIR_FREE(def->bridgeZone);\n    VIR_FREE(def->domain);\n\n    virNetworkForwardDefClear(&def->forward);\n\n    for (i = 0; i < def->nips && def->ips; i++)\n        virNetworkIPDefClear(&def->ips[i]);\n    VIR_FREE(def->ips);\n\n    for (i = 0; i < def->nroutes && def->routes; i++)\n        virNetDevIPRouteFree(def->routes[i]);\n    VIR_FREE(def->routes);\n\n    for (i = 0; i < def->nPortGroups && def->portGroups; i++)\n        virPortGroupDefClear(&def->portGroups[i]);\n    VIR_FREE(def->portGroups);\n\n    virNetworkDNSDefClear(&def->dns);\n\n    VIR_FREE(def->virtPortProfile);\n\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n\n    xmlFreeNode(def->metadata);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n    VIR_FREE(def);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "def->namespaceData"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeNode",
          "args": [
            "def->metadata"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVlanClear",
          "args": [
            "&def->vlan"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVlanClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvlan.c",
          "lines": "28-35",
          "snippet": "void\nvirNetDevVlanClear(virNetDevVlanPtr vlan)\n{\n    VIR_FREE(vlan->tag);\n    vlan->nTags = 0;\n    vlan->nativeMode = 0;\n    vlan->nativeTag = 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virnetdevvlan.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirNetDevVlanClear(virNetDevVlanPtr vlan)\n{\n    VIR_FREE(vlan->tag);\n    vlan->nTags = 0;\n    vlan->nativeMode = 0;\n    vlan->nativeTag = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthFree",
          "args": [
            "def->bandwidth"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "31-40",
          "snippet": "void\nvirNetDevBandwidthFree(virNetDevBandwidthPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->in);\n    VIR_FREE(def->out);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetDevBandwidthFree(virNetDevBandwidthPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->in);\n    VIR_FREE(def->out);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->virtPortProfile"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDNSDefClear",
          "args": [
            "&def->dns"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDNSDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "193-216",
          "snippet": "static void\nvirNetworkDNSDefClear(virNetworkDNSDefPtr def)\n{\n    if (def->forwarders) {\n        while (def->nfwds)\n            virNetworkDNSForwarderClear(&def->forwarders[--def->nfwds]);\n        VIR_FREE(def->forwarders);\n    }\n    if (def->txts) {\n        while (def->ntxts)\n            virNetworkDNSTxtDefClear(&def->txts[--def->ntxts]);\n        VIR_FREE(def->txts);\n    }\n    if (def->hosts) {\n        while (def->nhosts)\n            virNetworkDNSHostDefClear(&def->hosts[--def->nhosts]);\n        VIR_FREE(def->hosts);\n    }\n    if (def->srvs) {\n        while (def->nsrvs)\n            virNetworkDNSSrvDefClear(&def->srvs[--def->nsrvs]);\n        VIR_FREE(def->srvs);\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDNSDefClear(virNetworkDNSDefPtr def)\n{\n    if (def->forwarders) {\n        while (def->nfwds)\n            virNetworkDNSForwarderClear(&def->forwarders[--def->nfwds]);\n        VIR_FREE(def->forwarders);\n    }\n    if (def->txts) {\n        while (def->ntxts)\n            virNetworkDNSTxtDefClear(&def->txts[--def->ntxts]);\n        VIR_FREE(def->txts);\n    }\n    if (def->hosts) {\n        while (def->nhosts)\n            virNetworkDNSHostDefClear(&def->hosts[--def->nhosts]);\n        VIR_FREE(def->hosts);\n    }\n    if (def->srvs) {\n        while (def->nsrvs)\n            virNetworkDNSSrvDefClear(&def->srvs[--def->nsrvs]);\n        VIR_FREE(def->srvs);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->portGroups"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPortGroupDefClear",
          "args": [
            "&def->portGroups[i]"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "virPortGroupDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "109-117",
          "snippet": "static void\nvirPortGroupDefClear(virPortGroupDefPtr def)\n{\n    VIR_FREE(def->name);\n    VIR_FREE(def->virtPortProfile);\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n    def->bandwidth = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirPortGroupDefClear(virPortGroupDefPtr def)\n{\n    VIR_FREE(def->name);\n    VIR_FREE(def->virtPortProfile);\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n    def->bandwidth = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->routes"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteFree",
          "args": [
            "def->routes[i]"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "975-982",
          "snippet": "void\nvirNetDevIPRouteFree(virNetDevIPRoutePtr def)\n{\n    if (!def)\n        return;\n    VIR_FREE(def->family);\n    VIR_FREE(def);\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nvoid\nvirNetDevIPRouteFree(virNetDevIPRoutePtr def)\n{\n    if (!def)\n        return;\n    VIR_FREE(def->family);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->ips"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefClear",
          "args": [
            "&def->ips[i]"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "144-156",
          "snippet": "static void\nvirNetworkIPDefClear(virNetworkIPDefPtr def)\n{\n    VIR_FREE(def->family);\n    VIR_FREE(def->ranges);\n\n    while (def->nhosts)\n        virNetworkDHCPHostDefClear(&def->hosts[--def->nhosts]);\n\n    VIR_FREE(def->hosts);\n    VIR_FREE(def->tftproot);\n    VIR_FREE(def->bootfile);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkIPDefClear(virNetworkIPDefPtr def)\n{\n    VIR_FREE(def->family);\n    VIR_FREE(def->ranges);\n\n    while (def->nhosts)\n        virNetworkDHCPHostDefClear(&def->hosts[--def->nhosts]);\n\n    VIR_FREE(def->hosts);\n    VIR_FREE(def->tftproot);\n    VIR_FREE(def->bootfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkForwardDefClear",
          "args": [
            "&def->forward"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkForwardDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "219-232",
          "snippet": "static void\nvirNetworkForwardDefClear(virNetworkForwardDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->npfs && def->pfs; i++)\n        virNetworkForwardPfDefClear(&def->pfs[i]);\n    VIR_FREE(def->pfs);\n\n    for (i = 0; i < def->nifs && def->ifs; i++)\n        virNetworkForwardIfDefClear(&def->ifs[i]);\n    VIR_FREE(def->ifs);\n    def->nifs = def->npfs = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkForwardDefClear(virNetworkForwardDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->npfs && def->pfs; i++)\n        virNetworkForwardPfDefClear(&def->pfs[i]);\n    VIR_FREE(def->pfs);\n\n    for (i = 0; i < def->nifs && def->ifs; i++)\n        virNetworkForwardIfDefClear(&def->ifs[i]);\n    VIR_FREE(def->ifs);\n    def->nifs = def->npfs = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->domain"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->bridgeZone"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->bridge"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->name"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetworkDefFree(virNetworkDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->bridge);\n    VIR_FREE(def->bridgeZone);\n    VIR_FREE(def->domain);\n\n    virNetworkForwardDefClear(&def->forward);\n\n    for (i = 0; i < def->nips && def->ips; i++)\n        virNetworkIPDefClear(&def->ips[i]);\n    VIR_FREE(def->ips);\n\n    for (i = 0; i < def->nroutes && def->routes; i++)\n        virNetDevIPRouteFree(def->routes[i]);\n    VIR_FREE(def->routes);\n\n    for (i = 0; i < def->nPortGroups && def->portGroups; i++)\n        virPortGroupDefClear(&def->portGroups[i]);\n    VIR_FREE(def->portGroups);\n\n    virNetworkDNSDefClear(&def->dns);\n\n    VIR_FREE(def->virtPortProfile);\n\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n\n    xmlFreeNode(def->metadata);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n    VIR_FREE(def);\n}"
  },
  {
    "function_name": "virNetworkForwardDefClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "219-232",
    "snippet": "static void\nvirNetworkForwardDefClear(virNetworkForwardDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->npfs && def->pfs; i++)\n        virNetworkForwardPfDefClear(&def->pfs[i]);\n    VIR_FREE(def->pfs);\n\n    for (i = 0; i < def->nifs && def->ifs; i++)\n        virNetworkForwardIfDefClear(&def->ifs[i]);\n    VIR_FREE(def->ifs);\n    def->nifs = def->npfs = 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->ifs"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardIfDefClear",
          "args": [
            "&def->ifs[i]"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkForwardIfDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "120-125",
          "snippet": "static void\nvirNetworkForwardIfDefClear(virNetworkForwardIfDefPtr def)\n{\n    if (def->type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n        VIR_FREE(def->device.dev);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkForwardIfDefClear(virNetworkForwardIfDefPtr def)\n{\n    if (def->type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n        VIR_FREE(def->device.dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->pfs"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardPfDefClear",
          "args": [
            "&def->pfs[i]"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkForwardPfDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "128-132",
          "snippet": "static void\nvirNetworkForwardPfDefClear(virNetworkForwardPfDefPtr def)\n{\n    VIR_FREE(def->dev);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkForwardPfDefClear(virNetworkForwardPfDefPtr def)\n{\n    VIR_FREE(def->dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkForwardDefClear(virNetworkForwardDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->npfs && def->pfs; i++)\n        virNetworkForwardPfDefClear(&def->pfs[i]);\n    VIR_FREE(def->pfs);\n\n    for (i = 0; i < def->nifs && def->ifs; i++)\n        virNetworkForwardIfDefClear(&def->ifs[i]);\n    VIR_FREE(def->ifs);\n    def->nifs = def->npfs = 0;\n}"
  },
  {
    "function_name": "virNetworkDNSDefClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "193-216",
    "snippet": "static void\nvirNetworkDNSDefClear(virNetworkDNSDefPtr def)\n{\n    if (def->forwarders) {\n        while (def->nfwds)\n            virNetworkDNSForwarderClear(&def->forwarders[--def->nfwds]);\n        VIR_FREE(def->forwarders);\n    }\n    if (def->txts) {\n        while (def->ntxts)\n            virNetworkDNSTxtDefClear(&def->txts[--def->ntxts]);\n        VIR_FREE(def->txts);\n    }\n    if (def->hosts) {\n        while (def->nhosts)\n            virNetworkDNSHostDefClear(&def->hosts[--def->nhosts]);\n        VIR_FREE(def->hosts);\n    }\n    if (def->srvs) {\n        while (def->nsrvs)\n            virNetworkDNSSrvDefClear(&def->srvs[--def->nsrvs]);\n        VIR_FREE(def->srvs);\n    }\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->srvs"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDNSSrvDefClear",
          "args": [
            "&def->srvs[--def->nsrvs]"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDNSSrvDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "176-183",
          "snippet": "static void\nvirNetworkDNSSrvDefClear(virNetworkDNSSrvDefPtr def)\n{\n    VIR_FREE(def->domain);\n    VIR_FREE(def->service);\n    VIR_FREE(def->protocol);\n    VIR_FREE(def->target);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDNSSrvDefClear(virNetworkDNSSrvDefPtr def)\n{\n    VIR_FREE(def->domain);\n    VIR_FREE(def->service);\n    VIR_FREE(def->protocol);\n    VIR_FREE(def->target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->hosts"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDNSHostDefClear",
          "args": [
            "&def->hosts[--def->nhosts]"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDNSHostDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "167-173",
          "snippet": "static void\nvirNetworkDNSHostDefClear(virNetworkDNSHostDefPtr def)\n{\n    while (def->nnames)\n        VIR_FREE(def->names[--def->nnames]);\n    VIR_FREE(def->names);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDNSHostDefClear(virNetworkDNSHostDefPtr def)\n{\n    while (def->nnames)\n        VIR_FREE(def->names[--def->nnames]);\n    VIR_FREE(def->names);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->txts"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDNSTxtDefClear",
          "args": [
            "&def->txts[--def->ntxts]"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDNSTxtDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "159-164",
          "snippet": "static void\nvirNetworkDNSTxtDefClear(virNetworkDNSTxtDefPtr def)\n{\n    VIR_FREE(def->name);\n    VIR_FREE(def->value);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDNSTxtDefClear(virNetworkDNSTxtDefPtr def)\n{\n    VIR_FREE(def->name);\n    VIR_FREE(def->value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->forwarders"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDNSForwarderClear",
          "args": [
            "&def->forwarders[--def->nfwds]"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDNSForwarderClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "186-190",
          "snippet": "static void\nvirNetworkDNSForwarderClear(virNetworkDNSForwarderPtr def)\n{\n    VIR_FREE(def->domain);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDNSForwarderClear(virNetworkDNSForwarderPtr def)\n{\n    VIR_FREE(def->domain);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDNSDefClear(virNetworkDNSDefPtr def)\n{\n    if (def->forwarders) {\n        while (def->nfwds)\n            virNetworkDNSForwarderClear(&def->forwarders[--def->nfwds]);\n        VIR_FREE(def->forwarders);\n    }\n    if (def->txts) {\n        while (def->ntxts)\n            virNetworkDNSTxtDefClear(&def->txts[--def->ntxts]);\n        VIR_FREE(def->txts);\n    }\n    if (def->hosts) {\n        while (def->nhosts)\n            virNetworkDNSHostDefClear(&def->hosts[--def->nhosts]);\n        VIR_FREE(def->hosts);\n    }\n    if (def->srvs) {\n        while (def->nsrvs)\n            virNetworkDNSSrvDefClear(&def->srvs[--def->nsrvs]);\n        VIR_FREE(def->srvs);\n    }\n}"
  },
  {
    "function_name": "virNetworkDNSForwarderClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "186-190",
    "snippet": "static void\nvirNetworkDNSForwarderClear(virNetworkDNSForwarderPtr def)\n{\n    VIR_FREE(def->domain);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->domain"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDNSForwarderClear(virNetworkDNSForwarderPtr def)\n{\n    VIR_FREE(def->domain);\n}"
  },
  {
    "function_name": "virNetworkDNSSrvDefClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "176-183",
    "snippet": "static void\nvirNetworkDNSSrvDefClear(virNetworkDNSSrvDefPtr def)\n{\n    VIR_FREE(def->domain);\n    VIR_FREE(def->service);\n    VIR_FREE(def->protocol);\n    VIR_FREE(def->target);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->target"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->protocol"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->service"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->domain"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDNSSrvDefClear(virNetworkDNSSrvDefPtr def)\n{\n    VIR_FREE(def->domain);\n    VIR_FREE(def->service);\n    VIR_FREE(def->protocol);\n    VIR_FREE(def->target);\n}"
  },
  {
    "function_name": "virNetworkDNSHostDefClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "167-173",
    "snippet": "static void\nvirNetworkDNSHostDefClear(virNetworkDNSHostDefPtr def)\n{\n    while (def->nnames)\n        VIR_FREE(def->names[--def->nnames]);\n    VIR_FREE(def->names);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->names"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->names[--def->nnames]"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDNSHostDefClear(virNetworkDNSHostDefPtr def)\n{\n    while (def->nnames)\n        VIR_FREE(def->names[--def->nnames]);\n    VIR_FREE(def->names);\n}"
  },
  {
    "function_name": "virNetworkDNSTxtDefClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "159-164",
    "snippet": "static void\nvirNetworkDNSTxtDefClear(virNetworkDNSTxtDefPtr def)\n{\n    VIR_FREE(def->name);\n    VIR_FREE(def->value);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->value"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->name"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDNSTxtDefClear(virNetworkDNSTxtDefPtr def)\n{\n    VIR_FREE(def->name);\n    VIR_FREE(def->value);\n}"
  },
  {
    "function_name": "virNetworkIPDefClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "144-156",
    "snippet": "static void\nvirNetworkIPDefClear(virNetworkIPDefPtr def)\n{\n    VIR_FREE(def->family);\n    VIR_FREE(def->ranges);\n\n    while (def->nhosts)\n        virNetworkDHCPHostDefClear(&def->hosts[--def->nhosts]);\n\n    VIR_FREE(def->hosts);\n    VIR_FREE(def->tftproot);\n    VIR_FREE(def->bootfile);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->bootfile"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->tftproot"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->hosts"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDHCPHostDefClear",
          "args": [
            "&def->hosts[--def->nhosts]"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDHCPHostDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "135-141",
          "snippet": "static void\nvirNetworkDHCPHostDefClear(virNetworkDHCPHostDefPtr def)\n{\n    VIR_FREE(def->mac);\n    VIR_FREE(def->id);\n    VIR_FREE(def->name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDHCPHostDefClear(virNetworkDHCPHostDefPtr def)\n{\n    VIR_FREE(def->mac);\n    VIR_FREE(def->id);\n    VIR_FREE(def->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->ranges"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->family"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkIPDefClear(virNetworkIPDefPtr def)\n{\n    VIR_FREE(def->family);\n    VIR_FREE(def->ranges);\n\n    while (def->nhosts)\n        virNetworkDHCPHostDefClear(&def->hosts[--def->nhosts]);\n\n    VIR_FREE(def->hosts);\n    VIR_FREE(def->tftproot);\n    VIR_FREE(def->bootfile);\n}"
  },
  {
    "function_name": "virNetworkDHCPHostDefClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "135-141",
    "snippet": "static void\nvirNetworkDHCPHostDefClear(virNetworkDHCPHostDefPtr def)\n{\n    VIR_FREE(def->mac);\n    VIR_FREE(def->id);\n    VIR_FREE(def->name);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->name"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->id"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->mac"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkDHCPHostDefClear(virNetworkDHCPHostDefPtr def)\n{\n    VIR_FREE(def->mac);\n    VIR_FREE(def->id);\n    VIR_FREE(def->name);\n}"
  },
  {
    "function_name": "virNetworkForwardPfDefClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "128-132",
    "snippet": "static void\nvirNetworkForwardPfDefClear(virNetworkForwardPfDefPtr def)\n{\n    VIR_FREE(def->dev);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->dev"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkForwardPfDefClear(virNetworkForwardPfDefPtr def)\n{\n    VIR_FREE(def->dev);\n}"
  },
  {
    "function_name": "virNetworkForwardIfDefClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "120-125",
    "snippet": "static void\nvirNetworkForwardIfDefClear(virNetworkForwardIfDefPtr def)\n{\n    if (def->type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n        VIR_FREE(def->device.dev);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->device.dev"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkForwardIfDefClear(virNetworkForwardIfDefPtr def)\n{\n    if (def->type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n        VIR_FREE(def->device.dev);\n}"
  },
  {
    "function_name": "virPortGroupDefClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "109-117",
    "snippet": "static void\nvirPortGroupDefClear(virPortGroupDefPtr def)\n{\n    VIR_FREE(def->name);\n    VIR_FREE(def->virtPortProfile);\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n    def->bandwidth = NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDevVlanClear",
          "args": [
            "&def->vlan"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVlanClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvlan.c",
          "lines": "28-35",
          "snippet": "void\nvirNetDevVlanClear(virNetDevVlanPtr vlan)\n{\n    VIR_FREE(vlan->tag);\n    vlan->nTags = 0;\n    vlan->nativeMode = 0;\n    vlan->nativeTag = 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virnetdevvlan.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirNetDevVlanClear(virNetDevVlanPtr vlan)\n{\n    VIR_FREE(vlan->tag);\n    vlan->nTags = 0;\n    vlan->nativeMode = 0;\n    vlan->nativeTag = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthFree",
          "args": [
            "def->bandwidth"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "31-40",
          "snippet": "void\nvirNetDevBandwidthFree(virNetDevBandwidthPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->in);\n    VIR_FREE(def->out);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetDevBandwidthFree(virNetDevBandwidthPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->in);\n    VIR_FREE(def->out);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->virtPortProfile"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->name"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirPortGroupDefClear(virPortGroupDefPtr def)\n{\n    VIR_FREE(def->name);\n    VIR_FREE(def->virtPortProfile);\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n    def->bandwidth = NULL;\n}"
  },
  {
    "function_name": "virNetworkXMLOptionNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "92-107",
    "snippet": "virNetworkXMLOptionPtr\nvirNetworkXMLOptionNew(virXMLNamespacePtr xmlns)\n{\n    virNetworkXMLOptionPtr xmlopt;\n\n    if (virNetworkXMLInitialize() < 0)\n        return NULL;\n\n    if (!(xmlopt = virObjectNew(virNetworkXMLOptionClass)))\n        return NULL;\n\n    if (xmlns)\n        xmlopt->ns = *xmlns;\n\n    return xmlopt;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virNetworkXMLOptionClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "virNetworkXMLOptionClass"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkXMLInitialize",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virNetworkXMLOptionClass;\n\nvirNetworkXMLOptionPtr\nvirNetworkXMLOptionNew(virXMLNamespacePtr xmlns)\n{\n    virNetworkXMLOptionPtr xmlopt;\n\n    if (virNetworkXMLInitialize() < 0)\n        return NULL;\n\n    if (!(xmlopt = virObjectNew(virNetworkXMLOptionClass)))\n        return NULL;\n\n    if (xmlns)\n        xmlopt->ns = *xmlns;\n\n    return xmlopt;\n}"
  },
  {
    "function_name": "virNetworkXMLOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "81-88",
    "snippet": "static int\nvirNetworkXMLOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetworkXMLOption, virClassForObject()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virNetworkXMLOption",
            "virClassForObject()"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObject",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "110-116",
          "snippet": "virClassPtr\nvirClassForObjectEvent(void)\n{\n    if (virObjectEventInitialize() < 0)\n        return NULL;\n    return virObjectEventClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectEventClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectEventClass;\n\nvirClassPtr\nvirClassForObjectEvent(void)\n{\n    if (virObjectEventInitialize() < 0)\n        return NULL;\n    return virObjectEventClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetworkXMLOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetworkXMLOption, virClassForObject()))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetworkXMLOptionDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
    "lines": "75-79",
    "snippet": "static void\nvirNetworkXMLOptionDispose(void *obj G_GNUC_UNUSED)\n{\n    return;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetworkXMLOptionDispose(void *obj G_GNUC_UNUSED)\n{\n    return;\n}"
  }
]