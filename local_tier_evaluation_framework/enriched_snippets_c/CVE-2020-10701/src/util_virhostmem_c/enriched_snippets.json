[
  {
    "function_name": "virHostMemAllocPages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
    "lines": "871-907",
    "snippet": "int\nvirHostMemAllocPages(unsigned int npages,\n                     unsigned int *pageSizes,\n                     unsigned long long *pageCounts,\n                     int startCell,\n                     unsigned int cellCount,\n                     bool add)\n{\n    int cell, lastCell;\n    size_t i, ncounts = 0;\n\n    if ((lastCell = virNumaGetMaxNode()) < 0)\n        return 0;\n\n    if (startCell > lastCell) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"start cell %d out of range (0-%d)\"),\n                       startCell, lastCell);\n        return -1;\n    }\n\n    lastCell = MIN(lastCell, startCell + (int) cellCount - 1);\n\n    for (cell = startCell; cell <= lastCell; cell++) {\n        for (i = 0; i < npages; i++) {\n            unsigned int page_size = pageSizes[i];\n            unsigned long long page_count = pageCounts[i];\n\n            if (virNumaSetPagePoolSize(cell, page_size, page_count, add) < 0)\n                return -1;\n\n            ncounts++;\n        }\n    }\n\n    return ncounts;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "# include <windows.h>",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNumaSetPagePoolSize",
          "args": [
            "cell",
            "page_size",
            "page_count",
            "add"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaSetPagePoolSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "981-990",
          "snippet": "int\nvirNumaSetPagePoolSize(int node G_GNUC_UNUSED,\n                       unsigned int page_size G_GNUC_UNUSED,\n                       unsigned long long page_count G_GNUC_UNUSED,\n                       bool add G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                   _(\"page pool allocation is not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaSetPagePoolSize(int node G_GNUC_UNUSED,\n                       unsigned int page_size G_GNUC_UNUSED,\n                       unsigned long long page_count G_GNUC_UNUSED,\n                       bool add G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                   _(\"page pool allocation is not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "lastCell",
            "startCell + (int) cellCount - 1"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"start cell %d out of range (0-%d)\")",
            "startCell",
            "lastCell"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"start cell %d out of range (0-%d)\""
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaGetMaxNode",
          "args": [],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetMaxNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "362-368",
          "snippet": "int\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostMemAllocPages(unsigned int npages,\n                     unsigned int *pageSizes,\n                     unsigned long long *pageCounts,\n                     int startCell,\n                     unsigned int cellCount,\n                     bool add)\n{\n    int cell, lastCell;\n    size_t i, ncounts = 0;\n\n    if ((lastCell = virNumaGetMaxNode()) < 0)\n        return 0;\n\n    if (startCell > lastCell) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"start cell %d out of range (0-%d)\"),\n                       startCell, lastCell);\n        return -1;\n    }\n\n    lastCell = MIN(lastCell, startCell + (int) cellCount - 1);\n\n    for (cell = startCell; cell <= lastCell; cell++) {\n        for (i = 0; i < npages; i++) {\n            unsigned int page_size = pageSizes[i];\n            unsigned long long page_count = pageCounts[i];\n\n            if (virNumaSetPagePoolSize(cell, page_size, page_count, add) < 0)\n                return -1;\n\n            ncounts++;\n        }\n    }\n\n    return ncounts;\n}"
  },
  {
    "function_name": "virHostMemGetFreePages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
    "lines": "828-869",
    "snippet": "int\nvirHostMemGetFreePages(unsigned int npages,\n                       unsigned int *pages,\n                       int startCell,\n                       unsigned int cellCount,\n                       unsigned long long *counts)\n{\n    int cell, lastCell;\n    size_t i, ncounts = 0;\n\n    if ((lastCell = virNumaGetMaxNode()) < 0)\n        return 0;\n\n    if (startCell > lastCell) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"start cell %d out of range (0-%d)\"),\n                       startCell, lastCell);\n        return -1;\n    }\n\n    lastCell = MIN(lastCell, startCell + (int) cellCount - 1);\n\n    for (cell = startCell; cell <= lastCell; cell++) {\n        for (i = 0; i < npages; i++) {\n            unsigned int page_size = pages[i];\n            unsigned long long page_free;\n\n            if (virNumaGetPageInfo(cell, page_size, 0, NULL, &page_free) < 0)\n                return -1;\n\n            counts[ncounts++] = page_free;\n        }\n    }\n\n    if (!ncounts) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no suitable info found\"));\n        return -1;\n    }\n\n    return ncounts;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "# include <windows.h>",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no suitable info found\")"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no suitable info found\""
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaGetPageInfo",
          "args": [
            "cell",
            "page_size",
            "0",
            "NULL",
            "&page_free"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetPageInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "955-965",
          "snippet": "int\nvirNumaGetPageInfo(int node G_GNUC_UNUSED,\n                   unsigned int page_size G_GNUC_UNUSED,\n                   unsigned long long huge_page_sum G_GNUC_UNUSED,\n                   unsigned long long *page_avail G_GNUC_UNUSED,\n                   unsigned long long *page_free G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                   _(\"page info is not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetPageInfo(int node G_GNUC_UNUSED,\n                   unsigned int page_size G_GNUC_UNUSED,\n                   unsigned long long huge_page_sum G_GNUC_UNUSED,\n                   unsigned long long *page_avail G_GNUC_UNUSED,\n                   unsigned long long *page_free G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                   _(\"page info is not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "lastCell",
            "startCell + (int) cellCount - 1"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"start cell %d out of range (0-%d)\")",
            "startCell",
            "lastCell"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNumaGetMaxNode",
          "args": [],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetMaxNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "362-368",
          "snippet": "int\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostMemGetFreePages(unsigned int npages,\n                       unsigned int *pages,\n                       int startCell,\n                       unsigned int cellCount,\n                       unsigned long long *counts)\n{\n    int cell, lastCell;\n    size_t i, ncounts = 0;\n\n    if ((lastCell = virNumaGetMaxNode()) < 0)\n        return 0;\n\n    if (startCell > lastCell) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"start cell %d out of range (0-%d)\"),\n                       startCell, lastCell);\n        return -1;\n    }\n\n    lastCell = MIN(lastCell, startCell + (int) cellCount - 1);\n\n    for (cell = startCell; cell <= lastCell; cell++) {\n        for (i = 0; i < npages; i++) {\n            unsigned int page_size = pages[i];\n            unsigned long long page_free;\n\n            if (virNumaGetPageInfo(cell, page_size, 0, NULL, &page_free) < 0)\n                return -1;\n\n            counts[ncounts++] = page_free;\n        }\n    }\n\n    if (!ncounts) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no suitable info found\"));\n        return -1;\n    }\n\n    return ncounts;\n}"
  },
  {
    "function_name": "virHostMemGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
    "lines": "790-826",
    "snippet": "int\nvirHostMemGetInfo(unsigned long long *mem,\n                  unsigned long long *freeMem)\n{\n    int max_node;\n    int n;\n\n    if (mem)\n        *mem = 0;\n\n    if (freeMem)\n        *freeMem = 0;\n\n    if (!virNumaIsAvailable())\n        return virHostMemGetInfoFake(mem, freeMem);\n\n    if ((max_node = virNumaGetMaxNode()) < 0)\n        return -1;\n\n    for (n = 0; n <= max_node; n++) {\n        unsigned long long tmp_mem = 0, tmp_freeMem = 0;\n\n        if (!virNumaNodeIsAvailable(n))\n            continue;\n\n        if (virNumaGetNodeMemory(n, &tmp_mem, &tmp_freeMem) < 0)\n            return -1;\n\n        if (mem)\n            *mem += tmp_mem;\n\n        if (freeMem)\n            *freeMem += tmp_freeMem;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "# include <windows.h>",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNumaGetNodeMemory",
          "args": [
            "n",
            "&tmp_mem",
            "&tmp_freeMem"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetNodeMemory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "371-384",
          "snippet": "int\nvirNumaGetNodeMemory(int node G_GNUC_UNUSED,\n                     unsigned long long *memsize,\n                     unsigned long long *memfree)\n{\n    if (memsize)\n        *memsize = 0;\n\n    if (memfree)\n        *memfree = 0;\n\n    VIR_DEBUG(\"NUMA isn't available on this host\");\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetNodeMemory(int node G_GNUC_UNUSED,\n                     unsigned long long *memsize,\n                     unsigned long long *memfree)\n{\n    if (memsize)\n        *memsize = 0;\n\n    if (memfree)\n        *memfree = 0;\n\n    VIR_DEBUG(\"NUMA isn't available on this host\");\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaNodeIsAvailable",
          "args": [
            "n"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaNodeIsAvailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "497-507",
          "snippet": "bool\nvirNumaNodeIsAvailable(int node)\n{\n    int max_node = virNumaGetMaxNode();\n\n    if (max_node < 0)\n        return false;\n\n    /* Do we have anything better? */\n    return (node >= 0) && (node <= max_node);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nbool\nvirNumaNodeIsAvailable(int node)\n{\n    int max_node = virNumaGetMaxNode();\n\n    if (max_node < 0)\n        return false;\n\n    /* Do we have anything better? */\n    return (node >= 0) && (node <= max_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaGetMaxNode",
          "args": [],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetMaxNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "362-368",
          "snippet": "int\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostMemGetInfoFake",
          "args": [
            "mem",
            "freeMem"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "virHostMemGetInfoFake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
          "lines": "740-753",
          "snippet": "static int\nvirHostMemGetInfoFake(unsigned long long *mem,\n                      unsigned long long *freeMem)\n{\n    if (mem &&\n        (*mem = virHostMemGetTotal()) == 0)\n        return -1;\n\n    if (freeMem &&\n        (*freeMem = virHostMemGetAvailable()) == 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "# include <windows.h>",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostMemGetInfoFake(unsigned long long *mem,\n                      unsigned long long *freeMem)\n{\n    if (mem &&\n        (*mem = virHostMemGetTotal()) == 0)\n        return -1;\n\n    if (freeMem &&\n        (*freeMem = virHostMemGetAvailable()) == 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaIsAvailable",
          "args": [],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaIsAvailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "355-359",
          "snippet": "bool\nvirNumaIsAvailable(void)\n{\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nbool\nvirNumaIsAvailable(void)\n{\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostMemGetInfo(unsigned long long *mem,\n                  unsigned long long *freeMem)\n{\n    int max_node;\n    int n;\n\n    if (mem)\n        *mem = 0;\n\n    if (freeMem)\n        *freeMem = 0;\n\n    if (!virNumaIsAvailable())\n        return virHostMemGetInfoFake(mem, freeMem);\n\n    if ((max_node = virNumaGetMaxNode()) < 0)\n        return -1;\n\n    for (n = 0; n <= max_node; n++) {\n        unsigned long long tmp_mem = 0, tmp_freeMem = 0;\n\n        if (!virNumaNodeIsAvailable(n))\n            continue;\n\n        if (virNumaGetNodeMemory(n, &tmp_mem, &tmp_freeMem) < 0)\n            return -1;\n\n        if (mem)\n            *mem += tmp_mem;\n\n        if (freeMem)\n            *freeMem += tmp_freeMem;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostMemGetCellsFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
    "lines": "756-788",
    "snippet": "int\nvirHostMemGetCellsFree(unsigned long long *freeMems,\n                       int startCell,\n                       int maxCells)\n{\n    unsigned long long mem;\n    int n, lastCell, numCells;\n    int maxCell;\n\n    if (!virNumaIsAvailable())\n        return virHostMemGetCellsFreeFake(freeMems,\n                                          startCell, maxCells);\n\n    if ((maxCell = virNumaGetMaxNode()) < 0)\n        return 0;\n\n    if (startCell > maxCell) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"start cell %d out of range (0-%d)\"),\n                       startCell, maxCell);\n        return -1;\n    }\n    lastCell = startCell + maxCells - 1;\n    if (lastCell > maxCell)\n        lastCell = maxCell;\n\n    for (numCells = 0, n = startCell; n <= lastCell; n++) {\n        virNumaGetNodeMemory(n, NULL, &mem);\n\n        freeMems[numCells++] = mem;\n    }\n    return numCells;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "# include <windows.h>",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNumaGetNodeMemory",
          "args": [
            "n",
            "NULL",
            "&mem"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetNodeMemory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "371-384",
          "snippet": "int\nvirNumaGetNodeMemory(int node G_GNUC_UNUSED,\n                     unsigned long long *memsize,\n                     unsigned long long *memfree)\n{\n    if (memsize)\n        *memsize = 0;\n\n    if (memfree)\n        *memfree = 0;\n\n    VIR_DEBUG(\"NUMA isn't available on this host\");\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetNodeMemory(int node G_GNUC_UNUSED,\n                     unsigned long long *memsize,\n                     unsigned long long *memfree)\n{\n    if (memsize)\n        *memsize = 0;\n\n    if (memfree)\n        *memfree = 0;\n\n    VIR_DEBUG(\"NUMA isn't available on this host\");\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"start cell %d out of range (0-%d)\")",
            "startCell",
            "maxCell"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"start cell %d out of range (0-%d)\""
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaGetMaxNode",
          "args": [],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetMaxNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "362-368",
          "snippet": "int\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostMemGetCellsFreeFake",
          "args": [
            "freeMems",
            "startCell",
            "maxCells"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "virHostMemGetCellsFreeFake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
          "lines": "722-738",
          "snippet": "static int\nvirHostMemGetCellsFreeFake(unsigned long long *freeMems,\n                           int startCell,\n                           int maxCells G_GNUC_UNUSED)\n{\n    if (startCell != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"start cell %d out of range (0-%d)\"),\n                       startCell, 0);\n        return -1;\n    }\n\n    if ((freeMems[0] = virHostMemGetAvailable()) == 0)\n        return -1;\n\n    return 1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "# include <windows.h>",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostMemGetCellsFreeFake(unsigned long long *freeMems,\n                           int startCell,\n                           int maxCells G_GNUC_UNUSED)\n{\n    if (startCell != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"start cell %d out of range (0-%d)\"),\n                       startCell, 0);\n        return -1;\n    }\n\n    if ((freeMems[0] = virHostMemGetAvailable()) == 0)\n        return -1;\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaIsAvailable",
          "args": [],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaIsAvailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "355-359",
          "snippet": "bool\nvirNumaIsAvailable(void)\n{\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nbool\nvirNumaIsAvailable(void)\n{\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostMemGetCellsFree(unsigned long long *freeMems,\n                       int startCell,\n                       int maxCells)\n{\n    unsigned long long mem;\n    int n, lastCell, numCells;\n    int maxCell;\n\n    if (!virNumaIsAvailable())\n        return virHostMemGetCellsFreeFake(freeMems,\n                                          startCell, maxCells);\n\n    if ((maxCell = virNumaGetMaxNode()) < 0)\n        return 0;\n\n    if (startCell > maxCell) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"start cell %d out of range (0-%d)\"),\n                       startCell, maxCell);\n        return -1;\n    }\n    lastCell = startCell + maxCells - 1;\n    if (lastCell > maxCell)\n        lastCell = maxCell;\n\n    for (numCells = 0, n = startCell; n <= lastCell; n++) {\n        virNumaGetNodeMemory(n, NULL, &mem);\n\n        freeMems[numCells++] = mem;\n    }\n    return numCells;\n}"
  },
  {
    "function_name": "virHostMemGetInfoFake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
    "lines": "740-753",
    "snippet": "static int\nvirHostMemGetInfoFake(unsigned long long *mem,\n                      unsigned long long *freeMem)\n{\n    if (mem &&\n        (*mem = virHostMemGetTotal()) == 0)\n        return -1;\n\n    if (freeMem &&\n        (*freeMem = virHostMemGetAvailable()) == 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "# include <windows.h>",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostMemGetAvailable",
          "args": [],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "virHostMemGetAvailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
          "lines": "661-719",
          "snippet": "static unsigned long long\nvirHostMemGetAvailable(void)\n{\n#if defined HAVE_SYSCTLBYNAME\n    /* This works on freebsd and macOS */\n    unsigned long long usermem = 0;\n    size_t len = sizeof(usermem);\n\n    if (sysctlbyname(\"hw.usermem\", &usermem, &len, NULL, 0) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory available\"));\n        return 0;\n    }\n\n    return usermem;\n#elif defined _SC_AVPHYS_PAGES && defined _SC_PAGESIZE\n    /* this works on linux */\n    long long pages;\n    long long pagesize;\n    if ((pages = sysconf(_SC_AVPHYS_PAGES)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory available\"));\n        return 0;\n    }\n    if ((pagesize = sysconf(_SC_PAGESIZE)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory page size\"));\n        return 0;\n    }\n    return (unsigned long long)pages * (unsigned long long)pagesize;\n#elif defined WIN32\n    PFN_MS_EX pfnex;\n    HMODULE h = GetModuleHandle(\"kernel32.dll\");\n\n    if (!h) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to access kernel32.dll\"));\n        return 0;\n    }\n\n    /*  Use GlobalMemoryStatusEx if available.  */\n    if ((pfnex = (PFN_MS_EX) GetProcAddress(h, \"GlobalMemoryStatusEx\"))) {\n        lMEMORYSTATUSEX lms_ex;\n        lms_ex.dwLength = sizeof(lms_ex);\n        if (!pfnex(&lms_ex)) {\n            virReportSystemError(EIO, \"%s\",\n                                 _(\"Unable to query memory available\"));\n            return 0;\n        }\n        return lms_ex.ullAvailPhys;\n    } else {\n        /*  Fall back to GlobalMemoryStatus which is always available.\n            but returns wrong results for physical memory > 4GB  */\n        MEMORYSTATUS ms;\n        GlobalMemoryStatus(&ms);\n        return ms.dwAvailPhys;\n    }\n#endif\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "# include <windows.h>",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic unsigned long long\nvirHostMemGetAvailable(void)\n{\n#if defined HAVE_SYSCTLBYNAME\n    /* This works on freebsd and macOS */\n    unsigned long long usermem = 0;\n    size_t len = sizeof(usermem);\n\n    if (sysctlbyname(\"hw.usermem\", &usermem, &len, NULL, 0) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory available\"));\n        return 0;\n    }\n\n    return usermem;\n#elif defined _SC_AVPHYS_PAGES && defined _SC_PAGESIZE\n    /* this works on linux */\n    long long pages;\n    long long pagesize;\n    if ((pages = sysconf(_SC_AVPHYS_PAGES)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory available\"));\n        return 0;\n    }\n    if ((pagesize = sysconf(_SC_PAGESIZE)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory page size\"));\n        return 0;\n    }\n    return (unsigned long long)pages * (unsigned long long)pagesize;\n#elif defined WIN32\n    PFN_MS_EX pfnex;\n    HMODULE h = GetModuleHandle(\"kernel32.dll\");\n\n    if (!h) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to access kernel32.dll\"));\n        return 0;\n    }\n\n    /*  Use GlobalMemoryStatusEx if available.  */\n    if ((pfnex = (PFN_MS_EX) GetProcAddress(h, \"GlobalMemoryStatusEx\"))) {\n        lMEMORYSTATUSEX lms_ex;\n        lms_ex.dwLength = sizeof(lms_ex);\n        if (!pfnex(&lms_ex)) {\n            virReportSystemError(EIO, \"%s\",\n                                 _(\"Unable to query memory available\"));\n            return 0;\n        }\n        return lms_ex.ullAvailPhys;\n    } else {\n        /*  Fall back to GlobalMemoryStatus which is always available.\n            but returns wrong results for physical memory > 4GB  */\n        MEMORYSTATUS ms;\n        GlobalMemoryStatus(&ms);\n        return ms.dwAvailPhys;\n    }\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostMemGetTotal",
          "args": [],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "virHostMemGetTotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
          "lines": "600-658",
          "snippet": "static unsigned long long\nvirHostMemGetTotal(void)\n{\n#if defined HAVE_SYSCTLBYNAME\n    /* This works on freebsd & macOS. */\n    unsigned long long physmem = 0;\n    size_t len = sizeof(physmem);\n\n    if (sysctlbyname(\"hw.physmem\", &physmem, &len, NULL, 0) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory total\"));\n        return 0;\n    }\n\n    return physmem;\n#elif defined _SC_PHYS_PAGES && defined _SC_PAGESIZE\n    /* this works on linux */\n    long long pages;\n    long long pagesize;\n    if ((pages = sysconf(_SC_PHYS_PAGES)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory total\"));\n        return 0;\n    }\n    if ((pagesize = sysconf(_SC_PAGESIZE)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory page size\"));\n        return 0;\n    }\n    return (unsigned long long)pages * (unsigned long long)pagesize;\n#elif defined WIN32\n    PFN_MS_EX pfnex;\n    HMODULE h = GetModuleHandle(\"kernel32.dll\");\n\n    if (!h) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to access kernel32.dll\"));\n        return 0;\n    }\n\n    /*  Use GlobalMemoryStatusEx if available.  */\n    if ((pfnex = (PFN_MS_EX) GetProcAddress(h, \"GlobalMemoryStatusEx\"))) {\n        lMEMORYSTATUSEX lms_ex;\n        lms_ex.dwLength = sizeof(lms_ex);\n        if (!pfnex(&lms_ex)) {\n            virReportSystemError(EIO, \"%s\",\n                                 _(\"Unable to query memory total\"));\n            return 0;\n        }\n        return lms_ex.ullTotalPhys;\n    } else {\n        /*  Fall back to GlobalMemoryStatus which is always available.\n            but returns wrong results for physical memory > 4GB.  */\n        MEMORYSTATUS ms;\n        GlobalMemoryStatus(&ms);\n        return  ms.dwTotalPhys;\n    }\n#endif\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "# include <windows.h>",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic unsigned long long\nvirHostMemGetTotal(void)\n{\n#if defined HAVE_SYSCTLBYNAME\n    /* This works on freebsd & macOS. */\n    unsigned long long physmem = 0;\n    size_t len = sizeof(physmem);\n\n    if (sysctlbyname(\"hw.physmem\", &physmem, &len, NULL, 0) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory total\"));\n        return 0;\n    }\n\n    return physmem;\n#elif defined _SC_PHYS_PAGES && defined _SC_PAGESIZE\n    /* this works on linux */\n    long long pages;\n    long long pagesize;\n    if ((pages = sysconf(_SC_PHYS_PAGES)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory total\"));\n        return 0;\n    }\n    if ((pagesize = sysconf(_SC_PAGESIZE)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory page size\"));\n        return 0;\n    }\n    return (unsigned long long)pages * (unsigned long long)pagesize;\n#elif defined WIN32\n    PFN_MS_EX pfnex;\n    HMODULE h = GetModuleHandle(\"kernel32.dll\");\n\n    if (!h) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to access kernel32.dll\"));\n        return 0;\n    }\n\n    /*  Use GlobalMemoryStatusEx if available.  */\n    if ((pfnex = (PFN_MS_EX) GetProcAddress(h, \"GlobalMemoryStatusEx\"))) {\n        lMEMORYSTATUSEX lms_ex;\n        lms_ex.dwLength = sizeof(lms_ex);\n        if (!pfnex(&lms_ex)) {\n            virReportSystemError(EIO, \"%s\",\n                                 _(\"Unable to query memory total\"));\n            return 0;\n        }\n        return lms_ex.ullTotalPhys;\n    } else {\n        /*  Fall back to GlobalMemoryStatus which is always available.\n            but returns wrong results for physical memory > 4GB.  */\n        MEMORYSTATUS ms;\n        GlobalMemoryStatus(&ms);\n        return  ms.dwTotalPhys;\n    }\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostMemGetInfoFake(unsigned long long *mem,\n                      unsigned long long *freeMem)\n{\n    if (mem &&\n        (*mem = virHostMemGetTotal()) == 0)\n        return -1;\n\n    if (freeMem &&\n        (*freeMem = virHostMemGetAvailable()) == 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostMemGetCellsFreeFake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
    "lines": "722-738",
    "snippet": "static int\nvirHostMemGetCellsFreeFake(unsigned long long *freeMems,\n                           int startCell,\n                           int maxCells G_GNUC_UNUSED)\n{\n    if (startCell != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"start cell %d out of range (0-%d)\"),\n                       startCell, 0);\n        return -1;\n    }\n\n    if ((freeMems[0] = virHostMemGetAvailable()) == 0)\n        return -1;\n\n    return 1;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "# include <windows.h>",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostMemGetAvailable",
          "args": [],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "virHostMemGetAvailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
          "lines": "661-719",
          "snippet": "static unsigned long long\nvirHostMemGetAvailable(void)\n{\n#if defined HAVE_SYSCTLBYNAME\n    /* This works on freebsd and macOS */\n    unsigned long long usermem = 0;\n    size_t len = sizeof(usermem);\n\n    if (sysctlbyname(\"hw.usermem\", &usermem, &len, NULL, 0) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory available\"));\n        return 0;\n    }\n\n    return usermem;\n#elif defined _SC_AVPHYS_PAGES && defined _SC_PAGESIZE\n    /* this works on linux */\n    long long pages;\n    long long pagesize;\n    if ((pages = sysconf(_SC_AVPHYS_PAGES)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory available\"));\n        return 0;\n    }\n    if ((pagesize = sysconf(_SC_PAGESIZE)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory page size\"));\n        return 0;\n    }\n    return (unsigned long long)pages * (unsigned long long)pagesize;\n#elif defined WIN32\n    PFN_MS_EX pfnex;\n    HMODULE h = GetModuleHandle(\"kernel32.dll\");\n\n    if (!h) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to access kernel32.dll\"));\n        return 0;\n    }\n\n    /*  Use GlobalMemoryStatusEx if available.  */\n    if ((pfnex = (PFN_MS_EX) GetProcAddress(h, \"GlobalMemoryStatusEx\"))) {\n        lMEMORYSTATUSEX lms_ex;\n        lms_ex.dwLength = sizeof(lms_ex);\n        if (!pfnex(&lms_ex)) {\n            virReportSystemError(EIO, \"%s\",\n                                 _(\"Unable to query memory available\"));\n            return 0;\n        }\n        return lms_ex.ullAvailPhys;\n    } else {\n        /*  Fall back to GlobalMemoryStatus which is always available.\n            but returns wrong results for physical memory > 4GB  */\n        MEMORYSTATUS ms;\n        GlobalMemoryStatus(&ms);\n        return ms.dwAvailPhys;\n    }\n#endif\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "# include <windows.h>",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic unsigned long long\nvirHostMemGetAvailable(void)\n{\n#if defined HAVE_SYSCTLBYNAME\n    /* This works on freebsd and macOS */\n    unsigned long long usermem = 0;\n    size_t len = sizeof(usermem);\n\n    if (sysctlbyname(\"hw.usermem\", &usermem, &len, NULL, 0) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory available\"));\n        return 0;\n    }\n\n    return usermem;\n#elif defined _SC_AVPHYS_PAGES && defined _SC_PAGESIZE\n    /* this works on linux */\n    long long pages;\n    long long pagesize;\n    if ((pages = sysconf(_SC_AVPHYS_PAGES)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory available\"));\n        return 0;\n    }\n    if ((pagesize = sysconf(_SC_PAGESIZE)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory page size\"));\n        return 0;\n    }\n    return (unsigned long long)pages * (unsigned long long)pagesize;\n#elif defined WIN32\n    PFN_MS_EX pfnex;\n    HMODULE h = GetModuleHandle(\"kernel32.dll\");\n\n    if (!h) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to access kernel32.dll\"));\n        return 0;\n    }\n\n    /*  Use GlobalMemoryStatusEx if available.  */\n    if ((pfnex = (PFN_MS_EX) GetProcAddress(h, \"GlobalMemoryStatusEx\"))) {\n        lMEMORYSTATUSEX lms_ex;\n        lms_ex.dwLength = sizeof(lms_ex);\n        if (!pfnex(&lms_ex)) {\n            virReportSystemError(EIO, \"%s\",\n                                 _(\"Unable to query memory available\"));\n            return 0;\n        }\n        return lms_ex.ullAvailPhys;\n    } else {\n        /*  Fall back to GlobalMemoryStatus which is always available.\n            but returns wrong results for physical memory > 4GB  */\n        MEMORYSTATUS ms;\n        GlobalMemoryStatus(&ms);\n        return ms.dwAvailPhys;\n    }\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"start cell %d out of range (0-%d)\")",
            "startCell",
            "0"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"start cell %d out of range (0-%d)\""
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostMemGetCellsFreeFake(unsigned long long *freeMems,\n                           int startCell,\n                           int maxCells G_GNUC_UNUSED)\n{\n    if (startCell != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"start cell %d out of range (0-%d)\"),\n                       startCell, 0);\n        return -1;\n    }\n\n    if ((freeMems[0] = virHostMemGetAvailable()) == 0)\n        return -1;\n\n    return 1;\n}"
  },
  {
    "function_name": "virHostMemGetAvailable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
    "lines": "661-719",
    "snippet": "static unsigned long long\nvirHostMemGetAvailable(void)\n{\n#if defined HAVE_SYSCTLBYNAME\n    /* This works on freebsd and macOS */\n    unsigned long long usermem = 0;\n    size_t len = sizeof(usermem);\n\n    if (sysctlbyname(\"hw.usermem\", &usermem, &len, NULL, 0) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory available\"));\n        return 0;\n    }\n\n    return usermem;\n#elif defined _SC_AVPHYS_PAGES && defined _SC_PAGESIZE\n    /* this works on linux */\n    long long pages;\n    long long pagesize;\n    if ((pages = sysconf(_SC_AVPHYS_PAGES)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory available\"));\n        return 0;\n    }\n    if ((pagesize = sysconf(_SC_PAGESIZE)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory page size\"));\n        return 0;\n    }\n    return (unsigned long long)pages * (unsigned long long)pagesize;\n#elif defined WIN32\n    PFN_MS_EX pfnex;\n    HMODULE h = GetModuleHandle(\"kernel32.dll\");\n\n    if (!h) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to access kernel32.dll\"));\n        return 0;\n    }\n\n    /*  Use GlobalMemoryStatusEx if available.  */\n    if ((pfnex = (PFN_MS_EX) GetProcAddress(h, \"GlobalMemoryStatusEx\"))) {\n        lMEMORYSTATUSEX lms_ex;\n        lms_ex.dwLength = sizeof(lms_ex);\n        if (!pfnex(&lms_ex)) {\n            virReportSystemError(EIO, \"%s\",\n                                 _(\"Unable to query memory available\"));\n            return 0;\n        }\n        return lms_ex.ullAvailPhys;\n    } else {\n        /*  Fall back to GlobalMemoryStatus which is always available.\n            but returns wrong results for physical memory > 4GB  */\n        MEMORYSTATUS ms;\n        GlobalMemoryStatus(&ms);\n        return ms.dwAvailPhys;\n    }\n#endif\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "# include <windows.h>",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GlobalMemoryStatus",
          "args": [
            "&ms"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "EIO",
            "\"%s\"",
            "_(\"Unable to query memory available\")"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to query memory available\""
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfnex",
          "args": [
            "&lms_ex"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "h",
            "\"GlobalMemoryStatusEx\""
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to access kernel32.dll\")"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetModuleHandle",
          "args": [
            "\"kernel32.dll\""
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to query memory page size\")"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysconf",
          "args": [
            "_SC_PAGESIZE"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to query memory available\")"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysconf",
          "args": [
            "_SC_AVPHYS_PAGES"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to query memory available\")"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctlbyname",
          "args": [
            "\"hw.usermem\"",
            "&usermem",
            "&len",
            "NULL",
            "0"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic unsigned long long\nvirHostMemGetAvailable(void)\n{\n#if defined HAVE_SYSCTLBYNAME\n    /* This works on freebsd and macOS */\n    unsigned long long usermem = 0;\n    size_t len = sizeof(usermem);\n\n    if (sysctlbyname(\"hw.usermem\", &usermem, &len, NULL, 0) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory available\"));\n        return 0;\n    }\n\n    return usermem;\n#elif defined _SC_AVPHYS_PAGES && defined _SC_PAGESIZE\n    /* this works on linux */\n    long long pages;\n    long long pagesize;\n    if ((pages = sysconf(_SC_AVPHYS_PAGES)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory available\"));\n        return 0;\n    }\n    if ((pagesize = sysconf(_SC_PAGESIZE)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory page size\"));\n        return 0;\n    }\n    return (unsigned long long)pages * (unsigned long long)pagesize;\n#elif defined WIN32\n    PFN_MS_EX pfnex;\n    HMODULE h = GetModuleHandle(\"kernel32.dll\");\n\n    if (!h) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to access kernel32.dll\"));\n        return 0;\n    }\n\n    /*  Use GlobalMemoryStatusEx if available.  */\n    if ((pfnex = (PFN_MS_EX) GetProcAddress(h, \"GlobalMemoryStatusEx\"))) {\n        lMEMORYSTATUSEX lms_ex;\n        lms_ex.dwLength = sizeof(lms_ex);\n        if (!pfnex(&lms_ex)) {\n            virReportSystemError(EIO, \"%s\",\n                                 _(\"Unable to query memory available\"));\n            return 0;\n        }\n        return lms_ex.ullAvailPhys;\n    } else {\n        /*  Fall back to GlobalMemoryStatus which is always available.\n            but returns wrong results for physical memory > 4GB  */\n        MEMORYSTATUS ms;\n        GlobalMemoryStatus(&ms);\n        return ms.dwAvailPhys;\n    }\n#endif\n}"
  },
  {
    "function_name": "virHostMemGetTotal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
    "lines": "600-658",
    "snippet": "static unsigned long long\nvirHostMemGetTotal(void)\n{\n#if defined HAVE_SYSCTLBYNAME\n    /* This works on freebsd & macOS. */\n    unsigned long long physmem = 0;\n    size_t len = sizeof(physmem);\n\n    if (sysctlbyname(\"hw.physmem\", &physmem, &len, NULL, 0) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory total\"));\n        return 0;\n    }\n\n    return physmem;\n#elif defined _SC_PHYS_PAGES && defined _SC_PAGESIZE\n    /* this works on linux */\n    long long pages;\n    long long pagesize;\n    if ((pages = sysconf(_SC_PHYS_PAGES)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory total\"));\n        return 0;\n    }\n    if ((pagesize = sysconf(_SC_PAGESIZE)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory page size\"));\n        return 0;\n    }\n    return (unsigned long long)pages * (unsigned long long)pagesize;\n#elif defined WIN32\n    PFN_MS_EX pfnex;\n    HMODULE h = GetModuleHandle(\"kernel32.dll\");\n\n    if (!h) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to access kernel32.dll\"));\n        return 0;\n    }\n\n    /*  Use GlobalMemoryStatusEx if available.  */\n    if ((pfnex = (PFN_MS_EX) GetProcAddress(h, \"GlobalMemoryStatusEx\"))) {\n        lMEMORYSTATUSEX lms_ex;\n        lms_ex.dwLength = sizeof(lms_ex);\n        if (!pfnex(&lms_ex)) {\n            virReportSystemError(EIO, \"%s\",\n                                 _(\"Unable to query memory total\"));\n            return 0;\n        }\n        return lms_ex.ullTotalPhys;\n    } else {\n        /*  Fall back to GlobalMemoryStatus which is always available.\n            but returns wrong results for physical memory > 4GB.  */\n        MEMORYSTATUS ms;\n        GlobalMemoryStatus(&ms);\n        return  ms.dwTotalPhys;\n    }\n#endif\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "# include <windows.h>",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GlobalMemoryStatus",
          "args": [
            "&ms"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "EIO",
            "\"%s\"",
            "_(\"Unable to query memory total\")"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to query memory total\""
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfnex",
          "args": [
            "&lms_ex"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "h",
            "\"GlobalMemoryStatusEx\""
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to access kernel32.dll\")"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetModuleHandle",
          "args": [
            "\"kernel32.dll\""
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to query memory page size\")"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysconf",
          "args": [
            "_SC_PAGESIZE"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to query memory total\")"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysconf",
          "args": [
            "_SC_PHYS_PAGES"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to query memory total\")"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctlbyname",
          "args": [
            "\"hw.physmem\"",
            "&physmem",
            "&len",
            "NULL",
            "0"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic unsigned long long\nvirHostMemGetTotal(void)\n{\n#if defined HAVE_SYSCTLBYNAME\n    /* This works on freebsd & macOS. */\n    unsigned long long physmem = 0;\n    size_t len = sizeof(physmem);\n\n    if (sysctlbyname(\"hw.physmem\", &physmem, &len, NULL, 0) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory total\"));\n        return 0;\n    }\n\n    return physmem;\n#elif defined _SC_PHYS_PAGES && defined _SC_PAGESIZE\n    /* this works on linux */\n    long long pages;\n    long long pagesize;\n    if ((pages = sysconf(_SC_PHYS_PAGES)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory total\"));\n        return 0;\n    }\n    if ((pagesize = sysconf(_SC_PAGESIZE)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query memory page size\"));\n        return 0;\n    }\n    return (unsigned long long)pages * (unsigned long long)pagesize;\n#elif defined WIN32\n    PFN_MS_EX pfnex;\n    HMODULE h = GetModuleHandle(\"kernel32.dll\");\n\n    if (!h) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to access kernel32.dll\"));\n        return 0;\n    }\n\n    /*  Use GlobalMemoryStatusEx if available.  */\n    if ((pfnex = (PFN_MS_EX) GetProcAddress(h, \"GlobalMemoryStatusEx\"))) {\n        lMEMORYSTATUSEX lms_ex;\n        lms_ex.dwLength = sizeof(lms_ex);\n        if (!pfnex(&lms_ex)) {\n            virReportSystemError(EIO, \"%s\",\n                                 _(\"Unable to query memory total\"));\n            return 0;\n        }\n        return lms_ex.ullTotalPhys;\n    } else {\n        /*  Fall back to GlobalMemoryStatus which is always available.\n            but returns wrong results for physical memory > 4GB.  */\n        MEMORYSTATUS ms;\n        GlobalMemoryStatus(&ms);\n        return  ms.dwTotalPhys;\n    }\n#endif\n}"
  },
  {
    "function_name": "virHostMemGetParameters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
    "lines": "438-579",
    "snippet": "int\nvirHostMemGetParameters(virTypedParameterPtr params G_GNUC_UNUSED,\n                        int *nparams G_GNUC_UNUSED,\n                        unsigned int flags)\n{\n    virCheckFlags(VIR_TYPED_PARAM_STRING_OKAY, -1);\n\n#ifdef __linux__\n    unsigned int pages_to_scan;\n    unsigned int sleep_millisecs;\n    unsigned int merge_across_nodes;\n    unsigned long long pages_shared;\n    unsigned long long pages_sharing;\n    unsigned long long pages_unshared;\n    unsigned long long pages_volatile;\n    unsigned long long full_scans = 0;\n    size_t i;\n    int ret;\n\n    if ((*nparams) == 0) {\n        *nparams = NODE_MEMORY_PARAMETERS_NUM;\n        return 0;\n    }\n\n    for (i = 0; i < *nparams && i < NODE_MEMORY_PARAMETERS_NUM; i++) {\n        virTypedParameterPtr param = &params[i];\n\n        switch (i) {\n        case 0:\n            ret = virHostMemGetParameterValue(\"pages_to_scan\", &pages_to_scan);\n            if (ret == -2)\n                continue;\n            else if (ret == -1)\n                return -1;\n\n            if (virTypedParameterAssign(param, VIR_NODE_MEMORY_SHARED_PAGES_TO_SCAN,\n                                        VIR_TYPED_PARAM_UINT, pages_to_scan) < 0)\n                return -1;\n\n            break;\n\n        case 1:\n            ret = virHostMemGetParameterValue(\"sleep_millisecs\", &sleep_millisecs);\n            if (ret == -2)\n                continue;\n            else if (ret == -1)\n                return -1;\n\n            if (virTypedParameterAssign(param, VIR_NODE_MEMORY_SHARED_SLEEP_MILLISECS,\n                                        VIR_TYPED_PARAM_UINT, sleep_millisecs) < 0)\n                return -1;\n\n            break;\n\n        case 2:\n            ret = virHostMemGetParameterValue(\"pages_shared\", &pages_shared);\n            if (ret == -2)\n                continue;\n            else if (ret == -1)\n                return -1;\n\n            if (virTypedParameterAssign(param, VIR_NODE_MEMORY_SHARED_PAGES_SHARED,\n                                        VIR_TYPED_PARAM_ULLONG, pages_shared) < 0)\n                return -1;\n\n            break;\n\n        case 3:\n            ret = virHostMemGetParameterValue(\"pages_sharing\", &pages_sharing);\n            if (ret == -2)\n                continue;\n            else if (ret == -1)\n                return -1;\n\n            if (virTypedParameterAssign(param, VIR_NODE_MEMORY_SHARED_PAGES_SHARING,\n                                        VIR_TYPED_PARAM_ULLONG, pages_sharing) < 0)\n                return -1;\n\n            break;\n\n        case 4:\n            ret = virHostMemGetParameterValue(\"pages_unshared\", &pages_unshared);\n            if (ret == -2)\n                continue;\n            else if (ret == -1)\n                return -1;\n\n            if (virTypedParameterAssign(param, VIR_NODE_MEMORY_SHARED_PAGES_UNSHARED,\n                                        VIR_TYPED_PARAM_ULLONG, pages_unshared) < 0)\n                return -1;\n\n            break;\n\n        case 5:\n            ret = virHostMemGetParameterValue(\"pages_volatile\", &pages_volatile);\n            if (ret == -2)\n                continue;\n            else if (ret == -1)\n                return -1;\n\n            if (virTypedParameterAssign(param, VIR_NODE_MEMORY_SHARED_PAGES_VOLATILE,\n                                        VIR_TYPED_PARAM_ULLONG, pages_volatile) < 0)\n                return -1;\n\n            break;\n\n        case 6:\n            ret = virHostMemGetParameterValue(\"full_scans\", &full_scans);\n            if (ret == -2)\n                continue;\n            else if (ret == -1)\n                return -1;\n\n            if (virTypedParameterAssign(param, VIR_NODE_MEMORY_SHARED_FULL_SCANS,\n                                        VIR_TYPED_PARAM_ULLONG, full_scans) < 0)\n                return -1;\n\n            break;\n\n        case 7:\n            ret = virHostMemGetParameterValue(\"merge_across_nodes\", &merge_across_nodes);\n            if (ret == -2)\n                continue;\n            else if (ret == -1)\n                return -1;\n\n            if (virTypedParameterAssign(param, VIR_NODE_MEMORY_SHARED_MERGE_ACROSS_NODES,\n                                        VIR_TYPED_PARAM_UINT, merge_across_nodes) < 0)\n                return -1;\n\n            break;\n        }\n    }\n\n    return 0;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node get memory parameters not implemented\"\n                     \" on this platform\"));\n    return -1;\n#endif\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "# include <windows.h>",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define NODE_MEMORY_PARAMETERS_NUM 8"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "\"%s\"",
            "_(\"node get memory parameters not implemented\"\n                     \" on this platform\")"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"node get memory parameters not implemented\"\n                     \" on this platform\""
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParameterAssign",
          "args": [
            "param",
            "VIR_NODE_MEMORY_SHARED_MERGE_ACROSS_NODES",
            "VIR_TYPED_PARAM_UINT",
            "merge_across_nodes"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParameterAssign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "276-294",
          "snippet": "int\nvirTypedParameterAssign(virTypedParameterPtr param, const char *name,\n                        int type, ...)\n{\n    va_list ap;\n    int ret = -1;\n\n    if (virStrcpyStatic(param->field, name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Field name '%s' too long\"),\n                       name);\n        return -1;\n    }\n\n    va_start(ap, type);\n    ret = virTypedParameterAssignValueVArgs(param, type, ap, false);\n    va_end(ap);\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParameterAssign(virTypedParameterPtr param, const char *name,\n                        int type, ...)\n{\n    va_list ap;\n    int ret = -1;\n\n    if (virStrcpyStatic(param->field, name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Field name '%s' too long\"),\n                       name);\n        return -1;\n    }\n\n    va_start(ap, type);\n    ret = virTypedParameterAssignValueVArgs(param, type, ap, false);\n    va_end(ap);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostMemGetParameterValue",
          "args": [
            "\"merge_across_nodes\"",
            "&merge_across_nodes"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "virHostMemGetParameterValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
          "lines": "396-434",
          "snippet": "static int\nvirHostMemGetParameterValue(const char *field,\n                            void *value)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *buf = NULL;\n    char *tmp = NULL;\n    int rc = -1;\n\n    path = g_strdup_printf(\"%s/%s\", SYSFS_MEMORY_SHARED_PATH, field);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, 1024, &buf) < 0)\n        return -1;\n\n    if ((tmp = strchr(buf, '\\n')))\n        *tmp = '\\0';\n\n    if (STREQ(field, \"pages_to_scan\")   ||\n        STREQ(field, \"sleep_millisecs\") ||\n        STREQ(field, \"merge_across_nodes\"))\n        rc = virStrToLong_ui(buf, NULL, 10, (unsigned int *)value);\n    else if (STREQ(field, \"pages_shared\")    ||\n             STREQ(field, \"pages_sharing\")   ||\n             STREQ(field, \"pages_unshared\")  ||\n             STREQ(field, \"pages_volatile\")  ||\n             STREQ(field, \"full_scans\"))\n        rc = virStrToLong_ull(buf, NULL, 10, (unsigned long long *)value);\n\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse %s\"), field);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "# include <windows.h>",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostMemGetParameterValue(const char *field,\n                            void *value)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *buf = NULL;\n    char *tmp = NULL;\n    int rc = -1;\n\n    path = g_strdup_printf(\"%s/%s\", SYSFS_MEMORY_SHARED_PATH, field);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, 1024, &buf) < 0)\n        return -1;\n\n    if ((tmp = strchr(buf, '\\n')))\n        *tmp = '\\0';\n\n    if (STREQ(field, \"pages_to_scan\")   ||\n        STREQ(field, \"sleep_millisecs\") ||\n        STREQ(field, \"merge_across_nodes\"))\n        rc = virStrToLong_ui(buf, NULL, 10, (unsigned int *)value);\n    else if (STREQ(field, \"pages_shared\")    ||\n             STREQ(field, \"pages_sharing\")   ||\n             STREQ(field, \"pages_unshared\")  ||\n             STREQ(field, \"pages_volatile\")  ||\n             STREQ(field, \"full_scans\"))\n        rc = virStrToLong_ull(buf, NULL, 10, (unsigned long long *)value);\n\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse %s\"), field);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_TYPED_PARAM_STRING_OKAY",
            "-1"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define NODE_MEMORY_PARAMETERS_NUM 8\n\nint\nvirHostMemGetParameters(virTypedParameterPtr params G_GNUC_UNUSED,\n                        int *nparams G_GNUC_UNUSED,\n                        unsigned int flags)\n{\n    virCheckFlags(VIR_TYPED_PARAM_STRING_OKAY, -1);\n\n#ifdef __linux__\n    unsigned int pages_to_scan;\n    unsigned int sleep_millisecs;\n    unsigned int merge_across_nodes;\n    unsigned long long pages_shared;\n    unsigned long long pages_sharing;\n    unsigned long long pages_unshared;\n    unsigned long long pages_volatile;\n    unsigned long long full_scans = 0;\n    size_t i;\n    int ret;\n\n    if ((*nparams) == 0) {\n        *nparams = NODE_MEMORY_PARAMETERS_NUM;\n        return 0;\n    }\n\n    for (i = 0; i < *nparams && i < NODE_MEMORY_PARAMETERS_NUM; i++) {\n        virTypedParameterPtr param = &params[i];\n\n        switch (i) {\n        case 0:\n            ret = virHostMemGetParameterValue(\"pages_to_scan\", &pages_to_scan);\n            if (ret == -2)\n                continue;\n            else if (ret == -1)\n                return -1;\n\n            if (virTypedParameterAssign(param, VIR_NODE_MEMORY_SHARED_PAGES_TO_SCAN,\n                                        VIR_TYPED_PARAM_UINT, pages_to_scan) < 0)\n                return -1;\n\n            break;\n\n        case 1:\n            ret = virHostMemGetParameterValue(\"sleep_millisecs\", &sleep_millisecs);\n            if (ret == -2)\n                continue;\n            else if (ret == -1)\n                return -1;\n\n            if (virTypedParameterAssign(param, VIR_NODE_MEMORY_SHARED_SLEEP_MILLISECS,\n                                        VIR_TYPED_PARAM_UINT, sleep_millisecs) < 0)\n                return -1;\n\n            break;\n\n        case 2:\n            ret = virHostMemGetParameterValue(\"pages_shared\", &pages_shared);\n            if (ret == -2)\n                continue;\n            else if (ret == -1)\n                return -1;\n\n            if (virTypedParameterAssign(param, VIR_NODE_MEMORY_SHARED_PAGES_SHARED,\n                                        VIR_TYPED_PARAM_ULLONG, pages_shared) < 0)\n                return -1;\n\n            break;\n\n        case 3:\n            ret = virHostMemGetParameterValue(\"pages_sharing\", &pages_sharing);\n            if (ret == -2)\n                continue;\n            else if (ret == -1)\n                return -1;\n\n            if (virTypedParameterAssign(param, VIR_NODE_MEMORY_SHARED_PAGES_SHARING,\n                                        VIR_TYPED_PARAM_ULLONG, pages_sharing) < 0)\n                return -1;\n\n            break;\n\n        case 4:\n            ret = virHostMemGetParameterValue(\"pages_unshared\", &pages_unshared);\n            if (ret == -2)\n                continue;\n            else if (ret == -1)\n                return -1;\n\n            if (virTypedParameterAssign(param, VIR_NODE_MEMORY_SHARED_PAGES_UNSHARED,\n                                        VIR_TYPED_PARAM_ULLONG, pages_unshared) < 0)\n                return -1;\n\n            break;\n\n        case 5:\n            ret = virHostMemGetParameterValue(\"pages_volatile\", &pages_volatile);\n            if (ret == -2)\n                continue;\n            else if (ret == -1)\n                return -1;\n\n            if (virTypedParameterAssign(param, VIR_NODE_MEMORY_SHARED_PAGES_VOLATILE,\n                                        VIR_TYPED_PARAM_ULLONG, pages_volatile) < 0)\n                return -1;\n\n            break;\n\n        case 6:\n            ret = virHostMemGetParameterValue(\"full_scans\", &full_scans);\n            if (ret == -2)\n                continue;\n            else if (ret == -1)\n                return -1;\n\n            if (virTypedParameterAssign(param, VIR_NODE_MEMORY_SHARED_FULL_SCANS,\n                                        VIR_TYPED_PARAM_ULLONG, full_scans) < 0)\n                return -1;\n\n            break;\n\n        case 7:\n            ret = virHostMemGetParameterValue(\"merge_across_nodes\", &merge_across_nodes);\n            if (ret == -2)\n                continue;\n            else if (ret == -1)\n                return -1;\n\n            if (virTypedParameterAssign(param, VIR_NODE_MEMORY_SHARED_MERGE_ACROSS_NODES,\n                                        VIR_TYPED_PARAM_UINT, merge_across_nodes) < 0)\n                return -1;\n\n            break;\n        }\n    }\n\n    return 0;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node get memory parameters not implemented\"\n                     \" on this platform\"));\n    return -1;\n#endif\n}"
  },
  {
    "function_name": "virHostMemGetParameterValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
    "lines": "396-434",
    "snippet": "static int\nvirHostMemGetParameterValue(const char *field,\n                            void *value)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *buf = NULL;\n    char *tmp = NULL;\n    int rc = -1;\n\n    path = g_strdup_printf(\"%s/%s\", SYSFS_MEMORY_SHARED_PATH, field);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, 1024, &buf) < 0)\n        return -1;\n\n    if ((tmp = strchr(buf, '\\n')))\n        *tmp = '\\0';\n\n    if (STREQ(field, \"pages_to_scan\")   ||\n        STREQ(field, \"sleep_millisecs\") ||\n        STREQ(field, \"merge_across_nodes\"))\n        rc = virStrToLong_ui(buf, NULL, 10, (unsigned int *)value);\n    else if (STREQ(field, \"pages_shared\")    ||\n             STREQ(field, \"pages_sharing\")   ||\n             STREQ(field, \"pages_unshared\")  ||\n             STREQ(field, \"pages_volatile\")  ||\n             STREQ(field, \"full_scans\"))\n        rc = virStrToLong_ull(buf, NULL, 10, (unsigned long long *)value);\n\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse %s\"), field);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "# include <windows.h>",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to parse %s\")",
            "field"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to parse %s\""
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ull",
          "args": [
            "buf",
            "NULL",
            "10",
            "(unsigned long long *)value"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ullp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "568-586",
          "snippet": "int\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "field",
            "\"full_scans\""
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "field",
            "\"pages_volatile\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "field",
            "\"pages_unshared\""
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "field",
            "\"pages_sharing\""
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "field",
            "\"pages_shared\""
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "buf",
            "NULL",
            "10",
            "(unsigned int *)value"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "field",
            "\"merge_across_nodes\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "field",
            "\"sleep_millisecs\""
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "field",
            "\"pages_to_scan\""
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadAll",
          "args": [
            "path",
            "1024",
            "&buf"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "path"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostMemGetParameterValue(const char *field,\n                            void *value)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *buf = NULL;\n    char *tmp = NULL;\n    int rc = -1;\n\n    path = g_strdup_printf(\"%s/%s\", SYSFS_MEMORY_SHARED_PATH, field);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, 1024, &buf) < 0)\n        return -1;\n\n    if ((tmp = strchr(buf, '\\n')))\n        *tmp = '\\0';\n\n    if (STREQ(field, \"pages_to_scan\")   ||\n        STREQ(field, \"sleep_millisecs\") ||\n        STREQ(field, \"merge_across_nodes\"))\n        rc = virStrToLong_ui(buf, NULL, 10, (unsigned int *)value);\n    else if (STREQ(field, \"pages_shared\")    ||\n             STREQ(field, \"pages_sharing\")   ||\n             STREQ(field, \"pages_unshared\")  ||\n             STREQ(field, \"pages_volatile\")  ||\n             STREQ(field, \"full_scans\"))\n        rc = virStrToLong_ull(buf, NULL, 10, (unsigned long long *)value);\n\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse %s\"), field);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostMemSetParameters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
    "lines": "355-393",
    "snippet": "int\nvirHostMemSetParameters(virTypedParameterPtr params G_GNUC_UNUSED,\n                        int nparams G_GNUC_UNUSED,\n                        unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n#ifdef __linux__\n    size_t i;\n    int rc;\n\n    if (virTypedParamsValidate(params, nparams,\n                               VIR_NODE_MEMORY_SHARED_PAGES_TO_SCAN,\n                               VIR_TYPED_PARAM_UINT,\n                               VIR_NODE_MEMORY_SHARED_SLEEP_MILLISECS,\n                               VIR_TYPED_PARAM_UINT,\n                               VIR_NODE_MEMORY_SHARED_MERGE_ACROSS_NODES,\n                               VIR_TYPED_PARAM_UINT,\n                               NULL) < 0)\n        return -1;\n\n    if (!virHostMemParametersAreAllSupported(params, nparams))\n        return -1;\n\n    for (i = 0; i < nparams; i++) {\n        rc = virHostMemSetParameterValue(&params[i]);\n\n        if (rc < 0)\n            return -1;\n    }\n\n    return 0;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node set memory parameters not implemented\"\n                     \" on this platform\"));\n    return -1;\n#endif\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "# include <windows.h>",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "\"%s\"",
            "_(\"node set memory parameters not implemented\"\n                     \" on this platform\")"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"node set memory parameters not implemented\"\n                     \" on this platform\""
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostMemSetParameterValue",
          "args": [
            "&params[i]"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "virHostMemSetParameterValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
          "lines": "306-326",
          "snippet": "static int\nvirHostMemSetParameterValue(virTypedParameterPtr param)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *strval = NULL;\n    int rc = -1;\n\n    char *field = strchr(param->field, '_');\n    sa_assert(field);\n    field++;\n    path = g_strdup_printf(\"%s/%s\", SYSFS_MEMORY_SHARED_PATH, field);\n\n    strval = g_strdup_printf(\"%u\", param->value.ui);\n\n    if ((rc = virFileWriteStr(path, strval, 0)) < 0) {\n        virReportSystemError(-rc, _(\"failed to set %s\"), param->field);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "# include <windows.h>",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostMemSetParameterValue(virTypedParameterPtr param)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *strval = NULL;\n    int rc = -1;\n\n    char *field = strchr(param->field, '_');\n    sa_assert(field);\n    field++;\n    path = g_strdup_printf(\"%s/%s\", SYSFS_MEMORY_SHARED_PATH, field);\n\n    strval = g_strdup_printf(\"%u\", param->value.ui);\n\n    if ((rc = virFileWriteStr(path, strval, 0)) < 0) {\n        virReportSystemError(-rc, _(\"failed to set %s\"), param->field);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostMemParametersAreAllSupported",
          "args": [
            "params",
            "nparams"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "virHostMemParametersAreAllSupported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
          "lines": "328-352",
          "snippet": "static bool\nvirHostMemParametersAreAllSupported(virTypedParameterPtr params,\n                                    int nparams)\n{\n    size_t i;\n\n    for (i = 0; i < nparams; i++) {\n        g_autofree char *path = NULL;\n        virTypedParameterPtr param = &params[i];\n\n        char *field = strchr(param->field, '_');\n        sa_assert(field);\n        field++;\n        path = g_strdup_printf(\"%s/%s\", SYSFS_MEMORY_SHARED_PATH, field);\n\n        if (!virFileExists(path)) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"Parameter '%s' is not supported by \"\n                             \"this kernel\"), param->field);\n            return false;\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "# include <windows.h>",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic bool\nvirHostMemParametersAreAllSupported(virTypedParameterPtr params,\n                                    int nparams)\n{\n    size_t i;\n\n    for (i = 0; i < nparams; i++) {\n        g_autofree char *path = NULL;\n        virTypedParameterPtr param = &params[i];\n\n        char *field = strchr(param->field, '_');\n        sa_assert(field);\n        field++;\n        path = g_strdup_printf(\"%s/%s\", SYSFS_MEMORY_SHARED_PATH, field);\n\n        if (!virFileExists(path)) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"Parameter '%s' is not supported by \"\n                             \"this kernel\"), param->field);\n            return false;\n        }\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsValidate",
          "args": [
            "params",
            "nparams",
            "VIR_NODE_MEMORY_SHARED_PAGES_TO_SCAN",
            "VIR_TYPED_PARAM_UINT",
            "VIR_NODE_MEMORY_SHARED_SLEEP_MILLISECS",
            "VIR_TYPED_PARAM_UINT",
            "VIR_NODE_MEMORY_SHARED_MERGE_ACROSS_NODES",
            "VIR_TYPED_PARAM_UINT",
            "NULL"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "58-142",
          "snippet": "int\nvirTypedParamsValidate(virTypedParameterPtr params, int nparams, ...)\n{\n    va_list ap;\n    int ret = -1;\n    size_t i, j;\n    const char *name, *last_name = NULL;\n    int type;\n    size_t nkeys = 0, nkeysalloc = 0;\n    virTypedParameterPtr sorted = NULL, keys = NULL;\n\n    va_start(ap, nparams);\n\n    if (VIR_ALLOC_N(sorted, nparams) < 0)\n        goto cleanup;\n\n    /* Here we intentionally don't copy values */\n    memcpy(sorted, params, sizeof(*params) * nparams);\n    qsort(sorted, nparams, sizeof(*sorted), virTypedParamsSortName);\n\n    name = va_arg(ap, const char *);\n    while (name) {\n        type = va_arg(ap, int);\n        if (VIR_RESIZE_N(keys, nkeysalloc, nkeys, 1) < 0)\n            goto cleanup;\n\n        if (virStrcpyStatic(keys[nkeys].field, name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Field name '%s' too long\"), name);\n            goto cleanup;\n        }\n\n        keys[nkeys].type = type & ~VIR_TYPED_PARAM_MULTIPLE;\n        /* Value is not used anyway */\n        keys[nkeys].value.i = type & VIR_TYPED_PARAM_MULTIPLE;\n\n        nkeys++;\n        name = va_arg(ap, const char *);\n    }\n\n    qsort(keys, nkeys, sizeof(*keys), virTypedParamsSortName);\n\n    for (i = 0, j = 0; i < nparams && j < nkeys;) {\n        if (STRNEQ(sorted[i].field, keys[j].field)) {\n            j++;\n        } else {\n            if (STREQ_NULLABLE(last_name, sorted[i].field) &&\n                !(keys[j].value.i & VIR_TYPED_PARAM_MULTIPLE)) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"parameter '%s' occurs multiple times\"),\n                               sorted[i].field);\n                goto cleanup;\n            }\n            if (sorted[i].type != keys[j].type) {\n                const char *badtype;\n\n                badtype = virTypedParameterTypeToString(sorted[i].type);\n                if (!badtype)\n                    badtype = virTypedParameterTypeToString(0);\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"invalid type '%s' for parameter '%s', \"\n                                 \"expected '%s'\"),\n                               badtype, sorted[i].field,\n                               virTypedParameterTypeToString(keys[j].type));\n                goto cleanup;\n            }\n            last_name = sorted[i].field;\n            i++;\n        }\n    }\n\n    if (j == nkeys && i != nparams) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED,\n                       _(\"parameter '%s' not supported\"),\n                       sorted[i].field);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    va_end(ap);\n    VIR_FREE(sorted);\n    VIR_FREE(keys);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsValidate(virTypedParameterPtr params, int nparams, ...)\n{\n    va_list ap;\n    int ret = -1;\n    size_t i, j;\n    const char *name, *last_name = NULL;\n    int type;\n    size_t nkeys = 0, nkeysalloc = 0;\n    virTypedParameterPtr sorted = NULL, keys = NULL;\n\n    va_start(ap, nparams);\n\n    if (VIR_ALLOC_N(sorted, nparams) < 0)\n        goto cleanup;\n\n    /* Here we intentionally don't copy values */\n    memcpy(sorted, params, sizeof(*params) * nparams);\n    qsort(sorted, nparams, sizeof(*sorted), virTypedParamsSortName);\n\n    name = va_arg(ap, const char *);\n    while (name) {\n        type = va_arg(ap, int);\n        if (VIR_RESIZE_N(keys, nkeysalloc, nkeys, 1) < 0)\n            goto cleanup;\n\n        if (virStrcpyStatic(keys[nkeys].field, name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Field name '%s' too long\"), name);\n            goto cleanup;\n        }\n\n        keys[nkeys].type = type & ~VIR_TYPED_PARAM_MULTIPLE;\n        /* Value is not used anyway */\n        keys[nkeys].value.i = type & VIR_TYPED_PARAM_MULTIPLE;\n\n        nkeys++;\n        name = va_arg(ap, const char *);\n    }\n\n    qsort(keys, nkeys, sizeof(*keys), virTypedParamsSortName);\n\n    for (i = 0, j = 0; i < nparams && j < nkeys;) {\n        if (STRNEQ(sorted[i].field, keys[j].field)) {\n            j++;\n        } else {\n            if (STREQ_NULLABLE(last_name, sorted[i].field) &&\n                !(keys[j].value.i & VIR_TYPED_PARAM_MULTIPLE)) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"parameter '%s' occurs multiple times\"),\n                               sorted[i].field);\n                goto cleanup;\n            }\n            if (sorted[i].type != keys[j].type) {\n                const char *badtype;\n\n                badtype = virTypedParameterTypeToString(sorted[i].type);\n                if (!badtype)\n                    badtype = virTypedParameterTypeToString(0);\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"invalid type '%s' for parameter '%s', \"\n                                 \"expected '%s'\"),\n                               badtype, sorted[i].field,\n                               virTypedParameterTypeToString(keys[j].type));\n                goto cleanup;\n            }\n            last_name = sorted[i].field;\n            i++;\n        }\n    }\n\n    if (j == nkeys && i != nparams) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED,\n                       _(\"parameter '%s' not supported\"),\n                       sorted[i].field);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    va_end(ap);\n    VIR_FREE(sorted);\n    VIR_FREE(keys);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostMemSetParameters(virTypedParameterPtr params G_GNUC_UNUSED,\n                        int nparams G_GNUC_UNUSED,\n                        unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n#ifdef __linux__\n    size_t i;\n    int rc;\n\n    if (virTypedParamsValidate(params, nparams,\n                               VIR_NODE_MEMORY_SHARED_PAGES_TO_SCAN,\n                               VIR_TYPED_PARAM_UINT,\n                               VIR_NODE_MEMORY_SHARED_SLEEP_MILLISECS,\n                               VIR_TYPED_PARAM_UINT,\n                               VIR_NODE_MEMORY_SHARED_MERGE_ACROSS_NODES,\n                               VIR_TYPED_PARAM_UINT,\n                               NULL) < 0)\n        return -1;\n\n    if (!virHostMemParametersAreAllSupported(params, nparams))\n        return -1;\n\n    for (i = 0; i < nparams; i++) {\n        rc = virHostMemSetParameterValue(&params[i]);\n\n        if (rc < 0)\n            return -1;\n    }\n\n    return 0;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node set memory parameters not implemented\"\n                     \" on this platform\"));\n    return -1;\n#endif\n}"
  },
  {
    "function_name": "virHostMemParametersAreAllSupported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
    "lines": "328-352",
    "snippet": "static bool\nvirHostMemParametersAreAllSupported(virTypedParameterPtr params,\n                                    int nparams)\n{\n    size_t i;\n\n    for (i = 0; i < nparams; i++) {\n        g_autofree char *path = NULL;\n        virTypedParameterPtr param = &params[i];\n\n        char *field = strchr(param->field, '_');\n        sa_assert(field);\n        field++;\n        path = g_strdup_printf(\"%s/%s\", SYSFS_MEMORY_SHARED_PATH, field);\n\n        if (!virFileExists(path)) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"Parameter '%s' is not supported by \"\n                             \"this kernel\"), param->field);\n            return false;\n        }\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "# include <windows.h>",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"Parameter '%s' is not supported by \"\n                             \"this kernel\")",
            "param->field"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Parameter '%s' is not supported by \"\n                             \"this kernel\""
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "path"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sa_assert",
          "args": [
            "field"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "param->field",
            "'_'"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic bool\nvirHostMemParametersAreAllSupported(virTypedParameterPtr params,\n                                    int nparams)\n{\n    size_t i;\n\n    for (i = 0; i < nparams; i++) {\n        g_autofree char *path = NULL;\n        virTypedParameterPtr param = &params[i];\n\n        char *field = strchr(param->field, '_');\n        sa_assert(field);\n        field++;\n        path = g_strdup_printf(\"%s/%s\", SYSFS_MEMORY_SHARED_PATH, field);\n\n        if (!virFileExists(path)) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"Parameter '%s' is not supported by \"\n                             \"this kernel\"), param->field);\n            return false;\n        }\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "virHostMemSetParameterValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
    "lines": "306-326",
    "snippet": "static int\nvirHostMemSetParameterValue(virTypedParameterPtr param)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *strval = NULL;\n    int rc = -1;\n\n    char *field = strchr(param->field, '_');\n    sa_assert(field);\n    field++;\n    path = g_strdup_printf(\"%s/%s\", SYSFS_MEMORY_SHARED_PATH, field);\n\n    strval = g_strdup_printf(\"%u\", param->value.ui);\n\n    if ((rc = virFileWriteStr(path, strval, 0)) < 0) {\n        virReportSystemError(-rc, _(\"failed to set %s\"), param->field);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "# include <windows.h>",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-rc",
            "_(\"failed to set %s\")",
            "param->field"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to set %s\""
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileWriteStr",
          "args": [
            "path",
            "strval",
            "0"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "virFileWriteStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1502-1524",
          "snippet": "int\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sa_assert",
          "args": [
            "field"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "param->field",
            "'_'"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostMemSetParameterValue(virTypedParameterPtr param)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *strval = NULL;\n    int rc = -1;\n\n    char *field = strchr(param->field, '_');\n    sa_assert(field);\n    field++;\n    path = g_strdup_printf(\"%s/%s\", SYSFS_MEMORY_SHARED_PATH, field);\n\n    strval = g_strdup_printf(\"%u\", param->value.ui);\n\n    if ((rc = virFileWriteStr(path, strval, 0)) < 0) {\n        virReportSystemError(-rc, _(\"failed to set %s\"), param->field);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostMemGetStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
    "lines": "244-302",
    "snippet": "int\nvirHostMemGetStats(int cellNum G_GNUC_UNUSED,\n                   virNodeMemoryStatsPtr params G_GNUC_UNUSED,\n                   int *nparams G_GNUC_UNUSED,\n                   unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n#ifdef __linux__\n    {\n        int ret;\n        g_autofree char *meminfo_path = NULL;\n        FILE *meminfo;\n        int max_node;\n\n        /*\n         * Even if built without numactl, libvirt claims\n         * to have a one-cells NUMA topology. In such a\n         * case return the statistics for the entire host.\n         */\n        if (!virNumaIsAvailable() && cellNum == 0)\n            cellNum = VIR_NODE_MEMORY_STATS_ALL_CELLS;\n\n        if (cellNum == VIR_NODE_MEMORY_STATS_ALL_CELLS) {\n            meminfo_path = g_strdup(MEMINFO_PATH);\n        } else {\n            if ((max_node = virNumaGetMaxNode()) < 0)\n                return -1;\n\n            if (cellNum > max_node) {\n                virReportInvalidArg(cellNum,\n                                    _(\"cellNum in %s must be less than or equal to %d\"),\n                                    __FUNCTION__, max_node);\n                return -1;\n            }\n\n            meminfo_path = g_strdup_printf(\n                                           SYSFS_SYSTEM_PATH \"/node/node%d/meminfo\", cellNum);\n        }\n        meminfo = fopen(meminfo_path, \"r\");\n\n        if (!meminfo) {\n            virReportSystemError(errno,\n                                 _(\"cannot open %s\"), meminfo_path);\n            return -1;\n        }\n        ret = virHostMemGetStatsLinux(meminfo, cellNum, params, nparams);\n        VIR_FORCE_FCLOSE(meminfo);\n\n        return ret;\n    }\n#elif defined(__FreeBSD__)\n    return virHostMemGetStatsFreeBSD(params, nparams);\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node memory stats not implemented on this platform\"));\n    return -1;\n#endif\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "# include <windows.h>",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "\"%s\"",
            "_(\"node memory stats not implemented on this platform\")"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"node memory stats not implemented on this platform\""
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostMemGetStatsFreeBSD",
          "args": [
            "params",
            "nparams"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "virHostMemGetStatsFreeBSD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
          "lines": "57-129",
          "snippet": "static int\nvirHostMemGetStatsFreeBSD(virNodeMemoryStatsPtr params,\n                          int *nparams)\n{\n    size_t i, j = 0;\n    unsigned long pagesize = getpagesize() >> 10;\n    long bufpages;\n    size_t bufpages_size = sizeof(bufpages);\n    struct field_sysctl_map {\n        const char *field;\n        const char *sysctl_name;\n    } sysctl_map[] = {\n        {VIR_NODE_MEMORY_STATS_TOTAL, \"vm.stats.vm.v_page_count\"},\n        {VIR_NODE_MEMORY_STATS_FREE, \"vm.stats.vm.v_free_count\"},\n        {VIR_NODE_MEMORY_STATS_CACHED, \"vm.stats.vm.v_cache_count\"},\n        {NULL, NULL}\n    };\n\n    if ((*nparams) == 0) {\n        *nparams = BSD_MEMORY_STATS_ALL;\n        return 0;\n    }\n\n    if ((*nparams) != BSD_MEMORY_STATS_ALL) {\n        virReportInvalidArg(nparams,\n                            _(\"nparams in %s must be %d\"),\n                            __FUNCTION__, BSD_MEMORY_STATS_ALL);\n        return -1;\n    }\n\n    for (i = 0; sysctl_map[i].field != NULL; i++) {\n        u_int value;\n        size_t value_size = sizeof(value);\n        virNodeMemoryStatsPtr param;\n\n        if (sysctlbyname(sysctl_map[i].sysctl_name, &value,\n                         &value_size, NULL, 0) < 0) {\n            virReportSystemError(errno,\n                                 _(\"sysctl failed for '%s'\"),\n                                 sysctl_map[i].sysctl_name);\n            return -1;\n        }\n\n        param = &params[j++];\n        if (virStrcpyStatic(param->field, sysctl_map[i].field) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Field '%s' too long for destination\"),\n                           sysctl_map[i].field);\n            return -1;\n        }\n        param->value = (unsigned long long)value * pagesize;\n    }\n\n    {\n        virNodeMemoryStatsPtr param = &params[j++];\n\n        if (sysctlbyname(\"vfs.bufspace\", &bufpages, &bufpages_size, NULL, 0) < 0) {\n            virReportSystemError(errno,\n                                 _(\"sysctl failed for '%s'\"),\n                                 \"vfs.bufspace\");\n            return -1;\n        }\n        if (virStrcpyStatic(param->field, VIR_NODE_MEMORY_STATS_BUFFERS) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Field '%s' too long for destination\"),\n                           VIR_NODE_MEMORY_STATS_BUFFERS);\n            return -1;\n        }\n        param->value = (unsigned long long)bufpages >> 10;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "# include <windows.h>",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostMemGetStatsFreeBSD(virNodeMemoryStatsPtr params,\n                          int *nparams)\n{\n    size_t i, j = 0;\n    unsigned long pagesize = getpagesize() >> 10;\n    long bufpages;\n    size_t bufpages_size = sizeof(bufpages);\n    struct field_sysctl_map {\n        const char *field;\n        const char *sysctl_name;\n    } sysctl_map[] = {\n        {VIR_NODE_MEMORY_STATS_TOTAL, \"vm.stats.vm.v_page_count\"},\n        {VIR_NODE_MEMORY_STATS_FREE, \"vm.stats.vm.v_free_count\"},\n        {VIR_NODE_MEMORY_STATS_CACHED, \"vm.stats.vm.v_cache_count\"},\n        {NULL, NULL}\n    };\n\n    if ((*nparams) == 0) {\n        *nparams = BSD_MEMORY_STATS_ALL;\n        return 0;\n    }\n\n    if ((*nparams) != BSD_MEMORY_STATS_ALL) {\n        virReportInvalidArg(nparams,\n                            _(\"nparams in %s must be %d\"),\n                            __FUNCTION__, BSD_MEMORY_STATS_ALL);\n        return -1;\n    }\n\n    for (i = 0; sysctl_map[i].field != NULL; i++) {\n        u_int value;\n        size_t value_size = sizeof(value);\n        virNodeMemoryStatsPtr param;\n\n        if (sysctlbyname(sysctl_map[i].sysctl_name, &value,\n                         &value_size, NULL, 0) < 0) {\n            virReportSystemError(errno,\n                                 _(\"sysctl failed for '%s'\"),\n                                 sysctl_map[i].sysctl_name);\n            return -1;\n        }\n\n        param = &params[j++];\n        if (virStrcpyStatic(param->field, sysctl_map[i].field) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Field '%s' too long for destination\"),\n                           sysctl_map[i].field);\n            return -1;\n        }\n        param->value = (unsigned long long)value * pagesize;\n    }\n\n    {\n        virNodeMemoryStatsPtr param = &params[j++];\n\n        if (sysctlbyname(\"vfs.bufspace\", &bufpages, &bufpages_size, NULL, 0) < 0) {\n            virReportSystemError(errno,\n                                 _(\"sysctl failed for '%s'\"),\n                                 \"vfs.bufspace\");\n            return -1;\n        }\n        if (virStrcpyStatic(param->field, VIR_NODE_MEMORY_STATS_BUFFERS) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Field '%s' too long for destination\"),\n                           VIR_NODE_MEMORY_STATS_BUFFERS);\n            return -1;\n        }\n        param->value = (unsigned long long)bufpages >> 10;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_FCLOSE",
          "args": [
            "meminfo"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostMemGetStatsLinux",
          "args": [
            "meminfo",
            "cellNum",
            "params",
            "nparams"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "virHostMemGetStatsLinux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
          "lines": "141-240",
          "snippet": "static int\nvirHostMemGetStatsLinux(FILE *meminfo,\n                        int cellNum,\n                        virNodeMemoryStatsPtr params,\n                        int *nparams)\n{\n    size_t i = 0, j = 0, k = 0;\n    int found = 0;\n    int nr_param;\n    char line[1024];\n    char meminfo_hdr[VIR_NODE_MEMORY_STATS_FIELD_LENGTH];\n    unsigned long val;\n    struct field_conv {\n        const char *meminfo_hdr;  /* meminfo header */\n        const char *field;        /* MemoryStats field name */\n    } field_conv[] = {\n        {\"MemTotal:\", VIR_NODE_MEMORY_STATS_TOTAL},\n        {\"MemFree:\",  VIR_NODE_MEMORY_STATS_FREE},\n        {\"Buffers:\",  VIR_NODE_MEMORY_STATS_BUFFERS},\n        {\"Cached:\",   VIR_NODE_MEMORY_STATS_CACHED},\n        {NULL,        NULL}\n    };\n\n    if (cellNum == VIR_NODE_MEMORY_STATS_ALL_CELLS) {\n        nr_param = LINUX_NB_MEMORY_STATS_ALL;\n    } else {\n        nr_param = LINUX_NB_MEMORY_STATS_CELL;\n    }\n\n    if ((*nparams) == 0) {\n        /* Current number of memory stats supported by linux */\n        *nparams = nr_param;\n        return 0;\n    }\n\n    if ((*nparams) != nr_param) {\n        virReportInvalidArg(nparams,\n                            _(\"nparams in %s must be %d\"),\n                            __FUNCTION__, nr_param);\n        return -1;\n    }\n\n    while (fgets(line, sizeof(line), meminfo) != NULL) {\n        char *buf = line;\n\n        if (STRPREFIX(buf, \"Node \")) {\n            /*\n             * /sys/devices/system/node/nodeX/meminfo format is below.\n             * So, skip prefix \"Node XX \".\n             *\n             * Node 0 MemTotal:        8386980 kB\n             * Node 0 MemFree:         5300920 kB\n             *         :\n             */\n            char *p;\n\n            p = buf;\n            for (i = 0; i < 2; i++) {\n                p = strchr(p, ' ');\n                if (p == NULL) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   \"%s\", _(\"no prefix found\"));\n                    return -1;\n                }\n                p++;\n            }\n            buf = p;\n        }\n\n        if (sscanf(buf, \"%s %lu kB\", meminfo_hdr, &val) < 2)\n            continue;\n\n        for (j = 0; field_conv[j].meminfo_hdr != NULL; j++) {\n            struct field_conv *convp = &field_conv[j];\n\n            if (STREQ(meminfo_hdr, convp->meminfo_hdr)) {\n                virNodeMemoryStatsPtr param = &params[k++];\n\n                if (virStrcpyStatic(param->field, convp->field) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   \"%s\", _(\"Field kernel memory too long for destination\"));\n                    return -1;\n                }\n                param->value = val;\n                found++;\n                break;\n            }\n        }\n        if (found >= nr_param)\n            break;\n    }\n\n    if (found == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"no available memory line found\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "# include <windows.h>",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostMemGetStatsLinux(FILE *meminfo,\n                        int cellNum,\n                        virNodeMemoryStatsPtr params,\n                        int *nparams)\n{\n    size_t i = 0, j = 0, k = 0;\n    int found = 0;\n    int nr_param;\n    char line[1024];\n    char meminfo_hdr[VIR_NODE_MEMORY_STATS_FIELD_LENGTH];\n    unsigned long val;\n    struct field_conv {\n        const char *meminfo_hdr;  /* meminfo header */\n        const char *field;        /* MemoryStats field name */\n    } field_conv[] = {\n        {\"MemTotal:\", VIR_NODE_MEMORY_STATS_TOTAL},\n        {\"MemFree:\",  VIR_NODE_MEMORY_STATS_FREE},\n        {\"Buffers:\",  VIR_NODE_MEMORY_STATS_BUFFERS},\n        {\"Cached:\",   VIR_NODE_MEMORY_STATS_CACHED},\n        {NULL,        NULL}\n    };\n\n    if (cellNum == VIR_NODE_MEMORY_STATS_ALL_CELLS) {\n        nr_param = LINUX_NB_MEMORY_STATS_ALL;\n    } else {\n        nr_param = LINUX_NB_MEMORY_STATS_CELL;\n    }\n\n    if ((*nparams) == 0) {\n        /* Current number of memory stats supported by linux */\n        *nparams = nr_param;\n        return 0;\n    }\n\n    if ((*nparams) != nr_param) {\n        virReportInvalidArg(nparams,\n                            _(\"nparams in %s must be %d\"),\n                            __FUNCTION__, nr_param);\n        return -1;\n    }\n\n    while (fgets(line, sizeof(line), meminfo) != NULL) {\n        char *buf = line;\n\n        if (STRPREFIX(buf, \"Node \")) {\n            /*\n             * /sys/devices/system/node/nodeX/meminfo format is below.\n             * So, skip prefix \"Node XX \".\n             *\n             * Node 0 MemTotal:        8386980 kB\n             * Node 0 MemFree:         5300920 kB\n             *         :\n             */\n            char *p;\n\n            p = buf;\n            for (i = 0; i < 2; i++) {\n                p = strchr(p, ' ');\n                if (p == NULL) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   \"%s\", _(\"no prefix found\"));\n                    return -1;\n                }\n                p++;\n            }\n            buf = p;\n        }\n\n        if (sscanf(buf, \"%s %lu kB\", meminfo_hdr, &val) < 2)\n            continue;\n\n        for (j = 0; field_conv[j].meminfo_hdr != NULL; j++) {\n            struct field_conv *convp = &field_conv[j];\n\n            if (STREQ(meminfo_hdr, convp->meminfo_hdr)) {\n                virNodeMemoryStatsPtr param = &params[k++];\n\n                if (virStrcpyStatic(param->field, convp->field) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   \"%s\", _(\"Field kernel memory too long for destination\"));\n                    return -1;\n                }\n                param->value = val;\n                found++;\n                break;\n            }\n        }\n        if (found >= nr_param)\n            break;\n    }\n\n    if (found == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"no available memory line found\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot open %s\")",
            "meminfo_path"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "meminfo_path",
            "\"r\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportInvalidArg",
          "args": [
            "cellNum",
            "_(\"cellNum in %s must be less than or equal to %d\")",
            "__FUNCTION__",
            "max_node"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNumaGetMaxNode",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetMaxNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "362-368",
          "snippet": "int\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaIsAvailable",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaIsAvailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "355-359",
          "snippet": "bool\nvirNumaIsAvailable(void)\n{\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nbool\nvirNumaIsAvailable(void)\n{\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostMemGetStats(int cellNum G_GNUC_UNUSED,\n                   virNodeMemoryStatsPtr params G_GNUC_UNUSED,\n                   int *nparams G_GNUC_UNUSED,\n                   unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n#ifdef __linux__\n    {\n        int ret;\n        g_autofree char *meminfo_path = NULL;\n        FILE *meminfo;\n        int max_node;\n\n        /*\n         * Even if built without numactl, libvirt claims\n         * to have a one-cells NUMA topology. In such a\n         * case return the statistics for the entire host.\n         */\n        if (!virNumaIsAvailable() && cellNum == 0)\n            cellNum = VIR_NODE_MEMORY_STATS_ALL_CELLS;\n\n        if (cellNum == VIR_NODE_MEMORY_STATS_ALL_CELLS) {\n            meminfo_path = g_strdup(MEMINFO_PATH);\n        } else {\n            if ((max_node = virNumaGetMaxNode()) < 0)\n                return -1;\n\n            if (cellNum > max_node) {\n                virReportInvalidArg(cellNum,\n                                    _(\"cellNum in %s must be less than or equal to %d\"),\n                                    __FUNCTION__, max_node);\n                return -1;\n            }\n\n            meminfo_path = g_strdup_printf(\n                                           SYSFS_SYSTEM_PATH \"/node/node%d/meminfo\", cellNum);\n        }\n        meminfo = fopen(meminfo_path, \"r\");\n\n        if (!meminfo) {\n            virReportSystemError(errno,\n                                 _(\"cannot open %s\"), meminfo_path);\n            return -1;\n        }\n        ret = virHostMemGetStatsLinux(meminfo, cellNum, params, nparams);\n        VIR_FORCE_FCLOSE(meminfo);\n\n        return ret;\n    }\n#elif defined(__FreeBSD__)\n    return virHostMemGetStatsFreeBSD(params, nparams);\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node memory stats not implemented on this platform\"));\n    return -1;\n#endif\n}"
  },
  {
    "function_name": "virHostMemGetStatsLinux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
    "lines": "141-240",
    "snippet": "static int\nvirHostMemGetStatsLinux(FILE *meminfo,\n                        int cellNum,\n                        virNodeMemoryStatsPtr params,\n                        int *nparams)\n{\n    size_t i = 0, j = 0, k = 0;\n    int found = 0;\n    int nr_param;\n    char line[1024];\n    char meminfo_hdr[VIR_NODE_MEMORY_STATS_FIELD_LENGTH];\n    unsigned long val;\n    struct field_conv {\n        const char *meminfo_hdr;  /* meminfo header */\n        const char *field;        /* MemoryStats field name */\n    } field_conv[] = {\n        {\"MemTotal:\", VIR_NODE_MEMORY_STATS_TOTAL},\n        {\"MemFree:\",  VIR_NODE_MEMORY_STATS_FREE},\n        {\"Buffers:\",  VIR_NODE_MEMORY_STATS_BUFFERS},\n        {\"Cached:\",   VIR_NODE_MEMORY_STATS_CACHED},\n        {NULL,        NULL}\n    };\n\n    if (cellNum == VIR_NODE_MEMORY_STATS_ALL_CELLS) {\n        nr_param = LINUX_NB_MEMORY_STATS_ALL;\n    } else {\n        nr_param = LINUX_NB_MEMORY_STATS_CELL;\n    }\n\n    if ((*nparams) == 0) {\n        /* Current number of memory stats supported by linux */\n        *nparams = nr_param;\n        return 0;\n    }\n\n    if ((*nparams) != nr_param) {\n        virReportInvalidArg(nparams,\n                            _(\"nparams in %s must be %d\"),\n                            __FUNCTION__, nr_param);\n        return -1;\n    }\n\n    while (fgets(line, sizeof(line), meminfo) != NULL) {\n        char *buf = line;\n\n        if (STRPREFIX(buf, \"Node \")) {\n            /*\n             * /sys/devices/system/node/nodeX/meminfo format is below.\n             * So, skip prefix \"Node XX \".\n             *\n             * Node 0 MemTotal:        8386980 kB\n             * Node 0 MemFree:         5300920 kB\n             *         :\n             */\n            char *p;\n\n            p = buf;\n            for (i = 0; i < 2; i++) {\n                p = strchr(p, ' ');\n                if (p == NULL) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   \"%s\", _(\"no prefix found\"));\n                    return -1;\n                }\n                p++;\n            }\n            buf = p;\n        }\n\n        if (sscanf(buf, \"%s %lu kB\", meminfo_hdr, &val) < 2)\n            continue;\n\n        for (j = 0; field_conv[j].meminfo_hdr != NULL; j++) {\n            struct field_conv *convp = &field_conv[j];\n\n            if (STREQ(meminfo_hdr, convp->meminfo_hdr)) {\n                virNodeMemoryStatsPtr param = &params[k++];\n\n                if (virStrcpyStatic(param->field, convp->field) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   \"%s\", _(\"Field kernel memory too long for destination\"));\n                    return -1;\n                }\n                param->value = val;\n                found++;\n                break;\n            }\n        }\n        if (found >= nr_param)\n            break;\n    }\n\n    if (found == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"no available memory line found\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "# include <windows.h>",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no available memory line found\")"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no available memory line found\""
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Field kernel memory too long for destination\")"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "param->field",
            "convp->field"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "meminfo_hdr",
            "convp->meminfo_hdr"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%s %lu kB\"",
            "meminfo_hdr",
            "&val"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no prefix found\")"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "' '"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "buf",
            "\"Node \""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "meminfo"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportInvalidArg",
          "args": [
            "nparams",
            "_(\"nparams in %s must be %d\")",
            "__FUNCTION__",
            "nr_param"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostMemGetStatsLinux(FILE *meminfo,\n                        int cellNum,\n                        virNodeMemoryStatsPtr params,\n                        int *nparams)\n{\n    size_t i = 0, j = 0, k = 0;\n    int found = 0;\n    int nr_param;\n    char line[1024];\n    char meminfo_hdr[VIR_NODE_MEMORY_STATS_FIELD_LENGTH];\n    unsigned long val;\n    struct field_conv {\n        const char *meminfo_hdr;  /* meminfo header */\n        const char *field;        /* MemoryStats field name */\n    } field_conv[] = {\n        {\"MemTotal:\", VIR_NODE_MEMORY_STATS_TOTAL},\n        {\"MemFree:\",  VIR_NODE_MEMORY_STATS_FREE},\n        {\"Buffers:\",  VIR_NODE_MEMORY_STATS_BUFFERS},\n        {\"Cached:\",   VIR_NODE_MEMORY_STATS_CACHED},\n        {NULL,        NULL}\n    };\n\n    if (cellNum == VIR_NODE_MEMORY_STATS_ALL_CELLS) {\n        nr_param = LINUX_NB_MEMORY_STATS_ALL;\n    } else {\n        nr_param = LINUX_NB_MEMORY_STATS_CELL;\n    }\n\n    if ((*nparams) == 0) {\n        /* Current number of memory stats supported by linux */\n        *nparams = nr_param;\n        return 0;\n    }\n\n    if ((*nparams) != nr_param) {\n        virReportInvalidArg(nparams,\n                            _(\"nparams in %s must be %d\"),\n                            __FUNCTION__, nr_param);\n        return -1;\n    }\n\n    while (fgets(line, sizeof(line), meminfo) != NULL) {\n        char *buf = line;\n\n        if (STRPREFIX(buf, \"Node \")) {\n            /*\n             * /sys/devices/system/node/nodeX/meminfo format is below.\n             * So, skip prefix \"Node XX \".\n             *\n             * Node 0 MemTotal:        8386980 kB\n             * Node 0 MemFree:         5300920 kB\n             *         :\n             */\n            char *p;\n\n            p = buf;\n            for (i = 0; i < 2; i++) {\n                p = strchr(p, ' ');\n                if (p == NULL) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   \"%s\", _(\"no prefix found\"));\n                    return -1;\n                }\n                p++;\n            }\n            buf = p;\n        }\n\n        if (sscanf(buf, \"%s %lu kB\", meminfo_hdr, &val) < 2)\n            continue;\n\n        for (j = 0; field_conv[j].meminfo_hdr != NULL; j++) {\n            struct field_conv *convp = &field_conv[j];\n\n            if (STREQ(meminfo_hdr, convp->meminfo_hdr)) {\n                virNodeMemoryStatsPtr param = &params[k++];\n\n                if (virStrcpyStatic(param->field, convp->field) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   \"%s\", _(\"Field kernel memory too long for destination\"));\n                    return -1;\n                }\n                param->value = val;\n                found++;\n                break;\n            }\n        }\n        if (found >= nr_param)\n            break;\n    }\n\n    if (found == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"no available memory line found\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostMemGetStatsFreeBSD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
    "lines": "57-129",
    "snippet": "static int\nvirHostMemGetStatsFreeBSD(virNodeMemoryStatsPtr params,\n                          int *nparams)\n{\n    size_t i, j = 0;\n    unsigned long pagesize = getpagesize() >> 10;\n    long bufpages;\n    size_t bufpages_size = sizeof(bufpages);\n    struct field_sysctl_map {\n        const char *field;\n        const char *sysctl_name;\n    } sysctl_map[] = {\n        {VIR_NODE_MEMORY_STATS_TOTAL, \"vm.stats.vm.v_page_count\"},\n        {VIR_NODE_MEMORY_STATS_FREE, \"vm.stats.vm.v_free_count\"},\n        {VIR_NODE_MEMORY_STATS_CACHED, \"vm.stats.vm.v_cache_count\"},\n        {NULL, NULL}\n    };\n\n    if ((*nparams) == 0) {\n        *nparams = BSD_MEMORY_STATS_ALL;\n        return 0;\n    }\n\n    if ((*nparams) != BSD_MEMORY_STATS_ALL) {\n        virReportInvalidArg(nparams,\n                            _(\"nparams in %s must be %d\"),\n                            __FUNCTION__, BSD_MEMORY_STATS_ALL);\n        return -1;\n    }\n\n    for (i = 0; sysctl_map[i].field != NULL; i++) {\n        u_int value;\n        size_t value_size = sizeof(value);\n        virNodeMemoryStatsPtr param;\n\n        if (sysctlbyname(sysctl_map[i].sysctl_name, &value,\n                         &value_size, NULL, 0) < 0) {\n            virReportSystemError(errno,\n                                 _(\"sysctl failed for '%s'\"),\n                                 sysctl_map[i].sysctl_name);\n            return -1;\n        }\n\n        param = &params[j++];\n        if (virStrcpyStatic(param->field, sysctl_map[i].field) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Field '%s' too long for destination\"),\n                           sysctl_map[i].field);\n            return -1;\n        }\n        param->value = (unsigned long long)value * pagesize;\n    }\n\n    {\n        virNodeMemoryStatsPtr param = &params[j++];\n\n        if (sysctlbyname(\"vfs.bufspace\", &bufpages, &bufpages_size, NULL, 0) < 0) {\n            virReportSystemError(errno,\n                                 _(\"sysctl failed for '%s'\"),\n                                 \"vfs.bufspace\");\n            return -1;\n        }\n        if (virStrcpyStatic(param->field, VIR_NODE_MEMORY_STATS_BUFFERS) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Field '%s' too long for destination\"),\n                           VIR_NODE_MEMORY_STATS_BUFFERS);\n            return -1;\n        }\n        param->value = (unsigned long long)bufpages >> 10;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "# include <windows.h>",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Field '%s' too long for destination\")",
            "VIR_NODE_MEMORY_STATS_BUFFERS"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Field '%s' too long for destination\""
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "param->field",
            "VIR_NODE_MEMORY_STATS_BUFFERS"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"sysctl failed for '%s'\")",
            "\"vfs.bufspace\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctlbyname",
          "args": [
            "\"vfs.bufspace\"",
            "&bufpages",
            "&bufpages_size",
            "NULL",
            "0"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Field '%s' too long for destination\")",
            "sysctl_map[i].field"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "param->field",
            "sysctl_map[i].field"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"sysctl failed for '%s'\")",
            "sysctl_map[i].sysctl_name"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctlbyname",
          "args": [
            "sysctl_map[i].sysctl_name",
            "&value",
            "&value_size",
            "NULL",
            "0"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportInvalidArg",
          "args": [
            "nparams",
            "_(\"nparams in %s must be %d\")",
            "__FUNCTION__",
            "BSD_MEMORY_STATS_ALL"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpagesize",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostMemGetStatsFreeBSD(virNodeMemoryStatsPtr params,\n                          int *nparams)\n{\n    size_t i, j = 0;\n    unsigned long pagesize = getpagesize() >> 10;\n    long bufpages;\n    size_t bufpages_size = sizeof(bufpages);\n    struct field_sysctl_map {\n        const char *field;\n        const char *sysctl_name;\n    } sysctl_map[] = {\n        {VIR_NODE_MEMORY_STATS_TOTAL, \"vm.stats.vm.v_page_count\"},\n        {VIR_NODE_MEMORY_STATS_FREE, \"vm.stats.vm.v_free_count\"},\n        {VIR_NODE_MEMORY_STATS_CACHED, \"vm.stats.vm.v_cache_count\"},\n        {NULL, NULL}\n    };\n\n    if ((*nparams) == 0) {\n        *nparams = BSD_MEMORY_STATS_ALL;\n        return 0;\n    }\n\n    if ((*nparams) != BSD_MEMORY_STATS_ALL) {\n        virReportInvalidArg(nparams,\n                            _(\"nparams in %s must be %d\"),\n                            __FUNCTION__, BSD_MEMORY_STATS_ALL);\n        return -1;\n    }\n\n    for (i = 0; sysctl_map[i].field != NULL; i++) {\n        u_int value;\n        size_t value_size = sizeof(value);\n        virNodeMemoryStatsPtr param;\n\n        if (sysctlbyname(sysctl_map[i].sysctl_name, &value,\n                         &value_size, NULL, 0) < 0) {\n            virReportSystemError(errno,\n                                 _(\"sysctl failed for '%s'\"),\n                                 sysctl_map[i].sysctl_name);\n            return -1;\n        }\n\n        param = &params[j++];\n        if (virStrcpyStatic(param->field, sysctl_map[i].field) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Field '%s' too long for destination\"),\n                           sysctl_map[i].field);\n            return -1;\n        }\n        param->value = (unsigned long long)value * pagesize;\n    }\n\n    {\n        virNodeMemoryStatsPtr param = &params[j++];\n\n        if (sysctlbyname(\"vfs.bufspace\", &bufpages, &bufpages_size, NULL, 0) < 0) {\n            virReportSystemError(errno,\n                                 _(\"sysctl failed for '%s'\"),\n                                 \"vfs.bufspace\");\n            return -1;\n        }\n        if (virStrcpyStatic(param->field, VIR_NODE_MEMORY_STATS_BUFFERS) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Field '%s' too long for destination\"),\n                           VIR_NODE_MEMORY_STATS_BUFFERS);\n            return -1;\n        }\n        param->value = (unsigned long long)bufpages >> 10;\n    }\n\n    return 0;\n}"
  }
]