[
  {
    "function_name": "virTPMSwtpmSetupCapsGet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtpm.c",
    "lines": "357-363",
    "snippet": "bool\nvirTPMSwtpmSetupCapsGet(unsigned int cap)\n{\n    if (virTPMEmulatorInit() < 0)\n        return false;\n    return virBitmapIsBitSet(swtpm_setup_caps, cap);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"virtpm.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virBitmapPtr swtpm_setup_caps;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapIsBitSet",
          "args": [
            "swtpm_setup_caps",
            "cap"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapIsBitSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "298-306",
          "snippet": "bool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTPMEmulatorInit",
          "args": [],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "virTPMEmulatorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtpm.c",
          "lines": "252-347",
          "snippet": "int\nvirTPMEmulatorInit(void)\n{\n    int ret = -1;\n    static const struct {\n        const char *name;\n        char **path;\n        struct stat *stat;\n        const char *parm;\n        virBitmapPtr *caps;\n        TypeFromStringFn typeFromStringFn;\n    } prgs[] = {\n        {\n            .name = \"swtpm\",\n            .path = &swtpm_path,\n            .stat = &swtpm_stat,\n            .parm = \"socket\",\n            .caps = &swtpm_caps,\n            .typeFromStringFn = virTPMSwtpmFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_setup\",\n            .path = &swtpm_setup,\n            .stat = &swtpm_setup_stat,\n            .caps = &swtpm_setup_caps,\n            .typeFromStringFn = virTPMSwtpmSetupFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_ioctl\",\n            .path = &swtpm_ioctl,\n            .stat = &swtpm_ioctl_stat,\n        }\n    };\n    size_t i;\n\n    virMutexLock(&swtpm_tools_lock);\n\n    for (i = 0; i < G_N_ELEMENTS(prgs); i++) {\n        g_autofree char *path = NULL;\n        bool findit = *prgs[i].path == NULL;\n        struct stat statbuf;\n        char *tmp;\n\n        if (!findit) {\n            /* has executables changed? */\n            if (stat(*prgs[i].path, &statbuf) < 0)\n                findit = true;\n\n            if (!findit &&\n                &statbuf.st_mtime != &prgs[i].stat->st_mtime)\n                findit = true;\n        }\n\n        if (findit) {\n            tmp = *prgs[i].path;\n            VIR_FREE(tmp);\n            *prgs[i].path = NULL;\n\n            path = virFindFileInPath(prgs[i].name);\n            if (!path) {\n                virReportSystemError(ENOENT,\n                                _(\"Unable to find '%s' binary in $PATH\"),\n                                prgs[i].name);\n                goto cleanup;\n            }\n            if (!virFileIsExecutable(path)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s is not an executable\"),\n                               path);\n                goto cleanup;\n            }\n            if (stat(path, prgs[i].stat) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Could not stat %s\"), path);\n                goto cleanup;\n            }\n            *prgs[i].path = path;\n\n            if (prgs[i].caps) {\n                *prgs[i].caps = virTPMGetCaps(prgs[i].typeFromStringFn,\n                                              path, prgs[i].parm);\n                path = NULL;\n                if (!*prgs[i].caps)\n                    goto cleanup;\n            }\n            path = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&swtpm_tools_lock);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"virtpm.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virMutex swtpm_tools_lock = VIR_MUTEX_INITIALIZER;",
            "static char *swtpm_path;",
            "static struct stat swtpm_stat;",
            "static virBitmapPtr swtpm_caps;",
            "static char *swtpm_setup;",
            "static struct stat swtpm_setup_stat;",
            "static virBitmapPtr swtpm_setup_caps;",
            "static char *swtpm_ioctl;",
            "static struct stat swtpm_ioctl_stat;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"virtpm.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virMutex swtpm_tools_lock = VIR_MUTEX_INITIALIZER;\nstatic char *swtpm_path;\nstatic struct stat swtpm_stat;\nstatic virBitmapPtr swtpm_caps;\nstatic char *swtpm_setup;\nstatic struct stat swtpm_setup_stat;\nstatic virBitmapPtr swtpm_setup_caps;\nstatic char *swtpm_ioctl;\nstatic struct stat swtpm_ioctl_stat;\n\nint\nvirTPMEmulatorInit(void)\n{\n    int ret = -1;\n    static const struct {\n        const char *name;\n        char **path;\n        struct stat *stat;\n        const char *parm;\n        virBitmapPtr *caps;\n        TypeFromStringFn typeFromStringFn;\n    } prgs[] = {\n        {\n            .name = \"swtpm\",\n            .path = &swtpm_path,\n            .stat = &swtpm_stat,\n            .parm = \"socket\",\n            .caps = &swtpm_caps,\n            .typeFromStringFn = virTPMSwtpmFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_setup\",\n            .path = &swtpm_setup,\n            .stat = &swtpm_setup_stat,\n            .caps = &swtpm_setup_caps,\n            .typeFromStringFn = virTPMSwtpmSetupFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_ioctl\",\n            .path = &swtpm_ioctl,\n            .stat = &swtpm_ioctl_stat,\n        }\n    };\n    size_t i;\n\n    virMutexLock(&swtpm_tools_lock);\n\n    for (i = 0; i < G_N_ELEMENTS(prgs); i++) {\n        g_autofree char *path = NULL;\n        bool findit = *prgs[i].path == NULL;\n        struct stat statbuf;\n        char *tmp;\n\n        if (!findit) {\n            /* has executables changed? */\n            if (stat(*prgs[i].path, &statbuf) < 0)\n                findit = true;\n\n            if (!findit &&\n                &statbuf.st_mtime != &prgs[i].stat->st_mtime)\n                findit = true;\n        }\n\n        if (findit) {\n            tmp = *prgs[i].path;\n            VIR_FREE(tmp);\n            *prgs[i].path = NULL;\n\n            path = virFindFileInPath(prgs[i].name);\n            if (!path) {\n                virReportSystemError(ENOENT,\n                                _(\"Unable to find '%s' binary in $PATH\"),\n                                prgs[i].name);\n                goto cleanup;\n            }\n            if (!virFileIsExecutable(path)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s is not an executable\"),\n                               path);\n                goto cleanup;\n            }\n            if (stat(path, prgs[i].stat) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Could not stat %s\"), path);\n                goto cleanup;\n            }\n            *prgs[i].path = path;\n\n            if (prgs[i].caps) {\n                *prgs[i].caps = virTPMGetCaps(prgs[i].typeFromStringFn,\n                                              path, prgs[i].parm);\n                path = NULL;\n                if (!*prgs[i].caps)\n                    goto cleanup;\n            }\n            path = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&swtpm_tools_lock);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"virtpm.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virBitmapPtr swtpm_setup_caps;\n\nbool\nvirTPMSwtpmSetupCapsGet(unsigned int cap)\n{\n    if (virTPMEmulatorInit() < 0)\n        return false;\n    return virBitmapIsBitSet(swtpm_setup_caps, cap);\n}"
  },
  {
    "function_name": "virTPMSwtpmCapsGet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtpm.c",
    "lines": "349-355",
    "snippet": "bool\nvirTPMSwtpmCapsGet(unsigned int cap)\n{\n    if (virTPMEmulatorInit() < 0)\n        return false;\n    return virBitmapIsBitSet(swtpm_caps, cap);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"virtpm.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virBitmapPtr swtpm_caps;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapIsBitSet",
          "args": [
            "swtpm_caps",
            "cap"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapIsBitSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "298-306",
          "snippet": "bool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTPMEmulatorInit",
          "args": [],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "virTPMEmulatorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtpm.c",
          "lines": "252-347",
          "snippet": "int\nvirTPMEmulatorInit(void)\n{\n    int ret = -1;\n    static const struct {\n        const char *name;\n        char **path;\n        struct stat *stat;\n        const char *parm;\n        virBitmapPtr *caps;\n        TypeFromStringFn typeFromStringFn;\n    } prgs[] = {\n        {\n            .name = \"swtpm\",\n            .path = &swtpm_path,\n            .stat = &swtpm_stat,\n            .parm = \"socket\",\n            .caps = &swtpm_caps,\n            .typeFromStringFn = virTPMSwtpmFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_setup\",\n            .path = &swtpm_setup,\n            .stat = &swtpm_setup_stat,\n            .caps = &swtpm_setup_caps,\n            .typeFromStringFn = virTPMSwtpmSetupFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_ioctl\",\n            .path = &swtpm_ioctl,\n            .stat = &swtpm_ioctl_stat,\n        }\n    };\n    size_t i;\n\n    virMutexLock(&swtpm_tools_lock);\n\n    for (i = 0; i < G_N_ELEMENTS(prgs); i++) {\n        g_autofree char *path = NULL;\n        bool findit = *prgs[i].path == NULL;\n        struct stat statbuf;\n        char *tmp;\n\n        if (!findit) {\n            /* has executables changed? */\n            if (stat(*prgs[i].path, &statbuf) < 0)\n                findit = true;\n\n            if (!findit &&\n                &statbuf.st_mtime != &prgs[i].stat->st_mtime)\n                findit = true;\n        }\n\n        if (findit) {\n            tmp = *prgs[i].path;\n            VIR_FREE(tmp);\n            *prgs[i].path = NULL;\n\n            path = virFindFileInPath(prgs[i].name);\n            if (!path) {\n                virReportSystemError(ENOENT,\n                                _(\"Unable to find '%s' binary in $PATH\"),\n                                prgs[i].name);\n                goto cleanup;\n            }\n            if (!virFileIsExecutable(path)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s is not an executable\"),\n                               path);\n                goto cleanup;\n            }\n            if (stat(path, prgs[i].stat) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Could not stat %s\"), path);\n                goto cleanup;\n            }\n            *prgs[i].path = path;\n\n            if (prgs[i].caps) {\n                *prgs[i].caps = virTPMGetCaps(prgs[i].typeFromStringFn,\n                                              path, prgs[i].parm);\n                path = NULL;\n                if (!*prgs[i].caps)\n                    goto cleanup;\n            }\n            path = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&swtpm_tools_lock);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"virtpm.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virMutex swtpm_tools_lock = VIR_MUTEX_INITIALIZER;",
            "static char *swtpm_path;",
            "static struct stat swtpm_stat;",
            "static virBitmapPtr swtpm_caps;",
            "static char *swtpm_setup;",
            "static struct stat swtpm_setup_stat;",
            "static virBitmapPtr swtpm_setup_caps;",
            "static char *swtpm_ioctl;",
            "static struct stat swtpm_ioctl_stat;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"virtpm.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virMutex swtpm_tools_lock = VIR_MUTEX_INITIALIZER;\nstatic char *swtpm_path;\nstatic struct stat swtpm_stat;\nstatic virBitmapPtr swtpm_caps;\nstatic char *swtpm_setup;\nstatic struct stat swtpm_setup_stat;\nstatic virBitmapPtr swtpm_setup_caps;\nstatic char *swtpm_ioctl;\nstatic struct stat swtpm_ioctl_stat;\n\nint\nvirTPMEmulatorInit(void)\n{\n    int ret = -1;\n    static const struct {\n        const char *name;\n        char **path;\n        struct stat *stat;\n        const char *parm;\n        virBitmapPtr *caps;\n        TypeFromStringFn typeFromStringFn;\n    } prgs[] = {\n        {\n            .name = \"swtpm\",\n            .path = &swtpm_path,\n            .stat = &swtpm_stat,\n            .parm = \"socket\",\n            .caps = &swtpm_caps,\n            .typeFromStringFn = virTPMSwtpmFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_setup\",\n            .path = &swtpm_setup,\n            .stat = &swtpm_setup_stat,\n            .caps = &swtpm_setup_caps,\n            .typeFromStringFn = virTPMSwtpmSetupFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_ioctl\",\n            .path = &swtpm_ioctl,\n            .stat = &swtpm_ioctl_stat,\n        }\n    };\n    size_t i;\n\n    virMutexLock(&swtpm_tools_lock);\n\n    for (i = 0; i < G_N_ELEMENTS(prgs); i++) {\n        g_autofree char *path = NULL;\n        bool findit = *prgs[i].path == NULL;\n        struct stat statbuf;\n        char *tmp;\n\n        if (!findit) {\n            /* has executables changed? */\n            if (stat(*prgs[i].path, &statbuf) < 0)\n                findit = true;\n\n            if (!findit &&\n                &statbuf.st_mtime != &prgs[i].stat->st_mtime)\n                findit = true;\n        }\n\n        if (findit) {\n            tmp = *prgs[i].path;\n            VIR_FREE(tmp);\n            *prgs[i].path = NULL;\n\n            path = virFindFileInPath(prgs[i].name);\n            if (!path) {\n                virReportSystemError(ENOENT,\n                                _(\"Unable to find '%s' binary in $PATH\"),\n                                prgs[i].name);\n                goto cleanup;\n            }\n            if (!virFileIsExecutable(path)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s is not an executable\"),\n                               path);\n                goto cleanup;\n            }\n            if (stat(path, prgs[i].stat) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Could not stat %s\"), path);\n                goto cleanup;\n            }\n            *prgs[i].path = path;\n\n            if (prgs[i].caps) {\n                *prgs[i].caps = virTPMGetCaps(prgs[i].typeFromStringFn,\n                                              path, prgs[i].parm);\n                path = NULL;\n                if (!*prgs[i].caps)\n                    goto cleanup;\n            }\n            path = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&swtpm_tools_lock);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"virtpm.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virBitmapPtr swtpm_caps;\n\nbool\nvirTPMSwtpmCapsGet(unsigned int cap)\n{\n    if (virTPMEmulatorInit() < 0)\n        return false;\n    return virBitmapIsBitSet(swtpm_caps, cap);\n}"
  },
  {
    "function_name": "virTPMEmulatorInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtpm.c",
    "lines": "252-347",
    "snippet": "int\nvirTPMEmulatorInit(void)\n{\n    int ret = -1;\n    static const struct {\n        const char *name;\n        char **path;\n        struct stat *stat;\n        const char *parm;\n        virBitmapPtr *caps;\n        TypeFromStringFn typeFromStringFn;\n    } prgs[] = {\n        {\n            .name = \"swtpm\",\n            .path = &swtpm_path,\n            .stat = &swtpm_stat,\n            .parm = \"socket\",\n            .caps = &swtpm_caps,\n            .typeFromStringFn = virTPMSwtpmFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_setup\",\n            .path = &swtpm_setup,\n            .stat = &swtpm_setup_stat,\n            .caps = &swtpm_setup_caps,\n            .typeFromStringFn = virTPMSwtpmSetupFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_ioctl\",\n            .path = &swtpm_ioctl,\n            .stat = &swtpm_ioctl_stat,\n        }\n    };\n    size_t i;\n\n    virMutexLock(&swtpm_tools_lock);\n\n    for (i = 0; i < G_N_ELEMENTS(prgs); i++) {\n        g_autofree char *path = NULL;\n        bool findit = *prgs[i].path == NULL;\n        struct stat statbuf;\n        char *tmp;\n\n        if (!findit) {\n            /* has executables changed? */\n            if (stat(*prgs[i].path, &statbuf) < 0)\n                findit = true;\n\n            if (!findit &&\n                &statbuf.st_mtime != &prgs[i].stat->st_mtime)\n                findit = true;\n        }\n\n        if (findit) {\n            tmp = *prgs[i].path;\n            VIR_FREE(tmp);\n            *prgs[i].path = NULL;\n\n            path = virFindFileInPath(prgs[i].name);\n            if (!path) {\n                virReportSystemError(ENOENT,\n                                _(\"Unable to find '%s' binary in $PATH\"),\n                                prgs[i].name);\n                goto cleanup;\n            }\n            if (!virFileIsExecutable(path)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s is not an executable\"),\n                               path);\n                goto cleanup;\n            }\n            if (stat(path, prgs[i].stat) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Could not stat %s\"), path);\n                goto cleanup;\n            }\n            *prgs[i].path = path;\n\n            if (prgs[i].caps) {\n                *prgs[i].caps = virTPMGetCaps(prgs[i].typeFromStringFn,\n                                              path, prgs[i].parm);\n                path = NULL;\n                if (!*prgs[i].caps)\n                    goto cleanup;\n            }\n            path = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&swtpm_tools_lock);\n\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"virtpm.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virMutex swtpm_tools_lock = VIR_MUTEX_INITIALIZER;",
      "static char *swtpm_path;",
      "static struct stat swtpm_stat;",
      "static virBitmapPtr swtpm_caps;",
      "static char *swtpm_setup;",
      "static struct stat swtpm_setup_stat;",
      "static virBitmapPtr swtpm_setup_caps;",
      "static char *swtpm_ioctl;",
      "static struct stat swtpm_ioctl_stat;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&swtpm_tools_lock"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTPMGetCaps",
          "args": [
            "prgs[i].typeFromStringFn",
            "path",
            "prgs[i].parm"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "virTPMGetCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtpm.c",
          "lines": "229-244",
          "snippet": "static virBitmapPtr\nvirTPMGetCaps(TypeFromStringFn typeFromStringFn,\n                  const char *exec, const char *param1)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (!(cmd = virCommandNew(exec)))\n        return NULL;\n\n    if (param1)\n        virCommandAddArg(cmd, param1);\n    virCommandAddArg(cmd, \"--print-capabilities\");\n    virCommandClearCaps(cmd);\n\n    return virTPMExecGetCaps(cmd, typeFromStringFn);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"virtpm.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"virtpm.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virBitmapPtr\nvirTPMGetCaps(TypeFromStringFn typeFromStringFn,\n                  const char *exec, const char *param1)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (!(cmd = virCommandNew(exec)))\n        return NULL;\n\n    if (param1)\n        virCommandAddArg(cmd, param1);\n    virCommandAddArg(cmd, \"--print-capabilities\");\n    virCommandClearCaps(cmd);\n\n    return virTPMExecGetCaps(cmd, typeFromStringFn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Could not stat %s\")",
            "path"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not stat %s\""
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "prgs[i].stat"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "profile_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_apparmor.c",
          "lines": "70-108",
          "snippet": "static int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}",
          "includes": [
            "#include \"virmdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viruuid.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"internal.h\"",
            "#include <wait.h>",
            "#include <unistd.h>",
            "#include <sys/apparmor.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virmdev.h\"\n#include \"virscsi.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virscsivhost.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viruuid.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"security_apparmor.h\"\n#include \"internal.h\"\n#include <wait.h>\n#include <unistd.h>\n#include <sys/apparmor.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"%s is not an executable\")",
            "path"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileIsExecutable",
          "args": [
            "path"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "virFileIsExecutable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1886-1899",
          "snippet": "bool\nvirFileIsExecutable(const char *file)\n{\n    struct stat sb;\n\n    /* We would also want to check faccessat if we cared about ACLs,\n     * but we don't.  */\n    if (stat(file, &sb) < 0)\n        return false;\n    if (S_ISREG(sb.st_mode) && (sb.st_mode & 0111) != 0)\n        return true;\n    errno = S_ISDIR(sb.st_mode) ? EISDIR : EACCES;\n    return false;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileIsExecutable(const char *file)\n{\n    struct stat sb;\n\n    /* We would also want to check faccessat if we cared about ACLs,\n     * but we don't.  */\n    if (stat(file, &sb) < 0)\n        return false;\n    if (S_ISREG(sb.st_mode) && (sb.st_mode & 0111) != 0)\n        return true;\n    errno = S_ISDIR(sb.st_mode) ? EISDIR : EACCES;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOENT",
            "_(\"Unable to find '%s' binary in $PATH\")",
            "prgs[i].name"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFindFileInPath",
          "args": [
            "prgs[i].name"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "virFindFileInPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1657-1709",
          "snippet": "char *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "prgs"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&swtpm_tools_lock"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"virtpm.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virMutex swtpm_tools_lock = VIR_MUTEX_INITIALIZER;\nstatic char *swtpm_path;\nstatic struct stat swtpm_stat;\nstatic virBitmapPtr swtpm_caps;\nstatic char *swtpm_setup;\nstatic struct stat swtpm_setup_stat;\nstatic virBitmapPtr swtpm_setup_caps;\nstatic char *swtpm_ioctl;\nstatic struct stat swtpm_ioctl_stat;\n\nint\nvirTPMEmulatorInit(void)\n{\n    int ret = -1;\n    static const struct {\n        const char *name;\n        char **path;\n        struct stat *stat;\n        const char *parm;\n        virBitmapPtr *caps;\n        TypeFromStringFn typeFromStringFn;\n    } prgs[] = {\n        {\n            .name = \"swtpm\",\n            .path = &swtpm_path,\n            .stat = &swtpm_stat,\n            .parm = \"socket\",\n            .caps = &swtpm_caps,\n            .typeFromStringFn = virTPMSwtpmFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_setup\",\n            .path = &swtpm_setup,\n            .stat = &swtpm_setup_stat,\n            .caps = &swtpm_setup_caps,\n            .typeFromStringFn = virTPMSwtpmSetupFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_ioctl\",\n            .path = &swtpm_ioctl,\n            .stat = &swtpm_ioctl_stat,\n        }\n    };\n    size_t i;\n\n    virMutexLock(&swtpm_tools_lock);\n\n    for (i = 0; i < G_N_ELEMENTS(prgs); i++) {\n        g_autofree char *path = NULL;\n        bool findit = *prgs[i].path == NULL;\n        struct stat statbuf;\n        char *tmp;\n\n        if (!findit) {\n            /* has executables changed? */\n            if (stat(*prgs[i].path, &statbuf) < 0)\n                findit = true;\n\n            if (!findit &&\n                &statbuf.st_mtime != &prgs[i].stat->st_mtime)\n                findit = true;\n        }\n\n        if (findit) {\n            tmp = *prgs[i].path;\n            VIR_FREE(tmp);\n            *prgs[i].path = NULL;\n\n            path = virFindFileInPath(prgs[i].name);\n            if (!path) {\n                virReportSystemError(ENOENT,\n                                _(\"Unable to find '%s' binary in $PATH\"),\n                                prgs[i].name);\n                goto cleanup;\n            }\n            if (!virFileIsExecutable(path)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s is not an executable\"),\n                               path);\n                goto cleanup;\n            }\n            if (stat(path, prgs[i].stat) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Could not stat %s\"), path);\n                goto cleanup;\n            }\n            *prgs[i].path = path;\n\n            if (prgs[i].caps) {\n                *prgs[i].caps = virTPMGetCaps(prgs[i].typeFromStringFn,\n                                              path, prgs[i].parm);\n                path = NULL;\n                if (!*prgs[i].caps)\n                    goto cleanup;\n            }\n            path = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&swtpm_tools_lock);\n\n    return ret;\n}"
  },
  {
    "function_name": "virTPMGetCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtpm.c",
    "lines": "229-244",
    "snippet": "static virBitmapPtr\nvirTPMGetCaps(TypeFromStringFn typeFromStringFn,\n                  const char *exec, const char *param1)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (!(cmd = virCommandNew(exec)))\n        return NULL;\n\n    if (param1)\n        virCommandAddArg(cmd, param1);\n    virCommandAddArg(cmd, \"--print-capabilities\");\n    virCommandClearCaps(cmd);\n\n    return virTPMExecGetCaps(cmd, typeFromStringFn);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"virtpm.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virTPMExecGetCaps",
          "args": [
            "cmd",
            "typeFromStringFn"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "virTPMExecGetCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtpm.c",
          "lines": "168-227",
          "snippet": "static virBitmapPtr\nvirTPMExecGetCaps(virCommandPtr cmd,\n                  TypeFromStringFn typeFromStringFn)\n{\n    int exitstatus;\n    virBitmapPtr bitmap;\n    g_autofree char *outbuf = NULL;\n    g_autoptr(virJSONValue) json = NULL;\n    virJSONValuePtr featureList;\n    virJSONValuePtr item;\n    size_t idx;\n    const char *str;\n    int typ;\n\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, &exitstatus) < 0)\n        return NULL;\n\n    bitmap = virBitmapNewEmpty();\n\n    /* older version does not support --print-capabilties -- that's fine */\n    if (exitstatus != 0) {\n        VIR_DEBUG(\"Found swtpm that doesn't support --print-capabilities\");\n        return bitmap;\n    }\n\n    json = virJSONValueFromString(outbuf);\n    if (!json)\n        goto error_bad_json;\n\n    featureList = virJSONValueObjectGetArray(json, \"features\");\n    if (!featureList)\n        goto error_bad_json;\n\n    if (!virJSONValueIsArray(featureList))\n        goto error_bad_json;\n\n    for (idx = 0; idx < virJSONValueArraySize(featureList); idx++) {\n        item = virJSONValueArrayGet(featureList, idx);\n        if (!item)\n            continue;\n\n        str = virJSONValueGetString(item);\n        if (!str)\n            goto error_bad_json;\n        typ = typeFromStringFn(str);\n        if (typ < 0)\n            continue;\n\n        if (virBitmapSetBitExpand(bitmap, typ) < 0)\n            return bitmap;\n    }\n\n    return bitmap;\n\n error_bad_json:\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Unexpected JSON format: %s\"), outbuf);\n    return bitmap;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"virtpm.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"virtpm.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virBitmapPtr\nvirTPMExecGetCaps(virCommandPtr cmd,\n                  TypeFromStringFn typeFromStringFn)\n{\n    int exitstatus;\n    virBitmapPtr bitmap;\n    g_autofree char *outbuf = NULL;\n    g_autoptr(virJSONValue) json = NULL;\n    virJSONValuePtr featureList;\n    virJSONValuePtr item;\n    size_t idx;\n    const char *str;\n    int typ;\n\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, &exitstatus) < 0)\n        return NULL;\n\n    bitmap = virBitmapNewEmpty();\n\n    /* older version does not support --print-capabilties -- that's fine */\n    if (exitstatus != 0) {\n        VIR_DEBUG(\"Found swtpm that doesn't support --print-capabilities\");\n        return bitmap;\n    }\n\n    json = virJSONValueFromString(outbuf);\n    if (!json)\n        goto error_bad_json;\n\n    featureList = virJSONValueObjectGetArray(json, \"features\");\n    if (!featureList)\n        goto error_bad_json;\n\n    if (!virJSONValueIsArray(featureList))\n        goto error_bad_json;\n\n    for (idx = 0; idx < virJSONValueArraySize(featureList); idx++) {\n        item = virJSONValueArrayGet(featureList, idx);\n        if (!item)\n            continue;\n\n        str = virJSONValueGetString(item);\n        if (!str)\n            goto error_bad_json;\n        typ = typeFromStringFn(str);\n        if (typ < 0)\n            continue;\n\n        if (virBitmapSetBitExpand(bitmap, typ) < 0)\n            return bitmap;\n    }\n\n    return bitmap;\n\n error_bad_json:\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Unexpected JSON format: %s\"), outbuf);\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandClearCaps",
          "args": [
            "cmd"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandClearCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1179-1186",
          "snippet": "void\nvirCommandClearCaps(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_CLEAR_CAPS;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandClearCaps(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_CLEAR_CAPS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "\"--print-capabilities\""
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "exec"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"virtpm.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virBitmapPtr\nvirTPMGetCaps(TypeFromStringFn typeFromStringFn,\n                  const char *exec, const char *param1)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (!(cmd = virCommandNew(exec)))\n        return NULL;\n\n    if (param1)\n        virCommandAddArg(cmd, param1);\n    virCommandAddArg(cmd, \"--print-capabilities\");\n    virCommandClearCaps(cmd);\n\n    return virTPMExecGetCaps(cmd, typeFromStringFn);\n}"
  },
  {
    "function_name": "virTPMExecGetCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtpm.c",
    "lines": "168-227",
    "snippet": "static virBitmapPtr\nvirTPMExecGetCaps(virCommandPtr cmd,\n                  TypeFromStringFn typeFromStringFn)\n{\n    int exitstatus;\n    virBitmapPtr bitmap;\n    g_autofree char *outbuf = NULL;\n    g_autoptr(virJSONValue) json = NULL;\n    virJSONValuePtr featureList;\n    virJSONValuePtr item;\n    size_t idx;\n    const char *str;\n    int typ;\n\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, &exitstatus) < 0)\n        return NULL;\n\n    bitmap = virBitmapNewEmpty();\n\n    /* older version does not support --print-capabilties -- that's fine */\n    if (exitstatus != 0) {\n        VIR_DEBUG(\"Found swtpm that doesn't support --print-capabilities\");\n        return bitmap;\n    }\n\n    json = virJSONValueFromString(outbuf);\n    if (!json)\n        goto error_bad_json;\n\n    featureList = virJSONValueObjectGetArray(json, \"features\");\n    if (!featureList)\n        goto error_bad_json;\n\n    if (!virJSONValueIsArray(featureList))\n        goto error_bad_json;\n\n    for (idx = 0; idx < virJSONValueArraySize(featureList); idx++) {\n        item = virJSONValueArrayGet(featureList, idx);\n        if (!item)\n            continue;\n\n        str = virJSONValueGetString(item);\n        if (!str)\n            goto error_bad_json;\n        typ = typeFromStringFn(str);\n        if (typ < 0)\n            continue;\n\n        if (virBitmapSetBitExpand(bitmap, typ) < 0)\n            return bitmap;\n    }\n\n    return bitmap;\n\n error_bad_json:\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Unexpected JSON format: %s\"), outbuf);\n    return bitmap;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"virtpm.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unexpected JSON format: %s\")",
            "outbuf"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unexpected JSON format: %s\""
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapSetBitExpand",
          "args": [
            "bitmap",
            "typ"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "typeFromStringFn",
          "args": [
            "str"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueGetString",
          "args": [
            "item"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueGetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1115-1122",
          "snippet": "const char *\nvirJSONValueGetString(virJSONValuePtr string)\n{\n    if (string->type != VIR_JSON_TYPE_STRING)\n        return NULL;\n\n    return string->data.string;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueGetString(virJSONValuePtr string)\n{\n    if (string->type != VIR_JSON_TYPE_STRING)\n        return NULL;\n\n    return string->data.string;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayGet",
          "args": [
            "featureList",
            "idx"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1024-1035",
          "snippet": "virJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArraySize",
          "args": [
            "featureList"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArraySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1017-1021",
          "snippet": "size_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nsize_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueIsArray",
          "args": [
            "featureList"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueIsArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1010-1014",
          "snippet": "bool\nvirJSONValueIsArray(virJSONValuePtr array)\n{\n    return array->type == VIR_JSON_TYPE_ARRAY;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nbool\nvirJSONValueIsArray(virJSONValuePtr array)\n{\n    return array->type == VIR_JSON_TYPE_ARRAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetArray",
          "args": [
            "json",
            "\"features\""
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1422-1426",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueFromString",
          "args": [
            "outbuf"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFromString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1993-1999",
          "snippet": "virJSONValuePtr\nvirJSONValueFromString(const char *jsonstring G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"No JSON parser implementation is available\"));\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueFromString(const char *jsonstring G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"No JSON parser implementation is available\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Found swtpm that doesn't support --print-capabilities\""
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapNewEmpty",
          "args": [],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "115-119",
          "snippet": "virBitmapPtr\nvirBitmapNewEmpty(void)\n{\n    return g_new0(virBitmap, 1);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewEmpty(void)\n{\n    return g_new0(virBitmap, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "&exitstatus"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputBuffer",
          "args": [
            "cmd",
            "&outbuf"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1869-1884",
          "snippet": "void\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"virtpm.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virBitmapPtr\nvirTPMExecGetCaps(virCommandPtr cmd,\n                  TypeFromStringFn typeFromStringFn)\n{\n    int exitstatus;\n    virBitmapPtr bitmap;\n    g_autofree char *outbuf = NULL;\n    g_autoptr(virJSONValue) json = NULL;\n    virJSONValuePtr featureList;\n    virJSONValuePtr item;\n    size_t idx;\n    const char *str;\n    int typ;\n\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, &exitstatus) < 0)\n        return NULL;\n\n    bitmap = virBitmapNewEmpty();\n\n    /* older version does not support --print-capabilties -- that's fine */\n    if (exitstatus != 0) {\n        VIR_DEBUG(\"Found swtpm that doesn't support --print-capabilities\");\n        return bitmap;\n    }\n\n    json = virJSONValueFromString(outbuf);\n    if (!json)\n        goto error_bad_json;\n\n    featureList = virJSONValueObjectGetArray(json, \"features\");\n    if (!featureList)\n        goto error_bad_json;\n\n    if (!virJSONValueIsArray(featureList))\n        goto error_bad_json;\n\n    for (idx = 0; idx < virJSONValueArraySize(featureList); idx++) {\n        item = virJSONValueArrayGet(featureList, idx);\n        if (!item)\n            continue;\n\n        str = virJSONValueGetString(item);\n        if (!str)\n            goto error_bad_json;\n        typ = typeFromStringFn(str);\n        if (typ < 0)\n            continue;\n\n        if (virBitmapSetBitExpand(bitmap, typ) < 0)\n            return bitmap;\n    }\n\n    return bitmap;\n\n error_bad_json:\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Unexpected JSON format: %s\"), outbuf);\n    return bitmap;\n}"
  },
  {
    "function_name": "virTPMGetSwtpmIoctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtpm.c",
    "lines": "138-151",
    "snippet": "char *\nvirTPMGetSwtpmIoctl(void)\n{\n    char *s;\n\n    if (!swtpm_ioctl && virTPMEmulatorInit() < 0)\n        return NULL;\n\n    virMutexLock(&swtpm_tools_lock);\n    s = g_strdup(swtpm_ioctl);\n    virMutexUnlock(&swtpm_tools_lock);\n\n    return s;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"virtpm.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virMutex swtpm_tools_lock = VIR_MUTEX_INITIALIZER;",
      "static char *swtpm_ioctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&swtpm_tools_lock"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "swtpm_ioctl"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&swtpm_tools_lock"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTPMEmulatorInit",
          "args": [],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "virTPMEmulatorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtpm.c",
          "lines": "252-347",
          "snippet": "int\nvirTPMEmulatorInit(void)\n{\n    int ret = -1;\n    static const struct {\n        const char *name;\n        char **path;\n        struct stat *stat;\n        const char *parm;\n        virBitmapPtr *caps;\n        TypeFromStringFn typeFromStringFn;\n    } prgs[] = {\n        {\n            .name = \"swtpm\",\n            .path = &swtpm_path,\n            .stat = &swtpm_stat,\n            .parm = \"socket\",\n            .caps = &swtpm_caps,\n            .typeFromStringFn = virTPMSwtpmFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_setup\",\n            .path = &swtpm_setup,\n            .stat = &swtpm_setup_stat,\n            .caps = &swtpm_setup_caps,\n            .typeFromStringFn = virTPMSwtpmSetupFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_ioctl\",\n            .path = &swtpm_ioctl,\n            .stat = &swtpm_ioctl_stat,\n        }\n    };\n    size_t i;\n\n    virMutexLock(&swtpm_tools_lock);\n\n    for (i = 0; i < G_N_ELEMENTS(prgs); i++) {\n        g_autofree char *path = NULL;\n        bool findit = *prgs[i].path == NULL;\n        struct stat statbuf;\n        char *tmp;\n\n        if (!findit) {\n            /* has executables changed? */\n            if (stat(*prgs[i].path, &statbuf) < 0)\n                findit = true;\n\n            if (!findit &&\n                &statbuf.st_mtime != &prgs[i].stat->st_mtime)\n                findit = true;\n        }\n\n        if (findit) {\n            tmp = *prgs[i].path;\n            VIR_FREE(tmp);\n            *prgs[i].path = NULL;\n\n            path = virFindFileInPath(prgs[i].name);\n            if (!path) {\n                virReportSystemError(ENOENT,\n                                _(\"Unable to find '%s' binary in $PATH\"),\n                                prgs[i].name);\n                goto cleanup;\n            }\n            if (!virFileIsExecutable(path)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s is not an executable\"),\n                               path);\n                goto cleanup;\n            }\n            if (stat(path, prgs[i].stat) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Could not stat %s\"), path);\n                goto cleanup;\n            }\n            *prgs[i].path = path;\n\n            if (prgs[i].caps) {\n                *prgs[i].caps = virTPMGetCaps(prgs[i].typeFromStringFn,\n                                              path, prgs[i].parm);\n                path = NULL;\n                if (!*prgs[i].caps)\n                    goto cleanup;\n            }\n            path = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&swtpm_tools_lock);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"virtpm.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virMutex swtpm_tools_lock = VIR_MUTEX_INITIALIZER;",
            "static char *swtpm_path;",
            "static struct stat swtpm_stat;",
            "static virBitmapPtr swtpm_caps;",
            "static char *swtpm_setup;",
            "static struct stat swtpm_setup_stat;",
            "static virBitmapPtr swtpm_setup_caps;",
            "static char *swtpm_ioctl;",
            "static struct stat swtpm_ioctl_stat;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"virtpm.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virMutex swtpm_tools_lock = VIR_MUTEX_INITIALIZER;\nstatic char *swtpm_path;\nstatic struct stat swtpm_stat;\nstatic virBitmapPtr swtpm_caps;\nstatic char *swtpm_setup;\nstatic struct stat swtpm_setup_stat;\nstatic virBitmapPtr swtpm_setup_caps;\nstatic char *swtpm_ioctl;\nstatic struct stat swtpm_ioctl_stat;\n\nint\nvirTPMEmulatorInit(void)\n{\n    int ret = -1;\n    static const struct {\n        const char *name;\n        char **path;\n        struct stat *stat;\n        const char *parm;\n        virBitmapPtr *caps;\n        TypeFromStringFn typeFromStringFn;\n    } prgs[] = {\n        {\n            .name = \"swtpm\",\n            .path = &swtpm_path,\n            .stat = &swtpm_stat,\n            .parm = \"socket\",\n            .caps = &swtpm_caps,\n            .typeFromStringFn = virTPMSwtpmFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_setup\",\n            .path = &swtpm_setup,\n            .stat = &swtpm_setup_stat,\n            .caps = &swtpm_setup_caps,\n            .typeFromStringFn = virTPMSwtpmSetupFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_ioctl\",\n            .path = &swtpm_ioctl,\n            .stat = &swtpm_ioctl_stat,\n        }\n    };\n    size_t i;\n\n    virMutexLock(&swtpm_tools_lock);\n\n    for (i = 0; i < G_N_ELEMENTS(prgs); i++) {\n        g_autofree char *path = NULL;\n        bool findit = *prgs[i].path == NULL;\n        struct stat statbuf;\n        char *tmp;\n\n        if (!findit) {\n            /* has executables changed? */\n            if (stat(*prgs[i].path, &statbuf) < 0)\n                findit = true;\n\n            if (!findit &&\n                &statbuf.st_mtime != &prgs[i].stat->st_mtime)\n                findit = true;\n        }\n\n        if (findit) {\n            tmp = *prgs[i].path;\n            VIR_FREE(tmp);\n            *prgs[i].path = NULL;\n\n            path = virFindFileInPath(prgs[i].name);\n            if (!path) {\n                virReportSystemError(ENOENT,\n                                _(\"Unable to find '%s' binary in $PATH\"),\n                                prgs[i].name);\n                goto cleanup;\n            }\n            if (!virFileIsExecutable(path)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s is not an executable\"),\n                               path);\n                goto cleanup;\n            }\n            if (stat(path, prgs[i].stat) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Could not stat %s\"), path);\n                goto cleanup;\n            }\n            *prgs[i].path = path;\n\n            if (prgs[i].caps) {\n                *prgs[i].caps = virTPMGetCaps(prgs[i].typeFromStringFn,\n                                              path, prgs[i].parm);\n                path = NULL;\n                if (!*prgs[i].caps)\n                    goto cleanup;\n            }\n            path = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&swtpm_tools_lock);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"virtpm.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virMutex swtpm_tools_lock = VIR_MUTEX_INITIALIZER;\nstatic char *swtpm_ioctl;\n\nchar *\nvirTPMGetSwtpmIoctl(void)\n{\n    char *s;\n\n    if (!swtpm_ioctl && virTPMEmulatorInit() < 0)\n        return NULL;\n\n    virMutexLock(&swtpm_tools_lock);\n    s = g_strdup(swtpm_ioctl);\n    virMutexUnlock(&swtpm_tools_lock);\n\n    return s;\n}"
  },
  {
    "function_name": "virTPMGetSwtpmSetup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtpm.c",
    "lines": "123-136",
    "snippet": "char *\nvirTPMGetSwtpmSetup(void)\n{\n    char *s;\n\n    if (!swtpm_setup && virTPMEmulatorInit() < 0)\n        return NULL;\n\n    virMutexLock(&swtpm_tools_lock);\n    s = g_strdup(swtpm_setup);\n    virMutexUnlock(&swtpm_tools_lock);\n\n    return s;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"virtpm.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virMutex swtpm_tools_lock = VIR_MUTEX_INITIALIZER;",
      "static char *swtpm_setup;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&swtpm_tools_lock"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "swtpm_setup"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&swtpm_tools_lock"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTPMEmulatorInit",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "virTPMEmulatorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtpm.c",
          "lines": "252-347",
          "snippet": "int\nvirTPMEmulatorInit(void)\n{\n    int ret = -1;\n    static const struct {\n        const char *name;\n        char **path;\n        struct stat *stat;\n        const char *parm;\n        virBitmapPtr *caps;\n        TypeFromStringFn typeFromStringFn;\n    } prgs[] = {\n        {\n            .name = \"swtpm\",\n            .path = &swtpm_path,\n            .stat = &swtpm_stat,\n            .parm = \"socket\",\n            .caps = &swtpm_caps,\n            .typeFromStringFn = virTPMSwtpmFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_setup\",\n            .path = &swtpm_setup,\n            .stat = &swtpm_setup_stat,\n            .caps = &swtpm_setup_caps,\n            .typeFromStringFn = virTPMSwtpmSetupFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_ioctl\",\n            .path = &swtpm_ioctl,\n            .stat = &swtpm_ioctl_stat,\n        }\n    };\n    size_t i;\n\n    virMutexLock(&swtpm_tools_lock);\n\n    for (i = 0; i < G_N_ELEMENTS(prgs); i++) {\n        g_autofree char *path = NULL;\n        bool findit = *prgs[i].path == NULL;\n        struct stat statbuf;\n        char *tmp;\n\n        if (!findit) {\n            /* has executables changed? */\n            if (stat(*prgs[i].path, &statbuf) < 0)\n                findit = true;\n\n            if (!findit &&\n                &statbuf.st_mtime != &prgs[i].stat->st_mtime)\n                findit = true;\n        }\n\n        if (findit) {\n            tmp = *prgs[i].path;\n            VIR_FREE(tmp);\n            *prgs[i].path = NULL;\n\n            path = virFindFileInPath(prgs[i].name);\n            if (!path) {\n                virReportSystemError(ENOENT,\n                                _(\"Unable to find '%s' binary in $PATH\"),\n                                prgs[i].name);\n                goto cleanup;\n            }\n            if (!virFileIsExecutable(path)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s is not an executable\"),\n                               path);\n                goto cleanup;\n            }\n            if (stat(path, prgs[i].stat) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Could not stat %s\"), path);\n                goto cleanup;\n            }\n            *prgs[i].path = path;\n\n            if (prgs[i].caps) {\n                *prgs[i].caps = virTPMGetCaps(prgs[i].typeFromStringFn,\n                                              path, prgs[i].parm);\n                path = NULL;\n                if (!*prgs[i].caps)\n                    goto cleanup;\n            }\n            path = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&swtpm_tools_lock);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"virtpm.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virMutex swtpm_tools_lock = VIR_MUTEX_INITIALIZER;",
            "static char *swtpm_path;",
            "static struct stat swtpm_stat;",
            "static virBitmapPtr swtpm_caps;",
            "static char *swtpm_setup;",
            "static struct stat swtpm_setup_stat;",
            "static virBitmapPtr swtpm_setup_caps;",
            "static char *swtpm_ioctl;",
            "static struct stat swtpm_ioctl_stat;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"virtpm.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virMutex swtpm_tools_lock = VIR_MUTEX_INITIALIZER;\nstatic char *swtpm_path;\nstatic struct stat swtpm_stat;\nstatic virBitmapPtr swtpm_caps;\nstatic char *swtpm_setup;\nstatic struct stat swtpm_setup_stat;\nstatic virBitmapPtr swtpm_setup_caps;\nstatic char *swtpm_ioctl;\nstatic struct stat swtpm_ioctl_stat;\n\nint\nvirTPMEmulatorInit(void)\n{\n    int ret = -1;\n    static const struct {\n        const char *name;\n        char **path;\n        struct stat *stat;\n        const char *parm;\n        virBitmapPtr *caps;\n        TypeFromStringFn typeFromStringFn;\n    } prgs[] = {\n        {\n            .name = \"swtpm\",\n            .path = &swtpm_path,\n            .stat = &swtpm_stat,\n            .parm = \"socket\",\n            .caps = &swtpm_caps,\n            .typeFromStringFn = virTPMSwtpmFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_setup\",\n            .path = &swtpm_setup,\n            .stat = &swtpm_setup_stat,\n            .caps = &swtpm_setup_caps,\n            .typeFromStringFn = virTPMSwtpmSetupFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_ioctl\",\n            .path = &swtpm_ioctl,\n            .stat = &swtpm_ioctl_stat,\n        }\n    };\n    size_t i;\n\n    virMutexLock(&swtpm_tools_lock);\n\n    for (i = 0; i < G_N_ELEMENTS(prgs); i++) {\n        g_autofree char *path = NULL;\n        bool findit = *prgs[i].path == NULL;\n        struct stat statbuf;\n        char *tmp;\n\n        if (!findit) {\n            /* has executables changed? */\n            if (stat(*prgs[i].path, &statbuf) < 0)\n                findit = true;\n\n            if (!findit &&\n                &statbuf.st_mtime != &prgs[i].stat->st_mtime)\n                findit = true;\n        }\n\n        if (findit) {\n            tmp = *prgs[i].path;\n            VIR_FREE(tmp);\n            *prgs[i].path = NULL;\n\n            path = virFindFileInPath(prgs[i].name);\n            if (!path) {\n                virReportSystemError(ENOENT,\n                                _(\"Unable to find '%s' binary in $PATH\"),\n                                prgs[i].name);\n                goto cleanup;\n            }\n            if (!virFileIsExecutable(path)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s is not an executable\"),\n                               path);\n                goto cleanup;\n            }\n            if (stat(path, prgs[i].stat) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Could not stat %s\"), path);\n                goto cleanup;\n            }\n            *prgs[i].path = path;\n\n            if (prgs[i].caps) {\n                *prgs[i].caps = virTPMGetCaps(prgs[i].typeFromStringFn,\n                                              path, prgs[i].parm);\n                path = NULL;\n                if (!*prgs[i].caps)\n                    goto cleanup;\n            }\n            path = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&swtpm_tools_lock);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"virtpm.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virMutex swtpm_tools_lock = VIR_MUTEX_INITIALIZER;\nstatic char *swtpm_setup;\n\nchar *\nvirTPMGetSwtpmSetup(void)\n{\n    char *s;\n\n    if (!swtpm_setup && virTPMEmulatorInit() < 0)\n        return NULL;\n\n    virMutexLock(&swtpm_tools_lock);\n    s = g_strdup(swtpm_setup);\n    virMutexUnlock(&swtpm_tools_lock);\n\n    return s;\n}"
  },
  {
    "function_name": "virTPMGetSwtpm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtpm.c",
    "lines": "108-121",
    "snippet": "char *\nvirTPMGetSwtpm(void)\n{\n    char *s;\n\n    if (!swtpm_path && virTPMEmulatorInit() < 0)\n        return NULL;\n\n    virMutexLock(&swtpm_tools_lock);\n    s = g_strdup(swtpm_path);\n    virMutexUnlock(&swtpm_tools_lock);\n\n    return s;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"virtpm.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virMutex swtpm_tools_lock = VIR_MUTEX_INITIALIZER;",
      "static char *swtpm_path;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&swtpm_tools_lock"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "swtpm_path"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&swtpm_tools_lock"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTPMEmulatorInit",
          "args": [],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "virTPMEmulatorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtpm.c",
          "lines": "252-347",
          "snippet": "int\nvirTPMEmulatorInit(void)\n{\n    int ret = -1;\n    static const struct {\n        const char *name;\n        char **path;\n        struct stat *stat;\n        const char *parm;\n        virBitmapPtr *caps;\n        TypeFromStringFn typeFromStringFn;\n    } prgs[] = {\n        {\n            .name = \"swtpm\",\n            .path = &swtpm_path,\n            .stat = &swtpm_stat,\n            .parm = \"socket\",\n            .caps = &swtpm_caps,\n            .typeFromStringFn = virTPMSwtpmFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_setup\",\n            .path = &swtpm_setup,\n            .stat = &swtpm_setup_stat,\n            .caps = &swtpm_setup_caps,\n            .typeFromStringFn = virTPMSwtpmSetupFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_ioctl\",\n            .path = &swtpm_ioctl,\n            .stat = &swtpm_ioctl_stat,\n        }\n    };\n    size_t i;\n\n    virMutexLock(&swtpm_tools_lock);\n\n    for (i = 0; i < G_N_ELEMENTS(prgs); i++) {\n        g_autofree char *path = NULL;\n        bool findit = *prgs[i].path == NULL;\n        struct stat statbuf;\n        char *tmp;\n\n        if (!findit) {\n            /* has executables changed? */\n            if (stat(*prgs[i].path, &statbuf) < 0)\n                findit = true;\n\n            if (!findit &&\n                &statbuf.st_mtime != &prgs[i].stat->st_mtime)\n                findit = true;\n        }\n\n        if (findit) {\n            tmp = *prgs[i].path;\n            VIR_FREE(tmp);\n            *prgs[i].path = NULL;\n\n            path = virFindFileInPath(prgs[i].name);\n            if (!path) {\n                virReportSystemError(ENOENT,\n                                _(\"Unable to find '%s' binary in $PATH\"),\n                                prgs[i].name);\n                goto cleanup;\n            }\n            if (!virFileIsExecutable(path)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s is not an executable\"),\n                               path);\n                goto cleanup;\n            }\n            if (stat(path, prgs[i].stat) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Could not stat %s\"), path);\n                goto cleanup;\n            }\n            *prgs[i].path = path;\n\n            if (prgs[i].caps) {\n                *prgs[i].caps = virTPMGetCaps(prgs[i].typeFromStringFn,\n                                              path, prgs[i].parm);\n                path = NULL;\n                if (!*prgs[i].caps)\n                    goto cleanup;\n            }\n            path = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&swtpm_tools_lock);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"virtpm.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virMutex swtpm_tools_lock = VIR_MUTEX_INITIALIZER;",
            "static char *swtpm_path;",
            "static struct stat swtpm_stat;",
            "static virBitmapPtr swtpm_caps;",
            "static char *swtpm_setup;",
            "static struct stat swtpm_setup_stat;",
            "static virBitmapPtr swtpm_setup_caps;",
            "static char *swtpm_ioctl;",
            "static struct stat swtpm_ioctl_stat;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"virtpm.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virMutex swtpm_tools_lock = VIR_MUTEX_INITIALIZER;\nstatic char *swtpm_path;\nstatic struct stat swtpm_stat;\nstatic virBitmapPtr swtpm_caps;\nstatic char *swtpm_setup;\nstatic struct stat swtpm_setup_stat;\nstatic virBitmapPtr swtpm_setup_caps;\nstatic char *swtpm_ioctl;\nstatic struct stat swtpm_ioctl_stat;\n\nint\nvirTPMEmulatorInit(void)\n{\n    int ret = -1;\n    static const struct {\n        const char *name;\n        char **path;\n        struct stat *stat;\n        const char *parm;\n        virBitmapPtr *caps;\n        TypeFromStringFn typeFromStringFn;\n    } prgs[] = {\n        {\n            .name = \"swtpm\",\n            .path = &swtpm_path,\n            .stat = &swtpm_stat,\n            .parm = \"socket\",\n            .caps = &swtpm_caps,\n            .typeFromStringFn = virTPMSwtpmFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_setup\",\n            .path = &swtpm_setup,\n            .stat = &swtpm_setup_stat,\n            .caps = &swtpm_setup_caps,\n            .typeFromStringFn = virTPMSwtpmSetupFeatureTypeFromString,\n        },\n        {\n            .name = \"swtpm_ioctl\",\n            .path = &swtpm_ioctl,\n            .stat = &swtpm_ioctl_stat,\n        }\n    };\n    size_t i;\n\n    virMutexLock(&swtpm_tools_lock);\n\n    for (i = 0; i < G_N_ELEMENTS(prgs); i++) {\n        g_autofree char *path = NULL;\n        bool findit = *prgs[i].path == NULL;\n        struct stat statbuf;\n        char *tmp;\n\n        if (!findit) {\n            /* has executables changed? */\n            if (stat(*prgs[i].path, &statbuf) < 0)\n                findit = true;\n\n            if (!findit &&\n                &statbuf.st_mtime != &prgs[i].stat->st_mtime)\n                findit = true;\n        }\n\n        if (findit) {\n            tmp = *prgs[i].path;\n            VIR_FREE(tmp);\n            *prgs[i].path = NULL;\n\n            path = virFindFileInPath(prgs[i].name);\n            if (!path) {\n                virReportSystemError(ENOENT,\n                                _(\"Unable to find '%s' binary in $PATH\"),\n                                prgs[i].name);\n                goto cleanup;\n            }\n            if (!virFileIsExecutable(path)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s is not an executable\"),\n                               path);\n                goto cleanup;\n            }\n            if (stat(path, prgs[i].stat) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Could not stat %s\"), path);\n                goto cleanup;\n            }\n            *prgs[i].path = path;\n\n            if (prgs[i].caps) {\n                *prgs[i].caps = virTPMGetCaps(prgs[i].typeFromStringFn,\n                                              path, prgs[i].parm);\n                path = NULL;\n                if (!*prgs[i].caps)\n                    goto cleanup;\n            }\n            path = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virMutexUnlock(&swtpm_tools_lock);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"virtpm.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virMutex swtpm_tools_lock = VIR_MUTEX_INITIALIZER;\nstatic char *swtpm_path;\n\nchar *\nvirTPMGetSwtpm(void)\n{\n    char *s;\n\n    if (!swtpm_path && virTPMEmulatorInit() < 0)\n        return NULL;\n\n    virMutexLock(&swtpm_tools_lock);\n    s = g_strdup(swtpm_path);\n    virMutexUnlock(&swtpm_tools_lock);\n\n    return s;\n}"
  },
  {
    "function_name": "virTPMCreateCancelPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtpm.c",
    "lines": "55-88",
    "snippet": "char *\nvirTPMCreateCancelPath(const char *devpath)\n{\n    char *path = NULL;\n    const char *dev;\n    const char *prefix[] = {\"misc/\", \"tpm/\"};\n    size_t i;\n    if (!devpath) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing TPM device path\"));\n        return NULL;\n    }\n\n    if (!(dev = strrchr(devpath, '/'))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"TPM device path %s is invalid\"), devpath);\n        return NULL;\n    }\n\n    dev++;\n    for (i = 0; i < G_N_ELEMENTS(prefix); i++) {\n        path = g_strdup_printf(\"/sys/class/%s%s/device/cancel\", prefix[i],\n                               dev);\n\n        if (virFileExists(path))\n            break;\n\n        VIR_FREE(path);\n    }\n    if (!path)\n        path = g_strdup(\"/dev/null\");\n\n    return path;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"virtpm.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"/dev/null\""
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "path"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "prefix"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"TPM device path %s is invalid\")",
            "devpath"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "devpath",
            "'/'"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing TPM device path\")"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"virtpm.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nchar *\nvirTPMCreateCancelPath(const char *devpath)\n{\n    char *path = NULL;\n    const char *dev;\n    const char *prefix[] = {\"misc/\", \"tpm/\"};\n    size_t i;\n    if (!devpath) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing TPM device path\"));\n        return NULL;\n    }\n\n    if (!(dev = strrchr(devpath, '/'))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"TPM device path %s is invalid\"), devpath);\n        return NULL;\n    }\n\n    dev++;\n    for (i = 0; i < G_N_ELEMENTS(prefix); i++) {\n        path = g_strdup_printf(\"/sys/class/%s%s/device/cancel\", prefix[i],\n                               dev);\n\n        if (virFileExists(path))\n            break;\n\n        VIR_FREE(path);\n    }\n    if (!path)\n        path = g_strdup(\"/dev/null\");\n\n    return path;\n}"
  }
]