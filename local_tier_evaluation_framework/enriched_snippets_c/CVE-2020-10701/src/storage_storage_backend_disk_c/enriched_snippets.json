[
  {
    "function_name": "virStorageBackendDiskRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "987-991",
    "snippet": "int\nvirStorageBackendDiskRegister(void)\n{\n    return virStorageBackendRegister(&virStorageBackendDisk);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virStorageBackend virStorageBackendDisk = {\n    .type = VIR_STORAGE_POOL_DISK,\n\n    .startPool = virStorageBackendDiskStartPool,\n    .buildPool = virStorageBackendDiskBuildPool,\n    .refreshPool = virStorageBackendDiskRefreshPool,\n    .deletePool = virStorageBackendDiskDeletePool,\n\n    .createVol = virStorageBackendDiskCreateVol,\n    .deleteVol = virStorageBackendDiskDeleteVol,\n    .buildVolFrom = virStorageBackendDiskBuildVolFrom,\n    .uploadVol = virStorageBackendVolUploadLocal,\n    .downloadVol = virStorageBackendVolDownloadLocal,\n    .wipeVol = virStorageBackendDiskVolWipe,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendRegister",
          "args": [
            "&virStorageBackendDisk"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend.c",
          "lines": "153-169",
          "snippet": "int\nvirStorageBackendRegister(virStorageBackendPtr backend)\n{\n    VIR_DEBUG(\"Registering storage backend '%s'\",\n              virStoragePoolTypeToString(backend->type));\n\n    if (virStorageBackendsCount >= VIR_STORAGE_BACKENDS_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register storage backend '%s'\"),\n                       virStoragePoolTypeToString(backend->type));\n        return -1;\n    }\n\n    virStorageBackends[virStorageBackendsCount] = backend;\n    virStorageBackendsCount++;\n    return 0;\n}",
          "includes": [
            "# include \"storage_backend_vstorage.h\"",
            "# include \"storage_backend_zfs.h\"",
            "# include \"storage_backend_gluster.h\"",
            "# include \"storage_backend_sheepdog.h\"",
            "# include \"storage_backend_rbd.h\"",
            "# include \"storage_backend_fs.h\"",
            "# include \"storage_backend_disk.h\"",
            "# include \"storage_backend_mpath.h\"",
            "# include \"storage_backend_scsi.h\"",
            "# include \"storage_backend_iscsi_direct.h\"",
            "# include \"storage_backend_iscsi.h\"",
            "# include \"storage_backend_logical.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_STORAGE_BACKENDS_MAX 20"
          ],
          "globals_used": [
            "static virStorageBackendPtr virStorageBackends[VIR_STORAGE_BACKENDS_MAX];",
            "static size_t virStorageBackendsCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"storage_backend_vstorage.h\"\n# include \"storage_backend_zfs.h\"\n# include \"storage_backend_gluster.h\"\n# include \"storage_backend_sheepdog.h\"\n# include \"storage_backend_rbd.h\"\n# include \"storage_backend_fs.h\"\n# include \"storage_backend_disk.h\"\n# include \"storage_backend_mpath.h\"\n# include \"storage_backend_scsi.h\"\n# include \"storage_backend_iscsi_direct.h\"\n# include \"storage_backend_iscsi.h\"\n# include \"storage_backend_logical.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"virstoragefile.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\n#define VIR_STORAGE_BACKENDS_MAX 20\n\nstatic virStorageBackendPtr virStorageBackends[VIR_STORAGE_BACKENDS_MAX];\nstatic size_t virStorageBackendsCount;\n\nint\nvirStorageBackendRegister(virStorageBackendPtr backend)\n{\n    VIR_DEBUG(\"Registering storage backend '%s'\",\n              virStoragePoolTypeToString(backend->type));\n\n    if (virStorageBackendsCount >= VIR_STORAGE_BACKENDS_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register storage backend '%s'\"),\n                       virStoragePoolTypeToString(backend->type));\n        return -1;\n    }\n\n    virStorageBackends[virStorageBackendsCount] = backend;\n    virStorageBackendsCount++;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirStorageBackend virStorageBackendDisk = {\n    .type = VIR_STORAGE_POOL_DISK,\n\n    .startPool = virStorageBackendDiskStartPool,\n    .buildPool = virStorageBackendDiskBuildPool,\n    .refreshPool = virStorageBackendDiskRefreshPool,\n    .deletePool = virStorageBackendDiskDeletePool,\n\n    .createVol = virStorageBackendDiskCreateVol,\n    .deleteVol = virStorageBackendDiskDeleteVol,\n    .buildVolFrom = virStorageBackendDiskBuildVolFrom,\n    .uploadVol = virStorageBackendVolUploadLocal,\n    .downloadVol = virStorageBackendVolDownloadLocal,\n    .wipeVol = virStorageBackendDiskVolWipe,\n};\n\nint\nvirStorageBackendDiskRegister(void)\n{\n    return virStorageBackendRegister(&virStorageBackendDisk);\n}"
  },
  {
    "function_name": "virStorageBackendDiskVolWipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "953-967",
    "snippet": "static int\nvirStorageBackendDiskVolWipe(virStoragePoolObjPtr pool,\n                             virStorageVolDefPtr vol,\n                             unsigned int algorithm,\n                             unsigned int flags)\n{\n    if (vol->source.partType != VIR_STORAGE_VOL_DISK_TYPE_EXTENDED)\n        return virStorageBackendVolWipeLocal(pool, vol, algorithm, flags);\n\n    /* Wiping an extended partition is not support */\n    virReportError(VIR_ERR_NO_SUPPORT,\n                   _(\"cannot wipe extended partition '%s'\"),\n                   vol->target.path);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"cannot wipe extended partition '%s'\")",
            "vol->target.path"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot wipe extended partition '%s'\""
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendVolWipeLocal",
          "args": [
            "pool",
            "vol",
            "algorithm",
            "flags"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendVolWipeLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2695-2716",
          "snippet": "int\nvirStorageBackendVolWipeLocal(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                              virStorageVolDefPtr vol,\n                              unsigned int algorithm,\n                              unsigned int flags)\n{\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    VIR_DEBUG(\"Wiping volume with path '%s' and algorithm %u\",\n              vol->target.path, algorithm);\n\n    if (vol->target.format == VIR_STORAGE_FILE_PLOOP) {\n        ret = storageBackendVolWipePloop(vol, algorithm);\n    } else {\n        ret = storageBackendVolWipeLocalFile(vol->target.path, algorithm,\n                                             vol->target.allocation, false);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendVolWipeLocal(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                              virStorageVolDefPtr vol,\n                              unsigned int algorithm,\n                              unsigned int flags)\n{\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    VIR_DEBUG(\"Wiping volume with path '%s' and algorithm %u\",\n              vol->target.path, algorithm);\n\n    if (vol->target.format == VIR_STORAGE_FILE_PLOOP) {\n        ret = storageBackendVolWipePloop(vol, algorithm);\n    } else {\n        ret = storageBackendVolWipeLocalFile(vol->target.path, algorithm,\n                                             vol->target.allocation, false);\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskVolWipe(virStoragePoolObjPtr pool,\n                             virStorageVolDefPtr vol,\n                             unsigned int algorithm,\n                             unsigned int flags)\n{\n    if (vol->source.partType != VIR_STORAGE_VOL_DISK_TYPE_EXTENDED)\n        return virStorageBackendVolWipeLocal(pool, vol, algorithm, flags);\n\n    /* Wiping an extended partition is not support */\n    virReportError(VIR_ERR_NO_SUPPORT,\n                   _(\"cannot wipe extended partition '%s'\"),\n                   vol->target.path);\n    return -1;\n}"
  },
  {
    "function_name": "virStorageBackendDiskBuildVolFrom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "937-950",
    "snippet": "static int\nvirStorageBackendDiskBuildVolFrom(virStoragePoolObjPtr pool,\n                                  virStorageVolDefPtr vol,\n                                  virStorageVolDefPtr inputvol,\n                                  unsigned int flags)\n{\n    virStorageBackendBuildVolFrom build_func;\n\n    build_func = virStorageBackendGetBuildVolFromFunction(vol, inputvol);\n    if (!build_func)\n        return -1;\n\n    return build_func(pool, vol, inputvol, flags);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "build_func",
          "args": [
            "pool",
            "vol",
            "inputvol",
            "flags"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendGetBuildVolFromFunction",
          "args": [
            "vol",
            "inputvol"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendGetBuildVolFromFunction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1387-1412",
          "snippet": "virStorageBackendBuildVolFrom\nvirStorageBackendGetBuildVolFromFunction(virStorageVolDefPtr vol,\n                                         virStorageVolDefPtr inputvol)\n{\n    if (!inputvol)\n        return NULL;\n\n    /* If either volume is a non-raw file vol, or uses encryption,\n     * we need to use an external tool for converting\n     */\n    if ((vol->type == VIR_STORAGE_VOL_FILE &&\n         (vol->target.format != VIR_STORAGE_FILE_RAW ||\n          vol->target.encryption)) ||\n        (inputvol->type == VIR_STORAGE_VOL_FILE &&\n         (inputvol->target.format != VIR_STORAGE_FILE_RAW ||\n          inputvol->target.encryption))) {\n        return storageBackendCreateQemuImg;\n    }\n\n    if (vol->type == VIR_STORAGE_VOL_PLOOP)\n        return storageBackendCreatePloop;\n    if (vol->type == VIR_STORAGE_VOL_BLOCK)\n        return storageBackendCreateBlockFrom;\n    else\n        return storageBackendCreateRaw;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirStorageBackendBuildVolFrom\nvirStorageBackendGetBuildVolFromFunction(virStorageVolDefPtr vol,\n                                         virStorageVolDefPtr inputvol)\n{\n    if (!inputvol)\n        return NULL;\n\n    /* If either volume is a non-raw file vol, or uses encryption,\n     * we need to use an external tool for converting\n     */\n    if ((vol->type == VIR_STORAGE_VOL_FILE &&\n         (vol->target.format != VIR_STORAGE_FILE_RAW ||\n          vol->target.encryption)) ||\n        (inputvol->type == VIR_STORAGE_VOL_FILE &&\n         (inputvol->target.format != VIR_STORAGE_FILE_RAW ||\n          inputvol->target.encryption))) {\n        return storageBackendCreateQemuImg;\n    }\n\n    if (vol->type == VIR_STORAGE_VOL_PLOOP)\n        return storageBackendCreatePloop;\n    if (vol->type == VIR_STORAGE_VOL_BLOCK)\n        return storageBackendCreateBlockFrom;\n    else\n        return storageBackendCreateRaw;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskBuildVolFrom(virStoragePoolObjPtr pool,\n                                  virStorageVolDefPtr vol,\n                                  virStorageVolDefPtr inputvol,\n                                  unsigned int flags)\n{\n    virStorageBackendBuildVolFrom build_func;\n\n    build_func = virStorageBackendGetBuildVolFromFunction(vol, inputvol);\n    if (!build_func)\n        return -1;\n\n    return build_func(pool, vol, inputvol, flags);\n}"
  },
  {
    "function_name": "virStorageBackendDiskCreateVol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "860-934",
    "snippet": "static int\nvirStorageBackendDiskCreateVol(virStoragePoolObjPtr pool,\n                               virStorageVolDefPtr vol)\n{\n    unsigned long long startOffset = 0, endOffset = 0;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virErrorPtr save_err;\n    g_autofree char *partFormat = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(PARTED,\n                               def->source.devices[0].path,\n                               \"mkpart\",\n                               \"--script\",\n                               NULL);\n\n    if (vol->target.encryption &&\n        vol->target.encryption->format != VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"storage pool only supports LUKS encrypted volumes\"));\n        return -1;\n    }\n\n    if (virStorageBackendDiskPartFormat(pool, vol, &partFormat) != 0)\n        return -1;\n    virCommandAddArg(cmd, partFormat);\n\n    /* If we're going to encrypt using LUKS, then we could need up to\n     * an extra 2MB for the LUKS header - so account for that now */\n    if (vol->target.encryption)\n        vol->target.capacity += 2 * 1024 * 1024;\n\n    if (virStorageBackendDiskPartBoundaries(pool, &startOffset, &endOffset,\n                                            vol->target.capacity) < 0)\n        return -1;\n\n    virCommandAddArgFormat(cmd, \"%lluB\", startOffset);\n    virCommandAddArgFormat(cmd, \"%lluB\", endOffset);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    /* wait for device node to show up */\n    virWaitForDevices();\n\n    /* Blow away free extent info, as we're about to re-populate it */\n    VIR_FREE(def->source.devices[0].freeExtents);\n    def->source.devices[0].nfreeExtent = 0;\n\n    /* Specifying a target path is meaningless */\n    VIR_FREE(vol->target.path);\n\n    /* Fetch actual extent info, generate key */\n    if (virStorageBackendDiskReadPartitions(pool, vol) < 0)\n        goto error;\n\n    if (vol->target.encryption) {\n        /* Adjust the sizes to account for the LUKS header */\n        vol->target.capacity -= 2 * 1024 * 1024;\n        vol->target.allocation -= 2 * 1024 * 1024;\n        if (virStorageBackendCreateVolUsingQemuImg(pool, vol, NULL, 0) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    /* Best effort to remove the partition. Ignore any errors\n     * since we could be calling this with vol->target.path == NULL\n     */\n    virErrorPreserveLast(&save_err);\n    ignore_value(virStorageBackendDiskDeleteVol(pool, vol, 0));\n    virErrorRestore(&save_err);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&save_err"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virStorageBackendDiskDeleteVol(pool, vol, 0)"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendDiskDeleteVol",
          "args": [
            "pool",
            "vol",
            "0"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendDiskDeleteVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
          "lines": "774-857",
          "snippet": "static int\nvirStorageBackendDiskDeleteVol(virStoragePoolObjPtr pool,\n                               virStorageVolDefPtr vol,\n                               unsigned int flags)\n{\n    char *part_num = NULL;\n    g_autofree char *dev_name = NULL;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    char *src_path = def->source.devices[0].path;\n    g_autofree char *srcname = g_path_get_basename(src_path);\n    bool isDevMapperDevice;\n    g_autofree char *devpath = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (!vol->target.path) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"volume target path empty for source path '%s'\"),\n                      src_path);\n        return -1;\n    }\n\n    /* NB: This is the corollary to the algorithm in libvirt_parthelper\n     *     (parthelper.c) that is used to generate the target.path name\n     *     for use by libvirt. Changes to either, need to be reflected\n     *     in both places */\n    isDevMapperDevice = virIsDevMapperDevice(vol->target.path);\n    if (isDevMapperDevice) {\n        dev_name = g_path_get_basename(vol->target.path);\n    } else {\n        if (virFileResolveLink(vol->target.path, &devpath) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Couldn't read volume target path '%s'\"),\n                                 vol->target.path);\n            return -1;\n        }\n        dev_name = g_path_get_basename(devpath);\n    }\n\n    VIR_DEBUG(\"dev_name=%s, srcname=%s\", dev_name, srcname);\n\n    if (!STRPREFIX(dev_name, srcname)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' did not start with parent \"\n                         \"pool source device name.\"), dev_name);\n        return -1;\n    }\n\n    part_num = dev_name + strlen(srcname);\n\n    /* For device mapper and we have a partition character 'p' as the\n     * current character, let's move beyond that before checking part_num */\n    if (isDevMapperDevice && *part_num == 'p')\n        part_num++;\n\n    if (*part_num == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot parse partition number from target \"\n                         \"'%s'\"), dev_name);\n        return -1;\n    }\n\n    /* eg parted /dev/sda rm 2 or /dev/mapper/mpathc rm 2 */\n    cmd = virCommandNewArgList(PARTED,\n                               src_path,\n                               \"rm\",\n                               \"--script\",\n                               part_num,\n                               NULL);\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    /* Refreshing the pool is the easiest option as LOGICAL and EXTENDED\n     * partition allocation/capacity management is handled within\n     * virStorageBackendDiskMakeDataVol and trying to redo that logic\n     * here is pointless\n     */\n    virStoragePoolObjClearVols(pool);\n    if (virStorageBackendDiskRefreshPool(pool) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_disk.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskDeleteVol(virStoragePoolObjPtr pool,\n                               virStorageVolDefPtr vol,\n                               unsigned int flags)\n{\n    char *part_num = NULL;\n    g_autofree char *dev_name = NULL;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    char *src_path = def->source.devices[0].path;\n    g_autofree char *srcname = g_path_get_basename(src_path);\n    bool isDevMapperDevice;\n    g_autofree char *devpath = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (!vol->target.path) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"volume target path empty for source path '%s'\"),\n                      src_path);\n        return -1;\n    }\n\n    /* NB: This is the corollary to the algorithm in libvirt_parthelper\n     *     (parthelper.c) that is used to generate the target.path name\n     *     for use by libvirt. Changes to either, need to be reflected\n     *     in both places */\n    isDevMapperDevice = virIsDevMapperDevice(vol->target.path);\n    if (isDevMapperDevice) {\n        dev_name = g_path_get_basename(vol->target.path);\n    } else {\n        if (virFileResolveLink(vol->target.path, &devpath) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Couldn't read volume target path '%s'\"),\n                                 vol->target.path);\n            return -1;\n        }\n        dev_name = g_path_get_basename(devpath);\n    }\n\n    VIR_DEBUG(\"dev_name=%s, srcname=%s\", dev_name, srcname);\n\n    if (!STRPREFIX(dev_name, srcname)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' did not start with parent \"\n                         \"pool source device name.\"), dev_name);\n        return -1;\n    }\n\n    part_num = dev_name + strlen(srcname);\n\n    /* For device mapper and we have a partition character 'p' as the\n     * current character, let's move beyond that before checking part_num */\n    if (isDevMapperDevice && *part_num == 'p')\n        part_num++;\n\n    if (*part_num == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot parse partition number from target \"\n                         \"'%s'\"), dev_name);\n        return -1;\n    }\n\n    /* eg parted /dev/sda rm 2 or /dev/mapper/mpathc rm 2 */\n    cmd = virCommandNewArgList(PARTED,\n                               src_path,\n                               \"rm\",\n                               \"--script\",\n                               part_num,\n                               NULL);\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    /* Refreshing the pool is the easiest option as LOGICAL and EXTENDED\n     * partition allocation/capacity management is handled within\n     * virStorageBackendDiskMakeDataVol and trying to redo that logic\n     * here is pointless\n     */\n    virStoragePoolObjClearVols(pool);\n    if (virStorageBackendDiskRefreshPool(pool) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&save_err"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendCreateVolUsingQemuImg",
          "args": [
            "pool",
            "vol",
            "NULL",
            "0"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendCreateVolUsingQemuImg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1364-1384",
          "snippet": "int\nvirStorageBackendCreateVolUsingQemuImg(virStoragePoolObjPtr pool,\n                                       virStorageVolDefPtr vol,\n                                       virStorageVolDefPtr inputvol,\n                                       unsigned int flags)\n{\n    int ret = -1;\n    bool changeFormat = false;\n\n    if (vol->target.format == VIR_STORAGE_FILE_NONE) {\n        vol->target.format = VIR_STORAGE_FILE_RAW;\n        changeFormat = true;\n    }\n\n    ret = storageBackendCreateQemuImg(pool, vol, inputvol, flags);\n\n    if (changeFormat)\n        vol->target.format = VIR_STORAGE_FILE_NONE;\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendCreateVolUsingQemuImg(virStoragePoolObjPtr pool,\n                                       virStorageVolDefPtr vol,\n                                       virStorageVolDefPtr inputvol,\n                                       unsigned int flags)\n{\n    int ret = -1;\n    bool changeFormat = false;\n\n    if (vol->target.format == VIR_STORAGE_FILE_NONE) {\n        vol->target.format = VIR_STORAGE_FILE_RAW;\n        changeFormat = true;\n    }\n\n    ret = storageBackendCreateQemuImg(pool, vol, inputvol, flags);\n\n    if (changeFormat)\n        vol->target.format = VIR_STORAGE_FILE_NONE;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendDiskReadPartitions",
          "args": [
            "pool",
            "vol"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendDiskReadPartitions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
          "lines": "340-386",
          "snippet": "static int\nvirStorageBackendDiskReadPartitions(virStoragePoolObjPtr pool,\n                                    virStorageVolDefPtr vol)\n{\n    /*\n     *  # libvirt_parthelper DEVICE\n     * /dev/sda1      normal       data        32256    106928128    106896384\n     * /dev/sda2      normal       data    106928640 100027629568  99920701440\n     * -              normal   metadata 100027630080 100030242304      2612736\n     *\n     */\n\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct virStorageBackendDiskPoolVolData cbdata = {\n        .pool = pool,\n        .vol = vol,\n    };\n    g_autofree char *parthelper_path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (!(parthelper_path = virFileFindResource(\"libvirt_parthelper\",\n                                                abs_top_builddir \"/src\",\n                                                LIBEXECDIR)))\n        return -1;\n\n    cmd = virCommandNewArgList(parthelper_path,\n                               def->source.devices[0].path,\n                               NULL);\n\n    /* Check for the presence of the part_separator='yes'. Pass this\n     * along to the libvirt_parthelper as option '-p'. This will cause\n     * libvirt_parthelper to append the \"p\" partition separator to\n     * the generated device name for a source device which ends with\n     * a non-numeric value (e.g. mpatha would generate mpathap#).\n     */\n    if (def->source.devices[0].part_separator == VIR_TRISTATE_BOOL_YES)\n        virCommandAddArg(cmd, \"-p\");\n\n    /* If a volume is passed, virStorageBackendDiskMakeVol only updates the\n     * pool allocation for that single volume.\n     */\n    if (!vol)\n        def->allocation = 0;\n    def->capacity = def->available = 0;\n\n    return virCommandRunNul(cmd, 6, virStorageBackendDiskMakeVol, &cbdata);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_disk.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskReadPartitions(virStoragePoolObjPtr pool,\n                                    virStorageVolDefPtr vol)\n{\n    /*\n     *  # libvirt_parthelper DEVICE\n     * /dev/sda1      normal       data        32256    106928128    106896384\n     * /dev/sda2      normal       data    106928640 100027629568  99920701440\n     * -              normal   metadata 100027630080 100030242304      2612736\n     *\n     */\n\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct virStorageBackendDiskPoolVolData cbdata = {\n        .pool = pool,\n        .vol = vol,\n    };\n    g_autofree char *parthelper_path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (!(parthelper_path = virFileFindResource(\"libvirt_parthelper\",\n                                                abs_top_builddir \"/src\",\n                                                LIBEXECDIR)))\n        return -1;\n\n    cmd = virCommandNewArgList(parthelper_path,\n                               def->source.devices[0].path,\n                               NULL);\n\n    /* Check for the presence of the part_separator='yes'. Pass this\n     * along to the libvirt_parthelper as option '-p'. This will cause\n     * libvirt_parthelper to append the \"p\" partition separator to\n     * the generated device name for a source device which ends with\n     * a non-numeric value (e.g. mpatha would generate mpathap#).\n     */\n    if (def->source.devices[0].part_separator == VIR_TRISTATE_BOOL_YES)\n        virCommandAddArg(cmd, \"-p\");\n\n    /* If a volume is passed, virStorageBackendDiskMakeVol only updates the\n     * pool allocation for that single volume.\n     */\n    if (!vol)\n        def->allocation = 0;\n    def->capacity = def->available = 0;\n\n    return virCommandRunNul(cmd, 6, virStorageBackendDiskMakeVol, &cbdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vol->target.path"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->source.devices[0].freeExtents"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virWaitForDevices",
          "args": [],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "virWaitForDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1324-1341",
          "snippet": "void virWaitForDevices(void)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *udev = NULL;\n    int exitstatus;\n\n    if (!(udev = virFindFileInPath(UDEVADM)))\n        return;\n\n    if (!(cmd = virCommandNewArgList(udev, \"settle\", NULL)))\n        return;\n\n    /*\n     * NOTE: we ignore errors here; this is just to make sure that any device\n     * nodes that are being created finish before we try to scan them.\n     */\n    ignore_value(virCommandRun(cmd, &exitstatus));\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virWaitForDevices(void)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *udev = NULL;\n    int exitstatus;\n\n    if (!(udev = virFindFileInPath(UDEVADM)))\n        return;\n\n    if (!(cmd = virCommandNewArgList(udev, \"settle\", NULL)))\n        return;\n\n    /*\n     * NOTE: we ignore errors here; this is just to make sure that any device\n     * nodes that are being created finish before we try to scan them.\n     */\n    ignore_value(virCommandRun(cmd, &exitstatus));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%lluB\"",
            "endOffset"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendDiskPartBoundaries",
          "args": [
            "pool",
            "&startOffset",
            "&endOffset",
            "vol->target.capacity"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendDiskPartBoundaries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
          "lines": "660-747",
          "snippet": "static int\nvirStorageBackendDiskPartBoundaries(virStoragePoolObjPtr pool,\n                                    unsigned long long *start,\n                                    unsigned long long *end,\n                                    unsigned long long allocation)\n{\n    size_t i;\n    int smallestExtent = -1;\n    unsigned long long smallestSize = 0;\n    unsigned long long extraBytes = 0;\n    unsigned long long alignedAllocation = allocation;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStoragePoolSourceDevicePtr dev = &def->source.devices[0];\n    unsigned long long cylinderSize = (unsigned long long)dev->geometry.heads *\n                                      dev->geometry.sectors * SECTOR_SIZE;\n\n    VIR_DEBUG(\"find free area: allocation %llu, cyl size %llu\", allocation,\n          cylinderSize);\n    int partType = virStorageBackendDiskPartTypeToCreate(pool);\n\n    /* how many extra bytes we have since we allocate\n       aligned to the cylinder boundary */\n    extraBytes = cylinderSize - (allocation % cylinderSize);\n\n    for (i = 0; i < dev->nfreeExtent; i++) {\n         unsigned long long size =\n             dev->freeExtents[i].end -\n             dev->freeExtents[i].start;\n         unsigned long long neededSize = allocation;\n\n         if (def->source.format == VIR_STORAGE_POOL_DISK_DOS) {\n             /* align to cylinder boundary */\n             neededSize += extraBytes;\n             if ((*start % cylinderSize) > extraBytes) {\n                 /* add an extra cylinder if the offset can't fit within\n                    the extra bytes we have */\n                 neededSize += cylinderSize;\n             }\n             /* if we are creating a logical partition, we need one extra\n                block between partitions (or actually move start one block) */\n             if (partType == VIR_STORAGE_VOL_DISK_TYPE_LOGICAL)\n                 size -= SECTOR_SIZE;\n         }\n         if (size > neededSize &&\n             (smallestSize == 0 ||\n             size < smallestSize)) {\n             /* for logical partition, the free extent\n                must be within a logical free area */\n             if (partType == VIR_STORAGE_VOL_DISK_TYPE_LOGICAL &&\n                 dev->freeExtents[i].type != VIR_STORAGE_FREE_LOGICAL) {\n                 continue;\n                 /* for primary partition, the free extent\n                    must not be within a logical free area */\n             } else if (partType == VIR_STORAGE_VOL_DISK_TYPE_PRIMARY &&\n                        dev->freeExtents[i].type != VIR_STORAGE_FREE_NORMAL) {\n                 continue;\n             }\n             smallestSize = size;\n             smallestExtent = i;\n             alignedAllocation = neededSize;\n         }\n    }\n\n    if (smallestExtent == -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"no large enough free extent\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"aligned alloc %llu\", alignedAllocation);\n    *start = dev->freeExtents[smallestExtent].start;\n\n    if (partType == VIR_STORAGE_VOL_DISK_TYPE_LOGICAL) {\n        /* for logical partition, skip one block */\n        *start += SECTOR_SIZE;\n    }\n\n    *end = *start + alignedAllocation;\n    if (def->source.format == VIR_STORAGE_POOL_DISK_DOS) {\n        /* adjust our allocation if start is not at a cylinder boundary */\n        *end -= (*start % cylinderSize);\n    }\n\n    /* counting in bytes, we want the last byte of the current sector */\n    *end -= 1;\n    VIR_DEBUG(\"final aligned start %llu, end %llu\", *start, *end);\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_disk.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECTOR_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\n#define SECTOR_SIZE 512\n\nstatic int\nvirStorageBackendDiskPartBoundaries(virStoragePoolObjPtr pool,\n                                    unsigned long long *start,\n                                    unsigned long long *end,\n                                    unsigned long long allocation)\n{\n    size_t i;\n    int smallestExtent = -1;\n    unsigned long long smallestSize = 0;\n    unsigned long long extraBytes = 0;\n    unsigned long long alignedAllocation = allocation;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStoragePoolSourceDevicePtr dev = &def->source.devices[0];\n    unsigned long long cylinderSize = (unsigned long long)dev->geometry.heads *\n                                      dev->geometry.sectors * SECTOR_SIZE;\n\n    VIR_DEBUG(\"find free area: allocation %llu, cyl size %llu\", allocation,\n          cylinderSize);\n    int partType = virStorageBackendDiskPartTypeToCreate(pool);\n\n    /* how many extra bytes we have since we allocate\n       aligned to the cylinder boundary */\n    extraBytes = cylinderSize - (allocation % cylinderSize);\n\n    for (i = 0; i < dev->nfreeExtent; i++) {\n         unsigned long long size =\n             dev->freeExtents[i].end -\n             dev->freeExtents[i].start;\n         unsigned long long neededSize = allocation;\n\n         if (def->source.format == VIR_STORAGE_POOL_DISK_DOS) {\n             /* align to cylinder boundary */\n             neededSize += extraBytes;\n             if ((*start % cylinderSize) > extraBytes) {\n                 /* add an extra cylinder if the offset can't fit within\n                    the extra bytes we have */\n                 neededSize += cylinderSize;\n             }\n             /* if we are creating a logical partition, we need one extra\n                block between partitions (or actually move start one block) */\n             if (partType == VIR_STORAGE_VOL_DISK_TYPE_LOGICAL)\n                 size -= SECTOR_SIZE;\n         }\n         if (size > neededSize &&\n             (smallestSize == 0 ||\n             size < smallestSize)) {\n             /* for logical partition, the free extent\n                must be within a logical free area */\n             if (partType == VIR_STORAGE_VOL_DISK_TYPE_LOGICAL &&\n                 dev->freeExtents[i].type != VIR_STORAGE_FREE_LOGICAL) {\n                 continue;\n                 /* for primary partition, the free extent\n                    must not be within a logical free area */\n             } else if (partType == VIR_STORAGE_VOL_DISK_TYPE_PRIMARY &&\n                        dev->freeExtents[i].type != VIR_STORAGE_FREE_NORMAL) {\n                 continue;\n             }\n             smallestSize = size;\n             smallestExtent = i;\n             alignedAllocation = neededSize;\n         }\n    }\n\n    if (smallestExtent == -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"no large enough free extent\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"aligned alloc %llu\", alignedAllocation);\n    *start = dev->freeExtents[smallestExtent].start;\n\n    if (partType == VIR_STORAGE_VOL_DISK_TYPE_LOGICAL) {\n        /* for logical partition, skip one block */\n        *start += SECTOR_SIZE;\n    }\n\n    *end = *start + alignedAllocation;\n    if (def->source.format == VIR_STORAGE_POOL_DISK_DOS) {\n        /* adjust our allocation if start is not at a cylinder boundary */\n        *end -= (*start % cylinderSize);\n    }\n\n    /* counting in bytes, we want the last byte of the current sector */\n    *end -= 1;\n    VIR_DEBUG(\"final aligned start %llu, end %llu\", *start, *end);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "partFormat"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendDiskPartFormat",
          "args": [
            "pool",
            "vol",
            "&partFormat"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendDiskPartFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
          "lines": "595-652",
          "snippet": "static int\nvirStorageBackendDiskPartFormat(virStoragePoolObjPtr pool,\n                                virStorageVolDefPtr vol,\n                                char** partFormat)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    if (def->source.format == VIR_STORAGE_POOL_DISK_DOS) {\n        const char *partedFormat;\n        partedFormat = virStoragePartedFsTypeToString(vol->target.format);\n        if (partedFormat == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"Invalid partition type\"));\n            return -1;\n        }\n        if (vol->target.format == VIR_STORAGE_VOL_DISK_EXTENDED) {\n            /* make sure we don't have an extended partition already */\n            if (virStoragePoolObjSearchVolume(pool,\n                                              virStorageVolPartFindExtended,\n                                              NULL)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"extended partition already exists\"));\n                    return -1;\n            }\n            *partFormat = g_strdup(partedFormat);\n        } else {\n            /* create primary partition as long as it is possible\n               and after that check if an extended partition exists\n               to create logical partitions. */\n            /* XXX Only support one extended partition */\n            switch (virStorageBackendDiskPartTypeToCreate(pool)) {\n            case VIR_STORAGE_VOL_DISK_TYPE_PRIMARY:\n                *partFormat = g_strdup_printf(\"primary %s\", partedFormat);\n                break;\n            case VIR_STORAGE_VOL_DISK_TYPE_LOGICAL:\n                /* make sure we have an extended partition */\n                if (virStoragePoolObjSearchVolume(pool,\n                                                  virStorageVolPartFindExtended,\n                                                  NULL)) {\n                    *partFormat = g_strdup_printf(\"logical %s\", partedFormat);\n                } else {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"no extended partition found and no \"\n                                     \"primary partition available\"));\n                    return -1;\n                }\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               \"%s\", _(\"unknown partition type\"));\n                return -1;\n            }\n        }\n    } else {\n        *partFormat = g_strdup(\"primary\");\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_disk.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskPartFormat(virStoragePoolObjPtr pool,\n                                virStorageVolDefPtr vol,\n                                char** partFormat)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    if (def->source.format == VIR_STORAGE_POOL_DISK_DOS) {\n        const char *partedFormat;\n        partedFormat = virStoragePartedFsTypeToString(vol->target.format);\n        if (partedFormat == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"Invalid partition type\"));\n            return -1;\n        }\n        if (vol->target.format == VIR_STORAGE_VOL_DISK_EXTENDED) {\n            /* make sure we don't have an extended partition already */\n            if (virStoragePoolObjSearchVolume(pool,\n                                              virStorageVolPartFindExtended,\n                                              NULL)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"extended partition already exists\"));\n                    return -1;\n            }\n            *partFormat = g_strdup(partedFormat);\n        } else {\n            /* create primary partition as long as it is possible\n               and after that check if an extended partition exists\n               to create logical partitions. */\n            /* XXX Only support one extended partition */\n            switch (virStorageBackendDiskPartTypeToCreate(pool)) {\n            case VIR_STORAGE_VOL_DISK_TYPE_PRIMARY:\n                *partFormat = g_strdup_printf(\"primary %s\", partedFormat);\n                break;\n            case VIR_STORAGE_VOL_DISK_TYPE_LOGICAL:\n                /* make sure we have an extended partition */\n                if (virStoragePoolObjSearchVolume(pool,\n                                                  virStorageVolPartFindExtended,\n                                                  NULL)) {\n                    *partFormat = g_strdup_printf(\"logical %s\", partedFormat);\n                } else {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"no extended partition found and no \"\n                                     \"primary partition available\"));\n                    return -1;\n                }\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               \"%s\", _(\"unknown partition type\"));\n                return -1;\n            }\n        }\n    } else {\n        *partFormat = g_strdup(\"primary\");\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"storage pool only supports LUKS encrypted volumes\")"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"storage pool only supports LUKS encrypted volumes\""
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "PARTED",
            "def->source.devices[0].path",
            "\"mkpart\"",
            "\"--script\"",
            "NULL"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskCreateVol(virStoragePoolObjPtr pool,\n                               virStorageVolDefPtr vol)\n{\n    unsigned long long startOffset = 0, endOffset = 0;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virErrorPtr save_err;\n    g_autofree char *partFormat = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(PARTED,\n                               def->source.devices[0].path,\n                               \"mkpart\",\n                               \"--script\",\n                               NULL);\n\n    if (vol->target.encryption &&\n        vol->target.encryption->format != VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"storage pool only supports LUKS encrypted volumes\"));\n        return -1;\n    }\n\n    if (virStorageBackendDiskPartFormat(pool, vol, &partFormat) != 0)\n        return -1;\n    virCommandAddArg(cmd, partFormat);\n\n    /* If we're going to encrypt using LUKS, then we could need up to\n     * an extra 2MB for the LUKS header - so account for that now */\n    if (vol->target.encryption)\n        vol->target.capacity += 2 * 1024 * 1024;\n\n    if (virStorageBackendDiskPartBoundaries(pool, &startOffset, &endOffset,\n                                            vol->target.capacity) < 0)\n        return -1;\n\n    virCommandAddArgFormat(cmd, \"%lluB\", startOffset);\n    virCommandAddArgFormat(cmd, \"%lluB\", endOffset);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    /* wait for device node to show up */\n    virWaitForDevices();\n\n    /* Blow away free extent info, as we're about to re-populate it */\n    VIR_FREE(def->source.devices[0].freeExtents);\n    def->source.devices[0].nfreeExtent = 0;\n\n    /* Specifying a target path is meaningless */\n    VIR_FREE(vol->target.path);\n\n    /* Fetch actual extent info, generate key */\n    if (virStorageBackendDiskReadPartitions(pool, vol) < 0)\n        goto error;\n\n    if (vol->target.encryption) {\n        /* Adjust the sizes to account for the LUKS header */\n        vol->target.capacity -= 2 * 1024 * 1024;\n        vol->target.allocation -= 2 * 1024 * 1024;\n        if (virStorageBackendCreateVolUsingQemuImg(pool, vol, NULL, 0) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    /* Best effort to remove the partition. Ignore any errors\n     * since we could be calling this with vol->target.path == NULL\n     */\n    virErrorPreserveLast(&save_err);\n    ignore_value(virStorageBackendDiskDeleteVol(pool, vol, 0));\n    virErrorRestore(&save_err);\n    return -1;\n}"
  },
  {
    "function_name": "virStorageBackendDiskDeleteVol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "774-857",
    "snippet": "static int\nvirStorageBackendDiskDeleteVol(virStoragePoolObjPtr pool,\n                               virStorageVolDefPtr vol,\n                               unsigned int flags)\n{\n    char *part_num = NULL;\n    g_autofree char *dev_name = NULL;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    char *src_path = def->source.devices[0].path;\n    g_autofree char *srcname = g_path_get_basename(src_path);\n    bool isDevMapperDevice;\n    g_autofree char *devpath = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (!vol->target.path) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"volume target path empty for source path '%s'\"),\n                      src_path);\n        return -1;\n    }\n\n    /* NB: This is the corollary to the algorithm in libvirt_parthelper\n     *     (parthelper.c) that is used to generate the target.path name\n     *     for use by libvirt. Changes to either, need to be reflected\n     *     in both places */\n    isDevMapperDevice = virIsDevMapperDevice(vol->target.path);\n    if (isDevMapperDevice) {\n        dev_name = g_path_get_basename(vol->target.path);\n    } else {\n        if (virFileResolveLink(vol->target.path, &devpath) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Couldn't read volume target path '%s'\"),\n                                 vol->target.path);\n            return -1;\n        }\n        dev_name = g_path_get_basename(devpath);\n    }\n\n    VIR_DEBUG(\"dev_name=%s, srcname=%s\", dev_name, srcname);\n\n    if (!STRPREFIX(dev_name, srcname)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' did not start with parent \"\n                         \"pool source device name.\"), dev_name);\n        return -1;\n    }\n\n    part_num = dev_name + strlen(srcname);\n\n    /* For device mapper and we have a partition character 'p' as the\n     * current character, let's move beyond that before checking part_num */\n    if (isDevMapperDevice && *part_num == 'p')\n        part_num++;\n\n    if (*part_num == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot parse partition number from target \"\n                         \"'%s'\"), dev_name);\n        return -1;\n    }\n\n    /* eg parted /dev/sda rm 2 or /dev/mapper/mpathc rm 2 */\n    cmd = virCommandNewArgList(PARTED,\n                               src_path,\n                               \"rm\",\n                               \"--script\",\n                               part_num,\n                               NULL);\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    /* Refreshing the pool is the easiest option as LOGICAL and EXTENDED\n     * partition allocation/capacity management is handled within\n     * virStorageBackendDiskMakeDataVol and trying to redo that logic\n     * here is pointless\n     */\n    virStoragePoolObjClearVols(pool);\n    if (virStorageBackendDiskRefreshPool(pool) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendDiskRefreshPool",
          "args": [
            "pool"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendDiskRefreshPool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
          "lines": "428-449",
          "snippet": "static int\nvirStorageBackendDiskRefreshPool(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    VIR_FREE(def->source.devices[0].freeExtents);\n    def->source.devices[0].nfreeExtent = 0;\n\n    virWaitForDevices();\n\n    if (!virFileExists(def->source.devices[0].path)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"device path '%s' doesn't exist\"),\n                       def->source.devices[0].path);\n        return -1;\n    }\n\n    if (virStorageBackendDiskReadGeometry(pool) != 0)\n        return -1;\n\n    return virStorageBackendDiskReadPartitions(pool, NULL);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_disk.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskRefreshPool(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    VIR_FREE(def->source.devices[0].freeExtents);\n    def->source.devices[0].nfreeExtent = 0;\n\n    virWaitForDevices();\n\n    if (!virFileExists(def->source.devices[0].path)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"device path '%s' doesn't exist\"),\n                       def->source.devices[0].path);\n        return -1;\n    }\n\n    if (virStorageBackendDiskReadGeometry(pool) != 0)\n        return -1;\n\n    return virStorageBackendDiskReadPartitions(pool, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjClearVols",
          "args": [
            "pool"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjClearVols",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "629-638",
          "snippet": "void\nvirStoragePoolObjClearVols(virStoragePoolObjPtr obj)\n{\n    if (!obj->volumes)\n        return;\n\n    virHashRemoveAll(obj->volumes->objsKey);\n    virHashRemoveAll(obj->volumes->objsName);\n    virHashRemoveAll(obj->volumes->objsPath);\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvoid\nvirStoragePoolObjClearVols(virStoragePoolObjPtr obj)\n{\n    if (!obj->volumes)\n        return;\n\n    virHashRemoveAll(obj->volumes->objsKey);\n    virHashRemoveAll(obj->volumes->objsName);\n    virHashRemoveAll(obj->volumes->objsPath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "PARTED",
            "src_path",
            "\"rm\"",
            "\"--script\"",
            "part_num",
            "NULL"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"cannot parse partition number from target \"\n                         \"'%s'\")",
            "dev_name"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot parse partition number from target \"\n                         \"'%s'\""
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "srcname"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Volume path '%s' did not start with parent \"\n                         \"pool source device name.\")",
            "dev_name"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "dev_name",
            "srcname"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"dev_name=%s, srcname=%s\"",
            "dev_name",
            "srcname"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_path_get_basename",
          "args": [
            "devpath"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Couldn't read volume target path '%s'\")",
            "vol->target.path"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileResolveLink",
          "args": [
            "vol->target.path",
            "&devpath"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "virFileResolveLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1608-1612",
          "snippet": "int\nvirFileResolveLink(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, false, resultpath);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileResolveLink(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, false, resultpath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_path_get_basename",
          "args": [
            "vol->target.path"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virIsDevMapperDevice",
          "args": [
            "vol->target.path"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "virIsDevMapperDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1357-1360",
          "snippet": "bool virIsDevMapperDevice(const char *dev_name G_GNUC_UNUSED)\n{\n    return false;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nbool virIsDevMapperDevice(const char *dev_name G_GNUC_UNUSED)\n{\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"volume target path empty for source path '%s'\")",
            "src_path"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_path_get_basename",
          "args": [
            "src_path"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskDeleteVol(virStoragePoolObjPtr pool,\n                               virStorageVolDefPtr vol,\n                               unsigned int flags)\n{\n    char *part_num = NULL;\n    g_autofree char *dev_name = NULL;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    char *src_path = def->source.devices[0].path;\n    g_autofree char *srcname = g_path_get_basename(src_path);\n    bool isDevMapperDevice;\n    g_autofree char *devpath = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (!vol->target.path) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"volume target path empty for source path '%s'\"),\n                      src_path);\n        return -1;\n    }\n\n    /* NB: This is the corollary to the algorithm in libvirt_parthelper\n     *     (parthelper.c) that is used to generate the target.path name\n     *     for use by libvirt. Changes to either, need to be reflected\n     *     in both places */\n    isDevMapperDevice = virIsDevMapperDevice(vol->target.path);\n    if (isDevMapperDevice) {\n        dev_name = g_path_get_basename(vol->target.path);\n    } else {\n        if (virFileResolveLink(vol->target.path, &devpath) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Couldn't read volume target path '%s'\"),\n                                 vol->target.path);\n            return -1;\n        }\n        dev_name = g_path_get_basename(devpath);\n    }\n\n    VIR_DEBUG(\"dev_name=%s, srcname=%s\", dev_name, srcname);\n\n    if (!STRPREFIX(dev_name, srcname)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' did not start with parent \"\n                         \"pool source device name.\"), dev_name);\n        return -1;\n    }\n\n    part_num = dev_name + strlen(srcname);\n\n    /* For device mapper and we have a partition character 'p' as the\n     * current character, let's move beyond that before checking part_num */\n    if (isDevMapperDevice && *part_num == 'p')\n        part_num++;\n\n    if (*part_num == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot parse partition number from target \"\n                         \"'%s'\"), dev_name);\n        return -1;\n    }\n\n    /* eg parted /dev/sda rm 2 or /dev/mapper/mpathc rm 2 */\n    cmd = virCommandNewArgList(PARTED,\n                               src_path,\n                               \"rm\",\n                               \"--script\",\n                               part_num,\n                               NULL);\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    /* Refreshing the pool is the easiest option as LOGICAL and EXTENDED\n     * partition allocation/capacity management is handled within\n     * virStorageBackendDiskMakeDataVol and trying to redo that logic\n     * here is pointless\n     */\n    virStoragePoolObjClearVols(pool);\n    if (virStorageBackendDiskRefreshPool(pool) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendDiskPartBoundaries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "660-747",
    "snippet": "static int\nvirStorageBackendDiskPartBoundaries(virStoragePoolObjPtr pool,\n                                    unsigned long long *start,\n                                    unsigned long long *end,\n                                    unsigned long long allocation)\n{\n    size_t i;\n    int smallestExtent = -1;\n    unsigned long long smallestSize = 0;\n    unsigned long long extraBytes = 0;\n    unsigned long long alignedAllocation = allocation;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStoragePoolSourceDevicePtr dev = &def->source.devices[0];\n    unsigned long long cylinderSize = (unsigned long long)dev->geometry.heads *\n                                      dev->geometry.sectors * SECTOR_SIZE;\n\n    VIR_DEBUG(\"find free area: allocation %llu, cyl size %llu\", allocation,\n          cylinderSize);\n    int partType = virStorageBackendDiskPartTypeToCreate(pool);\n\n    /* how many extra bytes we have since we allocate\n       aligned to the cylinder boundary */\n    extraBytes = cylinderSize - (allocation % cylinderSize);\n\n    for (i = 0; i < dev->nfreeExtent; i++) {\n         unsigned long long size =\n             dev->freeExtents[i].end -\n             dev->freeExtents[i].start;\n         unsigned long long neededSize = allocation;\n\n         if (def->source.format == VIR_STORAGE_POOL_DISK_DOS) {\n             /* align to cylinder boundary */\n             neededSize += extraBytes;\n             if ((*start % cylinderSize) > extraBytes) {\n                 /* add an extra cylinder if the offset can't fit within\n                    the extra bytes we have */\n                 neededSize += cylinderSize;\n             }\n             /* if we are creating a logical partition, we need one extra\n                block between partitions (or actually move start one block) */\n             if (partType == VIR_STORAGE_VOL_DISK_TYPE_LOGICAL)\n                 size -= SECTOR_SIZE;\n         }\n         if (size > neededSize &&\n             (smallestSize == 0 ||\n             size < smallestSize)) {\n             /* for logical partition, the free extent\n                must be within a logical free area */\n             if (partType == VIR_STORAGE_VOL_DISK_TYPE_LOGICAL &&\n                 dev->freeExtents[i].type != VIR_STORAGE_FREE_LOGICAL) {\n                 continue;\n                 /* for primary partition, the free extent\n                    must not be within a logical free area */\n             } else if (partType == VIR_STORAGE_VOL_DISK_TYPE_PRIMARY &&\n                        dev->freeExtents[i].type != VIR_STORAGE_FREE_NORMAL) {\n                 continue;\n             }\n             smallestSize = size;\n             smallestExtent = i;\n             alignedAllocation = neededSize;\n         }\n    }\n\n    if (smallestExtent == -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"no large enough free extent\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"aligned alloc %llu\", alignedAllocation);\n    *start = dev->freeExtents[smallestExtent].start;\n\n    if (partType == VIR_STORAGE_VOL_DISK_TYPE_LOGICAL) {\n        /* for logical partition, skip one block */\n        *start += SECTOR_SIZE;\n    }\n\n    *end = *start + alignedAllocation;\n    if (def->source.format == VIR_STORAGE_POOL_DISK_DOS) {\n        /* adjust our allocation if start is not at a cylinder boundary */\n        *end -= (*start % cylinderSize);\n    }\n\n    /* counting in bytes, we want the last byte of the current sector */\n    *end -= 1;\n    VIR_DEBUG(\"final aligned start %llu, end %llu\", *start, *end);\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECTOR_SIZE 512"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"final aligned start %llu, end %llu\"",
            "*start",
            "*end"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"aligned alloc %llu\"",
            "alignedAllocation"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no large enough free extent\")"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no large enough free extent\""
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendDiskPartTypeToCreate",
          "args": [
            "pool"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendDiskPartTypeToCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
          "lines": "575-593",
          "snippet": "static int\nvirStorageBackendDiskPartTypeToCreate(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct virStorageVolNumData data = { .count = 0 };\n\n    if (def->source.format == VIR_STORAGE_POOL_DISK_DOS) {\n        /* count primary and extended partitions,\n           can't be more than 3 to create a new primary partition */\n        if (virStoragePoolObjForEachVolume(pool, virStorageVolNumOfPartTypes,\n                                           &data) == 0) {\n            if (data.count >= 4)\n                return VIR_STORAGE_VOL_DISK_TYPE_LOGICAL;\n        }\n    }\n\n    /* for all other cases, all partitions are primary */\n    return VIR_STORAGE_VOL_DISK_TYPE_PRIMARY;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_disk.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskPartTypeToCreate(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct virStorageVolNumData data = { .count = 0 };\n\n    if (def->source.format == VIR_STORAGE_POOL_DISK_DOS) {\n        /* count primary and extended partitions,\n           can't be more than 3 to create a new primary partition */\n        if (virStoragePoolObjForEachVolume(pool, virStorageVolNumOfPartTypes,\n                                           &data) == 0) {\n            if (data.count >= 4)\n                return VIR_STORAGE_VOL_DISK_TYPE_LOGICAL;\n        }\n    }\n\n    /* for all other cases, all partitions are primary */\n    return VIR_STORAGE_VOL_DISK_TYPE_PRIMARY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"find free area: allocation %llu, cyl size %llu\"",
            "allocation",
            "cylinderSize"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\n#define SECTOR_SIZE 512\n\nstatic int\nvirStorageBackendDiskPartBoundaries(virStoragePoolObjPtr pool,\n                                    unsigned long long *start,\n                                    unsigned long long *end,\n                                    unsigned long long allocation)\n{\n    size_t i;\n    int smallestExtent = -1;\n    unsigned long long smallestSize = 0;\n    unsigned long long extraBytes = 0;\n    unsigned long long alignedAllocation = allocation;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStoragePoolSourceDevicePtr dev = &def->source.devices[0];\n    unsigned long long cylinderSize = (unsigned long long)dev->geometry.heads *\n                                      dev->geometry.sectors * SECTOR_SIZE;\n\n    VIR_DEBUG(\"find free area: allocation %llu, cyl size %llu\", allocation,\n          cylinderSize);\n    int partType = virStorageBackendDiskPartTypeToCreate(pool);\n\n    /* how many extra bytes we have since we allocate\n       aligned to the cylinder boundary */\n    extraBytes = cylinderSize - (allocation % cylinderSize);\n\n    for (i = 0; i < dev->nfreeExtent; i++) {\n         unsigned long long size =\n             dev->freeExtents[i].end -\n             dev->freeExtents[i].start;\n         unsigned long long neededSize = allocation;\n\n         if (def->source.format == VIR_STORAGE_POOL_DISK_DOS) {\n             /* align to cylinder boundary */\n             neededSize += extraBytes;\n             if ((*start % cylinderSize) > extraBytes) {\n                 /* add an extra cylinder if the offset can't fit within\n                    the extra bytes we have */\n                 neededSize += cylinderSize;\n             }\n             /* if we are creating a logical partition, we need one extra\n                block between partitions (or actually move start one block) */\n             if (partType == VIR_STORAGE_VOL_DISK_TYPE_LOGICAL)\n                 size -= SECTOR_SIZE;\n         }\n         if (size > neededSize &&\n             (smallestSize == 0 ||\n             size < smallestSize)) {\n             /* for logical partition, the free extent\n                must be within a logical free area */\n             if (partType == VIR_STORAGE_VOL_DISK_TYPE_LOGICAL &&\n                 dev->freeExtents[i].type != VIR_STORAGE_FREE_LOGICAL) {\n                 continue;\n                 /* for primary partition, the free extent\n                    must not be within a logical free area */\n             } else if (partType == VIR_STORAGE_VOL_DISK_TYPE_PRIMARY &&\n                        dev->freeExtents[i].type != VIR_STORAGE_FREE_NORMAL) {\n                 continue;\n             }\n             smallestSize = size;\n             smallestExtent = i;\n             alignedAllocation = neededSize;\n         }\n    }\n\n    if (smallestExtent == -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"no large enough free extent\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"aligned alloc %llu\", alignedAllocation);\n    *start = dev->freeExtents[smallestExtent].start;\n\n    if (partType == VIR_STORAGE_VOL_DISK_TYPE_LOGICAL) {\n        /* for logical partition, skip one block */\n        *start += SECTOR_SIZE;\n    }\n\n    *end = *start + alignedAllocation;\n    if (def->source.format == VIR_STORAGE_POOL_DISK_DOS) {\n        /* adjust our allocation if start is not at a cylinder boundary */\n        *end -= (*start % cylinderSize);\n    }\n\n    /* counting in bytes, we want the last byte of the current sector */\n    *end -= 1;\n    VIR_DEBUG(\"final aligned start %llu, end %llu\", *start, *end);\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendDiskPartFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "595-652",
    "snippet": "static int\nvirStorageBackendDiskPartFormat(virStoragePoolObjPtr pool,\n                                virStorageVolDefPtr vol,\n                                char** partFormat)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    if (def->source.format == VIR_STORAGE_POOL_DISK_DOS) {\n        const char *partedFormat;\n        partedFormat = virStoragePartedFsTypeToString(vol->target.format);\n        if (partedFormat == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"Invalid partition type\"));\n            return -1;\n        }\n        if (vol->target.format == VIR_STORAGE_VOL_DISK_EXTENDED) {\n            /* make sure we don't have an extended partition already */\n            if (virStoragePoolObjSearchVolume(pool,\n                                              virStorageVolPartFindExtended,\n                                              NULL)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"extended partition already exists\"));\n                    return -1;\n            }\n            *partFormat = g_strdup(partedFormat);\n        } else {\n            /* create primary partition as long as it is possible\n               and after that check if an extended partition exists\n               to create logical partitions. */\n            /* XXX Only support one extended partition */\n            switch (virStorageBackendDiskPartTypeToCreate(pool)) {\n            case VIR_STORAGE_VOL_DISK_TYPE_PRIMARY:\n                *partFormat = g_strdup_printf(\"primary %s\", partedFormat);\n                break;\n            case VIR_STORAGE_VOL_DISK_TYPE_LOGICAL:\n                /* make sure we have an extended partition */\n                if (virStoragePoolObjSearchVolume(pool,\n                                                  virStorageVolPartFindExtended,\n                                                  NULL)) {\n                    *partFormat = g_strdup_printf(\"logical %s\", partedFormat);\n                } else {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"no extended partition found and no \"\n                                     \"primary partition available\"));\n                    return -1;\n                }\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               \"%s\", _(\"unknown partition type\"));\n                return -1;\n            }\n        }\n    } else {\n        *partFormat = g_strdup(\"primary\");\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"primary\""
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"unknown partition type\")"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no extended partition found and no \"\n                                     \"primary partition available\")"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjSearchVolume",
          "args": [
            "pool",
            "virStorageVolPartFindExtended",
            "NULL"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjSearchVolume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "787-806",
          "snippet": "virStorageVolDefPtr\nvirStoragePoolObjSearchVolume(virStoragePoolObjPtr obj,\n                              virStorageVolObjListSearcher iter,\n                              const void *opaque)\n{\n    virStorageVolObjPtr volobj;\n    struct _virStoragePoolObjSearchVolData data = {\n        .iter = iter, .opaque = opaque };\n\n    virObjectRWLockRead(obj->volumes);\n    volobj = virHashSearch(obj->volumes->objsKey,\n                           virStoragePoolObjSearchVolumeCb,\n                           &data, NULL);\n    virObjectRWUnlock(obj->volumes);\n\n    if (volobj)\n        return volobj->voldef;\n\n    return NULL;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nvirStoragePoolObjDispose(void *opaque);",
            "static void\nvirStoragePoolObjListDispose(void *opaque);",
            "static void\nvirStorageVolObjDispose(void *opaque);",
            "static void\nvirStorageVolObjListDispose(void *opaque);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void\nvirStoragePoolObjDispose(void *opaque);\nstatic void\nvirStoragePoolObjListDispose(void *opaque);\nstatic void\nvirStorageVolObjDispose(void *opaque);\nstatic void\nvirStorageVolObjListDispose(void *opaque);\n\nvirStorageVolDefPtr\nvirStoragePoolObjSearchVolume(virStoragePoolObjPtr obj,\n                              virStorageVolObjListSearcher iter,\n                              const void *opaque)\n{\n    virStorageVolObjPtr volobj;\n    struct _virStoragePoolObjSearchVolData data = {\n        .iter = iter, .opaque = opaque };\n\n    virObjectRWLockRead(obj->volumes);\n    volobj = virHashSearch(obj->volumes->objsKey,\n                           virStoragePoolObjSearchVolumeCb,\n                           &data, NULL);\n    virObjectRWUnlock(obj->volumes);\n\n    if (volobj)\n        return volobj->voldef;\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendDiskPartTypeToCreate",
          "args": [
            "pool"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendDiskPartTypeToCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
          "lines": "575-593",
          "snippet": "static int\nvirStorageBackendDiskPartTypeToCreate(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct virStorageVolNumData data = { .count = 0 };\n\n    if (def->source.format == VIR_STORAGE_POOL_DISK_DOS) {\n        /* count primary and extended partitions,\n           can't be more than 3 to create a new primary partition */\n        if (virStoragePoolObjForEachVolume(pool, virStorageVolNumOfPartTypes,\n                                           &data) == 0) {\n            if (data.count >= 4)\n                return VIR_STORAGE_VOL_DISK_TYPE_LOGICAL;\n        }\n    }\n\n    /* for all other cases, all partitions are primary */\n    return VIR_STORAGE_VOL_DISK_TYPE_PRIMARY;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_disk.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskPartTypeToCreate(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct virStorageVolNumData data = { .count = 0 };\n\n    if (def->source.format == VIR_STORAGE_POOL_DISK_DOS) {\n        /* count primary and extended partitions,\n           can't be more than 3 to create a new primary partition */\n        if (virStoragePoolObjForEachVolume(pool, virStorageVolNumOfPartTypes,\n                                           &data) == 0) {\n            if (data.count >= 4)\n                return VIR_STORAGE_VOL_DISK_TYPE_LOGICAL;\n        }\n    }\n\n    /* for all other cases, all partitions are primary */\n    return VIR_STORAGE_VOL_DISK_TYPE_PRIMARY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"extended partition already exists\")"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid partition type\")"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePartedFsTypeToString",
          "args": [
            "vol->target.format"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskPartFormat(virStoragePoolObjPtr pool,\n                                virStorageVolDefPtr vol,\n                                char** partFormat)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    if (def->source.format == VIR_STORAGE_POOL_DISK_DOS) {\n        const char *partedFormat;\n        partedFormat = virStoragePartedFsTypeToString(vol->target.format);\n        if (partedFormat == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"Invalid partition type\"));\n            return -1;\n        }\n        if (vol->target.format == VIR_STORAGE_VOL_DISK_EXTENDED) {\n            /* make sure we don't have an extended partition already */\n            if (virStoragePoolObjSearchVolume(pool,\n                                              virStorageVolPartFindExtended,\n                                              NULL)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"extended partition already exists\"));\n                    return -1;\n            }\n            *partFormat = g_strdup(partedFormat);\n        } else {\n            /* create primary partition as long as it is possible\n               and after that check if an extended partition exists\n               to create logical partitions. */\n            /* XXX Only support one extended partition */\n            switch (virStorageBackendDiskPartTypeToCreate(pool)) {\n            case VIR_STORAGE_VOL_DISK_TYPE_PRIMARY:\n                *partFormat = g_strdup_printf(\"primary %s\", partedFormat);\n                break;\n            case VIR_STORAGE_VOL_DISK_TYPE_LOGICAL:\n                /* make sure we have an extended partition */\n                if (virStoragePoolObjSearchVolume(pool,\n                                                  virStorageVolPartFindExtended,\n                                                  NULL)) {\n                    *partFormat = g_strdup_printf(\"logical %s\", partedFormat);\n                } else {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"no extended partition found and no \"\n                                     \"primary partition available\"));\n                    return -1;\n                }\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               \"%s\", _(\"unknown partition type\"));\n                return -1;\n            }\n        }\n    } else {\n        *partFormat = g_strdup(\"primary\");\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendDiskPartTypeToCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "575-593",
    "snippet": "static int\nvirStorageBackendDiskPartTypeToCreate(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct virStorageVolNumData data = { .count = 0 };\n\n    if (def->source.format == VIR_STORAGE_POOL_DISK_DOS) {\n        /* count primary and extended partitions,\n           can't be more than 3 to create a new primary partition */\n        if (virStoragePoolObjForEachVolume(pool, virStorageVolNumOfPartTypes,\n                                           &data) == 0) {\n            if (data.count >= 4)\n                return VIR_STORAGE_VOL_DISK_TYPE_LOGICAL;\n        }\n    }\n\n    /* for all other cases, all partitions are primary */\n    return VIR_STORAGE_VOL_DISK_TYPE_PRIMARY;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStoragePoolObjForEachVolume",
          "args": [
            "pool",
            "virStorageVolNumOfPartTypes",
            "&data"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjForEachVolume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "747-760",
          "snippet": "int\nvirStoragePoolObjForEachVolume(virStoragePoolObjPtr obj,\n                               virStorageVolObjListIterator iter,\n                               const void *opaque)\n{\n    struct _virStoragePoolObjForEachVolData data = {\n        .iter = iter, .opaque = opaque };\n\n    virObjectRWLockRead(obj->volumes);\n    virHashForEach(obj->volumes->objsKey, virStoragePoolObjForEachVolumeCb,\n                   &data);\n    virObjectRWUnlock(obj->volumes);\n    return 0;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nvirStoragePoolObjDispose(void *opaque);",
            "static void\nvirStoragePoolObjListDispose(void *opaque);",
            "static void\nvirStorageVolObjDispose(void *opaque);",
            "static void\nvirStorageVolObjListDispose(void *opaque);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void\nvirStoragePoolObjDispose(void *opaque);\nstatic void\nvirStoragePoolObjListDispose(void *opaque);\nstatic void\nvirStorageVolObjDispose(void *opaque);\nstatic void\nvirStorageVolObjListDispose(void *opaque);\n\nint\nvirStoragePoolObjForEachVolume(virStoragePoolObjPtr obj,\n                               virStorageVolObjListIterator iter,\n                               const void *opaque)\n{\n    struct _virStoragePoolObjForEachVolData data = {\n        .iter = iter, .opaque = opaque };\n\n    virObjectRWLockRead(obj->volumes);\n    virHashForEach(obj->volumes->objsKey, virStoragePoolObjForEachVolumeCb,\n                   &data);\n    virObjectRWUnlock(obj->volumes);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskPartTypeToCreate(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct virStorageVolNumData data = { .count = 0 };\n\n    if (def->source.format == VIR_STORAGE_POOL_DISK_DOS) {\n        /* count primary and extended partitions,\n           can't be more than 3 to create a new primary partition */\n        if (virStoragePoolObjForEachVolume(pool, virStorageVolNumOfPartTypes,\n                                           &data) == 0) {\n            if (data.count >= 4)\n                return VIR_STORAGE_VOL_DISK_TYPE_LOGICAL;\n        }\n    }\n\n    /* for all other cases, all partitions are primary */\n    return VIR_STORAGE_VOL_DISK_TYPE_PRIMARY;\n}"
  },
  {
    "function_name": "virStorageVolNumOfPartTypes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "557-568",
    "snippet": "static int\nvirStorageVolNumOfPartTypes(virStorageVolDefPtr def,\n                            const void *opaque)\n{\n    struct virStorageVolNumData *data = (struct virStorageVolNumData *)opaque;\n\n    if (def->source.partType == VIR_STORAGE_VOL_DISK_TYPE_PRIMARY ||\n        def->source.partType == VIR_STORAGE_VOL_DISK_TYPE_EXTENDED)\n        data->count++;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageVolNumOfPartTypes(virStorageVolDefPtr def,\n                            const void *opaque)\n{\n    struct virStorageVolNumData *data = (struct virStorageVolNumData *)opaque;\n\n    if (def->source.partType == VIR_STORAGE_VOL_DISK_TYPE_PRIMARY ||\n        def->source.partType == VIR_STORAGE_VOL_DISK_TYPE_EXTENDED)\n        data->count++;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendDiskDeletePool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "537-550",
    "snippet": "static int\nvirStorageBackendDiskDeletePool(virStoragePoolObjPtr pool,\n                                unsigned int flags)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    virCheckFlags(0, -1);\n\n    if (virStorageBackendZeroPartitionTable(def->source.devices[0].path,\n                                            1024 * 1024) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendZeroPartitionTable",
          "args": [
            "def->source.devices[0].path",
            "1024 * 1024"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendZeroPartitionTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "4014-4024",
          "snippet": "int\nvirStorageBackendZeroPartitionTable(const char *path,\n                                    unsigned long long size)\n{\n    if (storageBackendVolWipeLocalFile(path, VIR_STORAGE_VOL_WIPE_ALG_ZERO,\n                                       size, false) < 0)\n        return -1;\n\n    return storageBackendVolWipeLocalFile(path, VIR_STORAGE_VOL_WIPE_ALG_ZERO,\n                                          size, true);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendZeroPartitionTable(const char *path,\n                                    unsigned long long size)\n{\n    if (storageBackendVolWipeLocalFile(path, VIR_STORAGE_VOL_WIPE_ALG_ZERO,\n                                       size, false) < 0)\n        return -1;\n\n    return storageBackendVolWipeLocalFile(path, VIR_STORAGE_VOL_WIPE_ALG_ZERO,\n                                          size, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskDeletePool(virStoragePoolObjPtr pool,\n                                unsigned int flags)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    virCheckFlags(0, -1);\n\n    if (virStorageBackendZeroPartitionTable(def->source.devices[0].path,\n                                            1024 * 1024) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendDiskBuildPool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "483-531",
    "snippet": "static int\nvirStorageBackendDiskBuildPool(virStoragePoolObjPtr pool,\n                               unsigned int flags)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    int format = def->source.format;\n    const char *fmt;\n    g_autoptr(virCommand) cmd = NULL;\n    int ret = -1;\n\n    virCheckFlags(VIR_STORAGE_POOL_BUILD_OVERWRITE |\n                  VIR_STORAGE_POOL_BUILD_NO_OVERWRITE, -1);\n\n    VIR_EXCLUSIVE_FLAGS_RET(VIR_STORAGE_POOL_BUILD_OVERWRITE,\n                            VIR_STORAGE_POOL_BUILD_NO_OVERWRITE,\n                            -1);\n\n    fmt = virStoragePoolFormatDiskTypeToString(format);\n\n    if (!(flags & VIR_STORAGE_POOL_BUILD_OVERWRITE) &&\n        !(virStorageBackendDeviceIsEmpty(def->source.devices[0].path,\n                                         fmt, true)))\n        return -1;\n\n    if (virStorageBackendZeroPartitionTable(def->source.devices[0].path,\n                                            1024 * 1024) < 0)\n        return -1;\n\n    /* eg parted /dev/sda mklabel --script msdos */\n    if (format == VIR_STORAGE_POOL_DISK_UNKNOWN)\n        format = def->source.format = VIR_STORAGE_POOL_DISK_DOS;\n    if (format == VIR_STORAGE_POOL_DISK_DOS)\n        fmt = \"msdos\";\n    else\n        fmt = virStoragePoolFormatDiskTypeToString(format);\n\n    cmd = virCommandNewArgList(PARTED,\n                               def->source.devices[0].path,\n                               \"mklabel\",\n                               \"--script\",\n                               fmt,\n                               NULL);\n\n    virObjectUnlock(pool);\n    ret = virCommandRun(cmd, NULL);\n    virObjectLock(pool);\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "pool"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "pool"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "PARTED",
            "def->source.devices[0].path",
            "\"mklabel\"",
            "\"--script\"",
            "fmt",
            "NULL"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolFormatDiskTypeToString",
          "args": [
            "format"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendZeroPartitionTable",
          "args": [
            "def->source.devices[0].path",
            "1024 * 1024"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendZeroPartitionTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "4014-4024",
          "snippet": "int\nvirStorageBackendZeroPartitionTable(const char *path,\n                                    unsigned long long size)\n{\n    if (storageBackendVolWipeLocalFile(path, VIR_STORAGE_VOL_WIPE_ALG_ZERO,\n                                       size, false) < 0)\n        return -1;\n\n    return storageBackendVolWipeLocalFile(path, VIR_STORAGE_VOL_WIPE_ALG_ZERO,\n                                          size, true);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendZeroPartitionTable(const char *path,\n                                    unsigned long long size)\n{\n    if (storageBackendVolWipeLocalFile(path, VIR_STORAGE_VOL_WIPE_ALG_ZERO,\n                                       size, false) < 0)\n        return -1;\n\n    return storageBackendVolWipeLocalFile(path, VIR_STORAGE_VOL_WIPE_ALG_ZERO,\n                                          size, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendDeviceIsEmpty",
          "args": [
            "def->source.devices[0].path",
            "fmt",
            "true"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendDeviceIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "3304-3326",
          "snippet": "bool\nvirStorageBackendDeviceIsEmpty(const char *devpath,\n                               const char *format,\n                               bool writelabel)\n{\n    int ret;\n\n    if ((ret = virStorageBackendBLKIDFindEmpty(devpath, format,\n                                               writelabel)) == -2)\n        ret = virStorageBackendPARTEDValidLabel(devpath, format, writelabel);\n\n    if (ret == -2 && !writelabel)\n        ret = 0;\n\n    if (ret == -2) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Unable to probe '%s' for existing data, \"\n                         \"forced overwrite is necessary\"),\n                       devpath);\n    }\n\n    return ret == 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirStorageBackendDeviceIsEmpty(const char *devpath,\n                               const char *format,\n                               bool writelabel)\n{\n    int ret;\n\n    if ((ret = virStorageBackendBLKIDFindEmpty(devpath, format,\n                                               writelabel)) == -2)\n        ret = virStorageBackendPARTEDValidLabel(devpath, format, writelabel);\n\n    if (ret == -2 && !writelabel)\n        ret = 0;\n\n    if (ret == -2) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Unable to probe '%s' for existing data, \"\n                         \"forced overwrite is necessary\"),\n                       devpath);\n    }\n\n    return ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolFormatDiskTypeToString",
          "args": [
            "format"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXCLUSIVE_FLAGS_RET",
          "args": [
            "VIR_STORAGE_POOL_BUILD_OVERWRITE",
            "VIR_STORAGE_POOL_BUILD_NO_OVERWRITE",
            "-1"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_STORAGE_POOL_BUILD_OVERWRITE |\n                  VIR_STORAGE_POOL_BUILD_NO_OVERWRITE",
            "-1"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskBuildPool(virStoragePoolObjPtr pool,\n                               unsigned int flags)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    int format = def->source.format;\n    const char *fmt;\n    g_autoptr(virCommand) cmd = NULL;\n    int ret = -1;\n\n    virCheckFlags(VIR_STORAGE_POOL_BUILD_OVERWRITE |\n                  VIR_STORAGE_POOL_BUILD_NO_OVERWRITE, -1);\n\n    VIR_EXCLUSIVE_FLAGS_RET(VIR_STORAGE_POOL_BUILD_OVERWRITE,\n                            VIR_STORAGE_POOL_BUILD_NO_OVERWRITE,\n                            -1);\n\n    fmt = virStoragePoolFormatDiskTypeToString(format);\n\n    if (!(flags & VIR_STORAGE_POOL_BUILD_OVERWRITE) &&\n        !(virStorageBackendDeviceIsEmpty(def->source.devices[0].path,\n                                         fmt, true)))\n        return -1;\n\n    if (virStorageBackendZeroPartitionTable(def->source.devices[0].path,\n                                            1024 * 1024) < 0)\n        return -1;\n\n    /* eg parted /dev/sda mklabel --script msdos */\n    if (format == VIR_STORAGE_POOL_DISK_UNKNOWN)\n        format = def->source.format = VIR_STORAGE_POOL_DISK_DOS;\n    if (format == VIR_STORAGE_POOL_DISK_DOS)\n        fmt = \"msdos\";\n    else\n        fmt = virStoragePoolFormatDiskTypeToString(format);\n\n    cmd = virCommandNewArgList(PARTED,\n                               def->source.devices[0].path,\n                               \"mklabel\",\n                               \"--script\",\n                               fmt,\n                               NULL);\n\n    virObjectUnlock(pool);\n    ret = virCommandRun(cmd, NULL);\n    virObjectLock(pool);\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendDiskStartPool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "452-477",
    "snippet": "static int\nvirStorageBackendDiskStartPool(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    const char *format;\n    const char *path = def->source.devices[0].path;\n\n    /* This can take a significant amount of time. */\n    virObjectUnlock(pool);\n    virWaitForDevices();\n    virObjectLock(pool);\n\n    if (!virFileExists(path)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"device path '%s' doesn't exist\"), path);\n        return -1;\n    }\n\n    if (def->source.format == VIR_STORAGE_POOL_DISK_UNKNOWN)\n        def->source.format = VIR_STORAGE_POOL_DISK_DOS;\n    format = virStoragePoolFormatDiskTypeToString(def->source.format);\n    if (!virStorageBackendDeviceIsEmpty(path, format, false))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendDeviceIsEmpty",
          "args": [
            "path",
            "format",
            "false"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendDeviceIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "3304-3326",
          "snippet": "bool\nvirStorageBackendDeviceIsEmpty(const char *devpath,\n                               const char *format,\n                               bool writelabel)\n{\n    int ret;\n\n    if ((ret = virStorageBackendBLKIDFindEmpty(devpath, format,\n                                               writelabel)) == -2)\n        ret = virStorageBackendPARTEDValidLabel(devpath, format, writelabel);\n\n    if (ret == -2 && !writelabel)\n        ret = 0;\n\n    if (ret == -2) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Unable to probe '%s' for existing data, \"\n                         \"forced overwrite is necessary\"),\n                       devpath);\n    }\n\n    return ret == 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirStorageBackendDeviceIsEmpty(const char *devpath,\n                               const char *format,\n                               bool writelabel)\n{\n    int ret;\n\n    if ((ret = virStorageBackendBLKIDFindEmpty(devpath, format,\n                                               writelabel)) == -2)\n        ret = virStorageBackendPARTEDValidLabel(devpath, format, writelabel);\n\n    if (ret == -2 && !writelabel)\n        ret = 0;\n\n    if (ret == -2) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Unable to probe '%s' for existing data, \"\n                         \"forced overwrite is necessary\"),\n                       devpath);\n    }\n\n    return ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolFormatDiskTypeToString",
          "args": [
            "def->source.format"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"device path '%s' doesn't exist\")",
            "path"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"device path '%s' doesn't exist\""
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "path"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "pool"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virWaitForDevices",
          "args": [],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "virWaitForDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1324-1341",
          "snippet": "void virWaitForDevices(void)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *udev = NULL;\n    int exitstatus;\n\n    if (!(udev = virFindFileInPath(UDEVADM)))\n        return;\n\n    if (!(cmd = virCommandNewArgList(udev, \"settle\", NULL)))\n        return;\n\n    /*\n     * NOTE: we ignore errors here; this is just to make sure that any device\n     * nodes that are being created finish before we try to scan them.\n     */\n    ignore_value(virCommandRun(cmd, &exitstatus));\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virWaitForDevices(void)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *udev = NULL;\n    int exitstatus;\n\n    if (!(udev = virFindFileInPath(UDEVADM)))\n        return;\n\n    if (!(cmd = virCommandNewArgList(udev, \"settle\", NULL)))\n        return;\n\n    /*\n     * NOTE: we ignore errors here; this is just to make sure that any device\n     * nodes that are being created finish before we try to scan them.\n     */\n    ignore_value(virCommandRun(cmd, &exitstatus));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "pool"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskStartPool(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    const char *format;\n    const char *path = def->source.devices[0].path;\n\n    /* This can take a significant amount of time. */\n    virObjectUnlock(pool);\n    virWaitForDevices();\n    virObjectLock(pool);\n\n    if (!virFileExists(path)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"device path '%s' doesn't exist\"), path);\n        return -1;\n    }\n\n    if (def->source.format == VIR_STORAGE_POOL_DISK_UNKNOWN)\n        def->source.format = VIR_STORAGE_POOL_DISK_DOS;\n    format = virStoragePoolFormatDiskTypeToString(def->source.format);\n    if (!virStorageBackendDeviceIsEmpty(path, format, false))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendDiskRefreshPool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "428-449",
    "snippet": "static int\nvirStorageBackendDiskRefreshPool(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    VIR_FREE(def->source.devices[0].freeExtents);\n    def->source.devices[0].nfreeExtent = 0;\n\n    virWaitForDevices();\n\n    if (!virFileExists(def->source.devices[0].path)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"device path '%s' doesn't exist\"),\n                       def->source.devices[0].path);\n        return -1;\n    }\n\n    if (virStorageBackendDiskReadGeometry(pool) != 0)\n        return -1;\n\n    return virStorageBackendDiskReadPartitions(pool, NULL);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendDiskReadPartitions",
          "args": [
            "pool",
            "NULL"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendDiskReadPartitions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
          "lines": "340-386",
          "snippet": "static int\nvirStorageBackendDiskReadPartitions(virStoragePoolObjPtr pool,\n                                    virStorageVolDefPtr vol)\n{\n    /*\n     *  # libvirt_parthelper DEVICE\n     * /dev/sda1      normal       data        32256    106928128    106896384\n     * /dev/sda2      normal       data    106928640 100027629568  99920701440\n     * -              normal   metadata 100027630080 100030242304      2612736\n     *\n     */\n\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct virStorageBackendDiskPoolVolData cbdata = {\n        .pool = pool,\n        .vol = vol,\n    };\n    g_autofree char *parthelper_path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (!(parthelper_path = virFileFindResource(\"libvirt_parthelper\",\n                                                abs_top_builddir \"/src\",\n                                                LIBEXECDIR)))\n        return -1;\n\n    cmd = virCommandNewArgList(parthelper_path,\n                               def->source.devices[0].path,\n                               NULL);\n\n    /* Check for the presence of the part_separator='yes'. Pass this\n     * along to the libvirt_parthelper as option '-p'. This will cause\n     * libvirt_parthelper to append the \"p\" partition separator to\n     * the generated device name for a source device which ends with\n     * a non-numeric value (e.g. mpatha would generate mpathap#).\n     */\n    if (def->source.devices[0].part_separator == VIR_TRISTATE_BOOL_YES)\n        virCommandAddArg(cmd, \"-p\");\n\n    /* If a volume is passed, virStorageBackendDiskMakeVol only updates the\n     * pool allocation for that single volume.\n     */\n    if (!vol)\n        def->allocation = 0;\n    def->capacity = def->available = 0;\n\n    return virCommandRunNul(cmd, 6, virStorageBackendDiskMakeVol, &cbdata);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_disk.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskReadPartitions(virStoragePoolObjPtr pool,\n                                    virStorageVolDefPtr vol)\n{\n    /*\n     *  # libvirt_parthelper DEVICE\n     * /dev/sda1      normal       data        32256    106928128    106896384\n     * /dev/sda2      normal       data    106928640 100027629568  99920701440\n     * -              normal   metadata 100027630080 100030242304      2612736\n     *\n     */\n\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct virStorageBackendDiskPoolVolData cbdata = {\n        .pool = pool,\n        .vol = vol,\n    };\n    g_autofree char *parthelper_path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (!(parthelper_path = virFileFindResource(\"libvirt_parthelper\",\n                                                abs_top_builddir \"/src\",\n                                                LIBEXECDIR)))\n        return -1;\n\n    cmd = virCommandNewArgList(parthelper_path,\n                               def->source.devices[0].path,\n                               NULL);\n\n    /* Check for the presence of the part_separator='yes'. Pass this\n     * along to the libvirt_parthelper as option '-p'. This will cause\n     * libvirt_parthelper to append the \"p\" partition separator to\n     * the generated device name for a source device which ends with\n     * a non-numeric value (e.g. mpatha would generate mpathap#).\n     */\n    if (def->source.devices[0].part_separator == VIR_TRISTATE_BOOL_YES)\n        virCommandAddArg(cmd, \"-p\");\n\n    /* If a volume is passed, virStorageBackendDiskMakeVol only updates the\n     * pool allocation for that single volume.\n     */\n    if (!vol)\n        def->allocation = 0;\n    def->capacity = def->available = 0;\n\n    return virCommandRunNul(cmd, 6, virStorageBackendDiskMakeVol, &cbdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendDiskReadGeometry",
          "args": [
            "pool"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendDiskReadGeometry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
          "lines": "407-426",
          "snippet": "static int\nvirStorageBackendDiskReadGeometry(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    g_autofree char *parthelper_path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (!(parthelper_path = virFileFindResource(\"libvirt_parthelper\",\n                                                abs_top_builddir \"/src\",\n                                                LIBEXECDIR)))\n        return -1;\n\n    cmd = virCommandNewArgList(parthelper_path,\n                               def->source.devices[0].path,\n                               \"-g\",\n                               NULL);\n\n    return virCommandRunNul(cmd, 3, virStorageBackendDiskMakePoolGeometry,\n                            pool);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_disk.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskReadGeometry(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    g_autofree char *parthelper_path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (!(parthelper_path = virFileFindResource(\"libvirt_parthelper\",\n                                                abs_top_builddir \"/src\",\n                                                LIBEXECDIR)))\n        return -1;\n\n    cmd = virCommandNewArgList(parthelper_path,\n                               def->source.devices[0].path,\n                               \"-g\",\n                               NULL);\n\n    return virCommandRunNul(cmd, 3, virStorageBackendDiskMakePoolGeometry,\n                            pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"device path '%s' doesn't exist\")",
            "def->source.devices[0].path"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"device path '%s' doesn't exist\""
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "def->source.devices[0].path"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virWaitForDevices",
          "args": [],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "virWaitForDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1324-1341",
          "snippet": "void virWaitForDevices(void)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *udev = NULL;\n    int exitstatus;\n\n    if (!(udev = virFindFileInPath(UDEVADM)))\n        return;\n\n    if (!(cmd = virCommandNewArgList(udev, \"settle\", NULL)))\n        return;\n\n    /*\n     * NOTE: we ignore errors here; this is just to make sure that any device\n     * nodes that are being created finish before we try to scan them.\n     */\n    ignore_value(virCommandRun(cmd, &exitstatus));\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virWaitForDevices(void)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *udev = NULL;\n    int exitstatus;\n\n    if (!(udev = virFindFileInPath(UDEVADM)))\n        return;\n\n    if (!(cmd = virCommandNewArgList(udev, \"settle\", NULL)))\n        return;\n\n    /*\n     * NOTE: we ignore errors here; this is just to make sure that any device\n     * nodes that are being created finish before we try to scan them.\n     */\n    ignore_value(virCommandRun(cmd, &exitstatus));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->source.devices[0].freeExtents"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskRefreshPool(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    VIR_FREE(def->source.devices[0].freeExtents);\n    def->source.devices[0].nfreeExtent = 0;\n\n    virWaitForDevices();\n\n    if (!virFileExists(def->source.devices[0].path)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"device path '%s' doesn't exist\"),\n                       def->source.devices[0].path);\n        return -1;\n    }\n\n    if (virStorageBackendDiskReadGeometry(pool) != 0)\n        return -1;\n\n    return virStorageBackendDiskReadPartitions(pool, NULL);\n}"
  },
  {
    "function_name": "virStorageBackendDiskReadGeometry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "407-426",
    "snippet": "static int\nvirStorageBackendDiskReadGeometry(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    g_autofree char *parthelper_path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (!(parthelper_path = virFileFindResource(\"libvirt_parthelper\",\n                                                abs_top_builddir \"/src\",\n                                                LIBEXECDIR)))\n        return -1;\n\n    cmd = virCommandNewArgList(parthelper_path,\n                               def->source.devices[0].path,\n                               \"-g\",\n                               NULL);\n\n    return virCommandRunNul(cmd, 3, virStorageBackendDiskMakePoolGeometry,\n                            pool);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandRunNul",
          "args": [
            "cmd",
            "3",
            "virStorageBackendDiskMakePoolGeometry",
            "pool"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunNul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "3356-3365",
          "snippet": "int\nvirCommandRunNul(virCommandPtr cmd G_GNUC_UNUSED,\n                 size_t n_columns G_GNUC_UNUSED,\n                 virCommandRunNulFunc func G_GNUC_UNUSED,\n                 void *data G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"%s not implemented on Win32\"), __FUNCTION__);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunNul(virCommandPtr cmd G_GNUC_UNUSED,\n                 size_t n_columns G_GNUC_UNUSED,\n                 virCommandRunNulFunc func G_GNUC_UNUSED,\n                 void *data G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"%s not implemented on Win32\"), __FUNCTION__);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "parthelper_path",
            "def->source.devices[0].path",
            "\"-g\"",
            "NULL"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileFindResource",
          "args": [
            "\"libvirt_parthelper\"",
            "abs_top_builddir \"/src\"",
            "LIBEXECDIR"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFindResource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1771-1777",
          "snippet": "char *\nvirFileFindResource(const char *filename,\n                    const char *builddir,\n                    const char *installdir)\n{\n    return virFileFindResourceFull(filename, NULL, NULL, builddir, installdir, NULL);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFileFindResource(const char *filename,\n                    const char *builddir,\n                    const char *installdir)\n{\n    return virFileFindResourceFull(filename, NULL, NULL, builddir, installdir, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskReadGeometry(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    g_autofree char *parthelper_path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (!(parthelper_path = virFileFindResource(\"libvirt_parthelper\",\n                                                abs_top_builddir \"/src\",\n                                                LIBEXECDIR)))\n        return -1;\n\n    cmd = virCommandNewArgList(parthelper_path,\n                               def->source.devices[0].path,\n                               \"-g\",\n                               NULL);\n\n    return virCommandRunNul(cmd, 3, virStorageBackendDiskMakePoolGeometry,\n                            pool);\n}"
  },
  {
    "function_name": "virStorageBackendDiskMakePoolGeometry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "388-405",
    "snippet": "static int\nvirStorageBackendDiskMakePoolGeometry(size_t ntok G_GNUC_UNUSED,\n                                      char **const groups,\n                                      void *data)\n{\n    virStoragePoolObjPtr pool = data;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStoragePoolSourceDevicePtr device = &(def->source.devices[0]);\n    if (virStrToLong_i(groups[0], NULL, 0, &device->geometry.cylinders) < 0 ||\n        virStrToLong_i(groups[1], NULL, 0, &device->geometry.heads) < 0 ||\n        virStrToLong_i(groups[2], NULL, 0, &device->geometry.sectors) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to create disk pool geometry\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to create disk pool geometry\")"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to create disk pool geometry\""
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "groups[2]",
            "NULL",
            "0",
            "&device->geometry.sectors"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskMakePoolGeometry(size_t ntok G_GNUC_UNUSED,\n                                      char **const groups,\n                                      void *data)\n{\n    virStoragePoolObjPtr pool = data;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStoragePoolSourceDevicePtr device = &(def->source.devices[0]);\n    if (virStrToLong_i(groups[0], NULL, 0, &device->geometry.cylinders) < 0 ||\n        virStrToLong_i(groups[1], NULL, 0, &device->geometry.heads) < 0 ||\n        virStrToLong_i(groups[2], NULL, 0, &device->geometry.sectors) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to create disk pool geometry\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendDiskReadPartitions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "340-386",
    "snippet": "static int\nvirStorageBackendDiskReadPartitions(virStoragePoolObjPtr pool,\n                                    virStorageVolDefPtr vol)\n{\n    /*\n     *  # libvirt_parthelper DEVICE\n     * /dev/sda1      normal       data        32256    106928128    106896384\n     * /dev/sda2      normal       data    106928640 100027629568  99920701440\n     * -              normal   metadata 100027630080 100030242304      2612736\n     *\n     */\n\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct virStorageBackendDiskPoolVolData cbdata = {\n        .pool = pool,\n        .vol = vol,\n    };\n    g_autofree char *parthelper_path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (!(parthelper_path = virFileFindResource(\"libvirt_parthelper\",\n                                                abs_top_builddir \"/src\",\n                                                LIBEXECDIR)))\n        return -1;\n\n    cmd = virCommandNewArgList(parthelper_path,\n                               def->source.devices[0].path,\n                               NULL);\n\n    /* Check for the presence of the part_separator='yes'. Pass this\n     * along to the libvirt_parthelper as option '-p'. This will cause\n     * libvirt_parthelper to append the \"p\" partition separator to\n     * the generated device name for a source device which ends with\n     * a non-numeric value (e.g. mpatha would generate mpathap#).\n     */\n    if (def->source.devices[0].part_separator == VIR_TRISTATE_BOOL_YES)\n        virCommandAddArg(cmd, \"-p\");\n\n    /* If a volume is passed, virStorageBackendDiskMakeVol only updates the\n     * pool allocation for that single volume.\n     */\n    if (!vol)\n        def->allocation = 0;\n    def->capacity = def->available = 0;\n\n    return virCommandRunNul(cmd, 6, virStorageBackendDiskMakeVol, &cbdata);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandRunNul",
          "args": [
            "cmd",
            "6",
            "virStorageBackendDiskMakeVol",
            "&cbdata"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunNul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "3356-3365",
          "snippet": "int\nvirCommandRunNul(virCommandPtr cmd G_GNUC_UNUSED,\n                 size_t n_columns G_GNUC_UNUSED,\n                 virCommandRunNulFunc func G_GNUC_UNUSED,\n                 void *data G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"%s not implemented on Win32\"), __FUNCTION__);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunNul(virCommandPtr cmd G_GNUC_UNUSED,\n                 size_t n_columns G_GNUC_UNUSED,\n                 virCommandRunNulFunc func G_GNUC_UNUSED,\n                 void *data G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"%s not implemented on Win32\"), __FUNCTION__);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "\"-p\""
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "parthelper_path",
            "def->source.devices[0].path",
            "NULL"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileFindResource",
          "args": [
            "\"libvirt_parthelper\"",
            "abs_top_builddir \"/src\"",
            "LIBEXECDIR"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFindResource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1771-1777",
          "snippet": "char *\nvirFileFindResource(const char *filename,\n                    const char *builddir,\n                    const char *installdir)\n{\n    return virFileFindResourceFull(filename, NULL, NULL, builddir, installdir, NULL);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFileFindResource(const char *filename,\n                    const char *builddir,\n                    const char *installdir)\n{\n    return virFileFindResourceFull(filename, NULL, NULL, builddir, installdir, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskReadPartitions(virStoragePoolObjPtr pool,\n                                    virStorageVolDefPtr vol)\n{\n    /*\n     *  # libvirt_parthelper DEVICE\n     * /dev/sda1      normal       data        32256    106928128    106896384\n     * /dev/sda2      normal       data    106928640 100027629568  99920701440\n     * -              normal   metadata 100027630080 100030242304      2612736\n     *\n     */\n\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct virStorageBackendDiskPoolVolData cbdata = {\n        .pool = pool,\n        .vol = vol,\n    };\n    g_autofree char *parthelper_path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (!(parthelper_path = virFileFindResource(\"libvirt_parthelper\",\n                                                abs_top_builddir \"/src\",\n                                                LIBEXECDIR)))\n        return -1;\n\n    cmd = virCommandNewArgList(parthelper_path,\n                               def->source.devices[0].path,\n                               NULL);\n\n    /* Check for the presence of the part_separator='yes'. Pass this\n     * along to the libvirt_parthelper as option '-p'. This will cause\n     * libvirt_parthelper to append the \"p\" partition separator to\n     * the generated device name for a source device which ends with\n     * a non-numeric value (e.g. mpatha would generate mpathap#).\n     */\n    if (def->source.devices[0].part_separator == VIR_TRISTATE_BOOL_YES)\n        virCommandAddArg(cmd, \"-p\");\n\n    /* If a volume is passed, virStorageBackendDiskMakeVol only updates the\n     * pool allocation for that single volume.\n     */\n    if (!vol)\n        def->allocation = 0;\n    def->capacity = def->available = 0;\n\n    return virCommandRunNul(cmd, 6, virStorageBackendDiskMakeVol, &cbdata);\n}"
  },
  {
    "function_name": "virStorageBackendDiskMakeVol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "283-328",
    "snippet": "static int\nvirStorageBackendDiskMakeVol(size_t ntok G_GNUC_UNUSED,\n                             char **const groups,\n                             void *opaque)\n{\n    struct virStorageBackendDiskPoolVolData *data = opaque;\n    virStoragePoolObjPtr pool = data->pool;\n    /*\n     * Ignore normal+metadata, and logical+metadata partitions\n     * since they're basically internal book-keeping regions\n     * we have no control over. Do keep extended+metadata though\n     * because that's the MS-DOS extended partition region we\n     * need to be able to view/create/delete\n     */\n    if ((STREQ(groups[1], \"normal\") ||\n         STREQ(groups[1], \"logical\")) &&\n        STREQ(groups[2], \"metadata\"))\n        return 0;\n\n    /* Remaining data / metadata parts get turn into volumes... */\n    if (STREQ(groups[2], \"metadata\") ||\n        STREQ(groups[2], \"data\")) {\n        virStorageVolDefPtr vol = data->vol;\n\n        if (vol) {\n            /* We're searching for a specific vol only */\n            if (vol->key) {\n                if (STRNEQ(vol->key, groups[0]))\n                    return 0;\n            } else if (virStorageVolDefFindByKey(pool, groups[0]) != NULL) {\n                /* If no key, the volume must be newly created. If groups[0]\n                 * isn't already a volume, assume it's the path we want */\n                return 0;\n            }\n        }\n\n        return virStorageBackendDiskMakeDataVol(pool, groups, vol);\n    } else if (STREQ(groups[2], \"free\")) {\n        /* ....or free space extents */\n        return virStorageBackendDiskMakeFreeExtent(pool, groups);\n    } else {\n        /* This code path should never happen unless someone changed\n         * libvirt_parthelper forgot to change this code */\n        return -1;\n    }\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendDiskMakeFreeExtent",
          "args": [
            "pool",
            "groups"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendDiskMakeFreeExtent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
          "lines": "232-275",
          "snippet": "static int\nvirStorageBackendDiskMakeFreeExtent(virStoragePoolObjPtr pool,\n                                    char **const groups)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStoragePoolSourceDevicePtr dev = &def->source.devices[0];\n\n    if (VIR_REALLOC_N(dev->freeExtents,\n                      dev->nfreeExtent + 1) < 0)\n        return -1;\n\n    memset(dev->freeExtents +\n           dev->nfreeExtent, 0,\n           sizeof(dev->freeExtents[0]));\n\n    /* set type of free area */\n    if (STREQ(groups[1], \"logical\")) {\n        dev->freeExtents[dev->nfreeExtent].type = VIR_STORAGE_FREE_LOGICAL;\n    } else {\n        dev->freeExtents[dev->nfreeExtent].type = VIR_STORAGE_FREE_NORMAL;\n    }\n\n\n    if (virStrToLong_ull(groups[3], NULL, 10,\n                         &dev->freeExtents[dev->nfreeExtent].start) < 0)\n        return -1; /* Don't bother to re-alloc freeExtents - it'll be free'd shortly */\n\n    if (virStrToLong_ull(groups[4], NULL, 10,\n                         &dev->freeExtents[dev->nfreeExtent].end) < 0)\n        return -1; /* Don't bother to re-alloc freeExtents - it'll be free'd shortly */\n\n    /* first block reported as free, even if it is not */\n    if (dev->freeExtents[dev->nfreeExtent].start == 0)\n        dev->freeExtents[dev->nfreeExtent].start = SECTOR_SIZE;\n\n    def->available += (dev->freeExtents[dev->nfreeExtent].end -\n                       dev->freeExtents[dev->nfreeExtent].start);\n    if (dev->freeExtents[dev->nfreeExtent].end > def->capacity)\n        def->capacity = dev->freeExtents[dev->nfreeExtent].end;\n\n    dev->nfreeExtent++;\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_disk.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECTOR_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\n#define SECTOR_SIZE 512\n\nstatic int\nvirStorageBackendDiskMakeFreeExtent(virStoragePoolObjPtr pool,\n                                    char **const groups)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStoragePoolSourceDevicePtr dev = &def->source.devices[0];\n\n    if (VIR_REALLOC_N(dev->freeExtents,\n                      dev->nfreeExtent + 1) < 0)\n        return -1;\n\n    memset(dev->freeExtents +\n           dev->nfreeExtent, 0,\n           sizeof(dev->freeExtents[0]));\n\n    /* set type of free area */\n    if (STREQ(groups[1], \"logical\")) {\n        dev->freeExtents[dev->nfreeExtent].type = VIR_STORAGE_FREE_LOGICAL;\n    } else {\n        dev->freeExtents[dev->nfreeExtent].type = VIR_STORAGE_FREE_NORMAL;\n    }\n\n\n    if (virStrToLong_ull(groups[3], NULL, 10,\n                         &dev->freeExtents[dev->nfreeExtent].start) < 0)\n        return -1; /* Don't bother to re-alloc freeExtents - it'll be free'd shortly */\n\n    if (virStrToLong_ull(groups[4], NULL, 10,\n                         &dev->freeExtents[dev->nfreeExtent].end) < 0)\n        return -1; /* Don't bother to re-alloc freeExtents - it'll be free'd shortly */\n\n    /* first block reported as free, even if it is not */\n    if (dev->freeExtents[dev->nfreeExtent].start == 0)\n        dev->freeExtents[dev->nfreeExtent].start = SECTOR_SIZE;\n\n    def->available += (dev->freeExtents[dev->nfreeExtent].end -\n                       dev->freeExtents[dev->nfreeExtent].start);\n    if (dev->freeExtents[dev->nfreeExtent].end > def->capacity)\n        def->capacity = dev->freeExtents[dev->nfreeExtent].end;\n\n    dev->nfreeExtent++;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "groups[2]",
            "\"free\""
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendDiskMakeDataVol",
          "args": [
            "pool",
            "groups",
            "vol"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendDiskMakeDataVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
          "lines": "53-230",
          "snippet": "static int\nvirStorageBackendDiskMakeDataVol(virStoragePoolObjPtr pool,\n                                 char **const groups,\n                                 virStorageVolDefPtr vol)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    char *tmp, *partname;\n    bool addVol = false;\n    g_autofree char *devpath = NULL;\n\n    /* Prepended path will be same for all partitions, so we can\n     * strip the path to form a reasonable pool-unique name\n     */\n    if ((tmp = strrchr(groups[0], '/')))\n        partname = tmp + 1;\n    else\n        partname = groups[0];\n\n    if (vol == NULL) {\n        /* This is typically a reload/restart/refresh path where\n         * we're discovering the existing partitions for the pool\n         */\n        addVol = true;\n        if (VIR_ALLOC(vol) < 0)\n            return -1;\n        vol->name = g_strdup(partname);\n    }\n\n    if (vol->target.path == NULL) {\n        devpath = g_strdup(groups[0]);\n\n        /* Now figure out the stable path\n         *\n         * XXX this method is O(N) because it scans the pool target\n         * dir every time its run. Should figure out a more efficient\n         * way of doing this...\n         */\n        vol->target.path = virStorageBackendStablePath(pool, devpath, true);\n        if (vol->target.path == NULL)\n            goto error;\n    }\n\n    /* Enforce provided vol->name is the same as what parted created.\n     * We do this after filling target.path so that we have a chance at\n     * deleting the partition with this failure from CreateVol path\n     */\n    if (STRNEQ(vol->name, partname)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"invalid partition name '%s', expected '%s'\"),\n                       vol->name, partname);\n\n        /* Let's see if by chance parthelper created a name that won't be\n         * found later when we try to delete. We tell parthelper to add a 'p'\n         * to the output via the part_separator flag, but if devmapper has\n         * user_friendly_names set, the creation won't happen that way, thus\n         * our deletion will fail because the name we generated is wrong.\n         * Check for our conditions and see if the generated name is the\n         * same as StablePath returns and has the 'p' in it */\n        if (def->source.devices[0].part_separator == VIR_TRISTATE_BOOL_YES &&\n            !virIsDevMapperDevice(vol->target.path) &&\n            STREQ(groups[0], vol->target.path) &&\n            (tmp = strrchr(groups[0], 'p'))) {\n\n            /* If we remove the 'p' from groups[0] and the resulting\n             * device is a devmapper device, then we know parthelper\n             * was told to create the wrong name based on the results.\n             * So just remove the 'p' from the vol->target.path too. */\n            memmove(tmp, tmp + 1, strlen(tmp));\n            if (virIsDevMapperDevice(groups[0]) &&\n                (tmp = strrchr(vol->target.path, 'p')))\n                memmove(tmp, tmp + 1, strlen(tmp));\n        }\n        goto error;\n    }\n\n    if (vol->key == NULL) {\n        /* XXX base off a unique key of the underlying disk */\n        vol->key = g_strdup(vol->target.path);\n    }\n\n    if (vol->source.extents == NULL) {\n        if (VIR_ALLOC(vol->source.extents) < 0)\n            goto error;\n        vol->source.nextent = 1;\n\n        if (virStrToLong_ull(groups[3], NULL, 10,\n                             &vol->source.extents[0].start) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"cannot parse device start location\"));\n            goto error;\n        }\n\n        if (virStrToLong_ull(groups[4], NULL, 10,\n                             &vol->source.extents[0].end) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"cannot parse device end location\"));\n            goto error;\n        }\n\n        vol->source.extents[0].path = g_strdup(def->source.devices[0].path);\n    }\n\n    /* set partition type */\n    if (STREQ(groups[1], \"normal\"))\n       vol->source.partType = VIR_STORAGE_VOL_DISK_TYPE_PRIMARY;\n    else if (STREQ(groups[1], \"logical\"))\n       vol->source.partType = VIR_STORAGE_VOL_DISK_TYPE_LOGICAL;\n    else if (STREQ(groups[1], \"extended\"))\n       vol->source.partType = VIR_STORAGE_VOL_DISK_TYPE_EXTENDED;\n    else\n       vol->source.partType = VIR_STORAGE_VOL_DISK_TYPE_NONE;\n\n    vol->type = VIR_STORAGE_VOL_BLOCK;\n\n    /* Refresh allocation/capacity/perms\n     *\n     * For an extended partition, virStorageBackendUpdateVolInfo will\n     * return incorrect values for allocation and capacity, so use the\n     * extent information captured above instead.\n     *\n     * Also once a logical partition exists or another primary partition\n     * after an extended partition is created an open on the extended\n     * partition will fail, so pass the NOERROR flag and only error if a\n     * -1 was returned indicating some other error than an open error.\n     *\n     * NB: A small window exists in some cases where the just created\n     * partition disappears, but then reappears. Since we were given\n     * vol->target.path from parthelper, let's just be sure that any\n     * kernel magic that occurs as a result of parthelper doesn't cause\n     * us to fail with some sort of ENOENT failure since that would be\n     * quite \"unexpected\". So rather than just fail, let's use the\n     * virWaitForDevices to ensure everything has settled properly.\n     */\n    virWaitForDevices();\n    if (vol->source.partType == VIR_STORAGE_VOL_DISK_TYPE_EXTENDED) {\n        if (virStorageBackendUpdateVolInfo(vol, false,\n                                           VIR_STORAGE_VOL_OPEN_DEFAULT |\n                                           VIR_STORAGE_VOL_OPEN_NOERROR,\n                                           0) == -1)\n            goto error;\n        vol->target.allocation = 0;\n        vol->target.capacity =\n            (vol->source.extents[0].end - vol->source.extents[0].start);\n    } else {\n        if (virStorageBackendUpdateVolInfo(vol, false,\n                                           VIR_STORAGE_VOL_OPEN_DEFAULT, 0) < 0)\n            goto error;\n    }\n\n    /* Now that we've updated @vol enough, let's add it to the pool\n     * if it's not already there so that the subsequent pool search\n     * pool def adjustments will work properly */\n    if (addVol && virStoragePoolObjAddVol(pool, vol) < 0)\n        goto error;\n\n    /* Find the extended partition and increase the allocation value */\n    if (vol->source.partType == VIR_STORAGE_VOL_DISK_TYPE_LOGICAL) {\n        virStorageVolDefPtr voldef;\n\n        voldef = virStoragePoolObjSearchVolume(pool,\n                                               virStorageVolPartFindExtended,\n                                               NULL);\n        if (voldef)\n            voldef->target.allocation += vol->target.allocation;\n    }\n\n    if (STRNEQ(groups[2], \"metadata\"))\n        def->allocation += vol->target.allocation;\n    if (vol->source.extents[0].end > def->capacity)\n        def->capacity = vol->source.extents[0].end;\n\n    return 0;\n\n error:\n    if (addVol)\n        virStorageVolDefFree(vol);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_disk.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskMakeDataVol(virStoragePoolObjPtr pool,\n                                 char **const groups,\n                                 virStorageVolDefPtr vol)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    char *tmp, *partname;\n    bool addVol = false;\n    g_autofree char *devpath = NULL;\n\n    /* Prepended path will be same for all partitions, so we can\n     * strip the path to form a reasonable pool-unique name\n     */\n    if ((tmp = strrchr(groups[0], '/')))\n        partname = tmp + 1;\n    else\n        partname = groups[0];\n\n    if (vol == NULL) {\n        /* This is typically a reload/restart/refresh path where\n         * we're discovering the existing partitions for the pool\n         */\n        addVol = true;\n        if (VIR_ALLOC(vol) < 0)\n            return -1;\n        vol->name = g_strdup(partname);\n    }\n\n    if (vol->target.path == NULL) {\n        devpath = g_strdup(groups[0]);\n\n        /* Now figure out the stable path\n         *\n         * XXX this method is O(N) because it scans the pool target\n         * dir every time its run. Should figure out a more efficient\n         * way of doing this...\n         */\n        vol->target.path = virStorageBackendStablePath(pool, devpath, true);\n        if (vol->target.path == NULL)\n            goto error;\n    }\n\n    /* Enforce provided vol->name is the same as what parted created.\n     * We do this after filling target.path so that we have a chance at\n     * deleting the partition with this failure from CreateVol path\n     */\n    if (STRNEQ(vol->name, partname)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"invalid partition name '%s', expected '%s'\"),\n                       vol->name, partname);\n\n        /* Let's see if by chance parthelper created a name that won't be\n         * found later when we try to delete. We tell parthelper to add a 'p'\n         * to the output via the part_separator flag, but if devmapper has\n         * user_friendly_names set, the creation won't happen that way, thus\n         * our deletion will fail because the name we generated is wrong.\n         * Check for our conditions and see if the generated name is the\n         * same as StablePath returns and has the 'p' in it */\n        if (def->source.devices[0].part_separator == VIR_TRISTATE_BOOL_YES &&\n            !virIsDevMapperDevice(vol->target.path) &&\n            STREQ(groups[0], vol->target.path) &&\n            (tmp = strrchr(groups[0], 'p'))) {\n\n            /* If we remove the 'p' from groups[0] and the resulting\n             * device is a devmapper device, then we know parthelper\n             * was told to create the wrong name based on the results.\n             * So just remove the 'p' from the vol->target.path too. */\n            memmove(tmp, tmp + 1, strlen(tmp));\n            if (virIsDevMapperDevice(groups[0]) &&\n                (tmp = strrchr(vol->target.path, 'p')))\n                memmove(tmp, tmp + 1, strlen(tmp));\n        }\n        goto error;\n    }\n\n    if (vol->key == NULL) {\n        /* XXX base off a unique key of the underlying disk */\n        vol->key = g_strdup(vol->target.path);\n    }\n\n    if (vol->source.extents == NULL) {\n        if (VIR_ALLOC(vol->source.extents) < 0)\n            goto error;\n        vol->source.nextent = 1;\n\n        if (virStrToLong_ull(groups[3], NULL, 10,\n                             &vol->source.extents[0].start) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"cannot parse device start location\"));\n            goto error;\n        }\n\n        if (virStrToLong_ull(groups[4], NULL, 10,\n                             &vol->source.extents[0].end) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"cannot parse device end location\"));\n            goto error;\n        }\n\n        vol->source.extents[0].path = g_strdup(def->source.devices[0].path);\n    }\n\n    /* set partition type */\n    if (STREQ(groups[1], \"normal\"))\n       vol->source.partType = VIR_STORAGE_VOL_DISK_TYPE_PRIMARY;\n    else if (STREQ(groups[1], \"logical\"))\n       vol->source.partType = VIR_STORAGE_VOL_DISK_TYPE_LOGICAL;\n    else if (STREQ(groups[1], \"extended\"))\n       vol->source.partType = VIR_STORAGE_VOL_DISK_TYPE_EXTENDED;\n    else\n       vol->source.partType = VIR_STORAGE_VOL_DISK_TYPE_NONE;\n\n    vol->type = VIR_STORAGE_VOL_BLOCK;\n\n    /* Refresh allocation/capacity/perms\n     *\n     * For an extended partition, virStorageBackendUpdateVolInfo will\n     * return incorrect values for allocation and capacity, so use the\n     * extent information captured above instead.\n     *\n     * Also once a logical partition exists or another primary partition\n     * after an extended partition is created an open on the extended\n     * partition will fail, so pass the NOERROR flag and only error if a\n     * -1 was returned indicating some other error than an open error.\n     *\n     * NB: A small window exists in some cases where the just created\n     * partition disappears, but then reappears. Since we were given\n     * vol->target.path from parthelper, let's just be sure that any\n     * kernel magic that occurs as a result of parthelper doesn't cause\n     * us to fail with some sort of ENOENT failure since that would be\n     * quite \"unexpected\". So rather than just fail, let's use the\n     * virWaitForDevices to ensure everything has settled properly.\n     */\n    virWaitForDevices();\n    if (vol->source.partType == VIR_STORAGE_VOL_DISK_TYPE_EXTENDED) {\n        if (virStorageBackendUpdateVolInfo(vol, false,\n                                           VIR_STORAGE_VOL_OPEN_DEFAULT |\n                                           VIR_STORAGE_VOL_OPEN_NOERROR,\n                                           0) == -1)\n            goto error;\n        vol->target.allocation = 0;\n        vol->target.capacity =\n            (vol->source.extents[0].end - vol->source.extents[0].start);\n    } else {\n        if (virStorageBackendUpdateVolInfo(vol, false,\n                                           VIR_STORAGE_VOL_OPEN_DEFAULT, 0) < 0)\n            goto error;\n    }\n\n    /* Now that we've updated @vol enough, let's add it to the pool\n     * if it's not already there so that the subsequent pool search\n     * pool def adjustments will work properly */\n    if (addVol && virStoragePoolObjAddVol(pool, vol) < 0)\n        goto error;\n\n    /* Find the extended partition and increase the allocation value */\n    if (vol->source.partType == VIR_STORAGE_VOL_DISK_TYPE_LOGICAL) {\n        virStorageVolDefPtr voldef;\n\n        voldef = virStoragePoolObjSearchVolume(pool,\n                                               virStorageVolPartFindExtended,\n                                               NULL);\n        if (voldef)\n            voldef->target.allocation += vol->target.allocation;\n    }\n\n    if (STRNEQ(groups[2], \"metadata\"))\n        def->allocation += vol->target.allocation;\n    if (vol->source.extents[0].end > def->capacity)\n        def->capacity = vol->source.extents[0].end;\n\n    return 0;\n\n error:\n    if (addVol)\n        virStorageVolDefFree(vol);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageVolDefFindByKey",
          "args": [
            "pool",
            "groups[0]"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageVolDefFindByKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "809-822",
          "snippet": "virStorageVolDefPtr\nvirStorageVolDefFindByKey(virStoragePoolObjPtr obj,\n                          const char *key)\n{\n    virStorageVolObjPtr volobj;\n\n    virObjectRWLockRead(obj->volumes);\n    volobj = virHashLookup(obj->volumes->objsKey, key);\n    virObjectRWUnlock(obj->volumes);\n\n    if (volobj)\n        return volobj->voldef;\n    return NULL;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStorageVolDefPtr\nvirStorageVolDefFindByKey(virStoragePoolObjPtr obj,\n                          const char *key)\n{\n    virStorageVolObjPtr volobj;\n\n    virObjectRWLockRead(obj->volumes);\n    volobj = virHashLookup(obj->volumes->objsKey, key);\n    virObjectRWUnlock(obj->volumes);\n\n    if (volobj)\n        return volobj->voldef;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "vol->key",
            "groups[0]"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "groups[2]",
            "\"data\""
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "groups[2]",
            "\"metadata\""
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "groups[2]",
            "\"metadata\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "groups[1]",
            "\"logical\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "groups[1]",
            "\"normal\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskMakeVol(size_t ntok G_GNUC_UNUSED,\n                             char **const groups,\n                             void *opaque)\n{\n    struct virStorageBackendDiskPoolVolData *data = opaque;\n    virStoragePoolObjPtr pool = data->pool;\n    /*\n     * Ignore normal+metadata, and logical+metadata partitions\n     * since they're basically internal book-keeping regions\n     * we have no control over. Do keep extended+metadata though\n     * because that's the MS-DOS extended partition region we\n     * need to be able to view/create/delete\n     */\n    if ((STREQ(groups[1], \"normal\") ||\n         STREQ(groups[1], \"logical\")) &&\n        STREQ(groups[2], \"metadata\"))\n        return 0;\n\n    /* Remaining data / metadata parts get turn into volumes... */\n    if (STREQ(groups[2], \"metadata\") ||\n        STREQ(groups[2], \"data\")) {\n        virStorageVolDefPtr vol = data->vol;\n\n        if (vol) {\n            /* We're searching for a specific vol only */\n            if (vol->key) {\n                if (STRNEQ(vol->key, groups[0]))\n                    return 0;\n            } else if (virStorageVolDefFindByKey(pool, groups[0]) != NULL) {\n                /* If no key, the volume must be newly created. If groups[0]\n                 * isn't already a volume, assume it's the path we want */\n                return 0;\n            }\n        }\n\n        return virStorageBackendDiskMakeDataVol(pool, groups, vol);\n    } else if (STREQ(groups[2], \"free\")) {\n        /* ....or free space extents */\n        return virStorageBackendDiskMakeFreeExtent(pool, groups);\n    } else {\n        /* This code path should never happen unless someone changed\n         * libvirt_parthelper forgot to change this code */\n        return -1;\n    }\n}"
  },
  {
    "function_name": "virStorageBackendDiskMakeFreeExtent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "232-275",
    "snippet": "static int\nvirStorageBackendDiskMakeFreeExtent(virStoragePoolObjPtr pool,\n                                    char **const groups)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStoragePoolSourceDevicePtr dev = &def->source.devices[0];\n\n    if (VIR_REALLOC_N(dev->freeExtents,\n                      dev->nfreeExtent + 1) < 0)\n        return -1;\n\n    memset(dev->freeExtents +\n           dev->nfreeExtent, 0,\n           sizeof(dev->freeExtents[0]));\n\n    /* set type of free area */\n    if (STREQ(groups[1], \"logical\")) {\n        dev->freeExtents[dev->nfreeExtent].type = VIR_STORAGE_FREE_LOGICAL;\n    } else {\n        dev->freeExtents[dev->nfreeExtent].type = VIR_STORAGE_FREE_NORMAL;\n    }\n\n\n    if (virStrToLong_ull(groups[3], NULL, 10,\n                         &dev->freeExtents[dev->nfreeExtent].start) < 0)\n        return -1; /* Don't bother to re-alloc freeExtents - it'll be free'd shortly */\n\n    if (virStrToLong_ull(groups[4], NULL, 10,\n                         &dev->freeExtents[dev->nfreeExtent].end) < 0)\n        return -1; /* Don't bother to re-alloc freeExtents - it'll be free'd shortly */\n\n    /* first block reported as free, even if it is not */\n    if (dev->freeExtents[dev->nfreeExtent].start == 0)\n        dev->freeExtents[dev->nfreeExtent].start = SECTOR_SIZE;\n\n    def->available += (dev->freeExtents[dev->nfreeExtent].end -\n                       dev->freeExtents[dev->nfreeExtent].start);\n    if (dev->freeExtents[dev->nfreeExtent].end > def->capacity)\n        def->capacity = dev->freeExtents[dev->nfreeExtent].end;\n\n    dev->nfreeExtent++;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECTOR_SIZE 512"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStrToLong_ull",
          "args": [
            "groups[4]",
            "NULL",
            "10",
            "&dev->freeExtents[dev->nfreeExtent].end"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ullp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "568-586",
          "snippet": "int\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "groups[1]",
            "\"logical\""
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dev->freeExtents +\n           dev->nfreeExtent",
            "0",
            "sizeof(dev->freeExtents[0])"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "dev->freeExtents",
            "dev->nfreeExtent + 1"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\n#define SECTOR_SIZE 512\n\nstatic int\nvirStorageBackendDiskMakeFreeExtent(virStoragePoolObjPtr pool,\n                                    char **const groups)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStoragePoolSourceDevicePtr dev = &def->source.devices[0];\n\n    if (VIR_REALLOC_N(dev->freeExtents,\n                      dev->nfreeExtent + 1) < 0)\n        return -1;\n\n    memset(dev->freeExtents +\n           dev->nfreeExtent, 0,\n           sizeof(dev->freeExtents[0]));\n\n    /* set type of free area */\n    if (STREQ(groups[1], \"logical\")) {\n        dev->freeExtents[dev->nfreeExtent].type = VIR_STORAGE_FREE_LOGICAL;\n    } else {\n        dev->freeExtents[dev->nfreeExtent].type = VIR_STORAGE_FREE_NORMAL;\n    }\n\n\n    if (virStrToLong_ull(groups[3], NULL, 10,\n                         &dev->freeExtents[dev->nfreeExtent].start) < 0)\n        return -1; /* Don't bother to re-alloc freeExtents - it'll be free'd shortly */\n\n    if (virStrToLong_ull(groups[4], NULL, 10,\n                         &dev->freeExtents[dev->nfreeExtent].end) < 0)\n        return -1; /* Don't bother to re-alloc freeExtents - it'll be free'd shortly */\n\n    /* first block reported as free, even if it is not */\n    if (dev->freeExtents[dev->nfreeExtent].start == 0)\n        dev->freeExtents[dev->nfreeExtent].start = SECTOR_SIZE;\n\n    def->available += (dev->freeExtents[dev->nfreeExtent].end -\n                       dev->freeExtents[dev->nfreeExtent].start);\n    if (dev->freeExtents[dev->nfreeExtent].end > def->capacity)\n        def->capacity = dev->freeExtents[dev->nfreeExtent].end;\n\n    dev->nfreeExtent++;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendDiskMakeDataVol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "53-230",
    "snippet": "static int\nvirStorageBackendDiskMakeDataVol(virStoragePoolObjPtr pool,\n                                 char **const groups,\n                                 virStorageVolDefPtr vol)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    char *tmp, *partname;\n    bool addVol = false;\n    g_autofree char *devpath = NULL;\n\n    /* Prepended path will be same for all partitions, so we can\n     * strip the path to form a reasonable pool-unique name\n     */\n    if ((tmp = strrchr(groups[0], '/')))\n        partname = tmp + 1;\n    else\n        partname = groups[0];\n\n    if (vol == NULL) {\n        /* This is typically a reload/restart/refresh path where\n         * we're discovering the existing partitions for the pool\n         */\n        addVol = true;\n        if (VIR_ALLOC(vol) < 0)\n            return -1;\n        vol->name = g_strdup(partname);\n    }\n\n    if (vol->target.path == NULL) {\n        devpath = g_strdup(groups[0]);\n\n        /* Now figure out the stable path\n         *\n         * XXX this method is O(N) because it scans the pool target\n         * dir every time its run. Should figure out a more efficient\n         * way of doing this...\n         */\n        vol->target.path = virStorageBackendStablePath(pool, devpath, true);\n        if (vol->target.path == NULL)\n            goto error;\n    }\n\n    /* Enforce provided vol->name is the same as what parted created.\n     * We do this after filling target.path so that we have a chance at\n     * deleting the partition with this failure from CreateVol path\n     */\n    if (STRNEQ(vol->name, partname)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"invalid partition name '%s', expected '%s'\"),\n                       vol->name, partname);\n\n        /* Let's see if by chance parthelper created a name that won't be\n         * found later when we try to delete. We tell parthelper to add a 'p'\n         * to the output via the part_separator flag, but if devmapper has\n         * user_friendly_names set, the creation won't happen that way, thus\n         * our deletion will fail because the name we generated is wrong.\n         * Check for our conditions and see if the generated name is the\n         * same as StablePath returns and has the 'p' in it */\n        if (def->source.devices[0].part_separator == VIR_TRISTATE_BOOL_YES &&\n            !virIsDevMapperDevice(vol->target.path) &&\n            STREQ(groups[0], vol->target.path) &&\n            (tmp = strrchr(groups[0], 'p'))) {\n\n            /* If we remove the 'p' from groups[0] and the resulting\n             * device is a devmapper device, then we know parthelper\n             * was told to create the wrong name based on the results.\n             * So just remove the 'p' from the vol->target.path too. */\n            memmove(tmp, tmp + 1, strlen(tmp));\n            if (virIsDevMapperDevice(groups[0]) &&\n                (tmp = strrchr(vol->target.path, 'p')))\n                memmove(tmp, tmp + 1, strlen(tmp));\n        }\n        goto error;\n    }\n\n    if (vol->key == NULL) {\n        /* XXX base off a unique key of the underlying disk */\n        vol->key = g_strdup(vol->target.path);\n    }\n\n    if (vol->source.extents == NULL) {\n        if (VIR_ALLOC(vol->source.extents) < 0)\n            goto error;\n        vol->source.nextent = 1;\n\n        if (virStrToLong_ull(groups[3], NULL, 10,\n                             &vol->source.extents[0].start) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"cannot parse device start location\"));\n            goto error;\n        }\n\n        if (virStrToLong_ull(groups[4], NULL, 10,\n                             &vol->source.extents[0].end) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"cannot parse device end location\"));\n            goto error;\n        }\n\n        vol->source.extents[0].path = g_strdup(def->source.devices[0].path);\n    }\n\n    /* set partition type */\n    if (STREQ(groups[1], \"normal\"))\n       vol->source.partType = VIR_STORAGE_VOL_DISK_TYPE_PRIMARY;\n    else if (STREQ(groups[1], \"logical\"))\n       vol->source.partType = VIR_STORAGE_VOL_DISK_TYPE_LOGICAL;\n    else if (STREQ(groups[1], \"extended\"))\n       vol->source.partType = VIR_STORAGE_VOL_DISK_TYPE_EXTENDED;\n    else\n       vol->source.partType = VIR_STORAGE_VOL_DISK_TYPE_NONE;\n\n    vol->type = VIR_STORAGE_VOL_BLOCK;\n\n    /* Refresh allocation/capacity/perms\n     *\n     * For an extended partition, virStorageBackendUpdateVolInfo will\n     * return incorrect values for allocation and capacity, so use the\n     * extent information captured above instead.\n     *\n     * Also once a logical partition exists or another primary partition\n     * after an extended partition is created an open on the extended\n     * partition will fail, so pass the NOERROR flag and only error if a\n     * -1 was returned indicating some other error than an open error.\n     *\n     * NB: A small window exists in some cases where the just created\n     * partition disappears, but then reappears. Since we were given\n     * vol->target.path from parthelper, let's just be sure that any\n     * kernel magic that occurs as a result of parthelper doesn't cause\n     * us to fail with some sort of ENOENT failure since that would be\n     * quite \"unexpected\". So rather than just fail, let's use the\n     * virWaitForDevices to ensure everything has settled properly.\n     */\n    virWaitForDevices();\n    if (vol->source.partType == VIR_STORAGE_VOL_DISK_TYPE_EXTENDED) {\n        if (virStorageBackendUpdateVolInfo(vol, false,\n                                           VIR_STORAGE_VOL_OPEN_DEFAULT |\n                                           VIR_STORAGE_VOL_OPEN_NOERROR,\n                                           0) == -1)\n            goto error;\n        vol->target.allocation = 0;\n        vol->target.capacity =\n            (vol->source.extents[0].end - vol->source.extents[0].start);\n    } else {\n        if (virStorageBackendUpdateVolInfo(vol, false,\n                                           VIR_STORAGE_VOL_OPEN_DEFAULT, 0) < 0)\n            goto error;\n    }\n\n    /* Now that we've updated @vol enough, let's add it to the pool\n     * if it's not already there so that the subsequent pool search\n     * pool def adjustments will work properly */\n    if (addVol && virStoragePoolObjAddVol(pool, vol) < 0)\n        goto error;\n\n    /* Find the extended partition and increase the allocation value */\n    if (vol->source.partType == VIR_STORAGE_VOL_DISK_TYPE_LOGICAL) {\n        virStorageVolDefPtr voldef;\n\n        voldef = virStoragePoolObjSearchVolume(pool,\n                                               virStorageVolPartFindExtended,\n                                               NULL);\n        if (voldef)\n            voldef->target.allocation += vol->target.allocation;\n    }\n\n    if (STRNEQ(groups[2], \"metadata\"))\n        def->allocation += vol->target.allocation;\n    if (vol->source.extents[0].end > def->capacity)\n        def->capacity = vol->source.extents[0].end;\n\n    return 0;\n\n error:\n    if (addVol)\n        virStorageVolDefFree(vol);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageVolDefFree",
          "args": [
            "vol"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageVolDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "443-460",
          "snippet": "void\nvirStorageVolDefFree(virStorageVolDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->key);\n\n    for (i = 0; i < def->source.nextent; i++)\n        VIR_FREE(def->source.extents[i].path);\n    VIR_FREE(def->source.extents);\n\n    virStorageSourceClear(&def->target);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirStorageVolDefFree(virStorageVolDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->key);\n\n    for (i = 0; i < def->source.nextent; i++)\n        VIR_FREE(def->source.extents[i].path);\n    VIR_FREE(def->source.extents);\n\n    virStorageSourceClear(&def->target);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "groups[2]",
            "\"metadata\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjSearchVolume",
          "args": [
            "pool",
            "virStorageVolPartFindExtended",
            "NULL"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjSearchVolume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "787-806",
          "snippet": "virStorageVolDefPtr\nvirStoragePoolObjSearchVolume(virStoragePoolObjPtr obj,\n                              virStorageVolObjListSearcher iter,\n                              const void *opaque)\n{\n    virStorageVolObjPtr volobj;\n    struct _virStoragePoolObjSearchVolData data = {\n        .iter = iter, .opaque = opaque };\n\n    virObjectRWLockRead(obj->volumes);\n    volobj = virHashSearch(obj->volumes->objsKey,\n                           virStoragePoolObjSearchVolumeCb,\n                           &data, NULL);\n    virObjectRWUnlock(obj->volumes);\n\n    if (volobj)\n        return volobj->voldef;\n\n    return NULL;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nvirStoragePoolObjDispose(void *opaque);",
            "static void\nvirStoragePoolObjListDispose(void *opaque);",
            "static void\nvirStorageVolObjDispose(void *opaque);",
            "static void\nvirStorageVolObjListDispose(void *opaque);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void\nvirStoragePoolObjDispose(void *opaque);\nstatic void\nvirStoragePoolObjListDispose(void *opaque);\nstatic void\nvirStorageVolObjDispose(void *opaque);\nstatic void\nvirStorageVolObjListDispose(void *opaque);\n\nvirStorageVolDefPtr\nvirStoragePoolObjSearchVolume(virStoragePoolObjPtr obj,\n                              virStorageVolObjListSearcher iter,\n                              const void *opaque)\n{\n    virStorageVolObjPtr volobj;\n    struct _virStoragePoolObjSearchVolData data = {\n        .iter = iter, .opaque = opaque };\n\n    virObjectRWLockRead(obj->volumes);\n    volobj = virHashSearch(obj->volumes->objsKey,\n                           virStoragePoolObjSearchVolumeCb,\n                           &data, NULL);\n    virObjectRWUnlock(obj->volumes);\n\n    if (volobj)\n        return volobj->voldef;\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjAddVol",
          "args": [
            "pool",
            "vol"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjAddVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "641-679",
          "snippet": "int\nvirStoragePoolObjAddVol(virStoragePoolObjPtr obj,\n                        virStorageVolDefPtr voldef)\n{\n    virStorageVolObjPtr volobj = NULL;\n    virStorageVolObjListPtr volumes = obj->volumes;\n\n    virObjectRWLockWrite(volumes);\n\n    if (!(volobj = virStorageVolObjNew()))\n        goto error;\n\n    if (virHashAddEntry(volumes->objsKey, voldef->key, volobj) < 0)\n        goto error;\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsName, voldef->name, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsPath, voldef->target.path, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        virHashRemoveEntry(volumes->objsName, voldef->name);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    volobj->voldef = voldef;\n    virObjectRWUnlock(volumes);\n    virStorageVolObjEndAPI(&volobj);\n    return 0;\n\n error:\n    virStorageVolObjEndAPI(&volobj);\n    virObjectRWUnlock(volumes);\n    return -1;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nint\nvirStoragePoolObjAddVol(virStoragePoolObjPtr obj,\n                        virStorageVolDefPtr voldef)\n{\n    virStorageVolObjPtr volobj = NULL;\n    virStorageVolObjListPtr volumes = obj->volumes;\n\n    virObjectRWLockWrite(volumes);\n\n    if (!(volobj = virStorageVolObjNew()))\n        goto error;\n\n    if (virHashAddEntry(volumes->objsKey, voldef->key, volobj) < 0)\n        goto error;\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsName, voldef->name, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsPath, voldef->target.path, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        virHashRemoveEntry(volumes->objsName, voldef->name);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    volobj->voldef = voldef;\n    virObjectRWUnlock(volumes);\n    virStorageVolObjEndAPI(&volobj);\n    return 0;\n\n error:\n    virStorageVolObjEndAPI(&volobj);\n    virObjectRWUnlock(volumes);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendUpdateVolInfo",
          "args": [
            "vol",
            "false",
            "VIR_STORAGE_VOL_OPEN_DEFAULT",
            "0"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendUpdateVolInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1781-1805",
          "snippet": "int\nvirStorageBackendUpdateVolInfo(virStorageVolDefPtr vol,\n                               bool withBlockVolFormat,\n                               unsigned int openflags,\n                               unsigned int readflags)\n{\n    int ret;\n\n    if ((ret = storageBackendUpdateVolTargetInfo(vol->type,\n                                                 &vol->target,\n                                                 withBlockVolFormat,\n                                                 openflags, readflags)) < 0)\n        return ret;\n\n    if (virStorageSourceHasBacking(&vol->target) &&\n        (ret = storageBackendUpdateVolTargetInfo(VIR_STORAGE_VOL_FILE,\n                                                 vol->target.backingStore,\n                                                 withBlockVolFormat,\n                                                 VIR_STORAGE_VOL_OPEN_DEFAULT |\n                                                 VIR_STORAGE_VOL_OPEN_NOERROR,\n                                                 readflags)) == -1)\n        return ret;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendUpdateVolInfo(virStorageVolDefPtr vol,\n                               bool withBlockVolFormat,\n                               unsigned int openflags,\n                               unsigned int readflags)\n{\n    int ret;\n\n    if ((ret = storageBackendUpdateVolTargetInfo(vol->type,\n                                                 &vol->target,\n                                                 withBlockVolFormat,\n                                                 openflags, readflags)) < 0)\n        return ret;\n\n    if (virStorageSourceHasBacking(&vol->target) &&\n        (ret = storageBackendUpdateVolTargetInfo(VIR_STORAGE_VOL_FILE,\n                                                 vol->target.backingStore,\n                                                 withBlockVolFormat,\n                                                 VIR_STORAGE_VOL_OPEN_DEFAULT |\n                                                 VIR_STORAGE_VOL_OPEN_NOERROR,\n                                                 readflags)) == -1)\n        return ret;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virWaitForDevices",
          "args": [],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "virWaitForDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1324-1341",
          "snippet": "void virWaitForDevices(void)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *udev = NULL;\n    int exitstatus;\n\n    if (!(udev = virFindFileInPath(UDEVADM)))\n        return;\n\n    if (!(cmd = virCommandNewArgList(udev, \"settle\", NULL)))\n        return;\n\n    /*\n     * NOTE: we ignore errors here; this is just to make sure that any device\n     * nodes that are being created finish before we try to scan them.\n     */\n    ignore_value(virCommandRun(cmd, &exitstatus));\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virWaitForDevices(void)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *udev = NULL;\n    int exitstatus;\n\n    if (!(udev = virFindFileInPath(UDEVADM)))\n        return;\n\n    if (!(cmd = virCommandNewArgList(udev, \"settle\", NULL)))\n        return;\n\n    /*\n     * NOTE: we ignore errors here; this is just to make sure that any device\n     * nodes that are being created finish before we try to scan them.\n     */\n    ignore_value(virCommandRun(cmd, &exitstatus));\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "groups[1]",
            "\"extended\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "groups[1]",
            "\"logical\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "groups[1]",
            "\"normal\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "def->source.devices[0].path"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot parse device end location\")"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ull",
          "args": [
            "groups[4]",
            "NULL",
            "10",
            "&vol->source.extents[0].end"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ullp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "568-586",
          "snippet": "int\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot parse device start location\")"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "vol->source.extents"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "tmp",
            "tmp + 1",
            "strlen(tmp)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "vol->target.path",
            "'p'"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virIsDevMapperDevice",
          "args": [
            "groups[0]"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "virIsDevMapperDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1357-1360",
          "snippet": "bool virIsDevMapperDevice(const char *dev_name G_GNUC_UNUSED)\n{\n    return false;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nbool virIsDevMapperDevice(const char *dev_name G_GNUC_UNUSED)\n{\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "tmp",
            "tmp + 1",
            "strlen(tmp)"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "groups[0]",
            "'p'"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "groups[0]",
            "vol->target.path"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"invalid partition name '%s', expected '%s'\")",
            "vol->name",
            "partname"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "vol->name",
            "partname"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendStablePath",
          "args": [
            "pool",
            "devpath",
            "true"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendStablePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1904-1975",
          "snippet": "char *\nvirStorageBackendStablePath(virStoragePoolObjPtr pool,\n                            const char *devpath,\n                            bool loop)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    DIR *dh;\n    struct dirent *dent;\n    char *stablepath;\n    int opentries = 0;\n    int retry = 0;\n    int direrr;\n\n    /* Logical pools are under /dev but already have stable paths */\n    if (def->type == VIR_STORAGE_POOL_LOGICAL ||\n        !virStorageBackendPoolPathIsStable(def->target.path))\n        goto ret_strdup;\n\n    /* We loop here because /dev/disk/by-{id,path} may not have existed\n     * before we started this operation, so we have to give it some time to\n     * get created.\n     */\n reopen:\n    if (virDirOpenQuiet(&dh, def->target.path) < 0) {\n        opentries++;\n        if (loop && errno == ENOENT && opentries < 50) {\n            g_usleep(100 * 1000);\n            goto reopen;\n        }\n        virReportSystemError(errno,\n                             _(\"cannot read dir '%s'\"),\n                             def->target.path);\n        return NULL;\n    }\n\n    /* The pool is pointing somewhere like /dev/disk/by-path\n     * or /dev/disk/by-id, so we need to check all symlinks in\n     * the target directory and figure out which one points\n     * to this device node.\n     *\n     * And it might need some time till the stable path shows\n     * up, so add timeout to retry here.  Ignore readdir failures,\n     * since we have a fallback.\n     */\n retry:\n    while ((direrr = virDirRead(dh, &dent, NULL)) > 0) {\n        stablepath = g_strdup_printf(\"%s/%s\", def->target.path, dent->d_name);\n\n        if (virFileLinkPointsTo(stablepath, devpath)) {\n            VIR_DIR_CLOSE(dh);\n            return stablepath;\n        }\n\n        VIR_FREE(stablepath);\n    }\n\n    if (!direrr && loop && ++retry < 100) {\n        g_usleep(100 * 1000);\n        goto retry;\n    }\n\n    VIR_DIR_CLOSE(dh);\n\n ret_strdup:\n    /* Couldn't find any matching stable link so give back\n     * the original non-stable dev path\n     */\n\n    stablepath = g_strdup(devpath);\n\n    return stablepath;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirStorageBackendStablePath(virStoragePoolObjPtr pool,\n                            const char *devpath,\n                            bool loop)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    DIR *dh;\n    struct dirent *dent;\n    char *stablepath;\n    int opentries = 0;\n    int retry = 0;\n    int direrr;\n\n    /* Logical pools are under /dev but already have stable paths */\n    if (def->type == VIR_STORAGE_POOL_LOGICAL ||\n        !virStorageBackendPoolPathIsStable(def->target.path))\n        goto ret_strdup;\n\n    /* We loop here because /dev/disk/by-{id,path} may not have existed\n     * before we started this operation, so we have to give it some time to\n     * get created.\n     */\n reopen:\n    if (virDirOpenQuiet(&dh, def->target.path) < 0) {\n        opentries++;\n        if (loop && errno == ENOENT && opentries < 50) {\n            g_usleep(100 * 1000);\n            goto reopen;\n        }\n        virReportSystemError(errno,\n                             _(\"cannot read dir '%s'\"),\n                             def->target.path);\n        return NULL;\n    }\n\n    /* The pool is pointing somewhere like /dev/disk/by-path\n     * or /dev/disk/by-id, so we need to check all symlinks in\n     * the target directory and figure out which one points\n     * to this device node.\n     *\n     * And it might need some time till the stable path shows\n     * up, so add timeout to retry here.  Ignore readdir failures,\n     * since we have a fallback.\n     */\n retry:\n    while ((direrr = virDirRead(dh, &dent, NULL)) > 0) {\n        stablepath = g_strdup_printf(\"%s/%s\", def->target.path, dent->d_name);\n\n        if (virFileLinkPointsTo(stablepath, devpath)) {\n            VIR_DIR_CLOSE(dh);\n            return stablepath;\n        }\n\n        VIR_FREE(stablepath);\n    }\n\n    if (!direrr && loop && ++retry < 100) {\n        g_usleep(100 * 1000);\n        goto retry;\n    }\n\n    VIR_DIR_CLOSE(dh);\n\n ret_strdup:\n    /* Couldn't find any matching stable link so give back\n     * the original non-stable dev path\n     */\n\n    stablepath = g_strdup(devpath);\n\n    return stablepath;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "vol"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "groups[0]",
            "'/'"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendDiskMakeDataVol(virStoragePoolObjPtr pool,\n                                 char **const groups,\n                                 virStorageVolDefPtr vol)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    char *tmp, *partname;\n    bool addVol = false;\n    g_autofree char *devpath = NULL;\n\n    /* Prepended path will be same for all partitions, so we can\n     * strip the path to form a reasonable pool-unique name\n     */\n    if ((tmp = strrchr(groups[0], '/')))\n        partname = tmp + 1;\n    else\n        partname = groups[0];\n\n    if (vol == NULL) {\n        /* This is typically a reload/restart/refresh path where\n         * we're discovering the existing partitions for the pool\n         */\n        addVol = true;\n        if (VIR_ALLOC(vol) < 0)\n            return -1;\n        vol->name = g_strdup(partname);\n    }\n\n    if (vol->target.path == NULL) {\n        devpath = g_strdup(groups[0]);\n\n        /* Now figure out the stable path\n         *\n         * XXX this method is O(N) because it scans the pool target\n         * dir every time its run. Should figure out a more efficient\n         * way of doing this...\n         */\n        vol->target.path = virStorageBackendStablePath(pool, devpath, true);\n        if (vol->target.path == NULL)\n            goto error;\n    }\n\n    /* Enforce provided vol->name is the same as what parted created.\n     * We do this after filling target.path so that we have a chance at\n     * deleting the partition with this failure from CreateVol path\n     */\n    if (STRNEQ(vol->name, partname)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"invalid partition name '%s', expected '%s'\"),\n                       vol->name, partname);\n\n        /* Let's see if by chance parthelper created a name that won't be\n         * found later when we try to delete. We tell parthelper to add a 'p'\n         * to the output via the part_separator flag, but if devmapper has\n         * user_friendly_names set, the creation won't happen that way, thus\n         * our deletion will fail because the name we generated is wrong.\n         * Check for our conditions and see if the generated name is the\n         * same as StablePath returns and has the 'p' in it */\n        if (def->source.devices[0].part_separator == VIR_TRISTATE_BOOL_YES &&\n            !virIsDevMapperDevice(vol->target.path) &&\n            STREQ(groups[0], vol->target.path) &&\n            (tmp = strrchr(groups[0], 'p'))) {\n\n            /* If we remove the 'p' from groups[0] and the resulting\n             * device is a devmapper device, then we know parthelper\n             * was told to create the wrong name based on the results.\n             * So just remove the 'p' from the vol->target.path too. */\n            memmove(tmp, tmp + 1, strlen(tmp));\n            if (virIsDevMapperDevice(groups[0]) &&\n                (tmp = strrchr(vol->target.path, 'p')))\n                memmove(tmp, tmp + 1, strlen(tmp));\n        }\n        goto error;\n    }\n\n    if (vol->key == NULL) {\n        /* XXX base off a unique key of the underlying disk */\n        vol->key = g_strdup(vol->target.path);\n    }\n\n    if (vol->source.extents == NULL) {\n        if (VIR_ALLOC(vol->source.extents) < 0)\n            goto error;\n        vol->source.nextent = 1;\n\n        if (virStrToLong_ull(groups[3], NULL, 10,\n                             &vol->source.extents[0].start) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"cannot parse device start location\"));\n            goto error;\n        }\n\n        if (virStrToLong_ull(groups[4], NULL, 10,\n                             &vol->source.extents[0].end) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"cannot parse device end location\"));\n            goto error;\n        }\n\n        vol->source.extents[0].path = g_strdup(def->source.devices[0].path);\n    }\n\n    /* set partition type */\n    if (STREQ(groups[1], \"normal\"))\n       vol->source.partType = VIR_STORAGE_VOL_DISK_TYPE_PRIMARY;\n    else if (STREQ(groups[1], \"logical\"))\n       vol->source.partType = VIR_STORAGE_VOL_DISK_TYPE_LOGICAL;\n    else if (STREQ(groups[1], \"extended\"))\n       vol->source.partType = VIR_STORAGE_VOL_DISK_TYPE_EXTENDED;\n    else\n       vol->source.partType = VIR_STORAGE_VOL_DISK_TYPE_NONE;\n\n    vol->type = VIR_STORAGE_VOL_BLOCK;\n\n    /* Refresh allocation/capacity/perms\n     *\n     * For an extended partition, virStorageBackendUpdateVolInfo will\n     * return incorrect values for allocation and capacity, so use the\n     * extent information captured above instead.\n     *\n     * Also once a logical partition exists or another primary partition\n     * after an extended partition is created an open on the extended\n     * partition will fail, so pass the NOERROR flag and only error if a\n     * -1 was returned indicating some other error than an open error.\n     *\n     * NB: A small window exists in some cases where the just created\n     * partition disappears, but then reappears. Since we were given\n     * vol->target.path from parthelper, let's just be sure that any\n     * kernel magic that occurs as a result of parthelper doesn't cause\n     * us to fail with some sort of ENOENT failure since that would be\n     * quite \"unexpected\". So rather than just fail, let's use the\n     * virWaitForDevices to ensure everything has settled properly.\n     */\n    virWaitForDevices();\n    if (vol->source.partType == VIR_STORAGE_VOL_DISK_TYPE_EXTENDED) {\n        if (virStorageBackendUpdateVolInfo(vol, false,\n                                           VIR_STORAGE_VOL_OPEN_DEFAULT |\n                                           VIR_STORAGE_VOL_OPEN_NOERROR,\n                                           0) == -1)\n            goto error;\n        vol->target.allocation = 0;\n        vol->target.capacity =\n            (vol->source.extents[0].end - vol->source.extents[0].start);\n    } else {\n        if (virStorageBackendUpdateVolInfo(vol, false,\n                                           VIR_STORAGE_VOL_OPEN_DEFAULT, 0) < 0)\n            goto error;\n    }\n\n    /* Now that we've updated @vol enough, let's add it to the pool\n     * if it's not already there so that the subsequent pool search\n     * pool def adjustments will work properly */\n    if (addVol && virStoragePoolObjAddVol(pool, vol) < 0)\n        goto error;\n\n    /* Find the extended partition and increase the allocation value */\n    if (vol->source.partType == VIR_STORAGE_VOL_DISK_TYPE_LOGICAL) {\n        virStorageVolDefPtr voldef;\n\n        voldef = virStoragePoolObjSearchVolume(pool,\n                                               virStorageVolPartFindExtended,\n                                               NULL);\n        if (voldef)\n            voldef->target.allocation += vol->target.allocation;\n    }\n\n    if (STRNEQ(groups[2], \"metadata\"))\n        def->allocation += vol->target.allocation;\n    if (vol->source.extents[0].end > def->capacity)\n        def->capacity = vol->source.extents[0].end;\n\n    return 0;\n\n error:\n    if (addVol)\n        virStorageVolDefFree(vol);\n    return -1;\n}"
  },
  {
    "function_name": "virStorageVolPartFindExtended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_disk.c",
    "lines": "42-50",
    "snippet": "static bool\nvirStorageVolPartFindExtended(virStorageVolDefPtr def,\n                              const void *opaque G_GNUC_UNUSED)\n{\n    if (def->source.partType == VIR_STORAGE_VOL_DISK_TYPE_EXTENDED)\n        return true;\n\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_disk.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_disk.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic bool\nvirStorageVolPartFindExtended(virStorageVolDefPtr def,\n                              const void *opaque G_GNUC_UNUSED)\n{\n    if (def->source.partType == VIR_STORAGE_VOL_DISK_TYPE_EXTENDED)\n        return true;\n\n    return false;\n}"
  }
]