[
  {
    "function_name": "virSecurityMoveRememberedLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
    "lines": "444-530",
    "snippet": "int\nvirSecurityMoveRememberedLabel(const char *name,\n                               const char *src,\n                               const char *dst)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *ref_value = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *attr_value = NULL;\n    g_autofree char *timestamp_name = NULL;\n    g_autofree char *timestamp_value = NULL;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)) ||\n        !(attr_name = virSecurityGetAttrName(name)) ||\n        !(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(src, ref_name, &ref_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 ref_name, src);\n            return -1;\n        }\n    }\n\n    if (virFileGetXAttrQuiet(src, attr_name, &attr_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 attr_name, src);\n            return -1;\n        }\n    }\n\n    if (virFileGetXAttrQuiet(src, timestamp_name, &timestamp_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 attr_name, src);\n            return -1;\n        }\n    }\n\n    if (ref_value &&\n        virFileRemoveXAttr(src, ref_name) < 0) {\n        return -1;\n    }\n\n    if (attr_value &&\n        virFileRemoveXAttr(src, attr_name) < 0) {\n        return -1;\n    }\n\n    if (timestamp_value &&\n        virFileRemoveXAttr(src, timestamp_name) < 0) {\n        return -1;\n    }\n\n    if (dst) {\n        if (ref_value &&\n            virFileSetXAttr(dst, ref_name, ref_value) < 0) {\n            return -1;\n        }\n\n        if (attr_value &&\n            virFileSetXAttr(dst, attr_name, attr_value) < 0) {\n            ignore_value(virFileRemoveXAttr(dst, ref_name));\n            return -1;\n        }\n\n        if (timestamp_value &&\n            virFileSetXAttr(dst, timestamp_name, timestamp_value) < 0) {\n            ignore_value(virFileRemoveXAttr(dst, ref_name));\n            ignore_value(virFileRemoveXAttr(dst, attr_name));\n            return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"security_util.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virFileRemoveXAttr(dst, attr_name)"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileRemoveXAttr",
          "args": [
            "dst",
            "attr_name"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "virFileRemoveXAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4456-4465",
          "snippet": "int\nvirFileRemoveXAttr(const char *path,\n                   const char *name)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno,\n                         _(\"Unable to remove XATTR %s on %s\"),\n                         name, path);\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileRemoveXAttr(const char *path,\n                   const char *name)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno,\n                         _(\"Unable to remove XATTR %s on %s\"),\n                         name, path);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virFileRemoveXAttr(dst, ref_name)"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileSetXAttr",
          "args": [
            "dst",
            "timestamp_name",
            "timestamp_value"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "virFileSetXAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4444-4454",
          "snippet": "int\nvirFileSetXAttr(const char *path,\n                const char *name,\n                const char *value G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno,\n                         _(\"Unable to set XATTR %s on %s\"),\n                         name, path);\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileSetXAttr(const char *path,\n                const char *name,\n                const char *value G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno,\n                         _(\"Unable to set XATTR %s on %s\"),\n                         name, path);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virFileRemoveXAttr(dst, ref_name)"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to get XATTR %s on %s\")",
            "attr_name",
            "src"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to get XATTR %s on %s\""
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileGetXAttrQuiet",
          "args": [
            "src",
            "timestamp_name",
            "&timestamp_value"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "virFileGetXAttrQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4435-4442",
          "snippet": "int\nvirFileGetXAttrQuiet(const char *path G_GNUC_UNUSED,\n                     const char *name G_GNUC_UNUSED,\n                     char **value G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileGetXAttrQuiet(const char *path G_GNUC_UNUSED,\n                     const char *name G_GNUC_UNUSED,\n                     char **value G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to get XATTR %s on %s\")",
            "attr_name",
            "src"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to get XATTR %s on %s\")",
            "ref_name",
            "src"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityGetTimestampAttrName",
          "args": [
            "name"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityGetTimestampAttrName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "100-107",
          "snippet": "static char *\nvirSecurityGetTimestampAttrName(const char *name G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n    return NULL;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char *\nvirSecurityGetTimestampAttrName(const char *name G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityGetAttrName",
          "args": [
            "name"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityGetAttrName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "61-73",
          "snippet": "static char *\nvirSecurityGetAttrName(const char *name G_GNUC_UNUSED)\n{\n    char *ret = NULL;\n#ifdef XATTR_NAMESPACE\n    ret = g_strdup_printf(XATTR_NAMESPACE\".libvirt.security.%s\", name);\n#else\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n#endif\n    return ret;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char *\nvirSecurityGetAttrName(const char *name G_GNUC_UNUSED)\n{\n    char *ret = NULL;\n#ifdef XATTR_NAMESPACE\n    ret = g_strdup_printf(XATTR_NAMESPACE\".libvirt.security.%s\", name);\n#else\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n#endif\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityGetRefCountAttrName",
          "args": [
            "name"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityGetRefCountAttrName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "76-88",
          "snippet": "static char *\nvirSecurityGetRefCountAttrName(const char *name G_GNUC_UNUSED)\n{\n    char *ret = NULL;\n#ifdef XATTR_NAMESPACE\n    ret = g_strdup_printf(XATTR_NAMESPACE\".libvirt.security.ref_%s\", name);\n#else\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n#endif\n    return ret;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char *\nvirSecurityGetRefCountAttrName(const char *name G_GNUC_UNUSED)\n{\n    char *ret = NULL;\n#ifdef XATTR_NAMESPACE\n    ret = g_strdup_printf(XATTR_NAMESPACE\".libvirt.security.ref_%s\", name);\n#else\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n#endif\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirSecurityMoveRememberedLabel(const char *name,\n                               const char *src,\n                               const char *dst)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *ref_value = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *attr_value = NULL;\n    g_autofree char *timestamp_name = NULL;\n    g_autofree char *timestamp_value = NULL;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)) ||\n        !(attr_name = virSecurityGetAttrName(name)) ||\n        !(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(src, ref_name, &ref_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 ref_name, src);\n            return -1;\n        }\n    }\n\n    if (virFileGetXAttrQuiet(src, attr_name, &attr_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 attr_name, src);\n            return -1;\n        }\n    }\n\n    if (virFileGetXAttrQuiet(src, timestamp_name, &timestamp_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 attr_name, src);\n            return -1;\n        }\n    }\n\n    if (ref_value &&\n        virFileRemoveXAttr(src, ref_name) < 0) {\n        return -1;\n    }\n\n    if (attr_value &&\n        virFileRemoveXAttr(src, attr_name) < 0) {\n        return -1;\n    }\n\n    if (timestamp_value &&\n        virFileRemoveXAttr(src, timestamp_name) < 0) {\n        return -1;\n    }\n\n    if (dst) {\n        if (ref_value &&\n            virFileSetXAttr(dst, ref_name, ref_value) < 0) {\n            return -1;\n        }\n\n        if (attr_value &&\n            virFileSetXAttr(dst, attr_name, attr_value) < 0) {\n            ignore_value(virFileRemoveXAttr(dst, ref_name));\n            return -1;\n        }\n\n        if (timestamp_value &&\n            virFileSetXAttr(dst, timestamp_name, timestamp_value) < 0) {\n            ignore_value(virFileRemoveXAttr(dst, ref_name));\n            ignore_value(virFileRemoveXAttr(dst, attr_name));\n            return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySetRememberedLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
    "lines": "360-428",
    "snippet": "int\nvirSecuritySetRememberedLabel(const char *name,\n                              const char *path,\n                              const char *label)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *value = NULL;\n    unsigned int refcount = 0;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(path, ref_name, &value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 ref_name,\n                                 path);\n            return -1;\n        }\n    }\n\n    if (value) {\n        int rc;\n\n        /* Do this after we've tried to get refcounter to ensure underlying FS\n         * supports XATTRs and @path has refcounter attribute set, because\n         * validator might throws a warning. */\n        if ((rc = virSecurityValidateTimestamp(name, path)) < 0)\n            return rc;\n\n        /* Invalid label is like a non-existent one */\n        if (rc == 1)\n            VIR_FREE(value);\n    }\n\n    if (value &&\n        virStrToLong_ui(value, NULL, 10, &refcount) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed refcount %s on %s\"),\n                       value, path);\n        return -1;\n    }\n\n    VIR_FREE(value);\n\n    refcount++;\n\n    if (refcount == 1) {\n        if (!(attr_name = virSecurityGetAttrName(name)))\n            return -1;\n\n        if (virFileSetXAttr(path, attr_name, label) < 0)\n            return -1;\n\n        if (virSecurityAddTimestamp(name, path) < 0)\n            return -1;\n    }\n\n    value = g_strdup_printf(\"%u\", refcount);\n\n    if (virFileSetXAttr(path, ref_name, value) < 0)\n        return -1;\n\n    return refcount;\n}",
    "includes": [
      "#include \"security_util.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileSetXAttr",
          "args": [
            "path",
            "ref_name",
            "value"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "virFileSetXAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4444-4454",
          "snippet": "int\nvirFileSetXAttr(const char *path,\n                const char *name,\n                const char *value G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno,\n                         _(\"Unable to set XATTR %s on %s\"),\n                         name, path);\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileSetXAttr(const char *path,\n                const char *name,\n                const char *value G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno,\n                         _(\"Unable to set XATTR %s on %s\"),\n                         name, path);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%u\"",
            "refcount"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityAddTimestamp",
          "args": [
            "name",
            "path"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityAddTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "207-219",
          "snippet": "static int\nvirSecurityAddTimestamp(const char *name,\n                        const char *path)\n{\n    g_autofree char *timestamp_name = NULL;\n    g_autofree char *timestamp_value = NULL;\n\n    if (!(timestamp_value = virSecurityGetTimestamp()) ||\n        !(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    return virFileSetXAttr(path, timestamp_name, timestamp_value);\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirSecurityAddTimestamp(const char *name,\n                        const char *path)\n{\n    g_autofree char *timestamp_name = NULL;\n    g_autofree char *timestamp_value = NULL;\n\n    if (!(timestamp_value = virSecurityGetTimestamp()) ||\n        !(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    return virFileSetXAttr(path, timestamp_name, timestamp_value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityGetAttrName",
          "args": [
            "name"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityGetAttrName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "61-73",
          "snippet": "static char *\nvirSecurityGetAttrName(const char *name G_GNUC_UNUSED)\n{\n    char *ret = NULL;\n#ifdef XATTR_NAMESPACE\n    ret = g_strdup_printf(XATTR_NAMESPACE\".libvirt.security.%s\", name);\n#else\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n#endif\n    return ret;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char *\nvirSecurityGetAttrName(const char *name G_GNUC_UNUSED)\n{\n    char *ret = NULL;\n#ifdef XATTR_NAMESPACE\n    ret = g_strdup_printf(XATTR_NAMESPACE\".libvirt.security.%s\", name);\n#else\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n#endif\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "value"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"malformed refcount %s on %s\")",
            "value",
            "path"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"malformed refcount %s on %s\""
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "value",
            "NULL",
            "10",
            "&refcount"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "value"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityValidateTimestamp",
          "args": [
            "name",
            "path"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityValidateTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "161-204",
          "snippet": "static int\nvirSecurityValidateTimestamp(const char *name,\n                             const char *path)\n{\n    g_autofree char *expected_timestamp = NULL;\n    g_autofree char *timestamp_name = NULL;\n    g_autofree char *value = NULL;\n\n    if (!(expected_timestamp = virSecurityGetTimestamp()) ||\n        !(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    errno = 0;\n    if (virFileGetXAttrQuiet(path, timestamp_name, &value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 timestamp_name,\n                                 path);\n            return -1;\n        }\n\n        /* Timestamp is missing. We could continue and claim a valid timestamp.\n         * But then we would never remove stale XATTRs. Therefore, claim it\n         * invalid and have the code below remove all XATTRs. This of course\n         * means that we will not restore the original owner, but the plus side\n         * is that we reset refcounter which will represent the true state.\n         */\n    }\n\n    if (STREQ_NULLABLE(value, expected_timestamp)) {\n        VIR_DEBUG(\"XATTRs on %s secdriver=%s are valid\", path, name);\n        return 0;\n    }\n\n    VIR_WARN(\"Invalid XATTR timestamp detected on %s secdriver=%s\", path, name);\n\n    if (virSecurityMoveRememberedLabel(name, path, NULL) < 0)\n        return -1;\n\n    return 1;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirSecurityValidateTimestamp(const char *name,\n                             const char *path)\n{\n    g_autofree char *expected_timestamp = NULL;\n    g_autofree char *timestamp_name = NULL;\n    g_autofree char *value = NULL;\n\n    if (!(expected_timestamp = virSecurityGetTimestamp()) ||\n        !(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    errno = 0;\n    if (virFileGetXAttrQuiet(path, timestamp_name, &value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 timestamp_name,\n                                 path);\n            return -1;\n        }\n\n        /* Timestamp is missing. We could continue and claim a valid timestamp.\n         * But then we would never remove stale XATTRs. Therefore, claim it\n         * invalid and have the code below remove all XATTRs. This of course\n         * means that we will not restore the original owner, but the plus side\n         * is that we reset refcounter which will represent the true state.\n         */\n    }\n\n    if (STREQ_NULLABLE(value, expected_timestamp)) {\n        VIR_DEBUG(\"XATTRs on %s secdriver=%s are valid\", path, name);\n        return 0;\n    }\n\n    VIR_WARN(\"Invalid XATTR timestamp detected on %s secdriver=%s\", path, name);\n\n    if (virSecurityMoveRememberedLabel(name, path, NULL) < 0)\n        return -1;\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to get XATTR %s on %s\")",
            "ref_name",
            "path"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileGetXAttrQuiet",
          "args": [
            "path",
            "ref_name",
            "&value"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "virFileGetXAttrQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4435-4442",
          "snippet": "int\nvirFileGetXAttrQuiet(const char *path G_GNUC_UNUSED,\n                     const char *name G_GNUC_UNUSED,\n                     char **value G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileGetXAttrQuiet(const char *path G_GNUC_UNUSED,\n                     const char *name G_GNUC_UNUSED,\n                     char **value G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityGetRefCountAttrName",
          "args": [
            "name"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityGetRefCountAttrName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "76-88",
          "snippet": "static char *\nvirSecurityGetRefCountAttrName(const char *name G_GNUC_UNUSED)\n{\n    char *ret = NULL;\n#ifdef XATTR_NAMESPACE\n    ret = g_strdup_printf(XATTR_NAMESPACE\".libvirt.security.ref_%s\", name);\n#else\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n#endif\n    return ret;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char *\nvirSecurityGetRefCountAttrName(const char *name G_GNUC_UNUSED)\n{\n    char *ret = NULL;\n#ifdef XATTR_NAMESPACE\n    ret = g_strdup_printf(XATTR_NAMESPACE\".libvirt.security.ref_%s\", name);\n#else\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n#endif\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirSecuritySetRememberedLabel(const char *name,\n                              const char *path,\n                              const char *label)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *value = NULL;\n    unsigned int refcount = 0;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(path, ref_name, &value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 ref_name,\n                                 path);\n            return -1;\n        }\n    }\n\n    if (value) {\n        int rc;\n\n        /* Do this after we've tried to get refcounter to ensure underlying FS\n         * supports XATTRs and @path has refcounter attribute set, because\n         * validator might throws a warning. */\n        if ((rc = virSecurityValidateTimestamp(name, path)) < 0)\n            return rc;\n\n        /* Invalid label is like a non-existent one */\n        if (rc == 1)\n            VIR_FREE(value);\n    }\n\n    if (value &&\n        virStrToLong_ui(value, NULL, 10, &refcount) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed refcount %s on %s\"),\n                       value, path);\n        return -1;\n    }\n\n    VIR_FREE(value);\n\n    refcount++;\n\n    if (refcount == 1) {\n        if (!(attr_name = virSecurityGetAttrName(name)))\n            return -1;\n\n        if (virFileSetXAttr(path, attr_name, label) < 0)\n            return -1;\n\n        if (virSecurityAddTimestamp(name, path) < 0)\n            return -1;\n    }\n\n    value = g_strdup_printf(\"%u\", refcount);\n\n    if (virFileSetXAttr(path, ref_name, value) < 0)\n        return -1;\n\n    return refcount;\n}"
  },
  {
    "function_name": "virSecurityGetRememberedLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
    "lines": "263-337",
    "snippet": "int\nvirSecurityGetRememberedLabel(const char *name,\n                              const char *path,\n                              char **label)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *value = NULL;\n    unsigned int refcount = 0;\n\n    *label = NULL;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(path, ref_name, &value) < 0) {\n        if (errno == ENOSYS || errno == ENODATA || errno == ENOTSUP)\n            return -2;\n\n        virReportSystemError(errno,\n                             _(\"Unable to get XATTR %s on %s\"),\n                             ref_name,\n                             path);\n        return -1;\n    }\n\n    if (value) {\n        int rc;\n\n        /* Do this after we've tried to get refcounter to ensure underlying FS\n         * supports XATTRs and @path has refcounter attribute set, because\n         * validator might throws a warning. */\n        if ((rc = virSecurityValidateTimestamp(name, path)) < 0)\n            return rc;\n\n        /* Invalid label is like a non-existent one */\n        if (rc == 1)\n            return -2;\n    }\n\n    if (virStrToLong_ui(value, NULL, 10, &refcount) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed refcount %s on %s\"),\n                       value, path);\n        return -1;\n    }\n\n    VIR_FREE(value);\n\n    refcount--;\n\n    if (refcount > 0) {\n        value = g_strdup_printf(\"%u\", refcount);\n\n        if (virFileSetXAttr(path, ref_name, value) < 0)\n            return -1;\n    } else {\n        if (virFileRemoveXAttr(path, ref_name) < 0)\n            return -1;\n\n        if (!(attr_name = virSecurityGetAttrName(name)))\n            return -1;\n\n        if (virFileGetXAttr(path, attr_name, label) < 0)\n            return -1;\n\n        if (virFileRemoveXAttr(path, attr_name) < 0)\n            return -1;\n\n        if (virSecurityRemoveTimestamp(name, path) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"security_util.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityRemoveTimestamp",
          "args": [
            "name",
            "path"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityRemoveTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "222-235",
          "snippet": "static int\nvirSecurityRemoveTimestamp(const char *name,\n                           const char *path)\n{\n    g_autofree char *timestamp_name = NULL;\n\n    if (!(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    if (virFileRemoveXAttr(path, timestamp_name) < 0 && errno != ENOENT)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirSecurityRemoveTimestamp(const char *name,\n                           const char *path)\n{\n    g_autofree char *timestamp_name = NULL;\n\n    if (!(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    if (virFileRemoveXAttr(path, timestamp_name) < 0 && errno != ENOENT)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileRemoveXAttr",
          "args": [
            "path",
            "attr_name"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "virFileRemoveXAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4456-4465",
          "snippet": "int\nvirFileRemoveXAttr(const char *path,\n                   const char *name)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno,\n                         _(\"Unable to remove XATTR %s on %s\"),\n                         name, path);\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileRemoveXAttr(const char *path,\n                   const char *name)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno,\n                         _(\"Unable to remove XATTR %s on %s\"),\n                         name, path);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileGetXAttr",
          "args": [
            "path",
            "attr_name",
            "label"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "virFileGetXAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4481-4495",
          "snippet": "int\nvirFileGetXAttr(const char *path,\n                const char *name,\n                char **value)\n{\n    int ret;\n\n    if ((ret = virFileGetXAttrQuiet(path, name, value)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to get XATTR %s on %s\"),\n                             name, path);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileGetXAttr(const char *path,\n                const char *name,\n                char **value)\n{\n    int ret;\n\n    if ((ret = virFileGetXAttrQuiet(path, name, value)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to get XATTR %s on %s\"),\n                             name, path);\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityGetAttrName",
          "args": [
            "name"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityGetAttrName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "61-73",
          "snippet": "static char *\nvirSecurityGetAttrName(const char *name G_GNUC_UNUSED)\n{\n    char *ret = NULL;\n#ifdef XATTR_NAMESPACE\n    ret = g_strdup_printf(XATTR_NAMESPACE\".libvirt.security.%s\", name);\n#else\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n#endif\n    return ret;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char *\nvirSecurityGetAttrName(const char *name G_GNUC_UNUSED)\n{\n    char *ret = NULL;\n#ifdef XATTR_NAMESPACE\n    ret = g_strdup_printf(XATTR_NAMESPACE\".libvirt.security.%s\", name);\n#else\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n#endif\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileSetXAttr",
          "args": [
            "path",
            "ref_name",
            "value"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "virFileSetXAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4444-4454",
          "snippet": "int\nvirFileSetXAttr(const char *path,\n                const char *name,\n                const char *value G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno,\n                         _(\"Unable to set XATTR %s on %s\"),\n                         name, path);\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileSetXAttr(const char *path,\n                const char *name,\n                const char *value G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno,\n                         _(\"Unable to set XATTR %s on %s\"),\n                         name, path);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%u\"",
            "refcount"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "value"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"malformed refcount %s on %s\")",
            "value",
            "path"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"malformed refcount %s on %s\""
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "value",
            "NULL",
            "10",
            "&refcount"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityValidateTimestamp",
          "args": [
            "name",
            "path"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityValidateTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "161-204",
          "snippet": "static int\nvirSecurityValidateTimestamp(const char *name,\n                             const char *path)\n{\n    g_autofree char *expected_timestamp = NULL;\n    g_autofree char *timestamp_name = NULL;\n    g_autofree char *value = NULL;\n\n    if (!(expected_timestamp = virSecurityGetTimestamp()) ||\n        !(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    errno = 0;\n    if (virFileGetXAttrQuiet(path, timestamp_name, &value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 timestamp_name,\n                                 path);\n            return -1;\n        }\n\n        /* Timestamp is missing. We could continue and claim a valid timestamp.\n         * But then we would never remove stale XATTRs. Therefore, claim it\n         * invalid and have the code below remove all XATTRs. This of course\n         * means that we will not restore the original owner, but the plus side\n         * is that we reset refcounter which will represent the true state.\n         */\n    }\n\n    if (STREQ_NULLABLE(value, expected_timestamp)) {\n        VIR_DEBUG(\"XATTRs on %s secdriver=%s are valid\", path, name);\n        return 0;\n    }\n\n    VIR_WARN(\"Invalid XATTR timestamp detected on %s secdriver=%s\", path, name);\n\n    if (virSecurityMoveRememberedLabel(name, path, NULL) < 0)\n        return -1;\n\n    return 1;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirSecurityValidateTimestamp(const char *name,\n                             const char *path)\n{\n    g_autofree char *expected_timestamp = NULL;\n    g_autofree char *timestamp_name = NULL;\n    g_autofree char *value = NULL;\n\n    if (!(expected_timestamp = virSecurityGetTimestamp()) ||\n        !(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    errno = 0;\n    if (virFileGetXAttrQuiet(path, timestamp_name, &value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 timestamp_name,\n                                 path);\n            return -1;\n        }\n\n        /* Timestamp is missing. We could continue and claim a valid timestamp.\n         * But then we would never remove stale XATTRs. Therefore, claim it\n         * invalid and have the code below remove all XATTRs. This of course\n         * means that we will not restore the original owner, but the plus side\n         * is that we reset refcounter which will represent the true state.\n         */\n    }\n\n    if (STREQ_NULLABLE(value, expected_timestamp)) {\n        VIR_DEBUG(\"XATTRs on %s secdriver=%s are valid\", path, name);\n        return 0;\n    }\n\n    VIR_WARN(\"Invalid XATTR timestamp detected on %s secdriver=%s\", path, name);\n\n    if (virSecurityMoveRememberedLabel(name, path, NULL) < 0)\n        return -1;\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to get XATTR %s on %s\")",
            "ref_name",
            "path"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileGetXAttrQuiet",
          "args": [
            "path",
            "ref_name",
            "&value"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "virFileGetXAttrQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4435-4442",
          "snippet": "int\nvirFileGetXAttrQuiet(const char *path G_GNUC_UNUSED,\n                     const char *name G_GNUC_UNUSED,\n                     char **value G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileGetXAttrQuiet(const char *path G_GNUC_UNUSED,\n                     const char *name G_GNUC_UNUSED,\n                     char **value G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityGetRefCountAttrName",
          "args": [
            "name"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityGetRefCountAttrName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "76-88",
          "snippet": "static char *\nvirSecurityGetRefCountAttrName(const char *name G_GNUC_UNUSED)\n{\n    char *ret = NULL;\n#ifdef XATTR_NAMESPACE\n    ret = g_strdup_printf(XATTR_NAMESPACE\".libvirt.security.ref_%s\", name);\n#else\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n#endif\n    return ret;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char *\nvirSecurityGetRefCountAttrName(const char *name G_GNUC_UNUSED)\n{\n    char *ret = NULL;\n#ifdef XATTR_NAMESPACE\n    ret = g_strdup_printf(XATTR_NAMESPACE\".libvirt.security.ref_%s\", name);\n#else\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n#endif\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirSecurityGetRememberedLabel(const char *name,\n                              const char *path,\n                              char **label)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *value = NULL;\n    unsigned int refcount = 0;\n\n    *label = NULL;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(path, ref_name, &value) < 0) {\n        if (errno == ENOSYS || errno == ENODATA || errno == ENOTSUP)\n            return -2;\n\n        virReportSystemError(errno,\n                             _(\"Unable to get XATTR %s on %s\"),\n                             ref_name,\n                             path);\n        return -1;\n    }\n\n    if (value) {\n        int rc;\n\n        /* Do this after we've tried to get refcounter to ensure underlying FS\n         * supports XATTRs and @path has refcounter attribute set, because\n         * validator might throws a warning. */\n        if ((rc = virSecurityValidateTimestamp(name, path)) < 0)\n            return rc;\n\n        /* Invalid label is like a non-existent one */\n        if (rc == 1)\n            return -2;\n    }\n\n    if (virStrToLong_ui(value, NULL, 10, &refcount) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed refcount %s on %s\"),\n                       value, path);\n        return -1;\n    }\n\n    VIR_FREE(value);\n\n    refcount--;\n\n    if (refcount > 0) {\n        value = g_strdup_printf(\"%u\", refcount);\n\n        if (virFileSetXAttr(path, ref_name, value) < 0)\n            return -1;\n    } else {\n        if (virFileRemoveXAttr(path, ref_name) < 0)\n            return -1;\n\n        if (!(attr_name = virSecurityGetAttrName(name)))\n            return -1;\n\n        if (virFileGetXAttr(path, attr_name, label) < 0)\n            return -1;\n\n        if (virFileRemoveXAttr(path, attr_name) < 0)\n            return -1;\n\n        if (virSecurityRemoveTimestamp(name, path) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityRemoveTimestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
    "lines": "222-235",
    "snippet": "static int\nvirSecurityRemoveTimestamp(const char *name,\n                           const char *path)\n{\n    g_autofree char *timestamp_name = NULL;\n\n    if (!(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    if (virFileRemoveXAttr(path, timestamp_name) < 0 && errno != ENOENT)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"security_util.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileRemoveXAttr",
          "args": [
            "path",
            "timestamp_name"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "virFileRemoveXAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4456-4465",
          "snippet": "int\nvirFileRemoveXAttr(const char *path,\n                   const char *name)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno,\n                         _(\"Unable to remove XATTR %s on %s\"),\n                         name, path);\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileRemoveXAttr(const char *path,\n                   const char *name)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno,\n                         _(\"Unable to remove XATTR %s on %s\"),\n                         name, path);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityGetTimestampAttrName",
          "args": [
            "name"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityGetTimestampAttrName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "100-107",
          "snippet": "static char *\nvirSecurityGetTimestampAttrName(const char *name G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n    return NULL;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char *\nvirSecurityGetTimestampAttrName(const char *name G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirSecurityRemoveTimestamp(const char *name,\n                           const char *path)\n{\n    g_autofree char *timestamp_name = NULL;\n\n    if (!(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    if (virFileRemoveXAttr(path, timestamp_name) < 0 && errno != ENOENT)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityAddTimestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
    "lines": "207-219",
    "snippet": "static int\nvirSecurityAddTimestamp(const char *name,\n                        const char *path)\n{\n    g_autofree char *timestamp_name = NULL;\n    g_autofree char *timestamp_value = NULL;\n\n    if (!(timestamp_value = virSecurityGetTimestamp()) ||\n        !(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    return virFileSetXAttr(path, timestamp_name, timestamp_value);\n}",
    "includes": [
      "#include \"security_util.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileSetXAttr",
          "args": [
            "path",
            "timestamp_name",
            "timestamp_value"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "virFileSetXAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4444-4454",
          "snippet": "int\nvirFileSetXAttr(const char *path,\n                const char *name,\n                const char *value G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno,\n                         _(\"Unable to set XATTR %s on %s\"),\n                         name, path);\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileSetXAttr(const char *path,\n                const char *name,\n                const char *value G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno,\n                         _(\"Unable to set XATTR %s on %s\"),\n                         name, path);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityGetTimestampAttrName",
          "args": [
            "name"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityGetTimestampAttrName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "100-107",
          "snippet": "static char *\nvirSecurityGetTimestampAttrName(const char *name G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n    return NULL;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char *\nvirSecurityGetTimestampAttrName(const char *name G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityGetTimestamp",
          "args": [],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityGetTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "111-125",
          "snippet": "static char *\nvirSecurityGetTimestamp(void)\n{\n    unsigned long long boottime = 0;\n    char *ret = NULL;\n\n    if (virHostGetBootTime(&boottime) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get host boot time\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%llu\", boottime);\n    return ret;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char *\nvirSecurityGetTimestamp(void)\n{\n    unsigned long long boottime = 0;\n    char *ret = NULL;\n\n    if (virHostGetBootTime(&boottime) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get host boot time\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%llu\", boottime);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirSecurityAddTimestamp(const char *name,\n                        const char *path)\n{\n    g_autofree char *timestamp_name = NULL;\n    g_autofree char *timestamp_value = NULL;\n\n    if (!(timestamp_value = virSecurityGetTimestamp()) ||\n        !(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    return virFileSetXAttr(path, timestamp_name, timestamp_value);\n}"
  },
  {
    "function_name": "virSecurityValidateTimestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
    "lines": "161-204",
    "snippet": "static int\nvirSecurityValidateTimestamp(const char *name,\n                             const char *path)\n{\n    g_autofree char *expected_timestamp = NULL;\n    g_autofree char *timestamp_name = NULL;\n    g_autofree char *value = NULL;\n\n    if (!(expected_timestamp = virSecurityGetTimestamp()) ||\n        !(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    errno = 0;\n    if (virFileGetXAttrQuiet(path, timestamp_name, &value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 timestamp_name,\n                                 path);\n            return -1;\n        }\n\n        /* Timestamp is missing. We could continue and claim a valid timestamp.\n         * But then we would never remove stale XATTRs. Therefore, claim it\n         * invalid and have the code below remove all XATTRs. This of course\n         * means that we will not restore the original owner, but the plus side\n         * is that we reset refcounter which will represent the true state.\n         */\n    }\n\n    if (STREQ_NULLABLE(value, expected_timestamp)) {\n        VIR_DEBUG(\"XATTRs on %s secdriver=%s are valid\", path, name);\n        return 0;\n    }\n\n    VIR_WARN(\"Invalid XATTR timestamp detected on %s secdriver=%s\", path, name);\n\n    if (virSecurityMoveRememberedLabel(name, path, NULL) < 0)\n        return -1;\n\n    return 1;\n}",
    "includes": [
      "#include \"security_util.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityMoveRememberedLabel",
          "args": [
            "name",
            "path",
            "NULL"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityMoveRememberedLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "444-530",
          "snippet": "int\nvirSecurityMoveRememberedLabel(const char *name,\n                               const char *src,\n                               const char *dst)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *ref_value = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *attr_value = NULL;\n    g_autofree char *timestamp_name = NULL;\n    g_autofree char *timestamp_value = NULL;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)) ||\n        !(attr_name = virSecurityGetAttrName(name)) ||\n        !(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(src, ref_name, &ref_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 ref_name, src);\n            return -1;\n        }\n    }\n\n    if (virFileGetXAttrQuiet(src, attr_name, &attr_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 attr_name, src);\n            return -1;\n        }\n    }\n\n    if (virFileGetXAttrQuiet(src, timestamp_name, &timestamp_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 attr_name, src);\n            return -1;\n        }\n    }\n\n    if (ref_value &&\n        virFileRemoveXAttr(src, ref_name) < 0) {\n        return -1;\n    }\n\n    if (attr_value &&\n        virFileRemoveXAttr(src, attr_name) < 0) {\n        return -1;\n    }\n\n    if (timestamp_value &&\n        virFileRemoveXAttr(src, timestamp_name) < 0) {\n        return -1;\n    }\n\n    if (dst) {\n        if (ref_value &&\n            virFileSetXAttr(dst, ref_name, ref_value) < 0) {\n            return -1;\n        }\n\n        if (attr_value &&\n            virFileSetXAttr(dst, attr_name, attr_value) < 0) {\n            ignore_value(virFileRemoveXAttr(dst, ref_name));\n            return -1;\n        }\n\n        if (timestamp_value &&\n            virFileSetXAttr(dst, timestamp_name, timestamp_value) < 0) {\n            ignore_value(virFileRemoveXAttr(dst, ref_name));\n            ignore_value(virFileRemoveXAttr(dst, attr_name));\n            return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirSecurityMoveRememberedLabel(const char *name,\n                               const char *src,\n                               const char *dst)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *ref_value = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *attr_value = NULL;\n    g_autofree char *timestamp_name = NULL;\n    g_autofree char *timestamp_value = NULL;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)) ||\n        !(attr_name = virSecurityGetAttrName(name)) ||\n        !(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(src, ref_name, &ref_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 ref_name, src);\n            return -1;\n        }\n    }\n\n    if (virFileGetXAttrQuiet(src, attr_name, &attr_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 attr_name, src);\n            return -1;\n        }\n    }\n\n    if (virFileGetXAttrQuiet(src, timestamp_name, &timestamp_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 attr_name, src);\n            return -1;\n        }\n    }\n\n    if (ref_value &&\n        virFileRemoveXAttr(src, ref_name) < 0) {\n        return -1;\n    }\n\n    if (attr_value &&\n        virFileRemoveXAttr(src, attr_name) < 0) {\n        return -1;\n    }\n\n    if (timestamp_value &&\n        virFileRemoveXAttr(src, timestamp_name) < 0) {\n        return -1;\n    }\n\n    if (dst) {\n        if (ref_value &&\n            virFileSetXAttr(dst, ref_name, ref_value) < 0) {\n            return -1;\n        }\n\n        if (attr_value &&\n            virFileSetXAttr(dst, attr_name, attr_value) < 0) {\n            ignore_value(virFileRemoveXAttr(dst, ref_name));\n            return -1;\n        }\n\n        if (timestamp_value &&\n            virFileSetXAttr(dst, timestamp_name, timestamp_value) < 0) {\n            ignore_value(virFileRemoveXAttr(dst, ref_name));\n            ignore_value(virFileRemoveXAttr(dst, attr_name));\n            return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Invalid XATTR timestamp detected on %s secdriver=%s\"",
            "path",
            "name"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"XATTRs on %s secdriver=%s are valid\"",
            "path",
            "name"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "value",
            "expected_timestamp"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to get XATTR %s on %s\")",
            "timestamp_name",
            "path"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to get XATTR %s on %s\""
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileGetXAttrQuiet",
          "args": [
            "path",
            "timestamp_name",
            "&value"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "virFileGetXAttrQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4435-4442",
          "snippet": "int\nvirFileGetXAttrQuiet(const char *path G_GNUC_UNUSED,\n                     const char *name G_GNUC_UNUSED,\n                     char **value G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileGetXAttrQuiet(const char *path G_GNUC_UNUSED,\n                     const char *name G_GNUC_UNUSED,\n                     char **value G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityGetTimestampAttrName",
          "args": [
            "name"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityGetTimestampAttrName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "100-107",
          "snippet": "static char *\nvirSecurityGetTimestampAttrName(const char *name G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n    return NULL;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char *\nvirSecurityGetTimestampAttrName(const char *name G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityGetTimestamp",
          "args": [],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityGetTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "111-125",
          "snippet": "static char *\nvirSecurityGetTimestamp(void)\n{\n    unsigned long long boottime = 0;\n    char *ret = NULL;\n\n    if (virHostGetBootTime(&boottime) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get host boot time\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%llu\", boottime);\n    return ret;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char *\nvirSecurityGetTimestamp(void)\n{\n    unsigned long long boottime = 0;\n    char *ret = NULL;\n\n    if (virHostGetBootTime(&boottime) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get host boot time\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%llu\", boottime);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirSecurityValidateTimestamp(const char *name,\n                             const char *path)\n{\n    g_autofree char *expected_timestamp = NULL;\n    g_autofree char *timestamp_name = NULL;\n    g_autofree char *value = NULL;\n\n    if (!(expected_timestamp = virSecurityGetTimestamp()) ||\n        !(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    errno = 0;\n    if (virFileGetXAttrQuiet(path, timestamp_name, &value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 timestamp_name,\n                                 path);\n            return -1;\n        }\n\n        /* Timestamp is missing. We could continue and claim a valid timestamp.\n         * But then we would never remove stale XATTRs. Therefore, claim it\n         * invalid and have the code below remove all XATTRs. This of course\n         * means that we will not restore the original owner, but the plus side\n         * is that we reset refcounter which will represent the true state.\n         */\n    }\n\n    if (STREQ_NULLABLE(value, expected_timestamp)) {\n        VIR_DEBUG(\"XATTRs on %s secdriver=%s are valid\", path, name);\n        return 0;\n    }\n\n    VIR_WARN(\"Invalid XATTR timestamp detected on %s secdriver=%s\", path, name);\n\n    if (virSecurityMoveRememberedLabel(name, path, NULL) < 0)\n        return -1;\n\n    return 1;\n}"
  },
  {
    "function_name": "virSecurityGetTimestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
    "lines": "111-125",
    "snippet": "static char *\nvirSecurityGetTimestamp(void)\n{\n    unsigned long long boottime = 0;\n    char *ret = NULL;\n\n    if (virHostGetBootTime(&boottime) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get host boot time\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%llu\", boottime);\n    return ret;\n}",
    "includes": [
      "#include \"security_util.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%llu\"",
            "boottime"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to get host boot time\")"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to get host boot time\""
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostGetBootTime",
          "args": [
            "&boottime"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "virHostGetBootTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostuptime.c",
          "lines": "126-139",
          "snippet": "int\nvirHostGetBootTime(unsigned long long *when)\n{\n    if (virHostBootTimeInit() < 0)\n        return -1;\n\n    if (bootTimeErrno) {\n        errno = bootTimeErrno;\n        return -1;\n    }\n\n    *when = bootTime;\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostuptime.h\"",
            "# include <utmpx.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long long bootTime;",
            "static int bootTimeErrno;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virhostuptime.h\"\n# include <utmpx.h>\n#include <config.h>\n\nstatic unsigned long long bootTime;\nstatic int bootTimeErrno;\n\nint\nvirHostGetBootTime(unsigned long long *when)\n{\n    if (virHostBootTimeInit() < 0)\n        return -1;\n\n    if (bootTimeErrno) {\n        errno = bootTimeErrno;\n        return -1;\n    }\n\n    *when = bootTime;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char *\nvirSecurityGetTimestamp(void)\n{\n    unsigned long long boottime = 0;\n    char *ret = NULL;\n\n    if (virHostGetBootTime(&boottime) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get host boot time\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%llu\", boottime);\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityGetTimestampAttrName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
    "lines": "100-107",
    "snippet": "static char *\nvirSecurityGetTimestampAttrName(const char *name G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n    return NULL;\n}",
    "includes": [
      "#include \"security_util.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Extended attributes are not supported on this system\")"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Extended attributes are not supported on this system\""
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char *\nvirSecurityGetTimestampAttrName(const char *name G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n    return NULL;\n}"
  },
  {
    "function_name": "virSecurityGetTimestampAttrName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
    "lines": "92-98",
    "snippet": "static char *\nvirSecurityGetTimestampAttrName(const char *name)\n{\n    char *ret = NULL;\n    ret = g_strdup_printf(XATTR_NAMESPACE \".libvirt.security.timestamp_%s\", name);\n    return ret;\n}",
    "includes": [
      "#include \"security_util.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "XATTR_NAMESPACE \".libvirt.security.timestamp_%s\"",
            "name"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char *\nvirSecurityGetTimestampAttrName(const char *name)\n{\n    char *ret = NULL;\n    ret = g_strdup_printf(XATTR_NAMESPACE \".libvirt.security.timestamp_%s\", name);\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityGetRefCountAttrName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
    "lines": "76-88",
    "snippet": "static char *\nvirSecurityGetRefCountAttrName(const char *name G_GNUC_UNUSED)\n{\n    char *ret = NULL;\n#ifdef XATTR_NAMESPACE\n    ret = g_strdup_printf(XATTR_NAMESPACE\".libvirt.security.ref_%s\", name);\n#else\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n#endif\n    return ret;\n}",
    "includes": [
      "#include \"security_util.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Extended attributes are not supported on this system\")"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Extended attributes are not supported on this system\""
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "XATTR_NAMESPACE\".libvirt.security.ref_%s\"",
            "name"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char *\nvirSecurityGetRefCountAttrName(const char *name G_GNUC_UNUSED)\n{\n    char *ret = NULL;\n#ifdef XATTR_NAMESPACE\n    ret = g_strdup_printf(XATTR_NAMESPACE\".libvirt.security.ref_%s\", name);\n#else\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n#endif\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityGetAttrName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
    "lines": "61-73",
    "snippet": "static char *\nvirSecurityGetAttrName(const char *name G_GNUC_UNUSED)\n{\n    char *ret = NULL;\n#ifdef XATTR_NAMESPACE\n    ret = g_strdup_printf(XATTR_NAMESPACE\".libvirt.security.%s\", name);\n#else\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n#endif\n    return ret;\n}",
    "includes": [
      "#include \"security_util.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Extended attributes are not supported on this system\")"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Extended attributes are not supported on this system\""
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "XATTR_NAMESPACE\".libvirt.security.%s\"",
            "name"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char *\nvirSecurityGetAttrName(const char *name G_GNUC_UNUSED)\n{\n    char *ret = NULL;\n#ifdef XATTR_NAMESPACE\n    ret = g_strdup_printf(XATTR_NAMESPACE\".libvirt.security.%s\", name);\n#else\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"Extended attributes are not supported on this system\"));\n#endif\n    return ret;\n}"
  }
]