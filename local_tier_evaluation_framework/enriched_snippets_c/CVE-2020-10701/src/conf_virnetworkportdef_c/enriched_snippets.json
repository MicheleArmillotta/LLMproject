[
  {
    "function_name": "virNetworkPortDefDeleteStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
    "lines": "468-491",
    "snippet": "int\nvirNetworkPortDefDeleteStatus(virNetworkPortDef *def,\n                              const char *dir)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *path;\n    int ret = -1;\n\n    virUUIDFormat(def->uuid, uuidstr);\n\n    if (!(path = virNetworkPortDefConfigFile(dir, uuidstr)))\n        goto cleanup;\n\n    if (unlink(path) < 0 && errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Unable to delete %s\"), path);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(path);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virnetdevmacvlan.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to delete %s\")",
            "path"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to delete %s\""
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "path"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkPortDefConfigFile",
          "args": [
            "dir",
            "uuidstr"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkPortDefConfigFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
          "lines": "431-439",
          "snippet": "static char *\nvirNetworkPortDefConfigFile(const char *dir,\n                            const char *name)\n{\n    char *ret = NULL;\n\n    ret = g_strdup_printf(\"%s/%s.xml\", dir, name);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nvirNetworkPortDefConfigFile(const char *dir,\n                            const char *name)\n{\n    char *ret = NULL;\n\n    ret = g_strdup_printf(\"%s/%s.xml\", dir, name);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "def->uuid",
            "uuidstr"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkPortDefDeleteStatus(virNetworkPortDef *def,\n                              const char *dir)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *path;\n    int ret = -1;\n\n    virUUIDFormat(def->uuid, uuidstr);\n\n    if (!(path = virNetworkPortDefConfigFile(dir, uuidstr)))\n        goto cleanup;\n\n    if (unlink(path) < 0 && errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Unable to delete %s\"), path);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(path);\n    return ret;\n}"
  },
  {
    "function_name": "virNetworkPortDefSaveStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
    "lines": "442-465",
    "snippet": "int\nvirNetworkPortDefSaveStatus(virNetworkPortDef *def,\n                            const char *dir)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    g_autofree char *path = NULL;\n    g_autofree char *xml = NULL;\n\n    virUUIDFormat(def->uuid, uuidstr);\n\n    if (virFileMakePath(dir) < 0)\n        return -1;\n\n    if (!(path = virNetworkPortDefConfigFile(dir, uuidstr)))\n        return -1;\n\n    if (!(xml = virNetworkPortDefFormat(def)))\n        return -1;\n\n    if (virXMLSaveFile(path, uuidstr, \"net-port-create\", xml) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virnetdevmacvlan.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virXMLSaveFile",
          "args": [
            "path",
            "uuidstr",
            "\"net-port-create\"",
            "xml"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLSaveFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "941-950",
          "snippet": "int\nvirXMLSaveFile(const char *path,\n               const char *warnName,\n               const char *warnCommand,\n               const char *xml)\n{\n    struct virXMLRewriteFileData data = { warnName, warnCommand, xml };\n\n    return virFileRewrite(path, S_IRUSR | S_IWUSR, virXMLRewriteFile, &data);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXMLSaveFile(const char *path,\n               const char *warnName,\n               const char *warnCommand,\n               const char *xml)\n{\n    struct virXMLRewriteFileData data = { warnName, warnCommand, xml };\n\n    return virFileRewrite(path, S_IRUSR | S_IWUSR, virXMLRewriteFile, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkPortDefFormat",
          "args": [
            "def"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkPortDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
          "lines": "324-335",
          "snippet": "char *\nvirNetworkPortDefFormat(const virNetworkPortDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virNetworkPortDefFormatBuf(&buf, def) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirNetworkPortDefFormat(const virNetworkPortDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virNetworkPortDefFormatBuf(&buf, def) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkPortDefConfigFile",
          "args": [
            "dir",
            "uuidstr"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkPortDefConfigFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
          "lines": "431-439",
          "snippet": "static char *\nvirNetworkPortDefConfigFile(const char *dir,\n                            const char *name)\n{\n    char *ret = NULL;\n\n    ret = g_strdup_printf(\"%s/%s.xml\", dir, name);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nvirNetworkPortDefConfigFile(const char *dir,\n                            const char *name)\n{\n    char *ret = NULL;\n\n    ret = g_strdup_printf(\"%s/%s.xml\", dir, name);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileMakePath",
          "args": [
            "dir"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3076-3080",
          "snippet": "int\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "def->uuid",
            "uuidstr"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkPortDefSaveStatus(virNetworkPortDef *def,\n                            const char *dir)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    g_autofree char *path = NULL;\n    g_autofree char *xml = NULL;\n\n    virUUIDFormat(def->uuid, uuidstr);\n\n    if (virFileMakePath(dir) < 0)\n        return -1;\n\n    if (!(path = virNetworkPortDefConfigFile(dir, uuidstr)))\n        return -1;\n\n    if (!(xml = virNetworkPortDefFormat(def)))\n        return -1;\n\n    if (virXMLSaveFile(path, uuidstr, \"net-port-create\", xml) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetworkPortDefConfigFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
    "lines": "431-439",
    "snippet": "static char *\nvirNetworkPortDefConfigFile(const char *dir,\n                            const char *name)\n{\n    char *ret = NULL;\n\n    ret = g_strdup_printf(\"%s/%s.xml\", dir, name);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virnetdevmacvlan.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s.xml\"",
            "dir",
            "name"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nvirNetworkPortDefConfigFile(const char *dir,\n                            const char *name)\n{\n    char *ret = NULL;\n\n    ret = g_strdup_printf(\"%s/%s.xml\", dir, name);\n    return ret;\n}"
  },
  {
    "function_name": "virNetworkPortDefFormatBuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
    "lines": "338-428",
    "snippet": "int\nvirNetworkPortDefFormatBuf(virBufferPtr buf,\n                           const virNetworkPortDef *def)\n{\n    char uuid[VIR_UUID_STRING_BUFLEN];\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n\n    virBufferAddLit(buf, \"<networkport>\\n\");\n\n    virBufferAdjustIndent(buf, 2);\n\n    virUUIDFormat(def->uuid, uuid);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuid);\n\n    virBufferAddLit(buf, \"<owner>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->ownername);\n    virUUIDFormat(def->owneruuid, uuid);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuid);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</owner>\\n\");\n\n    virBufferEscapeString(buf, \"<group>%s</group>\\n\", def->group);\n\n    virMacAddrFormat(&def->mac, macaddr);\n    virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", macaddr);\n\n    if (virNetDevVPortProfileFormat(def->virtPortProfile, buf) < 0)\n        return -1;\n    if (def->bandwidth)\n        virNetDevBandwidthFormat(def->bandwidth, def->class_id, buf);\n    if (virNetDevVlanFormat(&def->vlan, buf) < 0)\n        return -1;\n    virNetworkPortOptionsFormat(def->isolatedPort, buf);\n    if (def->trustGuestRxFilters)\n        virBufferAsprintf(buf, \"<rxfilters trustGuest='%s'/>\\n\",\n                          virTristateBoolTypeToString(def->trustGuestRxFilters));\n\n    if (def->plugtype != VIR_NETWORK_PORT_PLUG_TYPE_NONE) {\n        virBufferAsprintf(buf, \"<plug type='%s'\",\n                          virNetworkPortPlugTypeToString(def->plugtype));\n\n        switch (def->plugtype) {\n        case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n        case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n            virBufferEscapeString(buf, \" bridge='%s'\", def->plug.bridge.brname);\n            if (def->plug.bridge.macTableManager)\n                virBufferAsprintf(buf, \" macTableManager='%s'\",\n                                  virNetworkBridgeMACTableManagerTypeToString(\n                                      def->plug.bridge.macTableManager));\n            virBufferAddLit(buf, \"/>\\n\");\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n            virBufferEscapeString(buf, \" dev='%s'\", def->plug.direct.linkdev);\n            virBufferAsprintf(buf, \" mode='%s'\",\n                              virNetDevMacVLanModeTypeToString(\n                                  def->plug.direct.mode));\n            virBufferAddLit(buf, \"/>\\n\");\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n            virBufferAsprintf(buf, \" managed='%s'>\\n\",\n                              def->plug.hostdevpci.managed ? \"yes\" : \"no\");\n            virBufferAdjustIndent(buf, 2);\n            if (def->plug.hostdevpci.driver)\n                virBufferEscapeString(buf, \"<driver name='%s'/>\\n\",\n                                      virNetworkForwardDriverNameTypeToString(\n                                          def->plug.hostdevpci.driver));\n\n            virPCIDeviceAddressFormat(buf, def->plug.hostdevpci.addr, false);\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</plug>\\n\");\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n        default:\n            virReportEnumRangeError(virNetworkPortPlugType, def->plugtype);\n            return -1;\n        }\n    }\n\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</networkport>\\n\");\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virnetdevmacvlan.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</networkport>\\n\""
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNetworkPortPlugType",
            "def->plugtype"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</plug>\\n\""
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressFormat",
          "args": [
            "buf",
            "def->plug.hostdevpci.addr",
            "false"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "293-305",
          "snippet": "void\nvirPCIDeviceAddressFormat(virBufferPtr buf,\n                          virPCIDeviceAddress addr,\n                          bool includeTypeInAddr)\n{\n    virBufferAsprintf(buf, \"<address %sdomain='0x%04x' bus='0x%02x' \"\n                      \"slot='0x%02x' function='0x%d'/>\\n\",\n                      includeTypeInAddr ? \"type='pci' \" : \"\",\n                      addr.domain,\n                      addr.bus,\n                      addr.slot,\n                      addr.function);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceAddressFormat(virBufferPtr buf,\n                          virPCIDeviceAddress addr,\n                          bool includeTypeInAddr)\n{\n    virBufferAsprintf(buf, \"<address %sdomain='0x%04x' bus='0x%02x' \"\n                      \"slot='0x%02x' function='0x%d'/>\\n\",\n                      includeTypeInAddr ? \"type='pci' \" : \"\",\n                      addr.domain,\n                      addr.bus,\n                      addr.slot,\n                      addr.function);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<driver name='%s'/>\\n\"",
            "virNetworkForwardDriverNameTypeToString(\n                                          def->plug.hostdevpci.driver)"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkForwardDriverNameTypeToString",
          "args": [
            "def->plug.hostdevpci.driver"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\" managed='%s'>\\n\"",
            "def->plug.hostdevpci.managed ? \"yes\" : \"no\""
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevMacVLanModeTypeToString",
          "args": [
            "def->plug.direct.mode"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkBridgeMACTableManagerTypeToString",
          "args": [
            "def->plug.bridge.macTableManager"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkPortPlugTypeToString",
          "args": [
            "def->plugtype"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeToString",
          "args": [
            "def->trustGuestRxFilters"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkPortOptionsFormat",
          "args": [
            "def->isolatedPort",
            "buf"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkPortOptionsFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2357-2364",
          "snippet": "void\nvirNetworkPortOptionsFormat(virTristateBool isolatedPort,\n                            virBufferPtr buf)\n{\n    if (isolatedPort != VIR_TRISTATE_BOOL_ABSENT)\n        virBufferAsprintf(buf, \"<port isolated='%s'/>\\n\",\n                          virTristateBoolTypeToString(isolatedPort));\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetworkPortOptionsFormat(virTristateBool isolatedPort,\n                            virBufferPtr buf)\n{\n    if (isolatedPort != VIR_TRISTATE_BOOL_ABSENT)\n        virBufferAsprintf(buf, \"<port isolated='%s'/>\\n\",\n                          virTristateBoolTypeToString(isolatedPort));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVlanFormat",
          "args": [
            "&def->vlan",
            "buf"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVlanFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_vlan_conf.c",
          "lines": "140-174",
          "snippet": "int\nvirNetDevVlanFormat(const virNetDevVlan *def, virBufferPtr buf)\n{\n    size_t i;\n\n    if (!(def && def->nTags))\n        return 0;\n\n    if (!def->tag) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing vlan tag data\"));\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<vlan%s>\\n\", def->trunk ? \" trunk='yes'\" : \"\");\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < def->nTags; i++) {\n        if (def->nativeMode != VIR_NATIVE_VLAN_MODE_DEFAULT &&\n            def->nativeTag == def->tag[i]) {\n            /* check the nativeMode in case we get <tag id='0'/>*/\n            const char *mode = virNativeVlanModeTypeToString(def->nativeMode);\n            if (!mode) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Bad value for nativeMode\"));\n            }\n            virBufferAsprintf(buf, \"<tag id='%u' nativeMode='%s'/>\\n\",\n                              def->tag[i], mode);\n        } else {\n            virBufferAsprintf(buf, \"<tag id='%u'/>\\n\", def->tag[i]);\n        }\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</vlan>\\n\");\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_vlan_conf.h\"\n#include <config.h>\n\nint\nvirNetDevVlanFormat(const virNetDevVlan *def, virBufferPtr buf)\n{\n    size_t i;\n\n    if (!(def && def->nTags))\n        return 0;\n\n    if (!def->tag) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing vlan tag data\"));\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<vlan%s>\\n\", def->trunk ? \" trunk='yes'\" : \"\");\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < def->nTags; i++) {\n        if (def->nativeMode != VIR_NATIVE_VLAN_MODE_DEFAULT &&\n            def->nativeTag == def->tag[i]) {\n            /* check the nativeMode in case we get <tag id='0'/>*/\n            const char *mode = virNativeVlanModeTypeToString(def->nativeMode);\n            if (!mode) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Bad value for nativeMode\"));\n            }\n            virBufferAsprintf(buf, \"<tag id='%u' nativeMode='%s'/>\\n\",\n                              def->tag[i], mode);\n        } else {\n            virBufferAsprintf(buf, \"<tag id='%u'/>\\n\", def->tag[i]);\n        }\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</vlan>\\n\");\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthFormat",
          "args": [
            "def->bandwidth",
            "def->class_id",
            "buf"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_bandwidth_conf.c",
          "lines": "262-285",
          "snippet": "int\nvirNetDevBandwidthFormat(const virNetDevBandwidth *def,\n                         unsigned int class_id,\n                         virBufferPtr buf)\n{\n    if (!buf)\n        return -1;\n\n    if (!def)\n        return 0;\n\n    virBufferAddLit(buf, \"<bandwidth\");\n    if (class_id)\n        virBufferAsprintf(buf, \" classID='%u'\", class_id);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (virNetDevBandwidthRateFormat(def->in, buf, \"inbound\") < 0 ||\n        virNetDevBandwidthRateFormat(def->out, buf, \"outbound\") < 0)\n        return -1;\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</bandwidth>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include <config.h>\n\nint\nvirNetDevBandwidthFormat(const virNetDevBandwidth *def,\n                         unsigned int class_id,\n                         virBufferPtr buf)\n{\n    if (!buf)\n        return -1;\n\n    if (!def)\n        return 0;\n\n    virBufferAddLit(buf, \"<bandwidth\");\n    if (class_id)\n        virBufferAsprintf(buf, \" classID='%u'\", class_id);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (virNetDevBandwidthRateFormat(def->in, buf, \"inbound\") < 0 ||\n        virNetDevBandwidthRateFormat(def->out, buf, \"outbound\") < 0)\n        return -1;\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</bandwidth>\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileFormat",
          "args": [
            "def->virtPortProfile",
            "buf"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_vport_profile_conf.c",
          "lines": "199-278",
          "snippet": "int\nvirNetDevVPortProfileFormat(const virNetDevVPortProfile *virtPort,\n                            virBufferPtr buf)\n{\n    enum virNetDevVPortProfile type;\n    bool noParameters;\n\n    if (!virtPort)\n        return 0;\n\n    noParameters = !(virtPort->managerID_specified ||\n                     virtPort->typeID_specified ||\n                     virtPort->typeIDVersion_specified ||\n                     virtPort->instanceID_specified ||\n                     virtPort->profileID[0] ||\n                     virtPort->interfaceID_specified);\n\n    type = virtPort->virtPortType;\n    if (type == VIR_NETDEV_VPORT_PROFILE_NONE) {\n        if (noParameters)\n            return 0;\n        virBufferAddLit(buf, \"<virtualport>\\n\");\n    } else {\n        if (noParameters) {\n            virBufferAsprintf(buf, \"<virtualport type='%s'/>\\n\",\n                              virNetDevVPortTypeToString(type));\n            return 0;\n        } else {\n            virBufferAsprintf(buf, \"<virtualport type='%s'>\\n\",\n                              virNetDevVPortTypeToString(type));\n        }\n    }\n    virBufferAdjustIndent(buf, 2);\n    virBufferAddLit(buf, \"<parameters\");\n\n    if (virtPort->managerID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" managerid='%d'\", virtPort->managerID);\n    }\n    if (virtPort->typeID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" typeid='%d'\", virtPort->typeID);\n    }\n    if (virtPort->typeIDVersion_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" typeidversion='%d'\",\n                          virtPort->typeIDVersion);\n    }\n    if (virtPort->instanceID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(virtPort->instanceID, uuidstr);\n        virBufferAsprintf(buf, \" instanceid='%s'\", uuidstr);\n    }\n    if (virtPort->interfaceID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_MIDONET ||\n         type == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(virtPort->interfaceID, uuidstr);\n        virBufferAsprintf(buf, \" interfaceid='%s'\", uuidstr);\n    }\n    if (virtPort->profileID[0] &&\n        (type == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         type == VIR_NETDEV_VPORT_PROFILE_8021QBH ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" profileid='%s'\", virtPort->profileID);\n    }\n\n    virBufferAddLit(buf, \"/>\\n\");\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</virtualport>\\n\");\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include <config.h>\n\nint\nvirNetDevVPortProfileFormat(const virNetDevVPortProfile *virtPort,\n                            virBufferPtr buf)\n{\n    enum virNetDevVPortProfile type;\n    bool noParameters;\n\n    if (!virtPort)\n        return 0;\n\n    noParameters = !(virtPort->managerID_specified ||\n                     virtPort->typeID_specified ||\n                     virtPort->typeIDVersion_specified ||\n                     virtPort->instanceID_specified ||\n                     virtPort->profileID[0] ||\n                     virtPort->interfaceID_specified);\n\n    type = virtPort->virtPortType;\n    if (type == VIR_NETDEV_VPORT_PROFILE_NONE) {\n        if (noParameters)\n            return 0;\n        virBufferAddLit(buf, \"<virtualport>\\n\");\n    } else {\n        if (noParameters) {\n            virBufferAsprintf(buf, \"<virtualport type='%s'/>\\n\",\n                              virNetDevVPortTypeToString(type));\n            return 0;\n        } else {\n            virBufferAsprintf(buf, \"<virtualport type='%s'>\\n\",\n                              virNetDevVPortTypeToString(type));\n        }\n    }\n    virBufferAdjustIndent(buf, 2);\n    virBufferAddLit(buf, \"<parameters\");\n\n    if (virtPort->managerID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" managerid='%d'\", virtPort->managerID);\n    }\n    if (virtPort->typeID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" typeid='%d'\", virtPort->typeID);\n    }\n    if (virtPort->typeIDVersion_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" typeidversion='%d'\",\n                          virtPort->typeIDVersion);\n    }\n    if (virtPort->instanceID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(virtPort->instanceID, uuidstr);\n        virBufferAsprintf(buf, \" instanceid='%s'\", uuidstr);\n    }\n    if (virtPort->interfaceID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_MIDONET ||\n         type == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(virtPort->interfaceID, uuidstr);\n        virBufferAsprintf(buf, \" interfaceid='%s'\", uuidstr);\n    }\n    if (virtPort->profileID[0] &&\n        (type == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         type == VIR_NETDEV_VPORT_PROFILE_8021QBH ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" profileid='%s'\", virtPort->profileID);\n    }\n\n    virBufferAddLit(buf, \"/>\\n\");\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</virtualport>\\n\");\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "&def->mac",
            "macaddr"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</owner>\\n\""
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "def->owneruuid",
            "uuid"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<owner>\\n\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<networkport>\\n\""
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkPortDefFormatBuf(virBufferPtr buf,\n                           const virNetworkPortDef *def)\n{\n    char uuid[VIR_UUID_STRING_BUFLEN];\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n\n    virBufferAddLit(buf, \"<networkport>\\n\");\n\n    virBufferAdjustIndent(buf, 2);\n\n    virUUIDFormat(def->uuid, uuid);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuid);\n\n    virBufferAddLit(buf, \"<owner>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->ownername);\n    virUUIDFormat(def->owneruuid, uuid);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuid);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</owner>\\n\");\n\n    virBufferEscapeString(buf, \"<group>%s</group>\\n\", def->group);\n\n    virMacAddrFormat(&def->mac, macaddr);\n    virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", macaddr);\n\n    if (virNetDevVPortProfileFormat(def->virtPortProfile, buf) < 0)\n        return -1;\n    if (def->bandwidth)\n        virNetDevBandwidthFormat(def->bandwidth, def->class_id, buf);\n    if (virNetDevVlanFormat(&def->vlan, buf) < 0)\n        return -1;\n    virNetworkPortOptionsFormat(def->isolatedPort, buf);\n    if (def->trustGuestRxFilters)\n        virBufferAsprintf(buf, \"<rxfilters trustGuest='%s'/>\\n\",\n                          virTristateBoolTypeToString(def->trustGuestRxFilters));\n\n    if (def->plugtype != VIR_NETWORK_PORT_PLUG_TYPE_NONE) {\n        virBufferAsprintf(buf, \"<plug type='%s'\",\n                          virNetworkPortPlugTypeToString(def->plugtype));\n\n        switch (def->plugtype) {\n        case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n        case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n            virBufferEscapeString(buf, \" bridge='%s'\", def->plug.bridge.brname);\n            if (def->plug.bridge.macTableManager)\n                virBufferAsprintf(buf, \" macTableManager='%s'\",\n                                  virNetworkBridgeMACTableManagerTypeToString(\n                                      def->plug.bridge.macTableManager));\n            virBufferAddLit(buf, \"/>\\n\");\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n            virBufferEscapeString(buf, \" dev='%s'\", def->plug.direct.linkdev);\n            virBufferAsprintf(buf, \" mode='%s'\",\n                              virNetDevMacVLanModeTypeToString(\n                                  def->plug.direct.mode));\n            virBufferAddLit(buf, \"/>\\n\");\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n            virBufferAsprintf(buf, \" managed='%s'>\\n\",\n                              def->plug.hostdevpci.managed ? \"yes\" : \"no\");\n            virBufferAdjustIndent(buf, 2);\n            if (def->plug.hostdevpci.driver)\n                virBufferEscapeString(buf, \"<driver name='%s'/>\\n\",\n                                      virNetworkForwardDriverNameTypeToString(\n                                          def->plug.hostdevpci.driver));\n\n            virPCIDeviceAddressFormat(buf, def->plug.hostdevpci.addr, false);\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</plug>\\n\");\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n        default:\n            virReportEnumRangeError(virNetworkPortPlugType, def->plugtype);\n            return -1;\n        }\n    }\n\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</networkport>\\n\");\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetworkPortDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
    "lines": "324-335",
    "snippet": "char *\nvirNetworkPortDefFormat(const virNetworkPortDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virNetworkPortDefFormatBuf(&buf, def) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
    "includes": [
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virnetdevmacvlan.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkPortDefFormatBuf",
          "args": [
            "&buf",
            "def"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkPortDefFormatBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
          "lines": "338-428",
          "snippet": "int\nvirNetworkPortDefFormatBuf(virBufferPtr buf,\n                           const virNetworkPortDef *def)\n{\n    char uuid[VIR_UUID_STRING_BUFLEN];\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n\n    virBufferAddLit(buf, \"<networkport>\\n\");\n\n    virBufferAdjustIndent(buf, 2);\n\n    virUUIDFormat(def->uuid, uuid);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuid);\n\n    virBufferAddLit(buf, \"<owner>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->ownername);\n    virUUIDFormat(def->owneruuid, uuid);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuid);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</owner>\\n\");\n\n    virBufferEscapeString(buf, \"<group>%s</group>\\n\", def->group);\n\n    virMacAddrFormat(&def->mac, macaddr);\n    virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", macaddr);\n\n    if (virNetDevVPortProfileFormat(def->virtPortProfile, buf) < 0)\n        return -1;\n    if (def->bandwidth)\n        virNetDevBandwidthFormat(def->bandwidth, def->class_id, buf);\n    if (virNetDevVlanFormat(&def->vlan, buf) < 0)\n        return -1;\n    virNetworkPortOptionsFormat(def->isolatedPort, buf);\n    if (def->trustGuestRxFilters)\n        virBufferAsprintf(buf, \"<rxfilters trustGuest='%s'/>\\n\",\n                          virTristateBoolTypeToString(def->trustGuestRxFilters));\n\n    if (def->plugtype != VIR_NETWORK_PORT_PLUG_TYPE_NONE) {\n        virBufferAsprintf(buf, \"<plug type='%s'\",\n                          virNetworkPortPlugTypeToString(def->plugtype));\n\n        switch (def->plugtype) {\n        case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n        case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n            virBufferEscapeString(buf, \" bridge='%s'\", def->plug.bridge.brname);\n            if (def->plug.bridge.macTableManager)\n                virBufferAsprintf(buf, \" macTableManager='%s'\",\n                                  virNetworkBridgeMACTableManagerTypeToString(\n                                      def->plug.bridge.macTableManager));\n            virBufferAddLit(buf, \"/>\\n\");\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n            virBufferEscapeString(buf, \" dev='%s'\", def->plug.direct.linkdev);\n            virBufferAsprintf(buf, \" mode='%s'\",\n                              virNetDevMacVLanModeTypeToString(\n                                  def->plug.direct.mode));\n            virBufferAddLit(buf, \"/>\\n\");\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n            virBufferAsprintf(buf, \" managed='%s'>\\n\",\n                              def->plug.hostdevpci.managed ? \"yes\" : \"no\");\n            virBufferAdjustIndent(buf, 2);\n            if (def->plug.hostdevpci.driver)\n                virBufferEscapeString(buf, \"<driver name='%s'/>\\n\",\n                                      virNetworkForwardDriverNameTypeToString(\n                                          def->plug.hostdevpci.driver));\n\n            virPCIDeviceAddressFormat(buf, def->plug.hostdevpci.addr, false);\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</plug>\\n\");\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n        default:\n            virReportEnumRangeError(virNetworkPortPlugType, def->plugtype);\n            return -1;\n        }\n    }\n\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</networkport>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkPortDefFormatBuf(virBufferPtr buf,\n                           const virNetworkPortDef *def)\n{\n    char uuid[VIR_UUID_STRING_BUFLEN];\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n\n    virBufferAddLit(buf, \"<networkport>\\n\");\n\n    virBufferAdjustIndent(buf, 2);\n\n    virUUIDFormat(def->uuid, uuid);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuid);\n\n    virBufferAddLit(buf, \"<owner>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->ownername);\n    virUUIDFormat(def->owneruuid, uuid);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuid);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</owner>\\n\");\n\n    virBufferEscapeString(buf, \"<group>%s</group>\\n\", def->group);\n\n    virMacAddrFormat(&def->mac, macaddr);\n    virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", macaddr);\n\n    if (virNetDevVPortProfileFormat(def->virtPortProfile, buf) < 0)\n        return -1;\n    if (def->bandwidth)\n        virNetDevBandwidthFormat(def->bandwidth, def->class_id, buf);\n    if (virNetDevVlanFormat(&def->vlan, buf) < 0)\n        return -1;\n    virNetworkPortOptionsFormat(def->isolatedPort, buf);\n    if (def->trustGuestRxFilters)\n        virBufferAsprintf(buf, \"<rxfilters trustGuest='%s'/>\\n\",\n                          virTristateBoolTypeToString(def->trustGuestRxFilters));\n\n    if (def->plugtype != VIR_NETWORK_PORT_PLUG_TYPE_NONE) {\n        virBufferAsprintf(buf, \"<plug type='%s'\",\n                          virNetworkPortPlugTypeToString(def->plugtype));\n\n        switch (def->plugtype) {\n        case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n        case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n            virBufferEscapeString(buf, \" bridge='%s'\", def->plug.bridge.brname);\n            if (def->plug.bridge.macTableManager)\n                virBufferAsprintf(buf, \" macTableManager='%s'\",\n                                  virNetworkBridgeMACTableManagerTypeToString(\n                                      def->plug.bridge.macTableManager));\n            virBufferAddLit(buf, \"/>\\n\");\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n            virBufferEscapeString(buf, \" dev='%s'\", def->plug.direct.linkdev);\n            virBufferAsprintf(buf, \" mode='%s'\",\n                              virNetDevMacVLanModeTypeToString(\n                                  def->plug.direct.mode));\n            virBufferAddLit(buf, \"/>\\n\");\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n            virBufferAsprintf(buf, \" managed='%s'>\\n\",\n                              def->plug.hostdevpci.managed ? \"yes\" : \"no\");\n            virBufferAdjustIndent(buf, 2);\n            if (def->plug.hostdevpci.driver)\n                virBufferEscapeString(buf, \"<driver name='%s'/>\\n\",\n                                      virNetworkForwardDriverNameTypeToString(\n                                          def->plug.hostdevpci.driver));\n\n            virPCIDeviceAddressFormat(buf, def->plug.hostdevpci.addr, false);\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</plug>\\n\");\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n        default:\n            virReportEnumRangeError(virNetworkPortPlugType, def->plugtype);\n            return -1;\n        }\n    }\n\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</networkport>\\n\");\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirNetworkPortDefFormat(const virNetworkPortDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virNetworkPortDefFormatBuf(&buf, def) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
  },
  {
    "function_name": "virNetworkPortDefParseFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
    "lines": "317-321",
    "snippet": "virNetworkPortDefPtr\nvirNetworkPortDefParseFile(const char *filename)\n{\n    return virNetworkPortDefParse(NULL, filename);\n}",
    "includes": [
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virnetdevmacvlan.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkPortDefParse",
          "args": [
            "NULL",
            "filename"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkPortDefParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
          "lines": "294-307",
          "snippet": "static virNetworkPortDefPtr\nvirNetworkPortDefParse(const char *xmlStr,\n                       const char *filename)\n{\n    virNetworkPortDefPtr def = NULL;\n    xmlDocPtr xml;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(networkport_definition)\")))) {\n        def = virNetworkPortDefParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}",
          "includes": [
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virNetworkPortDefPtr\nvirNetworkPortDefParse(const char *xmlStr,\n                       const char *filename)\n{\n    virNetworkPortDefPtr def = NULL;\n    xmlDocPtr xml;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(networkport_definition)\")))) {\n        def = virNetworkPortDefParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkPortDefPtr\nvirNetworkPortDefParseFile(const char *filename)\n{\n    return virNetworkPortDefParse(NULL, filename);\n}"
  },
  {
    "function_name": "virNetworkPortDefParseString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
    "lines": "310-314",
    "snippet": "virNetworkPortDefPtr\nvirNetworkPortDefParseString(const char *xmlStr)\n{\n    return virNetworkPortDefParse(xmlStr, NULL);\n}",
    "includes": [
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virnetdevmacvlan.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkPortDefParse",
          "args": [
            "xmlStr",
            "NULL"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkPortDefParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
          "lines": "294-307",
          "snippet": "static virNetworkPortDefPtr\nvirNetworkPortDefParse(const char *xmlStr,\n                       const char *filename)\n{\n    virNetworkPortDefPtr def = NULL;\n    xmlDocPtr xml;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(networkport_definition)\")))) {\n        def = virNetworkPortDefParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}",
          "includes": [
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virNetworkPortDefPtr\nvirNetworkPortDefParse(const char *xmlStr,\n                       const char *filename)\n{\n    virNetworkPortDefPtr def = NULL;\n    xmlDocPtr xml;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(networkport_definition)\")))) {\n        def = virNetworkPortDefParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkPortDefPtr\nvirNetworkPortDefParseString(const char *xmlStr)\n{\n    return virNetworkPortDefParse(xmlStr, NULL);\n}"
  },
  {
    "function_name": "virNetworkPortDefParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
    "lines": "294-307",
    "snippet": "static virNetworkPortDefPtr\nvirNetworkPortDefParse(const char *xmlStr,\n                       const char *filename)\n{\n    virNetworkPortDefPtr def = NULL;\n    xmlDocPtr xml;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(networkport_definition)\")))) {\n        def = virNetworkPortDefParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}",
    "includes": [
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virnetdevmacvlan.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "xml"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkPortDefParseNode",
          "args": [
            "xml",
            "xmlDocGetRootElement(xml)"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkPortDefParseNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
          "lines": "268-291",
          "snippet": "virNetworkPortDefPtr\nvirNetworkPortDefParseNode(xmlDocPtr xml,\n                           xmlNodePtr root)\n{\n    xmlXPathContextPtr ctxt = NULL;\n    virNetworkPortDefPtr def = NULL;\n\n    if (STRNEQ((const char *)root->name, \"networkport\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\",\n                       _(\"unknown root element for network port\"));\n        goto cleanup;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    ctxt->node = root;\n    def = virNetworkPortDefParseXML(ctxt);\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    return def;\n}",
          "includes": [
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkPortDefPtr\nvirNetworkPortDefParseNode(xmlDocPtr xml,\n                           xmlNodePtr root)\n{\n    xmlXPathContextPtr ctxt = NULL;\n    virNetworkPortDefPtr def = NULL;\n\n    if (STRNEQ((const char *)root->name, \"networkport\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\",\n                       _(\"unknown root element for network port\"));\n        goto cleanup;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    ctxt->node = root;\n    def = virNetworkPortDefParseXML(ctxt);\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlDocGetRootElement",
          "args": [
            "xml"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLParse",
          "args": [
            "filename",
            "xmlStr",
            "_(\"(networkport_definition)\")"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"(networkport_definition)\""
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virNetworkPortDefPtr\nvirNetworkPortDefParse(const char *xmlStr,\n                       const char *filename)\n{\n    virNetworkPortDefPtr def = NULL;\n    xmlDocPtr xml;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(networkport_definition)\")))) {\n        def = virNetworkPortDefParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}"
  },
  {
    "function_name": "virNetworkPortDefParseNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
    "lines": "268-291",
    "snippet": "virNetworkPortDefPtr\nvirNetworkPortDefParseNode(xmlDocPtr xml,\n                           xmlNodePtr root)\n{\n    xmlXPathContextPtr ctxt = NULL;\n    virNetworkPortDefPtr def = NULL;\n\n    if (STRNEQ((const char *)root->name, \"networkport\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\",\n                       _(\"unknown root element for network port\"));\n        goto cleanup;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    ctxt->node = root;\n    def = virNetworkPortDefParseXML(ctxt);\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    return def;\n}",
    "includes": [
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virnetdevmacvlan.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "ctxt"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkPortDefParseXML",
          "args": [
            "ctxt"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkPortDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
          "lines": "81-265",
          "snippet": "static virNetworkPortDefPtr\nvirNetworkPortDefParseXML(xmlXPathContextPtr ctxt)\n{\n    g_autoptr(virNetworkPortDef) def = NULL;\n    g_autofree char *uuid = NULL;\n    xmlNodePtr virtPortNode;\n    xmlNodePtr vlanNode;\n    xmlNodePtr bandwidthNode;\n    xmlNodePtr addressNode;\n    g_autofree char *trustGuestRxFilters = NULL;\n    g_autofree char *mac = NULL;\n    g_autofree char *macmgr = NULL;\n    g_autofree char *mode = NULL;\n    g_autofree char *plugtype = NULL;\n    g_autofree char *managed = NULL;\n    g_autofree char *driver = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    uuid = virXPathString(\"string(./uuid)\", ctxt);\n    if (!uuid) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"network port has no uuid\"));\n        return NULL;\n    }\n    if (virUUIDParse(uuid, def->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse UUID '%s'\"), uuid);\n        return NULL;\n    }\n\n    def->ownername = virXPathString(\"string(./owner/name)\", ctxt);\n    if (!def->ownername) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"network port has no owner name\"));\n        return NULL;\n    }\n\n    VIR_FREE(uuid);\n    uuid = virXPathString(\"string(./owner/uuid)\", ctxt);\n    if (!uuid) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"network port has no owner UUID\"));\n        return NULL;\n    }\n\n    if (virUUIDParse(uuid, def->owneruuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse UUID '%s'\"), uuid);\n        return NULL;\n    }\n\n    def->group = virXPathString(\"string(./group)\", ctxt);\n\n    virtPortNode = virXPathNode(\"./virtualport\", ctxt);\n    if (virtPortNode &&\n        (!(def->virtPortProfile = virNetDevVPortProfileParse(virtPortNode, 0)))) {\n        return NULL;\n    }\n\n    mac = virXPathString(\"string(./mac/@address)\", ctxt);\n    if (!mac) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"network port has no mac\"));\n        return NULL;\n    }\n    if (virMacAddrParse(mac, &def->mac) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse MAC '%s'\"), mac);\n        return NULL;\n    }\n\n    bandwidthNode = virXPathNode(\"./bandwidth\", ctxt);\n    /*\n     * We don't know if the port will allow the \"floor\" param or\n     * not at this stage, so we must just tell virNetDevBandwidthParse\n     * to allow it regardless. Any bad config must be reported at\n     * time of use instead.\n     */\n    if (bandwidthNode &&\n        virNetDevBandwidthParse(&def->bandwidth, &def->class_id,\n                                bandwidthNode, true) < 0)\n        return NULL;\n\n    vlanNode = virXPathNode(\"./vlan\", ctxt);\n    if (vlanNode && virNetDevVlanParse(vlanNode, ctxt, &def->vlan) < 0)\n        return NULL;\n\n    if (virNetworkPortOptionsParseXML(ctxt, &def->isolatedPort) < 0)\n        return NULL;\n\n    trustGuestRxFilters\n        = virXPathString(\"string(./rxfilters/@trustGuest)\", ctxt);\n    if (trustGuestRxFilters) {\n        if ((def->trustGuestRxFilters\n             = virTristateBoolTypeFromString(trustGuestRxFilters)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid guest rx filters trust setting '%s' \"),\n                           trustGuestRxFilters);\n            return NULL;\n        }\n    }\n\n    plugtype = virXPathString(\"string(./plug/@type)\", ctxt);\n\n    if (plugtype &&\n        (def->plugtype = virNetworkPortPlugTypeFromString(plugtype)) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid network prt plug type '%s'\"), plugtype);\n    }\n\n    switch (def->plugtype) {\n    case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n    case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n        if (!(def->plug.bridge.brname = virXPathString(\"string(./plug/@bridge)\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing network port bridge name\"));\n            return NULL;\n        }\n        macmgr = virXPathString(\"string(./plug/@macTableManager)\", ctxt);\n        if (macmgr &&\n            (def->plug.bridge.macTableManager =\n             virNetworkBridgeMACTableManagerTypeFromString(macmgr)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid macTableManager setting '%s' \"\n                             \"in network port\"), macmgr);\n            return NULL;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n        if (!(def->plug.direct.linkdev = virXPathString(\"string(./plug/@dev)\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing network port link device name\"));\n            return NULL;\n        }\n        mode = virXPathString(\"string(./plug/@mode)\", ctxt);\n        if (mode &&\n            (def->plug.direct.mode =\n             virNetDevMacVLanModeTypeFromString(mode)) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid mode setting '%s' in network port\"), mode);\n            return NULL;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n        managed = virXPathString(\"string(./plug/@managed)\", ctxt);\n        if (managed &&\n            (def->plug.hostdevpci.managed =\n             virTristateBoolTypeFromString(managed)) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid managed setting '%s' in network port\"), mode);\n            return NULL;\n        }\n        driver = virXPathString(\"string(./plug/driver/@name)\", ctxt);\n        if (driver &&\n            (def->plug.hostdevpci.driver =\n             virNetworkForwardDriverNameTypeFromString(driver)) <= 0) {\n              virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing network port driver name\"));\n            return NULL;\n        }\n        if (!(addressNode = virXPathNode(\"./plug/address\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing network port PCI address\"));\n            return NULL;\n        }\n\n        if (virPCIDeviceAddressParseXML(addressNode, &def->plug.hostdevpci.addr) < 0)\n            return NULL;\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virNetworkPortPlugType, def->plugtype);\n        return NULL;\n    }\n\n    return g_steal_pointer(&def);\n}",
          "includes": [
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virNetworkPortDefPtr\nvirNetworkPortDefParseXML(xmlXPathContextPtr ctxt)\n{\n    g_autoptr(virNetworkPortDef) def = NULL;\n    g_autofree char *uuid = NULL;\n    xmlNodePtr virtPortNode;\n    xmlNodePtr vlanNode;\n    xmlNodePtr bandwidthNode;\n    xmlNodePtr addressNode;\n    g_autofree char *trustGuestRxFilters = NULL;\n    g_autofree char *mac = NULL;\n    g_autofree char *macmgr = NULL;\n    g_autofree char *mode = NULL;\n    g_autofree char *plugtype = NULL;\n    g_autofree char *managed = NULL;\n    g_autofree char *driver = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    uuid = virXPathString(\"string(./uuid)\", ctxt);\n    if (!uuid) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"network port has no uuid\"));\n        return NULL;\n    }\n    if (virUUIDParse(uuid, def->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse UUID '%s'\"), uuid);\n        return NULL;\n    }\n\n    def->ownername = virXPathString(\"string(./owner/name)\", ctxt);\n    if (!def->ownername) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"network port has no owner name\"));\n        return NULL;\n    }\n\n    VIR_FREE(uuid);\n    uuid = virXPathString(\"string(./owner/uuid)\", ctxt);\n    if (!uuid) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"network port has no owner UUID\"));\n        return NULL;\n    }\n\n    if (virUUIDParse(uuid, def->owneruuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse UUID '%s'\"), uuid);\n        return NULL;\n    }\n\n    def->group = virXPathString(\"string(./group)\", ctxt);\n\n    virtPortNode = virXPathNode(\"./virtualport\", ctxt);\n    if (virtPortNode &&\n        (!(def->virtPortProfile = virNetDevVPortProfileParse(virtPortNode, 0)))) {\n        return NULL;\n    }\n\n    mac = virXPathString(\"string(./mac/@address)\", ctxt);\n    if (!mac) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"network port has no mac\"));\n        return NULL;\n    }\n    if (virMacAddrParse(mac, &def->mac) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse MAC '%s'\"), mac);\n        return NULL;\n    }\n\n    bandwidthNode = virXPathNode(\"./bandwidth\", ctxt);\n    /*\n     * We don't know if the port will allow the \"floor\" param or\n     * not at this stage, so we must just tell virNetDevBandwidthParse\n     * to allow it regardless. Any bad config must be reported at\n     * time of use instead.\n     */\n    if (bandwidthNode &&\n        virNetDevBandwidthParse(&def->bandwidth, &def->class_id,\n                                bandwidthNode, true) < 0)\n        return NULL;\n\n    vlanNode = virXPathNode(\"./vlan\", ctxt);\n    if (vlanNode && virNetDevVlanParse(vlanNode, ctxt, &def->vlan) < 0)\n        return NULL;\n\n    if (virNetworkPortOptionsParseXML(ctxt, &def->isolatedPort) < 0)\n        return NULL;\n\n    trustGuestRxFilters\n        = virXPathString(\"string(./rxfilters/@trustGuest)\", ctxt);\n    if (trustGuestRxFilters) {\n        if ((def->trustGuestRxFilters\n             = virTristateBoolTypeFromString(trustGuestRxFilters)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid guest rx filters trust setting '%s' \"),\n                           trustGuestRxFilters);\n            return NULL;\n        }\n    }\n\n    plugtype = virXPathString(\"string(./plug/@type)\", ctxt);\n\n    if (plugtype &&\n        (def->plugtype = virNetworkPortPlugTypeFromString(plugtype)) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid network prt plug type '%s'\"), plugtype);\n    }\n\n    switch (def->plugtype) {\n    case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n    case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n        if (!(def->plug.bridge.brname = virXPathString(\"string(./plug/@bridge)\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing network port bridge name\"));\n            return NULL;\n        }\n        macmgr = virXPathString(\"string(./plug/@macTableManager)\", ctxt);\n        if (macmgr &&\n            (def->plug.bridge.macTableManager =\n             virNetworkBridgeMACTableManagerTypeFromString(macmgr)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid macTableManager setting '%s' \"\n                             \"in network port\"), macmgr);\n            return NULL;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n        if (!(def->plug.direct.linkdev = virXPathString(\"string(./plug/@dev)\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing network port link device name\"));\n            return NULL;\n        }\n        mode = virXPathString(\"string(./plug/@mode)\", ctxt);\n        if (mode &&\n            (def->plug.direct.mode =\n             virNetDevMacVLanModeTypeFromString(mode)) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid mode setting '%s' in network port\"), mode);\n            return NULL;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n        managed = virXPathString(\"string(./plug/@managed)\", ctxt);\n        if (managed &&\n            (def->plug.hostdevpci.managed =\n             virTristateBoolTypeFromString(managed)) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid managed setting '%s' in network port\"), mode);\n            return NULL;\n        }\n        driver = virXPathString(\"string(./plug/driver/@name)\", ctxt);\n        if (driver &&\n            (def->plug.hostdevpci.driver =\n             virNetworkForwardDriverNameTypeFromString(driver)) <= 0) {\n              virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing network port driver name\"));\n            return NULL;\n        }\n        if (!(addressNode = virXPathNode(\"./plug/address\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing network port PCI address\"));\n            return NULL;\n        }\n\n        if (virPCIDeviceAddressParseXML(addressNode, &def->plug.hostdevpci.addr) < 0)\n            return NULL;\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virNetworkPortPlugType, def->plugtype);\n        return NULL;\n    }\n\n    return g_steal_pointer(&def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLXPathContextNew",
          "args": [
            "xml"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLXPathContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "48-59",
          "snippet": "xmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"unknown root element for network port\")"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown root element for network port\""
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "(const char *)root->name",
            "\"networkport\""
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkPortDefPtr\nvirNetworkPortDefParseNode(xmlDocPtr xml,\n                           xmlNodePtr root)\n{\n    xmlXPathContextPtr ctxt = NULL;\n    virNetworkPortDefPtr def = NULL;\n\n    if (STRNEQ((const char *)root->name, \"networkport\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\",\n                       _(\"unknown root element for network port\"));\n        goto cleanup;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    ctxt->node = root;\n    def = virNetworkPortDefParseXML(ctxt);\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    return def;\n}"
  },
  {
    "function_name": "virNetworkPortDefParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
    "lines": "81-265",
    "snippet": "static virNetworkPortDefPtr\nvirNetworkPortDefParseXML(xmlXPathContextPtr ctxt)\n{\n    g_autoptr(virNetworkPortDef) def = NULL;\n    g_autofree char *uuid = NULL;\n    xmlNodePtr virtPortNode;\n    xmlNodePtr vlanNode;\n    xmlNodePtr bandwidthNode;\n    xmlNodePtr addressNode;\n    g_autofree char *trustGuestRxFilters = NULL;\n    g_autofree char *mac = NULL;\n    g_autofree char *macmgr = NULL;\n    g_autofree char *mode = NULL;\n    g_autofree char *plugtype = NULL;\n    g_autofree char *managed = NULL;\n    g_autofree char *driver = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    uuid = virXPathString(\"string(./uuid)\", ctxt);\n    if (!uuid) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"network port has no uuid\"));\n        return NULL;\n    }\n    if (virUUIDParse(uuid, def->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse UUID '%s'\"), uuid);\n        return NULL;\n    }\n\n    def->ownername = virXPathString(\"string(./owner/name)\", ctxt);\n    if (!def->ownername) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"network port has no owner name\"));\n        return NULL;\n    }\n\n    VIR_FREE(uuid);\n    uuid = virXPathString(\"string(./owner/uuid)\", ctxt);\n    if (!uuid) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"network port has no owner UUID\"));\n        return NULL;\n    }\n\n    if (virUUIDParse(uuid, def->owneruuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse UUID '%s'\"), uuid);\n        return NULL;\n    }\n\n    def->group = virXPathString(\"string(./group)\", ctxt);\n\n    virtPortNode = virXPathNode(\"./virtualport\", ctxt);\n    if (virtPortNode &&\n        (!(def->virtPortProfile = virNetDevVPortProfileParse(virtPortNode, 0)))) {\n        return NULL;\n    }\n\n    mac = virXPathString(\"string(./mac/@address)\", ctxt);\n    if (!mac) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"network port has no mac\"));\n        return NULL;\n    }\n    if (virMacAddrParse(mac, &def->mac) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse MAC '%s'\"), mac);\n        return NULL;\n    }\n\n    bandwidthNode = virXPathNode(\"./bandwidth\", ctxt);\n    /*\n     * We don't know if the port will allow the \"floor\" param or\n     * not at this stage, so we must just tell virNetDevBandwidthParse\n     * to allow it regardless. Any bad config must be reported at\n     * time of use instead.\n     */\n    if (bandwidthNode &&\n        virNetDevBandwidthParse(&def->bandwidth, &def->class_id,\n                                bandwidthNode, true) < 0)\n        return NULL;\n\n    vlanNode = virXPathNode(\"./vlan\", ctxt);\n    if (vlanNode && virNetDevVlanParse(vlanNode, ctxt, &def->vlan) < 0)\n        return NULL;\n\n    if (virNetworkPortOptionsParseXML(ctxt, &def->isolatedPort) < 0)\n        return NULL;\n\n    trustGuestRxFilters\n        = virXPathString(\"string(./rxfilters/@trustGuest)\", ctxt);\n    if (trustGuestRxFilters) {\n        if ((def->trustGuestRxFilters\n             = virTristateBoolTypeFromString(trustGuestRxFilters)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid guest rx filters trust setting '%s' \"),\n                           trustGuestRxFilters);\n            return NULL;\n        }\n    }\n\n    plugtype = virXPathString(\"string(./plug/@type)\", ctxt);\n\n    if (plugtype &&\n        (def->plugtype = virNetworkPortPlugTypeFromString(plugtype)) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid network prt plug type '%s'\"), plugtype);\n    }\n\n    switch (def->plugtype) {\n    case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n    case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n        if (!(def->plug.bridge.brname = virXPathString(\"string(./plug/@bridge)\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing network port bridge name\"));\n            return NULL;\n        }\n        macmgr = virXPathString(\"string(./plug/@macTableManager)\", ctxt);\n        if (macmgr &&\n            (def->plug.bridge.macTableManager =\n             virNetworkBridgeMACTableManagerTypeFromString(macmgr)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid macTableManager setting '%s' \"\n                             \"in network port\"), macmgr);\n            return NULL;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n        if (!(def->plug.direct.linkdev = virXPathString(\"string(./plug/@dev)\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing network port link device name\"));\n            return NULL;\n        }\n        mode = virXPathString(\"string(./plug/@mode)\", ctxt);\n        if (mode &&\n            (def->plug.direct.mode =\n             virNetDevMacVLanModeTypeFromString(mode)) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid mode setting '%s' in network port\"), mode);\n            return NULL;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n        managed = virXPathString(\"string(./plug/@managed)\", ctxt);\n        if (managed &&\n            (def->plug.hostdevpci.managed =\n             virTristateBoolTypeFromString(managed)) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid managed setting '%s' in network port\"), mode);\n            return NULL;\n        }\n        driver = virXPathString(\"string(./plug/driver/@name)\", ctxt);\n        if (driver &&\n            (def->plug.hostdevpci.driver =\n             virNetworkForwardDriverNameTypeFromString(driver)) <= 0) {\n              virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing network port driver name\"));\n            return NULL;\n        }\n        if (!(addressNode = virXPathNode(\"./plug/address\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing network port PCI address\"));\n            return NULL;\n        }\n\n        if (virPCIDeviceAddressParseXML(addressNode, &def->plug.hostdevpci.addr) < 0)\n            return NULL;\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virNetworkPortPlugType, def->plugtype);\n        return NULL;\n    }\n\n    return g_steal_pointer(&def);\n}",
    "includes": [
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virnetdevmacvlan.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&def"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNetworkPortPlugType",
            "def->plugtype"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressParseXML",
          "args": [
            "addressNode",
            "&def->plug.hostdevpci.addr"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "214-291",
          "snippet": "int\nvirPCIDeviceAddressParseXML(xmlNodePtr node,\n                            virPCIDeviceAddressPtr addr)\n{\n    char *domain, *slot, *bus, *function, *multi;\n    xmlNodePtr cur;\n    xmlNodePtr zpci = NULL;\n    int ret = -1;\n\n    memset(addr, 0, sizeof(*addr));\n\n    domain   = virXMLPropString(node, \"domain\");\n    bus      = virXMLPropString(node, \"bus\");\n    slot     = virXMLPropString(node, \"slot\");\n    function = virXMLPropString(node, \"function\");\n    multi    = virXMLPropString(node, \"multifunction\");\n\n    if (domain &&\n        virStrToLong_uip(domain, NULL, 0, &addr->domain) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'domain' attribute\"));\n        goto cleanup;\n    }\n\n    if (bus &&\n        virStrToLong_uip(bus, NULL, 0, &addr->bus) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'bus' attribute\"));\n        goto cleanup;\n    }\n\n    if (slot &&\n        virStrToLong_uip(slot, NULL, 0, &addr->slot) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'slot' attribute\"));\n        goto cleanup;\n    }\n\n    if (function &&\n        virStrToLong_uip(function, NULL, 0, &addr->function) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'function' attribute\"));\n        goto cleanup;\n    }\n\n    if (multi &&\n        ((addr->multi = virTristateSwitchTypeFromString(multi)) <= 0)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unknown value '%s' for <address> 'multifunction' attribute\"),\n                       multi);\n        goto cleanup;\n\n    }\n    if (!virPCIDeviceAddressIsEmpty(addr) && !virPCIDeviceAddressIsValid(addr, true))\n        goto cleanup;\n\n    cur = node->children;\n    while (cur) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"zpci\")) {\n            zpci = cur;\n        }\n        cur = cur->next;\n    }\n\n    if (zpci && virZPCIDeviceAddressParseXML(zpci, addr) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(domain);\n    VIR_FREE(bus);\n    VIR_FREE(slot);\n    VIR_FREE(function);\n    VIR_FREE(multi);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirPCIDeviceAddressParseXML(xmlNodePtr node,\n                            virPCIDeviceAddressPtr addr)\n{\n    char *domain, *slot, *bus, *function, *multi;\n    xmlNodePtr cur;\n    xmlNodePtr zpci = NULL;\n    int ret = -1;\n\n    memset(addr, 0, sizeof(*addr));\n\n    domain   = virXMLPropString(node, \"domain\");\n    bus      = virXMLPropString(node, \"bus\");\n    slot     = virXMLPropString(node, \"slot\");\n    function = virXMLPropString(node, \"function\");\n    multi    = virXMLPropString(node, \"multifunction\");\n\n    if (domain &&\n        virStrToLong_uip(domain, NULL, 0, &addr->domain) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'domain' attribute\"));\n        goto cleanup;\n    }\n\n    if (bus &&\n        virStrToLong_uip(bus, NULL, 0, &addr->bus) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'bus' attribute\"));\n        goto cleanup;\n    }\n\n    if (slot &&\n        virStrToLong_uip(slot, NULL, 0, &addr->slot) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'slot' attribute\"));\n        goto cleanup;\n    }\n\n    if (function &&\n        virStrToLong_uip(function, NULL, 0, &addr->function) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'function' attribute\"));\n        goto cleanup;\n    }\n\n    if (multi &&\n        ((addr->multi = virTristateSwitchTypeFromString(multi)) <= 0)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unknown value '%s' for <address> 'multifunction' attribute\"),\n                       multi);\n        goto cleanup;\n\n    }\n    if (!virPCIDeviceAddressIsEmpty(addr) && !virPCIDeviceAddressIsValid(addr, true))\n        goto cleanup;\n\n    cur = node->children;\n    while (cur) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"zpci\")) {\n            zpci = cur;\n        }\n        cur = cur->next;\n    }\n\n    if (zpci && virZPCIDeviceAddressParseXML(zpci, addr) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(domain);\n    VIR_FREE(bus);\n    VIR_FREE(slot);\n    VIR_FREE(function);\n    VIR_FREE(multi);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Missing network port PCI address\")"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing network port PCI address\""
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./plug/address\"",
            "ctxt"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Missing network port driver name\")"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardDriverNameTypeFromString",
          "args": [
            "driver"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./plug/driver/@name)\"",
            "ctxt"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid managed setting '%s' in network port\")",
            "mode"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeFromString",
          "args": [
            "managed"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid mode setting '%s' in network port\")",
            "mode"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevMacVLanModeTypeFromString",
          "args": [
            "mode"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Missing network port link device name\")"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid macTableManager setting '%s' \"\n                             \"in network port\")",
            "macmgr"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkBridgeMACTableManagerTypeFromString",
          "args": [
            "macmgr"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Missing network port bridge name\")"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid network prt plug type '%s'\")",
            "plugtype"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkPortPlugTypeFromString",
          "args": [
            "plugtype"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid guest rx filters trust setting '%s' \")",
            "trustGuestRxFilters"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeFromString",
          "args": [
            "trustGuestRxFilters"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkPortOptionsParseXML",
          "args": [
            "ctxt",
            "&def->isolatedPort"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkPortOptionsParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "1175-1192",
          "snippet": "int\nvirNetworkPortOptionsParseXML(xmlXPathContextPtr ctxt,\n                              virTristateBool *isolatedPort)\n{\n    g_autofree char *str = NULL;\n    int tmp = VIR_TRISTATE_BOOL_ABSENT;\n\n    if ((str = virXPathString(\"string(./port/@isolated)\", ctxt))) {\n        if ((tmp = virTristateBoolTypeFromString(str)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown port isolated value '%s'\"), str);\n            return -1;\n        }\n    }\n\n    *isolatedPort = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkPortOptionsParseXML(xmlXPathContextPtr ctxt,\n                              virTristateBool *isolatedPort)\n{\n    g_autofree char *str = NULL;\n    int tmp = VIR_TRISTATE_BOOL_ABSENT;\n\n    if ((str = virXPathString(\"string(./port/@isolated)\", ctxt))) {\n        if ((tmp = virTristateBoolTypeFromString(str)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown port isolated value '%s'\"), str);\n            return -1;\n        }\n    }\n\n    *isolatedPort = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVlanParse",
          "args": [
            "vlanNode",
            "ctxt",
            "&def->vlan"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVlanParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_vlan_conf.c",
          "lines": "32-138",
          "snippet": "int\nvirNetDevVlanParse(xmlNodePtr node, xmlXPathContextPtr ctxt, virNetDevVlanPtr def)\n{\n    int ret = -1;\n    xmlNodePtr save = ctxt->node;\n    char *trunk = NULL;\n    char *nativeMode = NULL;\n    xmlNodePtr *tagNodes = NULL;\n    int nTags;\n    size_t i;\n\n    ctxt->node = node;\n\n    nTags = virXPathNodeSet(\"./tag\", ctxt, &tagNodes);\n    if (nTags < 0)\n        goto cleanup;\n\n    if (nTags == 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing tag id - each <vlan> must have \"\n                         \"at least one <tag id='n'/> subelement\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(def->tag, nTags) < 0)\n        goto cleanup;\n\n    def->nativeMode = 0;\n    def->nativeTag = 0;\n    for (i = 0; i < nTags; i++) {\n        unsigned long id;\n\n        ctxt->node = tagNodes[i];\n        if (virXPathULong(\"string(./@id)\", ctxt, &id) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing or invalid vlan tag id attribute\"));\n            goto cleanup;\n        }\n        if (id > 4095) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"vlan tag id %lu too large (maximum 4095)\"), id);\n            goto cleanup;\n        }\n        if ((nativeMode = virXPathString(\"string(./@nativeMode)\", ctxt))) {\n            if (def->nativeMode != 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"duplicate native vlan setting\"));\n                goto cleanup;\n            }\n            if ((def->nativeMode\n                 = virNativeVlanModeTypeFromString(nativeMode)) <= 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid \\\"nativeMode='%s'\\\" \"\n                                 \"in vlan <tag> element\"),\n                               nativeMode);\n                goto cleanup;\n            }\n            VIR_FREE(nativeMode);\n            def->nativeTag = id;\n        }\n        def->tag[i] = id;\n    }\n\n    def->nTags = nTags;\n\n    /* now that we know how many tags there are, look for an explicit\n     * trunk setting.\n     */\n    if (nTags > 1)\n        def->trunk = true;\n\n    ctxt->node = node;\n    if ((trunk = virXPathString(\"string(./@trunk)\", ctxt)) != NULL) {\n        def->trunk = STRCASEEQ(trunk, \"yes\");\n        if (!def->trunk) {\n            if (nTags > 1) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"invalid \\\"trunk='%s'\\\" in <vlan> - trunk='yes' \"\n                                 \"is required for more than one vlan tag\"), trunk);\n                goto cleanup;\n            }\n            if (def->nativeMode != 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"invalid configuration in <vlan> - \\\"trunk='no'\\\" is \"\n                                 \"not allowed with a native vlan id\"));\n                goto cleanup;\n            }\n            /* allow (but discard) \"trunk='no' if there is a single tag */\n            if (STRCASENEQ(trunk, \"no\")) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"invalid \\\"trunk='%s'\\\" in <vlan> \"\n                                 \"- must be yes or no\"), trunk);\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    ctxt->node = save;\n    VIR_FREE(tagNodes);\n    VIR_FREE(trunk);\n    VIR_FREE(nativeMode);\n    if (ret < 0)\n        virNetDevVlanClear(def);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_vlan_conf.h\"\n#include <config.h>\n\nint\nvirNetDevVlanParse(xmlNodePtr node, xmlXPathContextPtr ctxt, virNetDevVlanPtr def)\n{\n    int ret = -1;\n    xmlNodePtr save = ctxt->node;\n    char *trunk = NULL;\n    char *nativeMode = NULL;\n    xmlNodePtr *tagNodes = NULL;\n    int nTags;\n    size_t i;\n\n    ctxt->node = node;\n\n    nTags = virXPathNodeSet(\"./tag\", ctxt, &tagNodes);\n    if (nTags < 0)\n        goto cleanup;\n\n    if (nTags == 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing tag id - each <vlan> must have \"\n                         \"at least one <tag id='n'/> subelement\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(def->tag, nTags) < 0)\n        goto cleanup;\n\n    def->nativeMode = 0;\n    def->nativeTag = 0;\n    for (i = 0; i < nTags; i++) {\n        unsigned long id;\n\n        ctxt->node = tagNodes[i];\n        if (virXPathULong(\"string(./@id)\", ctxt, &id) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing or invalid vlan tag id attribute\"));\n            goto cleanup;\n        }\n        if (id > 4095) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"vlan tag id %lu too large (maximum 4095)\"), id);\n            goto cleanup;\n        }\n        if ((nativeMode = virXPathString(\"string(./@nativeMode)\", ctxt))) {\n            if (def->nativeMode != 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"duplicate native vlan setting\"));\n                goto cleanup;\n            }\n            if ((def->nativeMode\n                 = virNativeVlanModeTypeFromString(nativeMode)) <= 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid \\\"nativeMode='%s'\\\" \"\n                                 \"in vlan <tag> element\"),\n                               nativeMode);\n                goto cleanup;\n            }\n            VIR_FREE(nativeMode);\n            def->nativeTag = id;\n        }\n        def->tag[i] = id;\n    }\n\n    def->nTags = nTags;\n\n    /* now that we know how many tags there are, look for an explicit\n     * trunk setting.\n     */\n    if (nTags > 1)\n        def->trunk = true;\n\n    ctxt->node = node;\n    if ((trunk = virXPathString(\"string(./@trunk)\", ctxt)) != NULL) {\n        def->trunk = STRCASEEQ(trunk, \"yes\");\n        if (!def->trunk) {\n            if (nTags > 1) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"invalid \\\"trunk='%s'\\\" in <vlan> - trunk='yes' \"\n                                 \"is required for more than one vlan tag\"), trunk);\n                goto cleanup;\n            }\n            if (def->nativeMode != 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"invalid configuration in <vlan> - \\\"trunk='no'\\\" is \"\n                                 \"not allowed with a native vlan id\"));\n                goto cleanup;\n            }\n            /* allow (but discard) \"trunk='no' if there is a single tag */\n            if (STRCASENEQ(trunk, \"no\")) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"invalid \\\"trunk='%s'\\\" in <vlan> \"\n                                 \"- must be yes or no\"), trunk);\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    ctxt->node = save;\n    VIR_FREE(tagNodes);\n    VIR_FREE(trunk);\n    VIR_FREE(nativeMode);\n    if (ret < 0)\n        virNetDevVlanClear(def);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthParse",
          "args": [
            "&def->bandwidth",
            "&def->class_id",
            "bandwidthNode",
            "true"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_bandwidth_conf.c",
          "lines": "112-219",
          "snippet": "int\nvirNetDevBandwidthParse(virNetDevBandwidthPtr *bandwidth,\n                        unsigned int *class_id,\n                        xmlNodePtr node,\n                        bool allowFloor)\n{\n    int ret = -1;\n    virNetDevBandwidthPtr def = NULL;\n    xmlNodePtr cur;\n    xmlNodePtr in = NULL, out = NULL;\n    char *class_id_prop = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return ret;\n\n    if (!node || !virXMLNodeNameEqual(node, \"bandwidth\")) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"invalid argument supplied\"));\n        goto cleanup;\n    }\n\n    class_id_prop = virXMLPropString(node, \"classID\");\n    if (class_id_prop) {\n        if (!class_id) {\n            virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                           _(\"classID attribute not supported on <bandwidth> \"\n                             \"in this usage context\"));\n            goto cleanup;\n        }\n        if (virStrToLong_ui(class_id_prop, NULL, 10, class_id) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to parse class id '%s'\"),\n                           class_id_prop);\n            goto cleanup;\n        }\n    }\n\n    cur = node->children;\n\n    while (cur) {\n        if (cur->type == XML_ELEMENT_NODE) {\n            if (virXMLNodeNameEqual(cur, \"inbound\")) {\n                if (in) {\n                    virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                                   _(\"Only one child <inbound> \"\n                                     \"element allowed\"));\n                    goto cleanup;\n                }\n                in = cur;\n            } else if (virXMLNodeNameEqual(cur, \"outbound\")) {\n                if (out) {\n                    virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                                   _(\"Only one child <outbound> \"\n                                     \"element allowed\"));\n                    goto cleanup;\n                }\n                out = cur;\n            }\n            /* Silently ignore unknown elements */\n        }\n        cur = cur->next;\n    }\n\n    if (in) {\n        if (VIR_ALLOC(def->in) < 0)\n            goto cleanup;\n\n        if (virNetDevBandwidthParseRate(in, def->in) < 0) {\n            /* helper reported error for us */\n            goto cleanup;\n        }\n\n        if (def->in->floor && !allowFloor) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"floor attribute is not supported for this config\"));\n            goto cleanup;\n        }\n    }\n\n    if (out) {\n        if (VIR_ALLOC(def->out) < 0)\n            goto cleanup;\n\n        if (virNetDevBandwidthParseRate(out, def->out) < 0) {\n            /* helper reported error for us */\n            goto cleanup;\n        }\n\n        if (def->out->floor) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"'floor' attribute allowed \"\n                             \"only in <inbound> element\"));\n            goto cleanup;\n        }\n    }\n\n    if (!def->in && !def->out)\n        VIR_FREE(def);\n\n    *bandwidth = def;\n    def = NULL;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(class_id_prop);\n    virNetDevBandwidthFree(def);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include <config.h>\n\nint\nvirNetDevBandwidthParse(virNetDevBandwidthPtr *bandwidth,\n                        unsigned int *class_id,\n                        xmlNodePtr node,\n                        bool allowFloor)\n{\n    int ret = -1;\n    virNetDevBandwidthPtr def = NULL;\n    xmlNodePtr cur;\n    xmlNodePtr in = NULL, out = NULL;\n    char *class_id_prop = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return ret;\n\n    if (!node || !virXMLNodeNameEqual(node, \"bandwidth\")) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"invalid argument supplied\"));\n        goto cleanup;\n    }\n\n    class_id_prop = virXMLPropString(node, \"classID\");\n    if (class_id_prop) {\n        if (!class_id) {\n            virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                           _(\"classID attribute not supported on <bandwidth> \"\n                             \"in this usage context\"));\n            goto cleanup;\n        }\n        if (virStrToLong_ui(class_id_prop, NULL, 10, class_id) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to parse class id '%s'\"),\n                           class_id_prop);\n            goto cleanup;\n        }\n    }\n\n    cur = node->children;\n\n    while (cur) {\n        if (cur->type == XML_ELEMENT_NODE) {\n            if (virXMLNodeNameEqual(cur, \"inbound\")) {\n                if (in) {\n                    virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                                   _(\"Only one child <inbound> \"\n                                     \"element allowed\"));\n                    goto cleanup;\n                }\n                in = cur;\n            } else if (virXMLNodeNameEqual(cur, \"outbound\")) {\n                if (out) {\n                    virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                                   _(\"Only one child <outbound> \"\n                                     \"element allowed\"));\n                    goto cleanup;\n                }\n                out = cur;\n            }\n            /* Silently ignore unknown elements */\n        }\n        cur = cur->next;\n    }\n\n    if (in) {\n        if (VIR_ALLOC(def->in) < 0)\n            goto cleanup;\n\n        if (virNetDevBandwidthParseRate(in, def->in) < 0) {\n            /* helper reported error for us */\n            goto cleanup;\n        }\n\n        if (def->in->floor && !allowFloor) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"floor attribute is not supported for this config\"));\n            goto cleanup;\n        }\n    }\n\n    if (out) {\n        if (VIR_ALLOC(def->out) < 0)\n            goto cleanup;\n\n        if (virNetDevBandwidthParseRate(out, def->out) < 0) {\n            /* helper reported error for us */\n            goto cleanup;\n        }\n\n        if (def->out->floor) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"'floor' attribute allowed \"\n                             \"only in <inbound> element\"));\n            goto cleanup;\n        }\n    }\n\n    if (!def->in && !def->out)\n        VIR_FREE(def);\n\n    *bandwidth = def;\n    def = NULL;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(class_id_prop);\n    virNetDevBandwidthFree(def);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to parse MAC '%s'\")",
            "mac"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrParse",
          "args": [
            "mac",
            "&def->mac"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "205-218",
          "snippet": "int\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"network port has no mac\")"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileParse",
          "args": [
            "virtPortNode",
            "0"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_vport_profile_conf.c",
          "lines": "29-196",
          "snippet": "virNetDevVPortProfilePtr\nvirNetDevVPortProfileParse(xmlNodePtr node, unsigned int flags)\n{\n    char *virtPortType;\n    char *virtPortManagerID = NULL;\n    char *virtPortTypeID = NULL;\n    char *virtPortTypeIDVersion = NULL;\n    char *virtPortInstanceID = NULL;\n    char *virtPortProfileID = NULL;\n    char *virtPortInterfaceID = NULL;\n    virNetDevVPortProfilePtr virtPort = NULL;\n    xmlNodePtr cur = node->children;\n\n    if (VIR_ALLOC(virtPort) < 0)\n        return NULL;\n\n    if ((virtPortType = virXMLPropString(node, \"type\")) &&\n        (virtPort->virtPortType = virNetDevVPortTypeFromString(virtPortType)) <= 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown virtualport type %s\"), virtPortType);\n        goto error;\n    }\n\n    if ((virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE) &&\n        (flags & VIR_VPORT_XML_REQUIRE_TYPE)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing required virtualport type\"));\n        goto error;\n    }\n\n    while (cur != NULL) {\n        if (virXMLNodeNameEqual(cur, \"parameters\")) {\n            virtPortManagerID = virXMLPropString(cur, \"managerid\");\n            virtPortTypeID = virXMLPropString(cur, \"typeid\");\n            virtPortTypeIDVersion = virXMLPropString(cur, \"typeidversion\");\n            virtPortInstanceID = virXMLPropString(cur, \"instanceid\");\n            virtPortProfileID = virXMLPropString(cur, \"profileid\");\n            virtPortInterfaceID = virXMLPropString(cur, \"interfaceid\");\n            break;\n        }\n        cur = cur->next;\n    }\n\n    if (virtPortManagerID) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortManagerID, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of managerid parameter\"));\n            goto error;\n        }\n        if (val > 0xff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value of managerid out of range\"));\n            goto error;\n        }\n        virtPort->managerID = (uint8_t)val;\n        virtPort->managerID_specified = true;\n    }\n\n    if (virtPortTypeID) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortTypeID, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of typeid parameter\"));\n            goto error;\n        }\n        if (val > 0xffffff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value for typeid out of range\"));\n            goto error;\n        }\n        virtPort->typeID = (uint32_t)val;\n        virtPort->typeID_specified = true;\n    }\n\n    if (virtPortTypeIDVersion) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortTypeIDVersion, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of typeidversion parameter\"));\n            goto error;\n        }\n        if (val > 0xff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value of typeidversion out of range\"));\n            goto error;\n        }\n        virtPort->typeIDVersion = (uint8_t)val;\n        virtPort->typeIDVersion_specified = true;\n    }\n\n    if (virtPortInstanceID) {\n        if (virUUIDParse(virtPortInstanceID, virtPort->instanceID) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse instanceid parameter as a uuid\"));\n            goto error;\n        }\n        virtPort->instanceID_specified = true;\n    }\n\n    if (virtPortProfileID &&\n        virStrcpyStatic(virtPort->profileID, virtPortProfileID) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"profileid parameter too long\"));\n        goto error;\n    }\n\n    if (virtPortInterfaceID) {\n        if (virUUIDParse(virtPortInterfaceID, virtPort->interfaceID) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse interfaceid parameter as a uuid\"));\n            goto error;\n        }\n        virtPort->interfaceID_specified = true;\n    }\n\n    /* generate default instanceID/interfaceID if appropriate */\n    if (flags & VIR_VPORT_XML_GENERATE_MISSING_DEFAULTS) {\n        if (!virtPort->instanceID_specified &&\n            (virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n             virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n            if (virUUIDGenerate(virtPort->instanceID) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot generate a random uuid for instanceid\"));\n                goto error;\n            }\n            virtPort->instanceID_specified = true;\n        }\n        if (!virtPort->interfaceID_specified &&\n            (virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n             virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n            if (virUUIDGenerate(virtPort->interfaceID) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot generate a random uuid for interfaceid\"));\n                goto error;\n            }\n            virtPort->interfaceID_specified = true;\n        }\n    }\n\n    /* check for required/unsupported attributes */\n\n    if ((flags & VIR_VPORT_XML_REQUIRE_ALL_ATTRIBUTES) &&\n        (virNetDevVPortProfileCheckComplete(virtPort, false) < 0)) {\n        goto error;\n    }\n\n    if (virNetDevVPortProfileCheckNoExtras(virtPort) < 0)\n        goto error;\n\n cleanup:\n    VIR_FREE(virtPortManagerID);\n    VIR_FREE(virtPortTypeID);\n    VIR_FREE(virtPortTypeIDVersion);\n    VIR_FREE(virtPortInstanceID);\n    VIR_FREE(virtPortProfileID);\n    VIR_FREE(virtPortType);\n    VIR_FREE(virtPortInterfaceID);\n\n    return virtPort;\n\n error:\n    VIR_FREE(virtPort);\n    goto cleanup;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include <config.h>\n\nvirNetDevVPortProfilePtr\nvirNetDevVPortProfileParse(xmlNodePtr node, unsigned int flags)\n{\n    char *virtPortType;\n    char *virtPortManagerID = NULL;\n    char *virtPortTypeID = NULL;\n    char *virtPortTypeIDVersion = NULL;\n    char *virtPortInstanceID = NULL;\n    char *virtPortProfileID = NULL;\n    char *virtPortInterfaceID = NULL;\n    virNetDevVPortProfilePtr virtPort = NULL;\n    xmlNodePtr cur = node->children;\n\n    if (VIR_ALLOC(virtPort) < 0)\n        return NULL;\n\n    if ((virtPortType = virXMLPropString(node, \"type\")) &&\n        (virtPort->virtPortType = virNetDevVPortTypeFromString(virtPortType)) <= 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown virtualport type %s\"), virtPortType);\n        goto error;\n    }\n\n    if ((virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE) &&\n        (flags & VIR_VPORT_XML_REQUIRE_TYPE)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing required virtualport type\"));\n        goto error;\n    }\n\n    while (cur != NULL) {\n        if (virXMLNodeNameEqual(cur, \"parameters\")) {\n            virtPortManagerID = virXMLPropString(cur, \"managerid\");\n            virtPortTypeID = virXMLPropString(cur, \"typeid\");\n            virtPortTypeIDVersion = virXMLPropString(cur, \"typeidversion\");\n            virtPortInstanceID = virXMLPropString(cur, \"instanceid\");\n            virtPortProfileID = virXMLPropString(cur, \"profileid\");\n            virtPortInterfaceID = virXMLPropString(cur, \"interfaceid\");\n            break;\n        }\n        cur = cur->next;\n    }\n\n    if (virtPortManagerID) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortManagerID, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of managerid parameter\"));\n            goto error;\n        }\n        if (val > 0xff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value of managerid out of range\"));\n            goto error;\n        }\n        virtPort->managerID = (uint8_t)val;\n        virtPort->managerID_specified = true;\n    }\n\n    if (virtPortTypeID) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortTypeID, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of typeid parameter\"));\n            goto error;\n        }\n        if (val > 0xffffff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value for typeid out of range\"));\n            goto error;\n        }\n        virtPort->typeID = (uint32_t)val;\n        virtPort->typeID_specified = true;\n    }\n\n    if (virtPortTypeIDVersion) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortTypeIDVersion, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of typeidversion parameter\"));\n            goto error;\n        }\n        if (val > 0xff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value of typeidversion out of range\"));\n            goto error;\n        }\n        virtPort->typeIDVersion = (uint8_t)val;\n        virtPort->typeIDVersion_specified = true;\n    }\n\n    if (virtPortInstanceID) {\n        if (virUUIDParse(virtPortInstanceID, virtPort->instanceID) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse instanceid parameter as a uuid\"));\n            goto error;\n        }\n        virtPort->instanceID_specified = true;\n    }\n\n    if (virtPortProfileID &&\n        virStrcpyStatic(virtPort->profileID, virtPortProfileID) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"profileid parameter too long\"));\n        goto error;\n    }\n\n    if (virtPortInterfaceID) {\n        if (virUUIDParse(virtPortInterfaceID, virtPort->interfaceID) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse interfaceid parameter as a uuid\"));\n            goto error;\n        }\n        virtPort->interfaceID_specified = true;\n    }\n\n    /* generate default instanceID/interfaceID if appropriate */\n    if (flags & VIR_VPORT_XML_GENERATE_MISSING_DEFAULTS) {\n        if (!virtPort->instanceID_specified &&\n            (virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n             virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n            if (virUUIDGenerate(virtPort->instanceID) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot generate a random uuid for instanceid\"));\n                goto error;\n            }\n            virtPort->instanceID_specified = true;\n        }\n        if (!virtPort->interfaceID_specified &&\n            (virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n             virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n            if (virUUIDGenerate(virtPort->interfaceID) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot generate a random uuid for interfaceid\"));\n                goto error;\n            }\n            virtPort->interfaceID_specified = true;\n        }\n    }\n\n    /* check for required/unsupported attributes */\n\n    if ((flags & VIR_VPORT_XML_REQUIRE_ALL_ATTRIBUTES) &&\n        (virNetDevVPortProfileCheckComplete(virtPort, false) < 0)) {\n        goto error;\n    }\n\n    if (virNetDevVPortProfileCheckNoExtras(virtPort) < 0)\n        goto error;\n\n cleanup:\n    VIR_FREE(virtPortManagerID);\n    VIR_FREE(virtPortTypeID);\n    VIR_FREE(virtPortTypeIDVersion);\n    VIR_FREE(virtPortInstanceID);\n    VIR_FREE(virtPortProfileID);\n    VIR_FREE(virtPortType);\n    VIR_FREE(virtPortInterfaceID);\n\n    return virtPort;\n\n error:\n    VIR_FREE(virtPort);\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to parse UUID '%s'\")",
            "uuid"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "uuid",
            "def->owneruuid"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"network port has no owner UUID\")"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"network port has no owner name\")"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to parse UUID '%s'\")",
            "uuid"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"network port has no uuid\")"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virNetworkPortDefPtr\nvirNetworkPortDefParseXML(xmlXPathContextPtr ctxt)\n{\n    g_autoptr(virNetworkPortDef) def = NULL;\n    g_autofree char *uuid = NULL;\n    xmlNodePtr virtPortNode;\n    xmlNodePtr vlanNode;\n    xmlNodePtr bandwidthNode;\n    xmlNodePtr addressNode;\n    g_autofree char *trustGuestRxFilters = NULL;\n    g_autofree char *mac = NULL;\n    g_autofree char *macmgr = NULL;\n    g_autofree char *mode = NULL;\n    g_autofree char *plugtype = NULL;\n    g_autofree char *managed = NULL;\n    g_autofree char *driver = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    uuid = virXPathString(\"string(./uuid)\", ctxt);\n    if (!uuid) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"network port has no uuid\"));\n        return NULL;\n    }\n    if (virUUIDParse(uuid, def->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse UUID '%s'\"), uuid);\n        return NULL;\n    }\n\n    def->ownername = virXPathString(\"string(./owner/name)\", ctxt);\n    if (!def->ownername) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"network port has no owner name\"));\n        return NULL;\n    }\n\n    VIR_FREE(uuid);\n    uuid = virXPathString(\"string(./owner/uuid)\", ctxt);\n    if (!uuid) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"network port has no owner UUID\"));\n        return NULL;\n    }\n\n    if (virUUIDParse(uuid, def->owneruuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse UUID '%s'\"), uuid);\n        return NULL;\n    }\n\n    def->group = virXPathString(\"string(./group)\", ctxt);\n\n    virtPortNode = virXPathNode(\"./virtualport\", ctxt);\n    if (virtPortNode &&\n        (!(def->virtPortProfile = virNetDevVPortProfileParse(virtPortNode, 0)))) {\n        return NULL;\n    }\n\n    mac = virXPathString(\"string(./mac/@address)\", ctxt);\n    if (!mac) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"network port has no mac\"));\n        return NULL;\n    }\n    if (virMacAddrParse(mac, &def->mac) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse MAC '%s'\"), mac);\n        return NULL;\n    }\n\n    bandwidthNode = virXPathNode(\"./bandwidth\", ctxt);\n    /*\n     * We don't know if the port will allow the \"floor\" param or\n     * not at this stage, so we must just tell virNetDevBandwidthParse\n     * to allow it regardless. Any bad config must be reported at\n     * time of use instead.\n     */\n    if (bandwidthNode &&\n        virNetDevBandwidthParse(&def->bandwidth, &def->class_id,\n                                bandwidthNode, true) < 0)\n        return NULL;\n\n    vlanNode = virXPathNode(\"./vlan\", ctxt);\n    if (vlanNode && virNetDevVlanParse(vlanNode, ctxt, &def->vlan) < 0)\n        return NULL;\n\n    if (virNetworkPortOptionsParseXML(ctxt, &def->isolatedPort) < 0)\n        return NULL;\n\n    trustGuestRxFilters\n        = virXPathString(\"string(./rxfilters/@trustGuest)\", ctxt);\n    if (trustGuestRxFilters) {\n        if ((def->trustGuestRxFilters\n             = virTristateBoolTypeFromString(trustGuestRxFilters)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid guest rx filters trust setting '%s' \"),\n                           trustGuestRxFilters);\n            return NULL;\n        }\n    }\n\n    plugtype = virXPathString(\"string(./plug/@type)\", ctxt);\n\n    if (plugtype &&\n        (def->plugtype = virNetworkPortPlugTypeFromString(plugtype)) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid network prt plug type '%s'\"), plugtype);\n    }\n\n    switch (def->plugtype) {\n    case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n    case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n        if (!(def->plug.bridge.brname = virXPathString(\"string(./plug/@bridge)\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing network port bridge name\"));\n            return NULL;\n        }\n        macmgr = virXPathString(\"string(./plug/@macTableManager)\", ctxt);\n        if (macmgr &&\n            (def->plug.bridge.macTableManager =\n             virNetworkBridgeMACTableManagerTypeFromString(macmgr)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid macTableManager setting '%s' \"\n                             \"in network port\"), macmgr);\n            return NULL;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n        if (!(def->plug.direct.linkdev = virXPathString(\"string(./plug/@dev)\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing network port link device name\"));\n            return NULL;\n        }\n        mode = virXPathString(\"string(./plug/@mode)\", ctxt);\n        if (mode &&\n            (def->plug.direct.mode =\n             virNetDevMacVLanModeTypeFromString(mode)) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid mode setting '%s' in network port\"), mode);\n            return NULL;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n        managed = virXPathString(\"string(./plug/@managed)\", ctxt);\n        if (managed &&\n            (def->plug.hostdevpci.managed =\n             virTristateBoolTypeFromString(managed)) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid managed setting '%s' in network port\"), mode);\n            return NULL;\n        }\n        driver = virXPathString(\"string(./plug/driver/@name)\", ctxt);\n        if (driver &&\n            (def->plug.hostdevpci.driver =\n             virNetworkForwardDriverNameTypeFromString(driver)) <= 0) {\n              virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing network port driver name\"));\n            return NULL;\n        }\n        if (!(addressNode = virXPathNode(\"./plug/address\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing network port PCI address\"));\n            return NULL;\n        }\n\n        if (virPCIDeviceAddressParseXML(addressNode, &def->plug.hostdevpci.addr) < 0)\n            return NULL;\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virNetworkPortPlugType, def->plugtype);\n        return NULL;\n    }\n\n    return g_steal_pointer(&def);\n}"
  },
  {
    "function_name": "virNetworkPortDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
    "lines": "42-77",
    "snippet": "void\nvirNetworkPortDefFree(virNetworkPortDefPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->ownername);\n    VIR_FREE(def->group);\n\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n    VIR_FREE(def->virtPortProfile);\n\n    switch ((virNetworkPortPlugType)def->plugtype) {\n    case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n    case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n        VIR_FREE(def->plug.bridge.brname);\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n        VIR_FREE(def->plug.direct.linkdev);\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n    default:\n        break;\n    }\n\n    VIR_FREE(def);\n}",
    "includes": [
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"network_conf.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virnetdevmacvlan.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->plug.direct.linkdev"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->plug.bridge.brname"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->virtPortProfile"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVlanClear",
          "args": [
            "&def->vlan"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVlanClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvlan.c",
          "lines": "28-35",
          "snippet": "void\nvirNetDevVlanClear(virNetDevVlanPtr vlan)\n{\n    VIR_FREE(vlan->tag);\n    vlan->nTags = 0;\n    vlan->nativeMode = 0;\n    vlan->nativeTag = 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virnetdevvlan.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirNetDevVlanClear(virNetDevVlanPtr vlan)\n{\n    VIR_FREE(vlan->tag);\n    vlan->nTags = 0;\n    vlan->nativeMode = 0;\n    vlan->nativeTag = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthFree",
          "args": [
            "def->bandwidth"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "31-40",
          "snippet": "void\nvirNetDevBandwidthFree(virNetDevBandwidthPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->in);\n    VIR_FREE(def->out);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetDevBandwidthFree(virNetDevBandwidthPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->in);\n    VIR_FREE(def->out);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->group"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->ownername"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetworkPortDefFree(virNetworkPortDefPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->ownername);\n    VIR_FREE(def->group);\n\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n    VIR_FREE(def->virtPortProfile);\n\n    switch ((virNetworkPortPlugType)def->plugtype) {\n    case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n    case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n        VIR_FREE(def->plug.bridge.brname);\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n        VIR_FREE(def->plug.direct.linkdev);\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n    default:\n        break;\n    }\n\n    VIR_FREE(def);\n}"
  }
]