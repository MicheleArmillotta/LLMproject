[
  {
    "function_name": "libxlCreateXMLConf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "2475-2482",
    "snippet": "virDomainXMLOptionPtr\nlibxlCreateXMLConf(libxlDriverPrivatePtr driver)\n{\n    libxlDomainDefParserConfig.priv = driver;\n    return virDomainXMLOptionNew(&libxlDomainDefParserConfig,\n                                 &libxlDomainXMLPrivateDataCallbacks,\n                                 NULL, NULL, NULL);\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainXMLOptionNew",
          "args": [
            "&libxlDomainDefParserConfig",
            "&libxlDomainXMLPrivateDataCallbacks",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 2479
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainXMLOptionNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1415-1458",
          "snippet": "virDomainXMLOptionPtr\nvirDomainXMLOptionNew(virDomainDefParserConfigPtr config,\n                      virDomainXMLPrivateDataCallbacksPtr priv,\n                      virXMLNamespacePtr xmlns,\n                      virDomainABIStabilityPtr abi,\n                      virSaveCookieCallbacksPtr saveCookie)\n{\n    virDomainXMLOptionPtr xmlopt;\n\n    if (virDomainObjInitialize() < 0)\n        return NULL;\n\n    if (!(xmlopt = virObjectNew(virDomainXMLOptionClass)))\n        return NULL;\n\n    if (priv)\n        xmlopt->privateData = *priv;\n\n    if (config)\n        xmlopt->config = *config;\n\n    if (xmlns)\n        xmlopt->ns = *xmlns;\n\n    if (abi)\n        xmlopt->abi = *abi;\n\n    if (saveCookie)\n        xmlopt->saveCookie = *saveCookie;\n\n    /* Technically this forbids to use one of Xerox's MAC address prefixes in\n     * our hypervisor drivers. This shouldn't ever be a problem.\n     *\n     * Use the KVM prefix as default as it's in the privately administered\n     * range */\n    if (xmlopt->config.macPrefix[0] == 0 &&\n        xmlopt->config.macPrefix[1] == 0 &&\n        xmlopt->config.macPrefix[2] == 0) {\n        xmlopt->config.macPrefix[0] = 0x52;\n        xmlopt->config.macPrefix[1] = 0x54;\n    }\n\n    return xmlopt;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virDomainXMLOptionClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virClassPtr virDomainXMLOptionClass;\n\nvirDomainXMLOptionPtr\nvirDomainXMLOptionNew(virDomainDefParserConfigPtr config,\n                      virDomainXMLPrivateDataCallbacksPtr priv,\n                      virXMLNamespacePtr xmlns,\n                      virDomainABIStabilityPtr abi,\n                      virSaveCookieCallbacksPtr saveCookie)\n{\n    virDomainXMLOptionPtr xmlopt;\n\n    if (virDomainObjInitialize() < 0)\n        return NULL;\n\n    if (!(xmlopt = virObjectNew(virDomainXMLOptionClass)))\n        return NULL;\n\n    if (priv)\n        xmlopt->privateData = *priv;\n\n    if (config)\n        xmlopt->config = *config;\n\n    if (xmlns)\n        xmlopt->ns = *xmlns;\n\n    if (abi)\n        xmlopt->abi = *abi;\n\n    if (saveCookie)\n        xmlopt->saveCookie = *saveCookie;\n\n    /* Technically this forbids to use one of Xerox's MAC address prefixes in\n     * our hypervisor drivers. This shouldn't ever be a problem.\n     *\n     * Use the KVM prefix as default as it's in the privately administered\n     * range */\n    if (xmlopt->config.macPrefix[0] == 0 &&\n        xmlopt->config.macPrefix[1] == 0 &&\n        xmlopt->config.macPrefix[2] == 0) {\n        xmlopt->config.macPrefix[0] = 0x52;\n        xmlopt->config.macPrefix[1] = 0x54;\n    }\n\n    return xmlopt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nvirDomainXMLOptionPtr\nlibxlCreateXMLConf(libxlDriverPrivatePtr driver)\n{\n    libxlDomainDefParserConfig.priv = driver;\n    return virDomainXMLOptionNew(&libxlDomainDefParserConfig,\n                                 &libxlDomainXMLPrivateDataCallbacks,\n                                 NULL, NULL, NULL);\n}"
  },
  {
    "function_name": "libxlBuildDomainConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "2411-2473",
    "snippet": "int\nlibxlBuildDomainConfig(virPortAllocatorRangePtr graphicsports,\n                       virDomainDefPtr def,\n                       libxlDriverConfigPtr cfg,\n                       libxl_domain_config *d_config)\n{\n    virCapsPtr caps = cfg->caps;\n    libxl_ctx *ctx = cfg->ctx;\n    libxl_domain_config_init(d_config);\n\n    if (libxlMakeDomCreateInfo(ctx, def, &d_config->c_info) < 0)\n        return -1;\n\n    if (libxlMakeDomBuildInfo(def, cfg, caps, d_config) < 0)\n        return -1;\n\n#ifdef LIBXL_HAVE_VNUMA\n    if (libxlMakeVnumaList(def, ctx, d_config) < 0)\n        return -1;\n#endif\n\n    if (libxlMakeDiskList(def, d_config) < 0)\n        return -1;\n\n    if (libxlMakeNicList(def, d_config) < 0)\n        return -1;\n\n    if (libxlMakeVfbList(graphicsports, def, d_config) < 0)\n        return -1;\n\n    if (libxlMakeBuildInfoVfb(graphicsports, def, d_config) < 0)\n        return -1;\n\n    if (libxlMakePCIList(def, d_config) < 0)\n        return -1;\n\n#ifdef LIBXL_HAVE_PVUSB\n    if (libxlMakeUSBControllerList(def, d_config) < 0)\n        return -1;\n\n    if (libxlMakeUSBList(def, d_config) < 0)\n        return -1;\n#endif\n\n#ifdef LIBXL_HAVE_DEVICE_CHANNEL\n    if (libxlMakeChannelList(cfg->channelDir, def, d_config) < 0)\n        return -1;\n#endif\n\n    /*\n     * Now that any potential VFBs are defined, update the build info with\n     * the data of the primary display. Some day libxl might implicitly do\n     * so but as it does not right now, better be explicit.\n     */\n    if (libxlMakeVideo(def, d_config) < 0)\n        return -1;\n\n    d_config->on_reboot = libxlActionFromVirLifecycle(def->onReboot);\n    d_config->on_poweroff = libxlActionFromVirLifecycle(def->onPoweroff);\n    d_config->on_crash = libxlActionFromVirLifecycle(def->onCrash);\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libxlActionFromVirLifecycle",
          "args": [
            "def->onCrash"
          ],
          "line": 2470
        },
        "resolved": true,
        "details": {
          "function_name": "libxlActionFromVirLifecycle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "92-119",
          "snippet": "static libxl_action_on_shutdown\nlibxlActionFromVirLifecycle(virDomainLifecycleAction action)\n{\n    switch (action) {\n    case VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY:\n        return LIBXL_ACTION_ON_SHUTDOWN_DESTROY;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART:\n        return LIBXL_ACTION_ON_SHUTDOWN_RESTART;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART_RENAME:\n        return LIBXL_ACTION_ON_SHUTDOWN_RESTART_RENAME;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_PRESERVE:\n        return LIBXL_ACTION_ON_SHUTDOWN_PRESERVE;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_DESTROY:\n        return LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_DESTROY;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_RESTART:\n        return LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_RESTART;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_LAST:\n        break;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic libxl_action_on_shutdown\nlibxlActionFromVirLifecycle(virDomainLifecycleAction action)\n{\n    switch (action) {\n    case VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY:\n        return LIBXL_ACTION_ON_SHUTDOWN_DESTROY;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART:\n        return LIBXL_ACTION_ON_SHUTDOWN_RESTART;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART_RENAME:\n        return LIBXL_ACTION_ON_SHUTDOWN_RESTART_RENAME;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_PRESERVE:\n        return LIBXL_ACTION_ON_SHUTDOWN_PRESERVE;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_DESTROY:\n        return LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_DESTROY;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_RESTART:\n        return LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_RESTART;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_LAST:\n        break;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMakeVideo",
          "args": [
            "def",
            "d_config"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeVideo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "2296-2371",
          "snippet": "static int\nlibxlMakeVideo(virDomainDefPtr def, libxl_domain_config *d_config)\n\n{\n    libxl_domain_build_info *b_info = &d_config->b_info;\n    int dm_type = libxlDomainGetEmulatorType(def);\n\n    if (d_config->c_info.type != LIBXL_DOMAIN_TYPE_HVM)\n        return 0;\n\n    /*\n     * Take the first defined video device (graphics card) to display\n     * on the first graphics device (display).\n     */\n    if (def->nvideos) {\n        switch (def->videos[0]->type) {\n        case VIR_DOMAIN_VIDEO_TYPE_VGA:\n        case VIR_DOMAIN_VIDEO_TYPE_XEN:\n            b_info->u.hvm.vga.kind = LIBXL_VGA_INTERFACE_TYPE_STD;\n            if (dm_type == LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN) {\n                if (def->videos[0]->vram < 16 * 1024) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"videoram must be at least 16MB for VGA\"));\n                    return -1;\n                }\n            } else {\n                if (def->videos[0]->vram < 8 * 1024) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"videoram must be at least 8MB for VGA\"));\n                    return -1;\n                }\n            }\n            break;\n\n        case VIR_DOMAIN_VIDEO_TYPE_CIRRUS:\n            b_info->u.hvm.vga.kind = LIBXL_VGA_INTERFACE_TYPE_CIRRUS;\n            if (dm_type == LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN) {\n                if (def->videos[0]->vram < 8 * 1024) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"videoram must be at least 8MB for CIRRUS\"));\n                    return -1;\n                }\n            } else {\n                if (def->videos[0]->vram < 4 * 1024) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"videoram must be at least 4MB for CIRRUS\"));\n                    return -1;\n                }\n            }\n            break;\n\n#ifdef LIBXL_HAVE_QXL\n        case VIR_DOMAIN_VIDEO_TYPE_QXL:\n            b_info->u.hvm.vga.kind = LIBXL_VGA_INTERFACE_TYPE_QXL;\n            if (def->videos[0]->vram < 128 * 1024) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"videoram must be at least 128MB for QXL\"));\n                return -1;\n            }\n            break;\n#endif\n\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"video type %s is not supported by libxl\"),\n                           virDomainVideoTypeToString(def->videos[0]->type));\n            return -1;\n        }\n        /* vram validated for each video type, now set it */\n        b_info->video_memkb = def->videos[0]->vram;\n    } else {\n        libxl_defbool_set(&b_info->u.hvm.nographic, 1);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeVideo(virDomainDefPtr def, libxl_domain_config *d_config)\n\n{\n    libxl_domain_build_info *b_info = &d_config->b_info;\n    int dm_type = libxlDomainGetEmulatorType(def);\n\n    if (d_config->c_info.type != LIBXL_DOMAIN_TYPE_HVM)\n        return 0;\n\n    /*\n     * Take the first defined video device (graphics card) to display\n     * on the first graphics device (display).\n     */\n    if (def->nvideos) {\n        switch (def->videos[0]->type) {\n        case VIR_DOMAIN_VIDEO_TYPE_VGA:\n        case VIR_DOMAIN_VIDEO_TYPE_XEN:\n            b_info->u.hvm.vga.kind = LIBXL_VGA_INTERFACE_TYPE_STD;\n            if (dm_type == LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN) {\n                if (def->videos[0]->vram < 16 * 1024) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"videoram must be at least 16MB for VGA\"));\n                    return -1;\n                }\n            } else {\n                if (def->videos[0]->vram < 8 * 1024) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"videoram must be at least 8MB for VGA\"));\n                    return -1;\n                }\n            }\n            break;\n\n        case VIR_DOMAIN_VIDEO_TYPE_CIRRUS:\n            b_info->u.hvm.vga.kind = LIBXL_VGA_INTERFACE_TYPE_CIRRUS;\n            if (dm_type == LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN) {\n                if (def->videos[0]->vram < 8 * 1024) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"videoram must be at least 8MB for CIRRUS\"));\n                    return -1;\n                }\n            } else {\n                if (def->videos[0]->vram < 4 * 1024) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"videoram must be at least 4MB for CIRRUS\"));\n                    return -1;\n                }\n            }\n            break;\n\n#ifdef LIBXL_HAVE_QXL\n        case VIR_DOMAIN_VIDEO_TYPE_QXL:\n            b_info->u.hvm.vga.kind = LIBXL_VGA_INTERFACE_TYPE_QXL;\n            if (def->videos[0]->vram < 128 * 1024) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"videoram must be at least 128MB for QXL\"));\n                return -1;\n            }\n            break;\n#endif\n\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"video type %s is not supported by libxl\"),\n                           virDomainVideoTypeToString(def->videos[0]->type));\n            return -1;\n        }\n        /* vram validated for each video type, now set it */\n        b_info->video_memkb = def->videos[0]->vram;\n    } else {\n        libxl_defbool_set(&b_info->u.hvm.nographic, 1);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMakeChannelList",
          "args": [
            "cfg->channelDir",
            "def",
            "d_config"
          ],
          "line": 2456
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeChannelList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1972-2009",
          "snippet": "static int\nlibxlMakeChannelList(const char *channelDir,\n                     virDomainDefPtr def,\n                     libxl_domain_config *d_config)\n{\n    virDomainChrDefPtr *l_channels = def->channels;\n    size_t nchannels = def->nchannels;\n    libxl_device_channel *x_channels;\n    size_t i, nvchannels = 0;\n\n    if (VIR_ALLOC_N(x_channels, nchannels) < 0)\n        return -1;\n\n    for (i = 0; i < nchannels; i++) {\n        if (l_channels[i]->deviceType != VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL)\n            continue;\n\n        if (libxlPrepareChannel(l_channels[i], channelDir, def->name) < 0)\n            goto error;\n\n        if (libxlMakeChannel(l_channels[i], &x_channels[nvchannels]) < 0)\n            goto error;\n\n        nvchannels++;\n    }\n\n    VIR_SHRINK_N(x_channels, nchannels, nchannels - nvchannels);\n    d_config->channels = x_channels;\n    d_config->num_channels = nvchannels;\n\n    return 0;\n\n error:\n    for (i = 0; i < nchannels; i++)\n        libxl_device_channel_dispose(&x_channels[i]);\n    VIR_FREE(x_channels);\n    return -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeChannelList(const char *channelDir,\n                     virDomainDefPtr def,\n                     libxl_domain_config *d_config)\n{\n    virDomainChrDefPtr *l_channels = def->channels;\n    size_t nchannels = def->nchannels;\n    libxl_device_channel *x_channels;\n    size_t i, nvchannels = 0;\n\n    if (VIR_ALLOC_N(x_channels, nchannels) < 0)\n        return -1;\n\n    for (i = 0; i < nchannels; i++) {\n        if (l_channels[i]->deviceType != VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL)\n            continue;\n\n        if (libxlPrepareChannel(l_channels[i], channelDir, def->name) < 0)\n            goto error;\n\n        if (libxlMakeChannel(l_channels[i], &x_channels[nvchannels]) < 0)\n            goto error;\n\n        nvchannels++;\n    }\n\n    VIR_SHRINK_N(x_channels, nchannels, nchannels - nvchannels);\n    d_config->channels = x_channels;\n    d_config->num_channels = nvchannels;\n\n    return 0;\n\n error:\n    for (i = 0; i < nchannels; i++)\n        libxl_device_channel_dispose(&x_channels[i]);\n    VIR_FREE(x_channels);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMakeUSBList",
          "args": [
            "def",
            "d_config"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeUSBList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "2190-2232",
          "snippet": "static int\nlibxlMakeUSBList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainHostdevDefPtr *l_hostdevs = def->hostdevs;\n    size_t nhostdevs = def->nhostdevs;\n    size_t nusbdevs = 0;\n    libxl_device_usbdev *x_usbdevs;\n    size_t i, j;\n\n    if (nhostdevs == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(x_usbdevs, nhostdevs) < 0)\n        return -1;\n\n    for (i = 0, j = 0; i < nhostdevs; i++) {\n        if (l_hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (l_hostdevs[i]->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        libxl_device_usbdev_init(&x_usbdevs[j]);\n\n        if (libxlMakeUSB(l_hostdevs[i], &x_usbdevs[j]) < 0)\n            goto error;\n\n        nusbdevs++;\n        j++;\n    }\n\n    VIR_SHRINK_N(x_usbdevs, nhostdevs, nhostdevs - nusbdevs);\n    d_config->usbdevs = x_usbdevs;\n    d_config->num_usbdevs = nusbdevs;\n\n    return 0;\n\n error:\n    for (i = 0; i < nusbdevs; i++)\n        libxl_device_usbdev_dispose(&x_usbdevs[i]);\n\n    VIR_FREE(x_usbdevs);\n    return -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeUSBList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainHostdevDefPtr *l_hostdevs = def->hostdevs;\n    size_t nhostdevs = def->nhostdevs;\n    size_t nusbdevs = 0;\n    libxl_device_usbdev *x_usbdevs;\n    size_t i, j;\n\n    if (nhostdevs == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(x_usbdevs, nhostdevs) < 0)\n        return -1;\n\n    for (i = 0, j = 0; i < nhostdevs; i++) {\n        if (l_hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (l_hostdevs[i]->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        libxl_device_usbdev_init(&x_usbdevs[j]);\n\n        if (libxlMakeUSB(l_hostdevs[i], &x_usbdevs[j]) < 0)\n            goto error;\n\n        nusbdevs++;\n        j++;\n    }\n\n    VIR_SHRINK_N(x_usbdevs, nhostdevs, nhostdevs - nusbdevs);\n    d_config->usbdevs = x_usbdevs;\n    d_config->num_usbdevs = nusbdevs;\n\n    return 0;\n\n error:\n    for (i = 0; i < nusbdevs; i++)\n        libxl_device_usbdev_dispose(&x_usbdevs[i]);\n\n    VIR_FREE(x_usbdevs);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMakeUSBControllerList",
          "args": [
            "def",
            "d_config"
          ],
          "line": 2448
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeUSBControllerList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "2108-2152",
          "snippet": "static int\nlibxlMakeUSBControllerList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainControllerDefPtr *l_controllers = def->controllers;\n    size_t ncontrollers = def->ncontrollers;\n    size_t nusbctrls = 0;\n    libxl_device_usbctrl *x_usbctrls;\n    size_t i, j;\n\n    for (i = 0; i < ncontrollers; i++) {\n        if (l_controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB)\n            nusbctrls++;\n    }\n\n    if (nusbctrls == 0)\n        return libxlMakeDefaultUSBControllers(def, d_config);\n\n    if (VIR_ALLOC_N(x_usbctrls, nusbctrls) < 0)\n        return -1;\n\n    for (i = 0, j = 0; i < ncontrollers && j < nusbctrls; i++) {\n        if (l_controllers[i]->type != VIR_DOMAIN_CONTROLLER_TYPE_USB)\n            continue;\n\n        libxl_device_usbctrl_init(&x_usbctrls[j]);\n\n        if (libxlMakeUSBController(l_controllers[i],\n                                   &x_usbctrls[j]) < 0)\n            goto error;\n\n        j++;\n    }\n\n    d_config->usbctrls = x_usbctrls;\n    d_config->num_usbctrls = nusbctrls;\n\n    return 0;\n\n error:\n    for (i = 0; i < nusbctrls; i++)\n        libxl_device_usbctrl_dispose(&x_usbctrls[i]);\n\n    VIR_FREE(x_usbctrls);\n    return -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeUSBControllerList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainControllerDefPtr *l_controllers = def->controllers;\n    size_t ncontrollers = def->ncontrollers;\n    size_t nusbctrls = 0;\n    libxl_device_usbctrl *x_usbctrls;\n    size_t i, j;\n\n    for (i = 0; i < ncontrollers; i++) {\n        if (l_controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB)\n            nusbctrls++;\n    }\n\n    if (nusbctrls == 0)\n        return libxlMakeDefaultUSBControllers(def, d_config);\n\n    if (VIR_ALLOC_N(x_usbctrls, nusbctrls) < 0)\n        return -1;\n\n    for (i = 0, j = 0; i < ncontrollers && j < nusbctrls; i++) {\n        if (l_controllers[i]->type != VIR_DOMAIN_CONTROLLER_TYPE_USB)\n            continue;\n\n        libxl_device_usbctrl_init(&x_usbctrls[j]);\n\n        if (libxlMakeUSBController(l_controllers[i],\n                                   &x_usbctrls[j]) < 0)\n            goto error;\n\n        j++;\n    }\n\n    d_config->usbctrls = x_usbctrls;\n    d_config->num_usbctrls = nusbctrls;\n\n    return 0;\n\n error:\n    for (i = 0; i < nusbctrls; i++)\n        libxl_device_usbctrl_dispose(&x_usbctrls[i]);\n\n    VIR_FREE(x_usbctrls);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMakePCIList",
          "args": [
            "def",
            "d_config"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakePCIList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "2252-2294",
          "snippet": "static int\nlibxlMakePCIList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainHostdevDefPtr *l_hostdevs = def->hostdevs;\n    size_t nhostdevs = def->nhostdevs;\n    size_t npcidevs = 0;\n    libxl_device_pci *x_pcidevs;\n    size_t i, j;\n\n    if (nhostdevs == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(x_pcidevs, nhostdevs) < 0)\n        return -1;\n\n    for (i = 0, j = 0; i < nhostdevs; i++) {\n        if (l_hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (l_hostdevs[i]->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            continue;\n\n        libxl_device_pci_init(&x_pcidevs[j]);\n\n        if (libxlMakePCI(l_hostdevs[i], &x_pcidevs[j]) < 0)\n            goto error;\n\n        npcidevs++;\n        j++;\n    }\n\n    VIR_SHRINK_N(x_pcidevs, nhostdevs, nhostdevs - npcidevs);\n    d_config->pcidevs = x_pcidevs;\n    d_config->num_pcidevs = npcidevs;\n\n    return 0;\n\n error:\n    for (i = 0; i < npcidevs; i++)\n        libxl_device_pci_dispose(&x_pcidevs[i]);\n\n    VIR_FREE(x_pcidevs);\n    return -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakePCIList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainHostdevDefPtr *l_hostdevs = def->hostdevs;\n    size_t nhostdevs = def->nhostdevs;\n    size_t npcidevs = 0;\n    libxl_device_pci *x_pcidevs;\n    size_t i, j;\n\n    if (nhostdevs == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(x_pcidevs, nhostdevs) < 0)\n        return -1;\n\n    for (i = 0, j = 0; i < nhostdevs; i++) {\n        if (l_hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (l_hostdevs[i]->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            continue;\n\n        libxl_device_pci_init(&x_pcidevs[j]);\n\n        if (libxlMakePCI(l_hostdevs[i], &x_pcidevs[j]) < 0)\n            goto error;\n\n        npcidevs++;\n        j++;\n    }\n\n    VIR_SHRINK_N(x_pcidevs, nhostdevs, nhostdevs - npcidevs);\n    d_config->pcidevs = x_pcidevs;\n    d_config->num_pcidevs = npcidevs;\n\n    return 0;\n\n error:\n    for (i = 0; i < npcidevs; i++)\n        libxl_device_pci_dispose(&x_pcidevs[i]);\n\n    VIR_FREE(x_pcidevs);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMakeBuildInfoVfb",
          "args": [
            "graphicsports",
            "def",
            "d_config"
          ],
          "line": 2441
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeBuildInfoVfb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1551-1651",
          "snippet": "static int\nlibxlMakeBuildInfoVfb(virPortAllocatorRangePtr graphicsports,\n                      virDomainDefPtr def,\n                      libxl_domain_config *d_config)\n{\n    libxl_domain_build_info *b_info = &d_config->b_info;\n    libxl_device_vfb x_vfb;\n    size_t i;\n\n    if (def->os.type != VIR_DOMAIN_OSTYPE_HVM)\n        return 0;\n\n    if (def->ngraphics == 0)\n        return 0;\n\n    /*\n     * Prefer SPICE, otherwise use first libxl_device_vfb device in\n     * libxl_domain_config->vfbs. Prior to calling this function,\n     */\n    for (i = 0; i < def->ngraphics; i++) {\n        virDomainGraphicsDefPtr l_vfb = def->graphics[i];\n        unsigned short port;\n        virDomainGraphicsListenDefPtr glisten = NULL;\n\n        if (l_vfb->type != VIR_DOMAIN_GRAPHICS_TYPE_SPICE)\n            continue;\n\n        libxl_defbool_set(&b_info->u.hvm.spice.enable, true);\n\n        if (l_vfb->data.spice.autoport) {\n            if (virPortAllocatorAcquire(graphicsports, &port) < 0)\n                return -1;\n            l_vfb->data.spice.port = port;\n        }\n        b_info->u.hvm.spice.port = l_vfb->data.spice.port;\n\n        if ((glisten = virDomainGraphicsGetListen(l_vfb, 0))) {\n            if (glisten->address) {\n                b_info->u.hvm.spice.host = g_strdup(glisten->address);\n            } else {\n                b_info->u.hvm.spice.host = g_strdup(VIR_LOOPBACK_IPV4_ADDR);\n                glisten->address = g_strdup(VIR_LOOPBACK_IPV4_ADDR);\n            }\n        }\n\n        b_info->u.hvm.keymap = g_strdup(l_vfb->data.spice.keymap);\n\n        if (l_vfb->data.spice.auth.passwd) {\n            b_info->u.hvm.spice.passwd = g_strdup(l_vfb->data.spice.auth.passwd);\n            libxl_defbool_set(&b_info->u.hvm.spice.disable_ticketing, false);\n        } else {\n            libxl_defbool_set(&b_info->u.hvm.spice.disable_ticketing, true);\n        }\n\n        switch (l_vfb->data.spice.mousemode) {\n            /* client mouse mode is default in xl.cfg */\n        case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_DEFAULT:\n        case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_CLIENT:\n            libxl_defbool_set(&b_info->u.hvm.spice.agent_mouse, true);\n            break;\n        case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_SERVER:\n            libxl_defbool_set(&b_info->u.hvm.spice.agent_mouse, false);\n            break;\n        case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_LAST:\n            break;\n        }\n\n#ifdef LIBXL_HAVE_SPICE_VDAGENT\n        if (l_vfb->data.spice.copypaste == VIR_TRISTATE_BOOL_YES) {\n            libxl_defbool_set(&b_info->u.hvm.spice.vdagent, true);\n            libxl_defbool_set(&b_info->u.hvm.spice.clipboard_sharing, true);\n        } else {\n            libxl_defbool_set(&b_info->u.hvm.spice.vdagent, false);\n            libxl_defbool_set(&b_info->u.hvm.spice.clipboard_sharing, false);\n        }\n#endif\n\n        return 0;\n    }\n\n    x_vfb = d_config->vfbs[0];\n\n    if (libxl_defbool_val(x_vfb.vnc.enable)) {\n        libxl_defbool_set(&b_info->u.hvm.vnc.enable, true);\n        b_info->u.hvm.vnc.listen = g_strdup(x_vfb.vnc.listen);\n        b_info->u.hvm.vnc.passwd = g_strdup(x_vfb.vnc.passwd);\n        b_info->u.hvm.vnc.display = x_vfb.vnc.display;\n        libxl_defbool_set(&b_info->u.hvm.vnc.findunused,\n                          libxl_defbool_val(x_vfb.vnc.findunused));\n    } else if (libxl_defbool_val(x_vfb.sdl.enable)) {\n        libxl_defbool_set(&b_info->u.hvm.sdl.enable, true);\n        libxl_defbool_set(&b_info->u.hvm.sdl.opengl,\n                          libxl_defbool_val(x_vfb.sdl.opengl));\n        b_info->u.hvm.sdl.display = g_strdup(x_vfb.sdl.display);\n        b_info->u.hvm.sdl.xauthority = g_strdup(x_vfb.sdl.xauthority);\n    }\n\n    b_info->u.hvm.keymap = g_strdup(x_vfb.keymap);\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeBuildInfoVfb(virPortAllocatorRangePtr graphicsports,\n                      virDomainDefPtr def,\n                      libxl_domain_config *d_config)\n{\n    libxl_domain_build_info *b_info = &d_config->b_info;\n    libxl_device_vfb x_vfb;\n    size_t i;\n\n    if (def->os.type != VIR_DOMAIN_OSTYPE_HVM)\n        return 0;\n\n    if (def->ngraphics == 0)\n        return 0;\n\n    /*\n     * Prefer SPICE, otherwise use first libxl_device_vfb device in\n     * libxl_domain_config->vfbs. Prior to calling this function,\n     */\n    for (i = 0; i < def->ngraphics; i++) {\n        virDomainGraphicsDefPtr l_vfb = def->graphics[i];\n        unsigned short port;\n        virDomainGraphicsListenDefPtr glisten = NULL;\n\n        if (l_vfb->type != VIR_DOMAIN_GRAPHICS_TYPE_SPICE)\n            continue;\n\n        libxl_defbool_set(&b_info->u.hvm.spice.enable, true);\n\n        if (l_vfb->data.spice.autoport) {\n            if (virPortAllocatorAcquire(graphicsports, &port) < 0)\n                return -1;\n            l_vfb->data.spice.port = port;\n        }\n        b_info->u.hvm.spice.port = l_vfb->data.spice.port;\n\n        if ((glisten = virDomainGraphicsGetListen(l_vfb, 0))) {\n            if (glisten->address) {\n                b_info->u.hvm.spice.host = g_strdup(glisten->address);\n            } else {\n                b_info->u.hvm.spice.host = g_strdup(VIR_LOOPBACK_IPV4_ADDR);\n                glisten->address = g_strdup(VIR_LOOPBACK_IPV4_ADDR);\n            }\n        }\n\n        b_info->u.hvm.keymap = g_strdup(l_vfb->data.spice.keymap);\n\n        if (l_vfb->data.spice.auth.passwd) {\n            b_info->u.hvm.spice.passwd = g_strdup(l_vfb->data.spice.auth.passwd);\n            libxl_defbool_set(&b_info->u.hvm.spice.disable_ticketing, false);\n        } else {\n            libxl_defbool_set(&b_info->u.hvm.spice.disable_ticketing, true);\n        }\n\n        switch (l_vfb->data.spice.mousemode) {\n            /* client mouse mode is default in xl.cfg */\n        case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_DEFAULT:\n        case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_CLIENT:\n            libxl_defbool_set(&b_info->u.hvm.spice.agent_mouse, true);\n            break;\n        case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_SERVER:\n            libxl_defbool_set(&b_info->u.hvm.spice.agent_mouse, false);\n            break;\n        case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_LAST:\n            break;\n        }\n\n#ifdef LIBXL_HAVE_SPICE_VDAGENT\n        if (l_vfb->data.spice.copypaste == VIR_TRISTATE_BOOL_YES) {\n            libxl_defbool_set(&b_info->u.hvm.spice.vdagent, true);\n            libxl_defbool_set(&b_info->u.hvm.spice.clipboard_sharing, true);\n        } else {\n            libxl_defbool_set(&b_info->u.hvm.spice.vdagent, false);\n            libxl_defbool_set(&b_info->u.hvm.spice.clipboard_sharing, false);\n        }\n#endif\n\n        return 0;\n    }\n\n    x_vfb = d_config->vfbs[0];\n\n    if (libxl_defbool_val(x_vfb.vnc.enable)) {\n        libxl_defbool_set(&b_info->u.hvm.vnc.enable, true);\n        b_info->u.hvm.vnc.listen = g_strdup(x_vfb.vnc.listen);\n        b_info->u.hvm.vnc.passwd = g_strdup(x_vfb.vnc.passwd);\n        b_info->u.hvm.vnc.display = x_vfb.vnc.display;\n        libxl_defbool_set(&b_info->u.hvm.vnc.findunused,\n                          libxl_defbool_val(x_vfb.vnc.findunused));\n    } else if (libxl_defbool_val(x_vfb.sdl.enable)) {\n        libxl_defbool_set(&b_info->u.hvm.sdl.enable, true);\n        libxl_defbool_set(&b_info->u.hvm.sdl.opengl,\n                          libxl_defbool_val(x_vfb.sdl.opengl));\n        b_info->u.hvm.sdl.display = g_strdup(x_vfb.sdl.display);\n        b_info->u.hvm.sdl.xauthority = g_strdup(x_vfb.sdl.xauthority);\n    }\n\n    b_info->u.hvm.keymap = g_strdup(x_vfb.keymap);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMakeVfbList",
          "args": [
            "graphicsports",
            "def",
            "d_config"
          ],
          "line": 2438
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeVfbList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1502-1544",
          "snippet": "static int\nlibxlMakeVfbList(virPortAllocatorRangePtr graphicsports,\n                 virDomainDefPtr def,\n                 libxl_domain_config *d_config)\n{\n    virDomainGraphicsDefPtr *l_vfbs = def->graphics;\n    int nvfbs = def->ngraphics;\n    libxl_device_vfb *x_vfbs;\n    libxl_device_vkb *x_vkbs;\n    size_t i;\n\n    if (nvfbs == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(x_vfbs, nvfbs) < 0)\n        return -1;\n    if (VIR_ALLOC_N(x_vkbs, nvfbs) < 0) {\n        VIR_FREE(x_vfbs);\n        return -1;\n    }\n\n    for (i = 0; i < nvfbs; i++) {\n        libxl_device_vkb_init(&x_vkbs[i]);\n\n        if (libxlMakeVfb(graphicsports, l_vfbs[i], &x_vfbs[i]) < 0)\n            goto error;\n    }\n\n    d_config->vfbs = x_vfbs;\n    d_config->vkbs = x_vkbs;\n    d_config->num_vfbs = d_config->num_vkbs = nvfbs;\n\n    return 0;\n\n error:\n    for (i = 0; i < nvfbs; i++) {\n        libxl_device_vfb_dispose(&x_vfbs[i]);\n        libxl_device_vkb_dispose(&x_vkbs[i]);\n    }\n    VIR_FREE(x_vfbs);\n    VIR_FREE(x_vkbs);\n    return -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeVfbList(virPortAllocatorRangePtr graphicsports,\n                 virDomainDefPtr def,\n                 libxl_domain_config *d_config)\n{\n    virDomainGraphicsDefPtr *l_vfbs = def->graphics;\n    int nvfbs = def->ngraphics;\n    libxl_device_vfb *x_vfbs;\n    libxl_device_vkb *x_vkbs;\n    size_t i;\n\n    if (nvfbs == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(x_vfbs, nvfbs) < 0)\n        return -1;\n    if (VIR_ALLOC_N(x_vkbs, nvfbs) < 0) {\n        VIR_FREE(x_vfbs);\n        return -1;\n    }\n\n    for (i = 0; i < nvfbs; i++) {\n        libxl_device_vkb_init(&x_vkbs[i]);\n\n        if (libxlMakeVfb(graphicsports, l_vfbs[i], &x_vfbs[i]) < 0)\n            goto error;\n    }\n\n    d_config->vfbs = x_vfbs;\n    d_config->vkbs = x_vkbs;\n    d_config->num_vfbs = d_config->num_vkbs = nvfbs;\n\n    return 0;\n\n error:\n    for (i = 0; i < nvfbs; i++) {\n        libxl_device_vfb_dispose(&x_vfbs[i]);\n        libxl_device_vkb_dispose(&x_vkbs[i]);\n    }\n    VIR_FREE(x_vfbs);\n    VIR_FREE(x_vkbs);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMakeNicList",
          "args": [
            "def",
            "d_config"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeNicList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1405-1444",
          "snippet": "static int\nlibxlMakeNicList(virDomainDefPtr def,  libxl_domain_config *d_config)\n{\n    virDomainNetDefPtr *l_nics = def->nets;\n    size_t nnics = def->nnets;\n    libxl_device_nic *x_nics;\n    size_t i, nvnics = 0;\n\n    if (VIR_ALLOC_N(x_nics, nnics) < 0)\n        return -1;\n\n    for (i = 0; i < nnics; i++) {\n        if (virDomainNetGetActualType(l_nics[i]) == VIR_DOMAIN_NET_TYPE_HOSTDEV)\n            continue;\n\n        if (libxlMakeNic(def, l_nics[i], &x_nics[nvnics], false))\n            goto error;\n        /*\n         * The devid (at least right now) will not get initialized by\n         * libxl in the setup case but is required for starting the\n         * device-model.\n         */\n        if (x_nics[nvnics].devid < 0)\n            x_nics[nvnics].devid = nvnics;\n\n        nvnics++;\n    }\n\n    VIR_SHRINK_N(x_nics, nnics, nnics - nvnics);\n    d_config->nics = x_nics;\n    d_config->num_nics = nvnics;\n\n    return 0;\n\n error:\n    for (i = 0; i < nnics; i++)\n        libxl_device_nic_dispose(&x_nics[i]);\n    VIR_FREE(x_nics);\n    return -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeNicList(virDomainDefPtr def,  libxl_domain_config *d_config)\n{\n    virDomainNetDefPtr *l_nics = def->nets;\n    size_t nnics = def->nnets;\n    libxl_device_nic *x_nics;\n    size_t i, nvnics = 0;\n\n    if (VIR_ALLOC_N(x_nics, nnics) < 0)\n        return -1;\n\n    for (i = 0; i < nnics; i++) {\n        if (virDomainNetGetActualType(l_nics[i]) == VIR_DOMAIN_NET_TYPE_HOSTDEV)\n            continue;\n\n        if (libxlMakeNic(def, l_nics[i], &x_nics[nvnics], false))\n            goto error;\n        /*\n         * The devid (at least right now) will not get initialized by\n         * libxl in the setup case but is required for starting the\n         * device-model.\n         */\n        if (x_nics[nvnics].devid < 0)\n            x_nics[nvnics].devid = nvnics;\n\n        nvnics++;\n    }\n\n    VIR_SHRINK_N(x_nics, nnics, nnics - nvnics);\n    d_config->nics = x_nics;\n    d_config->num_nics = nvnics;\n\n    return 0;\n\n error:\n    for (i = 0; i < nnics; i++)\n        libxl_device_nic_dispose(&x_nics[i]);\n    VIR_FREE(x_nics);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMakeDiskList",
          "args": [
            "def",
            "d_config"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeDiskList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1133-1159",
          "snippet": "static int\nlibxlMakeDiskList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainDiskDefPtr *l_disks = def->disks;\n    int ndisks = def->ndisks;\n    libxl_device_disk *x_disks;\n    size_t i;\n\n    if (VIR_ALLOC_N(x_disks, ndisks) < 0)\n        return -1;\n\n    for (i = 0; i < ndisks; i++) {\n        if (libxlMakeDisk(l_disks[i], &x_disks[i]) < 0)\n            goto error;\n    }\n\n    d_config->disks = x_disks;\n    d_config->num_disks = ndisks;\n\n    return 0;\n\n error:\n    for (i = 0; i < ndisks; i++)\n        libxl_device_disk_dispose(&x_disks[i]);\n    VIR_FREE(x_disks);\n    return -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeDiskList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainDiskDefPtr *l_disks = def->disks;\n    int ndisks = def->ndisks;\n    libxl_device_disk *x_disks;\n    size_t i;\n\n    if (VIR_ALLOC_N(x_disks, ndisks) < 0)\n        return -1;\n\n    for (i = 0; i < ndisks; i++) {\n        if (libxlMakeDisk(l_disks[i], &x_disks[i]) < 0)\n            goto error;\n    }\n\n    d_config->disks = x_disks;\n    d_config->num_disks = ndisks;\n\n    return 0;\n\n error:\n    for (i = 0; i < ndisks; i++)\n        libxl_device_disk_dispose(&x_disks[i]);\n    VIR_FREE(x_disks);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMakeVnumaList",
          "args": [
            "def",
            "ctx",
            "d_config"
          ],
          "line": 2428
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeVnumaList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "728-838",
          "snippet": "static int\nlibxlMakeVnumaList(virDomainDefPtr def,\n                   libxl_ctx *ctx,\n                   libxl_domain_config *d_config)\n{\n    int ret = -1;\n    size_t i, j;\n    size_t nr_nodes;\n    size_t num_vnuma;\n    bool simulate = false;\n    virBitmapPtr bitmap = NULL;\n    virDomainNumaPtr numa = def->numa;\n    libxl_domain_build_info *b_info = &d_config->b_info;\n    libxl_physinfo physinfo;\n    libxl_vnode_info *vnuma_nodes = NULL;\n\n    if (!numa)\n        return 0;\n\n    num_vnuma = virDomainNumaGetNodeCount(numa);\n    if (!num_vnuma)\n        return 0;\n\n    libxl_physinfo_init(&physinfo);\n    if (libxl_get_physinfo(ctx, &physinfo) < 0) {\n        libxl_physinfo_dispose(&physinfo);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libxl_get_physinfo_info failed\"));\n        return -1;\n    }\n    nr_nodes = physinfo.nr_nodes;\n    libxl_physinfo_dispose(&physinfo);\n\n    if (num_vnuma > nr_nodes) {\n        VIR_WARN(\"Number of configured numa cells %zu exceeds available physical nodes %zu. All cells will use physical node 0\",\n                 num_vnuma, nr_nodes);\n        simulate = true;\n    }\n\n    /*\n     * allocate the vnuma_nodes for assignment under b_info.\n     */\n    if (VIR_ALLOC_N(vnuma_nodes, num_vnuma) < 0)\n        return -1;\n\n    /*\n     * parse the vnuma vnodes data.\n     */\n    for (i = 0; i < num_vnuma; i++) {\n        int cpu;\n        libxl_bitmap vcpu_bitmap;\n        libxl_vnode_info *p = &vnuma_nodes[i];\n\n        libxl_vnode_info_init(p);\n\n        /* pnode */\n        p->pnode = simulate ? 0 : i;\n\n        /* memory size */\n        p->memkb = virDomainNumaGetNodeMemorySize(numa, i);\n\n        /* vcpus */\n        bitmap = virDomainNumaGetNodeCpumask(numa, i);\n        if (bitmap == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"vnuma sibling %zu missing vcpus set\"), i);\n            goto cleanup;\n        }\n\n        if ((cpu = virBitmapNextSetBit(bitmap, -1)) < 0)\n            goto cleanup;\n\n        libxl_bitmap_init(&vcpu_bitmap);\n        if (libxl_cpu_bitmap_alloc(ctx, &vcpu_bitmap, b_info->max_vcpus)) {\n            virReportOOMError();\n            goto cleanup;\n        }\n\n        do {\n            libxl_bitmap_set(&vcpu_bitmap, cpu);\n        } while ((cpu = virBitmapNextSetBit(bitmap, cpu)) >= 0);\n\n        libxl_bitmap_copy_alloc(ctx, &p->vcpus, &vcpu_bitmap);\n        libxl_bitmap_dispose(&vcpu_bitmap);\n\n        /* vdistances */\n        if (VIR_ALLOC_N(p->distances, num_vnuma) < 0)\n            goto cleanup;\n        p->num_distances = num_vnuma;\n\n        for (j = 0; j < num_vnuma; j++)\n            p->distances[j] = virDomainNumaGetNodeDistance(numa, i, j);\n    }\n\n    b_info->vnuma_nodes = vnuma_nodes;\n    b_info->num_vnuma_nodes = num_vnuma;\n\n    ret = 0;\n\n cleanup:\n    if (ret) {\n        for (i = 0; i < num_vnuma; i++) {\n            libxl_vnode_info *p = &vnuma_nodes[i];\n\n            VIR_FREE(p->distances);\n        }\n        VIR_FREE(vnuma_nodes);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeVnumaList(virDomainDefPtr def,\n                   libxl_ctx *ctx,\n                   libxl_domain_config *d_config)\n{\n    int ret = -1;\n    size_t i, j;\n    size_t nr_nodes;\n    size_t num_vnuma;\n    bool simulate = false;\n    virBitmapPtr bitmap = NULL;\n    virDomainNumaPtr numa = def->numa;\n    libxl_domain_build_info *b_info = &d_config->b_info;\n    libxl_physinfo physinfo;\n    libxl_vnode_info *vnuma_nodes = NULL;\n\n    if (!numa)\n        return 0;\n\n    num_vnuma = virDomainNumaGetNodeCount(numa);\n    if (!num_vnuma)\n        return 0;\n\n    libxl_physinfo_init(&physinfo);\n    if (libxl_get_physinfo(ctx, &physinfo) < 0) {\n        libxl_physinfo_dispose(&physinfo);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libxl_get_physinfo_info failed\"));\n        return -1;\n    }\n    nr_nodes = physinfo.nr_nodes;\n    libxl_physinfo_dispose(&physinfo);\n\n    if (num_vnuma > nr_nodes) {\n        VIR_WARN(\"Number of configured numa cells %zu exceeds available physical nodes %zu. All cells will use physical node 0\",\n                 num_vnuma, nr_nodes);\n        simulate = true;\n    }\n\n    /*\n     * allocate the vnuma_nodes for assignment under b_info.\n     */\n    if (VIR_ALLOC_N(vnuma_nodes, num_vnuma) < 0)\n        return -1;\n\n    /*\n     * parse the vnuma vnodes data.\n     */\n    for (i = 0; i < num_vnuma; i++) {\n        int cpu;\n        libxl_bitmap vcpu_bitmap;\n        libxl_vnode_info *p = &vnuma_nodes[i];\n\n        libxl_vnode_info_init(p);\n\n        /* pnode */\n        p->pnode = simulate ? 0 : i;\n\n        /* memory size */\n        p->memkb = virDomainNumaGetNodeMemorySize(numa, i);\n\n        /* vcpus */\n        bitmap = virDomainNumaGetNodeCpumask(numa, i);\n        if (bitmap == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"vnuma sibling %zu missing vcpus set\"), i);\n            goto cleanup;\n        }\n\n        if ((cpu = virBitmapNextSetBit(bitmap, -1)) < 0)\n            goto cleanup;\n\n        libxl_bitmap_init(&vcpu_bitmap);\n        if (libxl_cpu_bitmap_alloc(ctx, &vcpu_bitmap, b_info->max_vcpus)) {\n            virReportOOMError();\n            goto cleanup;\n        }\n\n        do {\n            libxl_bitmap_set(&vcpu_bitmap, cpu);\n        } while ((cpu = virBitmapNextSetBit(bitmap, cpu)) >= 0);\n\n        libxl_bitmap_copy_alloc(ctx, &p->vcpus, &vcpu_bitmap);\n        libxl_bitmap_dispose(&vcpu_bitmap);\n\n        /* vdistances */\n        if (VIR_ALLOC_N(p->distances, num_vnuma) < 0)\n            goto cleanup;\n        p->num_distances = num_vnuma;\n\n        for (j = 0; j < num_vnuma; j++)\n            p->distances[j] = virDomainNumaGetNodeDistance(numa, i, j);\n    }\n\n    b_info->vnuma_nodes = vnuma_nodes;\n    b_info->num_vnuma_nodes = num_vnuma;\n\n    ret = 0;\n\n cleanup:\n    if (ret) {\n        for (i = 0; i < num_vnuma; i++) {\n            libxl_vnode_info *p = &vnuma_nodes[i];\n\n            VIR_FREE(p->distances);\n        }\n        VIR_FREE(vnuma_nodes);\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMakeDomBuildInfo",
          "args": [
            "def",
            "cfg",
            "caps",
            "d_config"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeDomBuildInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "263-725",
          "snippet": "static int\nlibxlMakeDomBuildInfo(virDomainDefPtr def,\n                      libxlDriverConfigPtr cfg,\n                      virCapsPtr caps,\n                      libxl_domain_config *d_config)\n{\n    virDomainClockDef clock = def->clock;\n    libxl_ctx *ctx = cfg->ctx;\n    libxl_domain_build_info *b_info = &d_config->b_info;\n    bool hvm = def->os.type == VIR_DOMAIN_OSTYPE_HVM;\n    bool pvh = def->os.type == VIR_DOMAIN_OSTYPE_XENPVH;\n    size_t i;\n    size_t nusbdevice = 0;\n\n    libxl_domain_build_info_init(b_info);\n\n    if (hvm) {\n        libxl_domain_build_info_init_type(b_info, LIBXL_DOMAIN_TYPE_HVM);\n    } else if (pvh) {\n#ifdef HAVE_XEN_PVH\n        libxl_domain_build_info_init_type(b_info, LIBXL_DOMAIN_TYPE_PVH);\n#else\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                _(\"PVH guest os type not supported\"));\n        return -1;\n#endif\n    } else {\n        libxl_domain_build_info_init_type(b_info, LIBXL_DOMAIN_TYPE_PV);\n    }\n\n    b_info->max_vcpus = virDomainDefGetVcpusMax(def);\n    if (libxl_cpu_bitmap_alloc(ctx, &b_info->avail_vcpus, b_info->max_vcpus))\n        return -1;\n    libxl_bitmap_set_none(&b_info->avail_vcpus);\n    for (i = 0; i < virDomainDefGetVcpus(def); i++)\n        libxl_bitmap_set((&b_info->avail_vcpus), i);\n\n    switch ((virDomainClockOffsetType) clock.offset) {\n    case VIR_DOMAIN_CLOCK_OFFSET_VARIABLE:\n        if (clock.data.variable.basis == VIR_DOMAIN_CLOCK_BASIS_LOCALTIME)\n            libxl_defbool_set(&b_info->localtime, true);\n        b_info->rtc_timeoffset = clock.data.variable.adjustment;\n        break;\n\n    case VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME:\n        libxl_defbool_set(&b_info->localtime, true);\n        break;\n\n    /* Nothing to do since UTC is the default in libxl */\n    case VIR_DOMAIN_CLOCK_OFFSET_UTC:\n        break;\n\n    case VIR_DOMAIN_CLOCK_OFFSET_TIMEZONE:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unsupported clock offset '%s'\"),\n                       virDomainClockOffsetTypeToString(clock.offset));\n        return -1;\n\n    case VIR_DOMAIN_CLOCK_OFFSET_LAST:\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unexpected clock offset '%d'\"), clock.offset);\n        return -1;\n    }\n\n    for (i = 0; i < clock.ntimers; i++) {\n        switch ((virDomainTimerNameType) clock.timers[i]->name) {\n        case VIR_DOMAIN_TIMER_NAME_TSC:\n            switch (clock.timers[i]->mode) {\n            case VIR_DOMAIN_TIMER_MODE_NATIVE:\n                b_info->tsc_mode = LIBXL_TSC_MODE_NATIVE;\n                break;\n            case VIR_DOMAIN_TIMER_MODE_PARAVIRT:\n                b_info->tsc_mode = LIBXL_TSC_MODE_NATIVE_PARAVIRT;\n                break;\n            case VIR_DOMAIN_TIMER_MODE_EMULATE:\n                b_info->tsc_mode = LIBXL_TSC_MODE_ALWAYS_EMULATE;\n                break;\n            default:\n                b_info->tsc_mode = LIBXL_TSC_MODE_DEFAULT;\n            }\n            break;\n\n        case VIR_DOMAIN_TIMER_NAME_HPET:\n            if (!hvm) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unsupported timer type (name) '%s'\"),\n                               virDomainTimerNameTypeToString(clock.timers[i]->name));\n                return -1;\n            }\n            if (clock.timers[i]->present == 1)\n                libxl_defbool_set(&b_info->u.hvm.hpet, 1);\n            break;\n\n        case VIR_DOMAIN_TIMER_NAME_PLATFORM:\n        case VIR_DOMAIN_TIMER_NAME_KVMCLOCK:\n        case VIR_DOMAIN_TIMER_NAME_HYPERVCLOCK:\n        case VIR_DOMAIN_TIMER_NAME_RTC:\n        case VIR_DOMAIN_TIMER_NAME_PIT:\n        case VIR_DOMAIN_TIMER_NAME_ARMVTIMER:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported timer type (name) '%s'\"),\n                           virDomainTimerNameTypeToString(clock.timers[i]->name));\n            return -1;\n\n        case VIR_DOMAIN_TIMER_NAME_LAST:\n            break;\n        }\n    }\n\n    if (def->cputune.sharesSpecified)\n        b_info->sched_params.weight = def->cputune.shares;\n\n    /* Xen requires the memory sizes to be rounded to 1MiB increments */\n    virDomainDefSetMemoryTotal(def,\n                               VIR_ROUND_UP(virDomainDefGetMemoryInitial(def), 1024));\n    def->mem.cur_balloon = VIR_ROUND_UP(def->mem.cur_balloon, 1024);\n    b_info->max_memkb = virDomainDefGetMemoryInitial(def);\n    b_info->target_memkb = def->mem.cur_balloon;\n\n#ifdef LIBXL_HAVE_BUILDINFO_GRANT_LIMITS\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_XENBUS &&\n            def->controllers[i]->opts.xenbusopts.maxGrantFrames > 0)\n            b_info->max_grant_frames = def->controllers[i]->opts.xenbusopts.maxGrantFrames;\n    }\n#endif\n\n    if (hvm || pvh) {\n        if (caps &&\n            def->cpu && def->cpu->mode == (VIR_CPU_MODE_HOST_PASSTHROUGH)) {\n            bool hasHwVirt = false;\n            bool svm = false, vmx = false;\n            char xlCPU[32];\n\n            /* enable nested HVM only if global nested_hvm option enable it and\n             * host support it */\n            if (ARCH_IS_X86(def->os.arch)) {\n                vmx = virCPUCheckFeature(caps->host.arch, caps->host.cpu, \"vmx\");\n                svm = virCPUCheckFeature(caps->host.arch, caps->host.cpu, \"svm\");\n                hasHwVirt = cfg->nested_hvm && (vmx | svm);\n            }\n\n            if (def->cpu->nfeatures) {\n                for (i = 0; i < def->cpu->nfeatures; i++) {\n\n                    switch (def->cpu->features[i].policy) {\n\n                        case VIR_CPU_FEATURE_DISABLE:\n                        case VIR_CPU_FEATURE_FORBID:\n                            if ((vmx && STREQ(def->cpu->features[i].name, \"vmx\")) ||\n                                (svm && STREQ(def->cpu->features[i].name, \"svm\"))) {\n                                hasHwVirt = false;\n                                continue;\n                            }\n\n                            g_snprintf(xlCPU,\n                                       sizeof(xlCPU),\n                                       \"%s=0\",\n                                       xenTranslateCPUFeature(\n                                           def->cpu->features[i].name,\n                                           false));\n                            if (libxl_cpuid_parse_config(&b_info->cpuid, xlCPU)) {\n                                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                        _(\"unsupported cpu feature '%s'\"),\n                                        def->cpu->features[i].name);\n                                return -1;\n                            }\n                            break;\n\n                        case VIR_CPU_FEATURE_FORCE:\n                        case VIR_CPU_FEATURE_REQUIRE:\n                            if ((vmx && STREQ(def->cpu->features[i].name, \"vmx\")) ||\n                                (svm && STREQ(def->cpu->features[i].name, \"svm\"))) {\n                                hasHwVirt = true;\n                                continue;\n                            }\n\n                            g_snprintf(xlCPU,\n                                       sizeof(xlCPU),\n                                       \"%s=1\",\n                                       xenTranslateCPUFeature(\n                                           def->cpu->features[i].name, false));\n                            if (libxl_cpuid_parse_config(&b_info->cpuid, xlCPU)) {\n                                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                        _(\"unsupported cpu feature '%s'\"),\n                                        def->cpu->features[i].name);\n                                return -1;\n                            }\n                            break;\n                        case VIR_CPU_FEATURE_OPTIONAL:\n                        case VIR_CPU_FEATURE_LAST:\n                            break;\n                    }\n                }\n            }\n#ifdef LIBXL_HAVE_BUILDINFO_NESTED_HVM\n            libxl_defbool_set(&b_info->nested_hvm, hasHwVirt);\n#else\n            if (hvm) {\n                libxl_defbool_set(&b_info->u.hvm.nested_hvm, hasHwVirt);\n            } else {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                        _(\"unsupported nested HVM setting for %s machine on this Xen version\"),\n                        def->os.machine);\n                return -1;\n            }\n#endif\n        }\n\n        if (def->cpu && def->cpu->mode == VIR_CPU_MODE_CUSTOM) {\n            VIR_WARN(\"Ignoring CPU with mode=custom, update your config to \"\n                     \"mode=host-passthrough to avoid risk of changed guest \"\n                     \"semantics when mode=custom is supported in the future\");\n        }\n    }\n\n    if (hvm) {\n        char bootorder[VIR_DOMAIN_BOOT_LAST + 1];\n\n        libxl_defbool_set(&b_info->u.hvm.pae,\n                          def->features[VIR_DOMAIN_FEATURE_PAE] ==\n                          VIR_TRISTATE_SWITCH_ON);\n        libxl_defbool_set(&b_info->u.hvm.apic,\n                          def->features[VIR_DOMAIN_FEATURE_APIC] ==\n                          VIR_TRISTATE_SWITCH_ON);\n        libxl_defbool_set(&b_info->u.hvm.acpi,\n                          def->features[VIR_DOMAIN_FEATURE_ACPI] ==\n                          VIR_TRISTATE_SWITCH_ON);\n\n        /* copy SLIC table path to acpi_firmware */\n        if (def->os.slic_table)\n            b_info->u.hvm.acpi_firmware = g_strdup(def->os.slic_table);\n\n        if (def->nsounds > 0) {\n            /*\n             * Use first sound device.  man xl.cfg(5) describes soundhw as\n             * a single device.  From the man page: soundhw=DEVICE\n             */\n            virDomainSoundDefPtr snd = def->sounds[0];\n\n            b_info->u.hvm.soundhw = g_strdup(virDomainSoundModelTypeToString(snd->model));\n        }\n\n        for (i = 0; i < def->os.nBootDevs; i++) {\n            switch (def->os.bootDevs[i]) {\n                case VIR_DOMAIN_BOOT_FLOPPY:\n                    bootorder[i] = 'a';\n                    break;\n                default:\n                case VIR_DOMAIN_BOOT_DISK:\n                    bootorder[i] = 'c';\n                    break;\n                case VIR_DOMAIN_BOOT_CDROM:\n                    bootorder[i] = 'd';\n                    break;\n                case VIR_DOMAIN_BOOT_NET:\n                    bootorder[i] = 'n';\n                    break;\n            }\n        }\n        if (def->os.nBootDevs == 0) {\n            bootorder[0] = 'c';\n            bootorder[1] = '\\0';\n        } else {\n            bootorder[def->os.nBootDevs] = '\\0';\n        }\n        b_info->u.hvm.boot = g_strdup(bootorder);\n\n#ifdef LIBXL_HAVE_BUILDINFO_KERNEL\n        b_info->cmdline = g_strdup(def->os.cmdline);\n        b_info->kernel = g_strdup(def->os.kernel);\n        b_info->ramdisk = g_strdup(def->os.initrd);\n#endif\n\n        /*\n         * Currently libxl only allows specifying the type of BIOS.\n         * If the type is PFLASH, we assume OVMF and set libxl_bios_type\n         * to LIBXL_BIOS_TYPE_OVMF. The path to the OVMF firmware is\n         * configured when building Xen using '--with-system-ovmf='. If\n         * not specified, LIBXL_FIRMWARE_DIR/ovmf.bin is used. In the\n         * future, Xen will support a user-specified firmware path. See\n         * http://lists.xenproject.org/archives/html/xen-devel/2016-03/msg01628.html\n         */\n        if (virDomainDefHasOldStyleUEFI(def))\n            b_info->u.hvm.bios = LIBXL_BIOS_TYPE_OVMF;\n\n        if (def->emulator) {\n            if (!virFileExists(def->emulator)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"emulator '%s' not found\"),\n                               def->emulator);\n                return -1;\n            }\n\n            if (!virFileIsExecutable(def->emulator)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"emulator '%s' is not executable\"),\n                               def->emulator);\n                return -1;\n            }\n\n            VIR_FREE(b_info->device_model);\n            b_info->device_model = g_strdup(def->emulator);\n\n            b_info->device_model_version = libxlDomainGetEmulatorType(def);\n        }\n\n        if (def->nserials) {\n            if (def->nserials == 1) {\n                if (libxlMakeChrdevStr(def->serials[0], &b_info->u.hvm.serial) <\n                    0)\n                    return -1;\n            } else {\n#ifdef LIBXL_HAVE_BUILDINFO_SERIAL_LIST\n                if (VIR_ALLOC_N(b_info->u.hvm.serial_list, def->nserials + 1) <\n                    0)\n                    return -1;\n                for (i = 0; i < def->nserials; i++) {\n                    if (libxlMakeChrdevStr(def->serials[i],\n                                           &b_info->u.hvm.serial_list[i]) < 0)\n                    {\n                        libxl_string_list_dispose(&b_info->u.hvm.serial_list);\n                        return -1;\n                    }\n                }\n                b_info->u.hvm.serial_list[i] = NULL;\n#else\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               \"%s\",\n                               _(\"Only one serial device is supported by libxl\"));\n                return -1;\n#endif\n            }\n        }\n\n        if (def->nparallels) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           \"%s\",\n                           _(\"Parallel devices are not supported by libxl\"));\n            return -1;\n        }\n\n        /* Disable VNC and SDL until explicitly enabled */\n        libxl_defbool_set(&b_info->u.hvm.vnc.enable, 0);\n        libxl_defbool_set(&b_info->u.hvm.sdl.enable, 0);\n\n        for (i = 0; i < def->ninputs; i++) {\n            char **usbdevice;\n\n            if (def->inputs[i]->bus != VIR_DOMAIN_INPUT_BUS_USB)\n                continue;\n\n#ifdef LIBXL_HAVE_BUILDINFO_USBDEVICE_LIST\n            if (VIR_EXPAND_N(b_info->u.hvm.usbdevice_list, nusbdevice, 1) < 0)\n                return -1;\n#else\n            nusbdevice++;\n            if (nusbdevice > 1) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                        _(\"libxenlight supports only one input device\"));\n                return -1;\n            }\n#endif\n\n#ifdef LIBXL_HAVE_BUILDINFO_USBDEVICE_LIST\n            usbdevice = &b_info->u.hvm.usbdevice_list[nusbdevice - 1];\n#else\n            usbdevice = &b_info->u.hvm.usbdevice;\n#endif\n            switch (def->inputs[i]->type) {\n                case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n                    VIR_FREE(*usbdevice);\n                    *usbdevice = g_strdup(\"mouse\");\n                    break;\n                case VIR_DOMAIN_INPUT_TYPE_TABLET:\n                    VIR_FREE(*usbdevice);\n                    *usbdevice = g_strdup(\"tablet\");\n                    break;\n                default:\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                            _(\"Unknown input device type\"));\n                    return -1;\n            }\n        }\n\n#ifdef LIBXL_HAVE_BUILDINFO_USBDEVICE_LIST\n        /* NULL-terminate usbdevice_list */\n        if (nusbdevice > 0 &&\n            VIR_EXPAND_N(b_info->u.hvm.usbdevice_list, nusbdevice, 1) < 0) {\n            VIR_DISPOSE_N(b_info->u.hvm.usbdevice_list, nusbdevice);\n            return -1;\n        }\n#endif\n    } else if (pvh) {\n        b_info->cmdline = g_strdup(def->os.cmdline);\n        b_info->kernel = g_strdup(def->os.kernel);\n        b_info->ramdisk = g_strdup(def->os.initrd);\n#ifdef LIBXL_HAVE_BUILDINFO_BOOTLOADER\n        b_info->bootloader = g_strdup(def->os.bootloader);\n        if (def->os.bootloaderArgs) {\n            if (!(b_info->bootloader_args =\n                  virStringSplit(def->os.bootloaderArgs, \" \\t\\n\", 0)))\n                return -1;\n        }\n#endif\n    } else {\n        /*\n         * For compatibility with the legacy xen toolstack, default to pygrub\n         * if bootloader is not specified AND direct kernel boot is not specified.\n         */\n        if (def->os.bootloader) {\n            b_info->u.pv.bootloader = g_strdup(def->os.bootloader);\n        } else if (def->os.kernel == NULL) {\n            b_info->u.pv.bootloader = g_strdup(LIBXL_BOOTLOADER_PATH);\n        }\n        if (def->os.bootloaderArgs) {\n            if (!(b_info->u.pv.bootloader_args =\n                  virStringSplit(def->os.bootloaderArgs, \" \\t\\n\", 0)))\n                return -1;\n        }\n        b_info->u.pv.cmdline = g_strdup(def->os.cmdline);\n        if (def->os.kernel) {\n            /* libxl_init_build_info() sets kernel.path = g_strdup(\"hvmloader\") */\n            VIR_FREE(b_info->u.pv.kernel);\n            b_info->u.pv.kernel = g_strdup(def->os.kernel);\n        }\n        b_info->u.pv.ramdisk = g_strdup(def->os.initrd);\n    }\n\n    /* only the 'xen' balloon device model is supported */\n    if (def->memballoon) {\n        int model = def->memballoon->model;\n\n        switch ((virDomainMemballoonModel)model) {\n        case VIR_DOMAIN_MEMBALLOON_MODEL_XEN:\n            break;\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_TRANSITIONAL:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_NON_TRANSITIONAL:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported balloon device model '%s'\"),\n                           virDomainMemballoonModelTypeToString(model));\n            return -1;\n        case VIR_DOMAIN_MEMBALLOON_MODEL_NONE:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           \"%s\",\n                           _(\"balloon device cannot be disabled\"));\n            return -1;\n        case VIR_DOMAIN_MEMBALLOON_MODEL_LAST:\n        default:\n            virReportEnumRangeError(virDomainMemballoonModel, model);\n            return -1;\n        }\n    }\n\n    /* Allow libxl to calculate shadow memory requirements */\n    b_info->shadow_memkb =\n        libxl_get_required_shadow_memory(b_info->max_memkb,\n                                         b_info->max_vcpus);\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeDomBuildInfo(virDomainDefPtr def,\n                      libxlDriverConfigPtr cfg,\n                      virCapsPtr caps,\n                      libxl_domain_config *d_config)\n{\n    virDomainClockDef clock = def->clock;\n    libxl_ctx *ctx = cfg->ctx;\n    libxl_domain_build_info *b_info = &d_config->b_info;\n    bool hvm = def->os.type == VIR_DOMAIN_OSTYPE_HVM;\n    bool pvh = def->os.type == VIR_DOMAIN_OSTYPE_XENPVH;\n    size_t i;\n    size_t nusbdevice = 0;\n\n    libxl_domain_build_info_init(b_info);\n\n    if (hvm) {\n        libxl_domain_build_info_init_type(b_info, LIBXL_DOMAIN_TYPE_HVM);\n    } else if (pvh) {\n#ifdef HAVE_XEN_PVH\n        libxl_domain_build_info_init_type(b_info, LIBXL_DOMAIN_TYPE_PVH);\n#else\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                _(\"PVH guest os type not supported\"));\n        return -1;\n#endif\n    } else {\n        libxl_domain_build_info_init_type(b_info, LIBXL_DOMAIN_TYPE_PV);\n    }\n\n    b_info->max_vcpus = virDomainDefGetVcpusMax(def);\n    if (libxl_cpu_bitmap_alloc(ctx, &b_info->avail_vcpus, b_info->max_vcpus))\n        return -1;\n    libxl_bitmap_set_none(&b_info->avail_vcpus);\n    for (i = 0; i < virDomainDefGetVcpus(def); i++)\n        libxl_bitmap_set((&b_info->avail_vcpus), i);\n\n    switch ((virDomainClockOffsetType) clock.offset) {\n    case VIR_DOMAIN_CLOCK_OFFSET_VARIABLE:\n        if (clock.data.variable.basis == VIR_DOMAIN_CLOCK_BASIS_LOCALTIME)\n            libxl_defbool_set(&b_info->localtime, true);\n        b_info->rtc_timeoffset = clock.data.variable.adjustment;\n        break;\n\n    case VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME:\n        libxl_defbool_set(&b_info->localtime, true);\n        break;\n\n    /* Nothing to do since UTC is the default in libxl */\n    case VIR_DOMAIN_CLOCK_OFFSET_UTC:\n        break;\n\n    case VIR_DOMAIN_CLOCK_OFFSET_TIMEZONE:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unsupported clock offset '%s'\"),\n                       virDomainClockOffsetTypeToString(clock.offset));\n        return -1;\n\n    case VIR_DOMAIN_CLOCK_OFFSET_LAST:\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unexpected clock offset '%d'\"), clock.offset);\n        return -1;\n    }\n\n    for (i = 0; i < clock.ntimers; i++) {\n        switch ((virDomainTimerNameType) clock.timers[i]->name) {\n        case VIR_DOMAIN_TIMER_NAME_TSC:\n            switch (clock.timers[i]->mode) {\n            case VIR_DOMAIN_TIMER_MODE_NATIVE:\n                b_info->tsc_mode = LIBXL_TSC_MODE_NATIVE;\n                break;\n            case VIR_DOMAIN_TIMER_MODE_PARAVIRT:\n                b_info->tsc_mode = LIBXL_TSC_MODE_NATIVE_PARAVIRT;\n                break;\n            case VIR_DOMAIN_TIMER_MODE_EMULATE:\n                b_info->tsc_mode = LIBXL_TSC_MODE_ALWAYS_EMULATE;\n                break;\n            default:\n                b_info->tsc_mode = LIBXL_TSC_MODE_DEFAULT;\n            }\n            break;\n\n        case VIR_DOMAIN_TIMER_NAME_HPET:\n            if (!hvm) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unsupported timer type (name) '%s'\"),\n                               virDomainTimerNameTypeToString(clock.timers[i]->name));\n                return -1;\n            }\n            if (clock.timers[i]->present == 1)\n                libxl_defbool_set(&b_info->u.hvm.hpet, 1);\n            break;\n\n        case VIR_DOMAIN_TIMER_NAME_PLATFORM:\n        case VIR_DOMAIN_TIMER_NAME_KVMCLOCK:\n        case VIR_DOMAIN_TIMER_NAME_HYPERVCLOCK:\n        case VIR_DOMAIN_TIMER_NAME_RTC:\n        case VIR_DOMAIN_TIMER_NAME_PIT:\n        case VIR_DOMAIN_TIMER_NAME_ARMVTIMER:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported timer type (name) '%s'\"),\n                           virDomainTimerNameTypeToString(clock.timers[i]->name));\n            return -1;\n\n        case VIR_DOMAIN_TIMER_NAME_LAST:\n            break;\n        }\n    }\n\n    if (def->cputune.sharesSpecified)\n        b_info->sched_params.weight = def->cputune.shares;\n\n    /* Xen requires the memory sizes to be rounded to 1MiB increments */\n    virDomainDefSetMemoryTotal(def,\n                               VIR_ROUND_UP(virDomainDefGetMemoryInitial(def), 1024));\n    def->mem.cur_balloon = VIR_ROUND_UP(def->mem.cur_balloon, 1024);\n    b_info->max_memkb = virDomainDefGetMemoryInitial(def);\n    b_info->target_memkb = def->mem.cur_balloon;\n\n#ifdef LIBXL_HAVE_BUILDINFO_GRANT_LIMITS\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_XENBUS &&\n            def->controllers[i]->opts.xenbusopts.maxGrantFrames > 0)\n            b_info->max_grant_frames = def->controllers[i]->opts.xenbusopts.maxGrantFrames;\n    }\n#endif\n\n    if (hvm || pvh) {\n        if (caps &&\n            def->cpu && def->cpu->mode == (VIR_CPU_MODE_HOST_PASSTHROUGH)) {\n            bool hasHwVirt = false;\n            bool svm = false, vmx = false;\n            char xlCPU[32];\n\n            /* enable nested HVM only if global nested_hvm option enable it and\n             * host support it */\n            if (ARCH_IS_X86(def->os.arch)) {\n                vmx = virCPUCheckFeature(caps->host.arch, caps->host.cpu, \"vmx\");\n                svm = virCPUCheckFeature(caps->host.arch, caps->host.cpu, \"svm\");\n                hasHwVirt = cfg->nested_hvm && (vmx | svm);\n            }\n\n            if (def->cpu->nfeatures) {\n                for (i = 0; i < def->cpu->nfeatures; i++) {\n\n                    switch (def->cpu->features[i].policy) {\n\n                        case VIR_CPU_FEATURE_DISABLE:\n                        case VIR_CPU_FEATURE_FORBID:\n                            if ((vmx && STREQ(def->cpu->features[i].name, \"vmx\")) ||\n                                (svm && STREQ(def->cpu->features[i].name, \"svm\"))) {\n                                hasHwVirt = false;\n                                continue;\n                            }\n\n                            g_snprintf(xlCPU,\n                                       sizeof(xlCPU),\n                                       \"%s=0\",\n                                       xenTranslateCPUFeature(\n                                           def->cpu->features[i].name,\n                                           false));\n                            if (libxl_cpuid_parse_config(&b_info->cpuid, xlCPU)) {\n                                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                        _(\"unsupported cpu feature '%s'\"),\n                                        def->cpu->features[i].name);\n                                return -1;\n                            }\n                            break;\n\n                        case VIR_CPU_FEATURE_FORCE:\n                        case VIR_CPU_FEATURE_REQUIRE:\n                            if ((vmx && STREQ(def->cpu->features[i].name, \"vmx\")) ||\n                                (svm && STREQ(def->cpu->features[i].name, \"svm\"))) {\n                                hasHwVirt = true;\n                                continue;\n                            }\n\n                            g_snprintf(xlCPU,\n                                       sizeof(xlCPU),\n                                       \"%s=1\",\n                                       xenTranslateCPUFeature(\n                                           def->cpu->features[i].name, false));\n                            if (libxl_cpuid_parse_config(&b_info->cpuid, xlCPU)) {\n                                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                        _(\"unsupported cpu feature '%s'\"),\n                                        def->cpu->features[i].name);\n                                return -1;\n                            }\n                            break;\n                        case VIR_CPU_FEATURE_OPTIONAL:\n                        case VIR_CPU_FEATURE_LAST:\n                            break;\n                    }\n                }\n            }\n#ifdef LIBXL_HAVE_BUILDINFO_NESTED_HVM\n            libxl_defbool_set(&b_info->nested_hvm, hasHwVirt);\n#else\n            if (hvm) {\n                libxl_defbool_set(&b_info->u.hvm.nested_hvm, hasHwVirt);\n            } else {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                        _(\"unsupported nested HVM setting for %s machine on this Xen version\"),\n                        def->os.machine);\n                return -1;\n            }\n#endif\n        }\n\n        if (def->cpu && def->cpu->mode == VIR_CPU_MODE_CUSTOM) {\n            VIR_WARN(\"Ignoring CPU with mode=custom, update your config to \"\n                     \"mode=host-passthrough to avoid risk of changed guest \"\n                     \"semantics when mode=custom is supported in the future\");\n        }\n    }\n\n    if (hvm) {\n        char bootorder[VIR_DOMAIN_BOOT_LAST + 1];\n\n        libxl_defbool_set(&b_info->u.hvm.pae,\n                          def->features[VIR_DOMAIN_FEATURE_PAE] ==\n                          VIR_TRISTATE_SWITCH_ON);\n        libxl_defbool_set(&b_info->u.hvm.apic,\n                          def->features[VIR_DOMAIN_FEATURE_APIC] ==\n                          VIR_TRISTATE_SWITCH_ON);\n        libxl_defbool_set(&b_info->u.hvm.acpi,\n                          def->features[VIR_DOMAIN_FEATURE_ACPI] ==\n                          VIR_TRISTATE_SWITCH_ON);\n\n        /* copy SLIC table path to acpi_firmware */\n        if (def->os.slic_table)\n            b_info->u.hvm.acpi_firmware = g_strdup(def->os.slic_table);\n\n        if (def->nsounds > 0) {\n            /*\n             * Use first sound device.  man xl.cfg(5) describes soundhw as\n             * a single device.  From the man page: soundhw=DEVICE\n             */\n            virDomainSoundDefPtr snd = def->sounds[0];\n\n            b_info->u.hvm.soundhw = g_strdup(virDomainSoundModelTypeToString(snd->model));\n        }\n\n        for (i = 0; i < def->os.nBootDevs; i++) {\n            switch (def->os.bootDevs[i]) {\n                case VIR_DOMAIN_BOOT_FLOPPY:\n                    bootorder[i] = 'a';\n                    break;\n                default:\n                case VIR_DOMAIN_BOOT_DISK:\n                    bootorder[i] = 'c';\n                    break;\n                case VIR_DOMAIN_BOOT_CDROM:\n                    bootorder[i] = 'd';\n                    break;\n                case VIR_DOMAIN_BOOT_NET:\n                    bootorder[i] = 'n';\n                    break;\n            }\n        }\n        if (def->os.nBootDevs == 0) {\n            bootorder[0] = 'c';\n            bootorder[1] = '\\0';\n        } else {\n            bootorder[def->os.nBootDevs] = '\\0';\n        }\n        b_info->u.hvm.boot = g_strdup(bootorder);\n\n#ifdef LIBXL_HAVE_BUILDINFO_KERNEL\n        b_info->cmdline = g_strdup(def->os.cmdline);\n        b_info->kernel = g_strdup(def->os.kernel);\n        b_info->ramdisk = g_strdup(def->os.initrd);\n#endif\n\n        /*\n         * Currently libxl only allows specifying the type of BIOS.\n         * If the type is PFLASH, we assume OVMF and set libxl_bios_type\n         * to LIBXL_BIOS_TYPE_OVMF. The path to the OVMF firmware is\n         * configured when building Xen using '--with-system-ovmf='. If\n         * not specified, LIBXL_FIRMWARE_DIR/ovmf.bin is used. In the\n         * future, Xen will support a user-specified firmware path. See\n         * http://lists.xenproject.org/archives/html/xen-devel/2016-03/msg01628.html\n         */\n        if (virDomainDefHasOldStyleUEFI(def))\n            b_info->u.hvm.bios = LIBXL_BIOS_TYPE_OVMF;\n\n        if (def->emulator) {\n            if (!virFileExists(def->emulator)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"emulator '%s' not found\"),\n                               def->emulator);\n                return -1;\n            }\n\n            if (!virFileIsExecutable(def->emulator)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"emulator '%s' is not executable\"),\n                               def->emulator);\n                return -1;\n            }\n\n            VIR_FREE(b_info->device_model);\n            b_info->device_model = g_strdup(def->emulator);\n\n            b_info->device_model_version = libxlDomainGetEmulatorType(def);\n        }\n\n        if (def->nserials) {\n            if (def->nserials == 1) {\n                if (libxlMakeChrdevStr(def->serials[0], &b_info->u.hvm.serial) <\n                    0)\n                    return -1;\n            } else {\n#ifdef LIBXL_HAVE_BUILDINFO_SERIAL_LIST\n                if (VIR_ALLOC_N(b_info->u.hvm.serial_list, def->nserials + 1) <\n                    0)\n                    return -1;\n                for (i = 0; i < def->nserials; i++) {\n                    if (libxlMakeChrdevStr(def->serials[i],\n                                           &b_info->u.hvm.serial_list[i]) < 0)\n                    {\n                        libxl_string_list_dispose(&b_info->u.hvm.serial_list);\n                        return -1;\n                    }\n                }\n                b_info->u.hvm.serial_list[i] = NULL;\n#else\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               \"%s\",\n                               _(\"Only one serial device is supported by libxl\"));\n                return -1;\n#endif\n            }\n        }\n\n        if (def->nparallels) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           \"%s\",\n                           _(\"Parallel devices are not supported by libxl\"));\n            return -1;\n        }\n\n        /* Disable VNC and SDL until explicitly enabled */\n        libxl_defbool_set(&b_info->u.hvm.vnc.enable, 0);\n        libxl_defbool_set(&b_info->u.hvm.sdl.enable, 0);\n\n        for (i = 0; i < def->ninputs; i++) {\n            char **usbdevice;\n\n            if (def->inputs[i]->bus != VIR_DOMAIN_INPUT_BUS_USB)\n                continue;\n\n#ifdef LIBXL_HAVE_BUILDINFO_USBDEVICE_LIST\n            if (VIR_EXPAND_N(b_info->u.hvm.usbdevice_list, nusbdevice, 1) < 0)\n                return -1;\n#else\n            nusbdevice++;\n            if (nusbdevice > 1) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                        _(\"libxenlight supports only one input device\"));\n                return -1;\n            }\n#endif\n\n#ifdef LIBXL_HAVE_BUILDINFO_USBDEVICE_LIST\n            usbdevice = &b_info->u.hvm.usbdevice_list[nusbdevice - 1];\n#else\n            usbdevice = &b_info->u.hvm.usbdevice;\n#endif\n            switch (def->inputs[i]->type) {\n                case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n                    VIR_FREE(*usbdevice);\n                    *usbdevice = g_strdup(\"mouse\");\n                    break;\n                case VIR_DOMAIN_INPUT_TYPE_TABLET:\n                    VIR_FREE(*usbdevice);\n                    *usbdevice = g_strdup(\"tablet\");\n                    break;\n                default:\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                            _(\"Unknown input device type\"));\n                    return -1;\n            }\n        }\n\n#ifdef LIBXL_HAVE_BUILDINFO_USBDEVICE_LIST\n        /* NULL-terminate usbdevice_list */\n        if (nusbdevice > 0 &&\n            VIR_EXPAND_N(b_info->u.hvm.usbdevice_list, nusbdevice, 1) < 0) {\n            VIR_DISPOSE_N(b_info->u.hvm.usbdevice_list, nusbdevice);\n            return -1;\n        }\n#endif\n    } else if (pvh) {\n        b_info->cmdline = g_strdup(def->os.cmdline);\n        b_info->kernel = g_strdup(def->os.kernel);\n        b_info->ramdisk = g_strdup(def->os.initrd);\n#ifdef LIBXL_HAVE_BUILDINFO_BOOTLOADER\n        b_info->bootloader = g_strdup(def->os.bootloader);\n        if (def->os.bootloaderArgs) {\n            if (!(b_info->bootloader_args =\n                  virStringSplit(def->os.bootloaderArgs, \" \\t\\n\", 0)))\n                return -1;\n        }\n#endif\n    } else {\n        /*\n         * For compatibility with the legacy xen toolstack, default to pygrub\n         * if bootloader is not specified AND direct kernel boot is not specified.\n         */\n        if (def->os.bootloader) {\n            b_info->u.pv.bootloader = g_strdup(def->os.bootloader);\n        } else if (def->os.kernel == NULL) {\n            b_info->u.pv.bootloader = g_strdup(LIBXL_BOOTLOADER_PATH);\n        }\n        if (def->os.bootloaderArgs) {\n            if (!(b_info->u.pv.bootloader_args =\n                  virStringSplit(def->os.bootloaderArgs, \" \\t\\n\", 0)))\n                return -1;\n        }\n        b_info->u.pv.cmdline = g_strdup(def->os.cmdline);\n        if (def->os.kernel) {\n            /* libxl_init_build_info() sets kernel.path = g_strdup(\"hvmloader\") */\n            VIR_FREE(b_info->u.pv.kernel);\n            b_info->u.pv.kernel = g_strdup(def->os.kernel);\n        }\n        b_info->u.pv.ramdisk = g_strdup(def->os.initrd);\n    }\n\n    /* only the 'xen' balloon device model is supported */\n    if (def->memballoon) {\n        int model = def->memballoon->model;\n\n        switch ((virDomainMemballoonModel)model) {\n        case VIR_DOMAIN_MEMBALLOON_MODEL_XEN:\n            break;\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_TRANSITIONAL:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_NON_TRANSITIONAL:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported balloon device model '%s'\"),\n                           virDomainMemballoonModelTypeToString(model));\n            return -1;\n        case VIR_DOMAIN_MEMBALLOON_MODEL_NONE:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           \"%s\",\n                           _(\"balloon device cannot be disabled\"));\n            return -1;\n        case VIR_DOMAIN_MEMBALLOON_MODEL_LAST:\n        default:\n            virReportEnumRangeError(virDomainMemballoonModel, model);\n            return -1;\n        }\n    }\n\n    /* Allow libxl to calculate shadow memory requirements */\n    b_info->shadow_memkb =\n        libxl_get_required_shadow_memory(b_info->max_memkb,\n                                         b_info->max_vcpus);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMakeDomCreateInfo",
          "args": [
            "ctx",
            "def",
            "&d_config->c_info"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeDomCreateInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "122-187",
          "snippet": "static int\nlibxlMakeDomCreateInfo(libxl_ctx *ctx,\n                       virDomainDefPtr def,\n                       libxl_domain_create_info *c_info)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    libxl_domain_create_info_init(c_info);\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM ||\n        def->os.type == VIR_DOMAIN_OSTYPE_XENPVH) {\n#ifdef HAVE_XEN_PVH\n        c_info->type = def->os.type == VIR_DOMAIN_OSTYPE_HVM ?\n            LIBXL_DOMAIN_TYPE_HVM : LIBXL_DOMAIN_TYPE_PVH;\n#else\n        if (def->os.type == VIR_DOMAIN_OSTYPE_XENPVH) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                    _(\"PVH guest os type not supported\"));\n            return -1;\n        }\n        c_info->type = LIBXL_DOMAIN_TYPE_HVM;\n#endif\n        switch ((virTristateSwitch) def->features[VIR_DOMAIN_FEATURE_HAP]) {\n        case VIR_TRISTATE_SWITCH_OFF:\n            libxl_defbool_set(&c_info->hap, false);\n            break;\n\n        case VIR_TRISTATE_SWITCH_ON:\n            libxl_defbool_set(&c_info->hap, true);\n            break;\n\n        case VIR_TRISTATE_SWITCH_ABSENT:\n        case VIR_TRISTATE_SWITCH_LAST:\n            break;\n        }\n    } else {\n        c_info->type = LIBXL_DOMAIN_TYPE_PV;\n    }\n\n    c_info->name = g_strdup(def->name);\n\n    if (def->nseclabels &&\n        def->seclabels[0]->type == VIR_DOMAIN_SECLABEL_STATIC) {\n        if (libxl_flask_context_to_sid(ctx,\n                                       def->seclabels[0]->label,\n                                       strlen(def->seclabels[0]->label),\n                                       &c_info->ssidref)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"libxenlight failed to resolve security label '%s'\"),\n                           def->seclabels[0]->label);\n        }\n    }\n\n    virUUIDFormat(def->uuid, uuidstr);\n    if (libxl_uuid_from_string(&c_info->uuid, uuidstr)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"libxenlight failed to parse UUID '%s'\"), uuidstr);\n        goto error;\n    }\n\n    return 0;\n\n error:\n    libxl_domain_create_info_dispose(c_info);\n    return -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeDomCreateInfo(libxl_ctx *ctx,\n                       virDomainDefPtr def,\n                       libxl_domain_create_info *c_info)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    libxl_domain_create_info_init(c_info);\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM ||\n        def->os.type == VIR_DOMAIN_OSTYPE_XENPVH) {\n#ifdef HAVE_XEN_PVH\n        c_info->type = def->os.type == VIR_DOMAIN_OSTYPE_HVM ?\n            LIBXL_DOMAIN_TYPE_HVM : LIBXL_DOMAIN_TYPE_PVH;\n#else\n        if (def->os.type == VIR_DOMAIN_OSTYPE_XENPVH) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                    _(\"PVH guest os type not supported\"));\n            return -1;\n        }\n        c_info->type = LIBXL_DOMAIN_TYPE_HVM;\n#endif\n        switch ((virTristateSwitch) def->features[VIR_DOMAIN_FEATURE_HAP]) {\n        case VIR_TRISTATE_SWITCH_OFF:\n            libxl_defbool_set(&c_info->hap, false);\n            break;\n\n        case VIR_TRISTATE_SWITCH_ON:\n            libxl_defbool_set(&c_info->hap, true);\n            break;\n\n        case VIR_TRISTATE_SWITCH_ABSENT:\n        case VIR_TRISTATE_SWITCH_LAST:\n            break;\n        }\n    } else {\n        c_info->type = LIBXL_DOMAIN_TYPE_PV;\n    }\n\n    c_info->name = g_strdup(def->name);\n\n    if (def->nseclabels &&\n        def->seclabels[0]->type == VIR_DOMAIN_SECLABEL_STATIC) {\n        if (libxl_flask_context_to_sid(ctx,\n                                       def->seclabels[0]->label,\n                                       strlen(def->seclabels[0]->label),\n                                       &c_info->ssidref)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"libxenlight failed to resolve security label '%s'\"),\n                           def->seclabels[0]->label);\n        }\n    }\n\n    virUUIDFormat(def->uuid, uuidstr);\n    if (libxl_uuid_from_string(&c_info->uuid, uuidstr)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"libxenlight failed to parse UUID '%s'\"), uuidstr);\n        goto error;\n    }\n\n    return 0;\n\n error:\n    libxl_domain_create_info_dispose(c_info);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_domain_config_init",
          "args": [
            "d_config"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nint\nlibxlBuildDomainConfig(virPortAllocatorRangePtr graphicsports,\n                       virDomainDefPtr def,\n                       libxlDriverConfigPtr cfg,\n                       libxl_domain_config *d_config)\n{\n    virCapsPtr caps = cfg->caps;\n    libxl_ctx *ctx = cfg->ctx;\n    libxl_domain_config_init(d_config);\n\n    if (libxlMakeDomCreateInfo(ctx, def, &d_config->c_info) < 0)\n        return -1;\n\n    if (libxlMakeDomBuildInfo(def, cfg, caps, d_config) < 0)\n        return -1;\n\n#ifdef LIBXL_HAVE_VNUMA\n    if (libxlMakeVnumaList(def, ctx, d_config) < 0)\n        return -1;\n#endif\n\n    if (libxlMakeDiskList(def, d_config) < 0)\n        return -1;\n\n    if (libxlMakeNicList(def, d_config) < 0)\n        return -1;\n\n    if (libxlMakeVfbList(graphicsports, def, d_config) < 0)\n        return -1;\n\n    if (libxlMakeBuildInfoVfb(graphicsports, def, d_config) < 0)\n        return -1;\n\n    if (libxlMakePCIList(def, d_config) < 0)\n        return -1;\n\n#ifdef LIBXL_HAVE_PVUSB\n    if (libxlMakeUSBControllerList(def, d_config) < 0)\n        return -1;\n\n    if (libxlMakeUSBList(def, d_config) < 0)\n        return -1;\n#endif\n\n#ifdef LIBXL_HAVE_DEVICE_CHANNEL\n    if (libxlMakeChannelList(cfg->channelDir, def, d_config) < 0)\n        return -1;\n#endif\n\n    /*\n     * Now that any potential VFBs are defined, update the build info with\n     * the data of the primary display. Some day libxl might implicitly do\n     * so but as it does not right now, better be explicit.\n     */\n    if (libxlMakeVideo(def, d_config) < 0)\n        return -1;\n\n    d_config->on_reboot = libxlActionFromVirLifecycle(def->onReboot);\n    d_config->on_poweroff = libxlActionFromVirLifecycle(def->onPoweroff);\n    d_config->on_crash = libxlActionFromVirLifecycle(def->onCrash);\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlDriverNodeGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "2373-2409",
    "snippet": "int\nlibxlDriverNodeGetInfo(libxlDriverPrivatePtr driver, virNodeInfoPtr info)\n{\n    libxl_physinfo phy_info;\n    virArch hostarch = virArchFromHost();\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    int ret = -1;\n\n    libxl_physinfo_init(&phy_info);\n    if (libxl_get_physinfo(cfg->ctx, &phy_info)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libxl_get_physinfo_info failed\"));\n        goto cleanup;\n    }\n\n    if (virStrcpyStatic(info->model, virArchToString(hostarch)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"host arch %s is too big for destination\"),\n                       virArchToString(hostarch));\n        goto cleanup;\n    }\n\n    info->memory = phy_info.total_pages * (cfg->verInfo->pagesize / 1024);\n    info->cpus = phy_info.nr_cpus;\n    info->nodes = phy_info.nr_nodes;\n    info->cores = phy_info.cores_per_socket;\n    info->threads = phy_info.threads_per_core;\n    info->sockets = 1;\n    info->mhz = phy_info.cpu_khz / 1000;\n\n    ret = 0;\n\n cleanup:\n    libxl_physinfo_dispose(&phy_info);\n    virObjectUnref(cfg);\n    return ret;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_physinfo_dispose",
          "args": [
            "&phy_info"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"host arch %s is too big for destination\")",
            "virArchToString(hostarch)"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "hostarch"
          ],
          "line": 2391
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"host arch %s is too big for destination\""
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "info->model",
            "virArchToString(hostarch)"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"libxl_get_physinfo_info failed\")"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_get_physinfo",
          "args": [
            "cfg->ctx",
            "&phy_info"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_physinfo_init",
          "args": [
            "&phy_info"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDriverConfigGet",
          "args": [
            "driver"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverConfigGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1783-1792",
          "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virArchFromHost",
          "args": [],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "206-235",
          "snippet": "virArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nvirArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nint\nlibxlDriverNodeGetInfo(libxlDriverPrivatePtr driver, virNodeInfoPtr info)\n{\n    libxl_physinfo phy_info;\n    virArch hostarch = virArchFromHost();\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    int ret = -1;\n\n    libxl_physinfo_init(&phy_info);\n    if (libxl_get_physinfo(cfg->ctx, &phy_info)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libxl_get_physinfo_info failed\"));\n        goto cleanup;\n    }\n\n    if (virStrcpyStatic(info->model, virArchToString(hostarch)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"host arch %s is too big for destination\"),\n                       virArchToString(hostarch));\n        goto cleanup;\n    }\n\n    info->memory = phy_info.total_pages * (cfg->verInfo->pagesize / 1024);\n    info->cpus = phy_info.nr_cpus;\n    info->nodes = phy_info.nr_nodes;\n    info->cores = phy_info.cores_per_socket;\n    info->threads = phy_info.threads_per_core;\n    info->sockets = 1;\n    info->mhz = phy_info.cpu_khz / 1000;\n\n    ret = 0;\n\n cleanup:\n    libxl_physinfo_dispose(&phy_info);\n    virObjectUnref(cfg);\n    return ret;\n}"
  },
  {
    "function_name": "libxlMakeVideo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "2296-2371",
    "snippet": "static int\nlibxlMakeVideo(virDomainDefPtr def, libxl_domain_config *d_config)\n\n{\n    libxl_domain_build_info *b_info = &d_config->b_info;\n    int dm_type = libxlDomainGetEmulatorType(def);\n\n    if (d_config->c_info.type != LIBXL_DOMAIN_TYPE_HVM)\n        return 0;\n\n    /*\n     * Take the first defined video device (graphics card) to display\n     * on the first graphics device (display).\n     */\n    if (def->nvideos) {\n        switch (def->videos[0]->type) {\n        case VIR_DOMAIN_VIDEO_TYPE_VGA:\n        case VIR_DOMAIN_VIDEO_TYPE_XEN:\n            b_info->u.hvm.vga.kind = LIBXL_VGA_INTERFACE_TYPE_STD;\n            if (dm_type == LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN) {\n                if (def->videos[0]->vram < 16 * 1024) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"videoram must be at least 16MB for VGA\"));\n                    return -1;\n                }\n            } else {\n                if (def->videos[0]->vram < 8 * 1024) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"videoram must be at least 8MB for VGA\"));\n                    return -1;\n                }\n            }\n            break;\n\n        case VIR_DOMAIN_VIDEO_TYPE_CIRRUS:\n            b_info->u.hvm.vga.kind = LIBXL_VGA_INTERFACE_TYPE_CIRRUS;\n            if (dm_type == LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN) {\n                if (def->videos[0]->vram < 8 * 1024) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"videoram must be at least 8MB for CIRRUS\"));\n                    return -1;\n                }\n            } else {\n                if (def->videos[0]->vram < 4 * 1024) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"videoram must be at least 4MB for CIRRUS\"));\n                    return -1;\n                }\n            }\n            break;\n\n#ifdef LIBXL_HAVE_QXL\n        case VIR_DOMAIN_VIDEO_TYPE_QXL:\n            b_info->u.hvm.vga.kind = LIBXL_VGA_INTERFACE_TYPE_QXL;\n            if (def->videos[0]->vram < 128 * 1024) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"videoram must be at least 128MB for QXL\"));\n                return -1;\n            }\n            break;\n#endif\n\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"video type %s is not supported by libxl\"),\n                           virDomainVideoTypeToString(def->videos[0]->type));\n            return -1;\n        }\n        /* vram validated for each video type, now set it */\n        b_info->video_memkb = def->videos[0]->vram;\n    } else {\n        libxl_defbool_set(&b_info->u.hvm.nographic, 1);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.nographic",
            "1"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"video type %s is not supported by libxl\")",
            "virDomainVideoTypeToString(def->videos[0]->type)"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVideoTypeToString",
          "args": [
            "def->videos[0]->type"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"video type %s is not supported by libxl\""
          ],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"videoram must be at least 128MB for QXL\")"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"videoram must be at least 4MB for CIRRUS\")"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"videoram must be at least 8MB for CIRRUS\")"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"videoram must be at least 8MB for VGA\")"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"videoram must be at least 16MB for VGA\")"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDomainGetEmulatorType",
          "args": [
            "def"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainGetEmulatorType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
          "lines": "777-806",
          "snippet": "int\nlibxlDomainGetEmulatorType(const virDomainDef *def)\n{\n    int ret = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN;\n    virCommandPtr cmd = NULL;\n    char *output = NULL;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (def->emulator) {\n            if (!virFileExists(def->emulator))\n                goto cleanup;\n\n            cmd = virCommandNew(def->emulator);\n\n            virCommandAddArgList(cmd, \"-help\", NULL);\n            virCommandSetOutputBuffer(cmd, &output);\n\n            if (virCommandRun(cmd, NULL) < 0)\n                goto cleanup;\n\n            if (strstr(output, LIBXL_QEMU_DM_STR))\n                ret = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN_TRADITIONAL;\n        }\n    }\n\n cleanup:\n    VIR_FREE(output);\n    virCommandFree(cmd);\n    return ret;\n}",
          "includes": [
            "#include \"cpu/cpu_x86_data.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBXL_QEMU_DM_STR  \"Options specific to the Xen version:\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\n#define LIBXL_QEMU_DM_STR  \"Options specific to the Xen version:\"\n\nint\nlibxlDomainGetEmulatorType(const virDomainDef *def)\n{\n    int ret = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN;\n    virCommandPtr cmd = NULL;\n    char *output = NULL;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (def->emulator) {\n            if (!virFileExists(def->emulator))\n                goto cleanup;\n\n            cmd = virCommandNew(def->emulator);\n\n            virCommandAddArgList(cmd, \"-help\", NULL);\n            virCommandSetOutputBuffer(cmd, &output);\n\n            if (virCommandRun(cmd, NULL) < 0)\n                goto cleanup;\n\n            if (strstr(output, LIBXL_QEMU_DM_STR))\n                ret = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN_TRADITIONAL;\n        }\n    }\n\n cleanup:\n    VIR_FREE(output);\n    virCommandFree(cmd);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeVideo(virDomainDefPtr def, libxl_domain_config *d_config)\n\n{\n    libxl_domain_build_info *b_info = &d_config->b_info;\n    int dm_type = libxlDomainGetEmulatorType(def);\n\n    if (d_config->c_info.type != LIBXL_DOMAIN_TYPE_HVM)\n        return 0;\n\n    /*\n     * Take the first defined video device (graphics card) to display\n     * on the first graphics device (display).\n     */\n    if (def->nvideos) {\n        switch (def->videos[0]->type) {\n        case VIR_DOMAIN_VIDEO_TYPE_VGA:\n        case VIR_DOMAIN_VIDEO_TYPE_XEN:\n            b_info->u.hvm.vga.kind = LIBXL_VGA_INTERFACE_TYPE_STD;\n            if (dm_type == LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN) {\n                if (def->videos[0]->vram < 16 * 1024) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"videoram must be at least 16MB for VGA\"));\n                    return -1;\n                }\n            } else {\n                if (def->videos[0]->vram < 8 * 1024) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"videoram must be at least 8MB for VGA\"));\n                    return -1;\n                }\n            }\n            break;\n\n        case VIR_DOMAIN_VIDEO_TYPE_CIRRUS:\n            b_info->u.hvm.vga.kind = LIBXL_VGA_INTERFACE_TYPE_CIRRUS;\n            if (dm_type == LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN) {\n                if (def->videos[0]->vram < 8 * 1024) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"videoram must be at least 8MB for CIRRUS\"));\n                    return -1;\n                }\n            } else {\n                if (def->videos[0]->vram < 4 * 1024) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"videoram must be at least 4MB for CIRRUS\"));\n                    return -1;\n                }\n            }\n            break;\n\n#ifdef LIBXL_HAVE_QXL\n        case VIR_DOMAIN_VIDEO_TYPE_QXL:\n            b_info->u.hvm.vga.kind = LIBXL_VGA_INTERFACE_TYPE_QXL;\n            if (def->videos[0]->vram < 128 * 1024) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"videoram must be at least 128MB for QXL\"));\n                return -1;\n            }\n            break;\n#endif\n\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"video type %s is not supported by libxl\"),\n                           virDomainVideoTypeToString(def->videos[0]->type));\n            return -1;\n        }\n        /* vram validated for each video type, now set it */\n        b_info->video_memkb = def->videos[0]->vram;\n    } else {\n        libxl_defbool_set(&b_info->u.hvm.nographic, 1);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlMakePCIList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "2252-2294",
    "snippet": "static int\nlibxlMakePCIList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainHostdevDefPtr *l_hostdevs = def->hostdevs;\n    size_t nhostdevs = def->nhostdevs;\n    size_t npcidevs = 0;\n    libxl_device_pci *x_pcidevs;\n    size_t i, j;\n\n    if (nhostdevs == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(x_pcidevs, nhostdevs) < 0)\n        return -1;\n\n    for (i = 0, j = 0; i < nhostdevs; i++) {\n        if (l_hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (l_hostdevs[i]->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            continue;\n\n        libxl_device_pci_init(&x_pcidevs[j]);\n\n        if (libxlMakePCI(l_hostdevs[i], &x_pcidevs[j]) < 0)\n            goto error;\n\n        npcidevs++;\n        j++;\n    }\n\n    VIR_SHRINK_N(x_pcidevs, nhostdevs, nhostdevs - npcidevs);\n    d_config->pcidevs = x_pcidevs;\n    d_config->num_pcidevs = npcidevs;\n\n    return 0;\n\n error:\n    for (i = 0; i < npcidevs; i++)\n        libxl_device_pci_dispose(&x_pcidevs[i]);\n\n    VIR_FREE(x_pcidevs);\n    return -1;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "x_pcidevs"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_device_pci_dispose",
          "args": [
            "&x_pcidevs[i]"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SHRINK_N",
          "args": [
            "x_pcidevs",
            "nhostdevs",
            "nhostdevs - npcidevs"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlMakePCI",
          "args": [
            "l_hostdevs[i]",
            "&x_pcidevs[j]"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakePCIList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "2252-2294",
          "snippet": "static int\nlibxlMakePCIList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainHostdevDefPtr *l_hostdevs = def->hostdevs;\n    size_t nhostdevs = def->nhostdevs;\n    size_t npcidevs = 0;\n    libxl_device_pci *x_pcidevs;\n    size_t i, j;\n\n    if (nhostdevs == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(x_pcidevs, nhostdevs) < 0)\n        return -1;\n\n    for (i = 0, j = 0; i < nhostdevs; i++) {\n        if (l_hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (l_hostdevs[i]->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            continue;\n\n        libxl_device_pci_init(&x_pcidevs[j]);\n\n        if (libxlMakePCI(l_hostdevs[i], &x_pcidevs[j]) < 0)\n            goto error;\n\n        npcidevs++;\n        j++;\n    }\n\n    VIR_SHRINK_N(x_pcidevs, nhostdevs, nhostdevs - npcidevs);\n    d_config->pcidevs = x_pcidevs;\n    d_config->num_pcidevs = npcidevs;\n\n    return 0;\n\n error:\n    for (i = 0; i < npcidevs; i++)\n        libxl_device_pci_dispose(&x_pcidevs[i]);\n\n    VIR_FREE(x_pcidevs);\n    return -1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "libxl_device_pci_init",
          "args": [
            "&x_pcidevs[j]"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "x_pcidevs",
            "nhostdevs"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakePCIList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainHostdevDefPtr *l_hostdevs = def->hostdevs;\n    size_t nhostdevs = def->nhostdevs;\n    size_t npcidevs = 0;\n    libxl_device_pci *x_pcidevs;\n    size_t i, j;\n\n    if (nhostdevs == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(x_pcidevs, nhostdevs) < 0)\n        return -1;\n\n    for (i = 0, j = 0; i < nhostdevs; i++) {\n        if (l_hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (l_hostdevs[i]->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            continue;\n\n        libxl_device_pci_init(&x_pcidevs[j]);\n\n        if (libxlMakePCI(l_hostdevs[i], &x_pcidevs[j]) < 0)\n            goto error;\n\n        npcidevs++;\n        j++;\n    }\n\n    VIR_SHRINK_N(x_pcidevs, nhostdevs, nhostdevs - npcidevs);\n    d_config->pcidevs = x_pcidevs;\n    d_config->num_pcidevs = npcidevs;\n\n    return 0;\n\n error:\n    for (i = 0; i < npcidevs; i++)\n        libxl_device_pci_dispose(&x_pcidevs[i]);\n\n    VIR_FREE(x_pcidevs);\n    return -1;\n}"
  },
  {
    "function_name": "libxlMakePCI",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "2235-2250",
    "snippet": "int\nlibxlMakePCI(virDomainHostdevDefPtr hostdev, libxl_device_pci *pcidev)\n{\n    virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n    if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n        return -1;\n    if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n        return -1;\n\n    pcidev->domain = pcisrc->addr.domain;\n    pcidev->bus = pcisrc->addr.bus;\n    pcidev->dev = pcisrc->addr.slot;\n    pcidev->func = pcisrc->addr.function;\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nint\nlibxlMakePCI(virDomainHostdevDefPtr hostdev, libxl_device_pci *pcidev)\n{\n    virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n    if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n        return -1;\n    if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n        return -1;\n\n    pcidev->domain = pcisrc->addr.domain;\n    pcidev->bus = pcisrc->addr.bus;\n    pcidev->dev = pcisrc->addr.slot;\n    pcidev->func = pcisrc->addr.function;\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlMakeUSBList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "2190-2232",
    "snippet": "static int\nlibxlMakeUSBList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainHostdevDefPtr *l_hostdevs = def->hostdevs;\n    size_t nhostdevs = def->nhostdevs;\n    size_t nusbdevs = 0;\n    libxl_device_usbdev *x_usbdevs;\n    size_t i, j;\n\n    if (nhostdevs == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(x_usbdevs, nhostdevs) < 0)\n        return -1;\n\n    for (i = 0, j = 0; i < nhostdevs; i++) {\n        if (l_hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (l_hostdevs[i]->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        libxl_device_usbdev_init(&x_usbdevs[j]);\n\n        if (libxlMakeUSB(l_hostdevs[i], &x_usbdevs[j]) < 0)\n            goto error;\n\n        nusbdevs++;\n        j++;\n    }\n\n    VIR_SHRINK_N(x_usbdevs, nhostdevs, nhostdevs - nusbdevs);\n    d_config->usbdevs = x_usbdevs;\n    d_config->num_usbdevs = nusbdevs;\n\n    return 0;\n\n error:\n    for (i = 0; i < nusbdevs; i++)\n        libxl_device_usbdev_dispose(&x_usbdevs[i]);\n\n    VIR_FREE(x_usbdevs);\n    return -1;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "x_usbdevs"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_device_usbdev_dispose",
          "args": [
            "&x_usbdevs[i]"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SHRINK_N",
          "args": [
            "x_usbdevs",
            "nhostdevs",
            "nhostdevs - nusbdevs"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlMakeUSB",
          "args": [
            "l_hostdevs[i]",
            "&x_usbdevs[j]"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeUSBList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "2190-2232",
          "snippet": "static int\nlibxlMakeUSBList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainHostdevDefPtr *l_hostdevs = def->hostdevs;\n    size_t nhostdevs = def->nhostdevs;\n    size_t nusbdevs = 0;\n    libxl_device_usbdev *x_usbdevs;\n    size_t i, j;\n\n    if (nhostdevs == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(x_usbdevs, nhostdevs) < 0)\n        return -1;\n\n    for (i = 0, j = 0; i < nhostdevs; i++) {\n        if (l_hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (l_hostdevs[i]->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        libxl_device_usbdev_init(&x_usbdevs[j]);\n\n        if (libxlMakeUSB(l_hostdevs[i], &x_usbdevs[j]) < 0)\n            goto error;\n\n        nusbdevs++;\n        j++;\n    }\n\n    VIR_SHRINK_N(x_usbdevs, nhostdevs, nhostdevs - nusbdevs);\n    d_config->usbdevs = x_usbdevs;\n    d_config->num_usbdevs = nusbdevs;\n\n    return 0;\n\n error:\n    for (i = 0; i < nusbdevs; i++)\n        libxl_device_usbdev_dispose(&x_usbdevs[i]);\n\n    VIR_FREE(x_usbdevs);\n    return -1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "libxl_device_usbdev_init",
          "args": [
            "&x_usbdevs[j]"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "x_usbdevs",
            "nhostdevs"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeUSBList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainHostdevDefPtr *l_hostdevs = def->hostdevs;\n    size_t nhostdevs = def->nhostdevs;\n    size_t nusbdevs = 0;\n    libxl_device_usbdev *x_usbdevs;\n    size_t i, j;\n\n    if (nhostdevs == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(x_usbdevs, nhostdevs) < 0)\n        return -1;\n\n    for (i = 0, j = 0; i < nhostdevs; i++) {\n        if (l_hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (l_hostdevs[i]->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        libxl_device_usbdev_init(&x_usbdevs[j]);\n\n        if (libxlMakeUSB(l_hostdevs[i], &x_usbdevs[j]) < 0)\n            goto error;\n\n        nusbdevs++;\n        j++;\n    }\n\n    VIR_SHRINK_N(x_usbdevs, nhostdevs, nhostdevs - nusbdevs);\n    d_config->usbdevs = x_usbdevs;\n    d_config->num_usbdevs = nusbdevs;\n\n    return 0;\n\n error:\n    for (i = 0; i < nusbdevs; i++)\n        libxl_device_usbdev_dispose(&x_usbdevs[i]);\n\n    VIR_FREE(x_usbdevs);\n    return -1;\n}"
  },
  {
    "function_name": "libxlMakeUSB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "2154-2188",
    "snippet": "int\nlibxlMakeUSB(virDomainHostdevDefPtr hostdev, libxl_device_usbdev *usbdev)\n{\n    virDomainHostdevSubsysUSBPtr usbsrc = &hostdev->source.subsys.u.usb;\n    virUSBDevicePtr usb = NULL;\n    int ret = -1;\n\n    if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n        return ret;\n    if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n        return ret;\n\n    if (usbsrc->bus > 0 && usbsrc->device > 0) {\n        usbdev->u.hostdev.hostbus = usbsrc->bus;\n        usbdev->u.hostdev.hostaddr = usbsrc->device;\n    } else {\n        if (virHostdevFindUSBDevice(hostdev, true, &usb) < 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"failed to find USB device busnum:devnum \"\n                             \"for %x:%x\"),\n                           usbsrc->vendor, usbsrc->product);\n            goto cleanup;\n        }\n\n        usbdev->u.hostdev.hostbus = virUSBDeviceGetBus(usb);\n        usbdev->u.hostdev.hostaddr = virUSBDeviceGetDevno(usb);\n    }\n\n    ret = 0;\n\n cleanup:\n    virUSBDeviceFree(usb);\n\n    return ret;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virUSBDeviceFree",
          "args": [
            "usb"
          ],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "353-363",
          "snippet": "void\nvirUSBDeviceFree(virUSBDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvoid\nvirUSBDeviceFree(virUSBDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceGetDevno",
          "args": [
            "usb"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceGetDevno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "403-406",
          "snippet": "unsigned int virUSBDeviceGetDevno(virUSBDevicePtr dev)\n{\n    return dev->dev;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nunsigned int virUSBDeviceGetDevno(virUSBDevicePtr dev)\n{\n    return dev->dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceGetBus",
          "args": [
            "usb"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceGetBus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "397-400",
          "snippet": "unsigned int virUSBDeviceGetBus(virUSBDevicePtr dev)\n{\n    return dev->bus;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nunsigned int virUSBDeviceGetBus(virUSBDevicePtr dev)\n{\n    return dev->bus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"failed to find USB device busnum:devnum \"\n                             \"for %x:%x\")",
            "usbsrc->vendor",
            "usbsrc->product"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to find USB device busnum:devnum \"\n                             \"for %x:%x\""
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevFindUSBDevice",
          "args": [
            "hostdev",
            "true",
            "&usb"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevFindUSBDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1356-1437",
          "snippet": "int\nvirHostdevFindUSBDevice(virDomainHostdevDefPtr hostdev,\n                        bool mandatory,\n                        virUSBDevicePtr *usb)\n{\n    virDomainHostdevSubsysUSBPtr usbsrc = &hostdev->source.subsys.u.usb;\n    unsigned vendor = usbsrc->vendor;\n    unsigned product = usbsrc->product;\n    unsigned bus = usbsrc->bus;\n    unsigned device = usbsrc->device;\n    bool autoAddress = usbsrc->autoAddress;\n    int rc;\n\n    *usb = NULL;\n\n    if (vendor && bus) {\n        rc = virUSBDeviceFind(vendor, product, bus, device,\n                              NULL,\n                              autoAddress ? false : mandatory,\n                              usb);\n        if (rc < 0) {\n            return -1;\n        } else if (!autoAddress) {\n            goto out;\n        } else {\n            VIR_INFO(\"USB device %x:%x could not be found at previous\"\n                     \" address (bus:%u device:%u)\",\n                     vendor, product, bus, device);\n        }\n    }\n\n    /* When vendor is specified, its USB address is either unspecified or the\n     * device could not be found at the USB device where it had been\n     * automatically found before.\n     */\n    if (vendor) {\n        g_autoptr(virUSBDeviceList) devs = NULL;\n\n        rc = virUSBDeviceFindByVendor(vendor, product, NULL, mandatory, &devs);\n        if (rc < 0) {\n            return -1;\n        } else if (rc == 0) {\n            goto out;\n        } else if (rc > 1) {\n            if (autoAddress) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Multiple USB devices for %x:%x were found,\"\n                                 \" but none of them is at bus:%u device:%u\"),\n                               vendor, product, bus, device);\n            } else {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Multiple USB devices for %x:%x, \"\n                                 \"use <address> to specify one\"),\n                               vendor, product);\n            }\n            return -1;\n        }\n\n        *usb = virUSBDeviceListGet(devs, 0);\n        virUSBDeviceListSteal(devs, *usb);\n\n        usbsrc->bus = virUSBDeviceGetBus(*usb);\n        usbsrc->device = virUSBDeviceGetDevno(*usb);\n        usbsrc->autoAddress = true;\n\n        if (autoAddress) {\n            VIR_INFO(\"USB device %x:%x found at bus:%u device:%u (moved\"\n                     \" from bus:%u device:%u)\",\n                     vendor, product,\n                     usbsrc->bus, usbsrc->device,\n                     bus, device);\n        }\n    } else if (!vendor && bus) {\n        if (virUSBDeviceFindByBus(bus, device, NULL, mandatory, usb) < 0)\n            return -1;\n    }\n\n out:\n    if (!*usb)\n        hostdev->missing = true;\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevFindUSBDevice(virDomainHostdevDefPtr hostdev,\n                        bool mandatory,\n                        virUSBDevicePtr *usb)\n{\n    virDomainHostdevSubsysUSBPtr usbsrc = &hostdev->source.subsys.u.usb;\n    unsigned vendor = usbsrc->vendor;\n    unsigned product = usbsrc->product;\n    unsigned bus = usbsrc->bus;\n    unsigned device = usbsrc->device;\n    bool autoAddress = usbsrc->autoAddress;\n    int rc;\n\n    *usb = NULL;\n\n    if (vendor && bus) {\n        rc = virUSBDeviceFind(vendor, product, bus, device,\n                              NULL,\n                              autoAddress ? false : mandatory,\n                              usb);\n        if (rc < 0) {\n            return -1;\n        } else if (!autoAddress) {\n            goto out;\n        } else {\n            VIR_INFO(\"USB device %x:%x could not be found at previous\"\n                     \" address (bus:%u device:%u)\",\n                     vendor, product, bus, device);\n        }\n    }\n\n    /* When vendor is specified, its USB address is either unspecified or the\n     * device could not be found at the USB device where it had been\n     * automatically found before.\n     */\n    if (vendor) {\n        g_autoptr(virUSBDeviceList) devs = NULL;\n\n        rc = virUSBDeviceFindByVendor(vendor, product, NULL, mandatory, &devs);\n        if (rc < 0) {\n            return -1;\n        } else if (rc == 0) {\n            goto out;\n        } else if (rc > 1) {\n            if (autoAddress) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Multiple USB devices for %x:%x were found,\"\n                                 \" but none of them is at bus:%u device:%u\"),\n                               vendor, product, bus, device);\n            } else {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Multiple USB devices for %x:%x, \"\n                                 \"use <address> to specify one\"),\n                               vendor, product);\n            }\n            return -1;\n        }\n\n        *usb = virUSBDeviceListGet(devs, 0);\n        virUSBDeviceListSteal(devs, *usb);\n\n        usbsrc->bus = virUSBDeviceGetBus(*usb);\n        usbsrc->device = virUSBDeviceGetDevno(*usb);\n        usbsrc->autoAddress = true;\n\n        if (autoAddress) {\n            VIR_INFO(\"USB device %x:%x found at bus:%u device:%u (moved\"\n                     \" from bus:%u device:%u)\",\n                     vendor, product,\n                     usbsrc->bus, usbsrc->device,\n                     bus, device);\n        }\n    } else if (!vendor && bus) {\n        if (virUSBDeviceFindByBus(bus, device, NULL, mandatory, usb) < 0)\n            return -1;\n    }\n\n out:\n    if (!*usb)\n        hostdev->missing = true;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nint\nlibxlMakeUSB(virDomainHostdevDefPtr hostdev, libxl_device_usbdev *usbdev)\n{\n    virDomainHostdevSubsysUSBPtr usbsrc = &hostdev->source.subsys.u.usb;\n    virUSBDevicePtr usb = NULL;\n    int ret = -1;\n\n    if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n        return ret;\n    if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n        return ret;\n\n    if (usbsrc->bus > 0 && usbsrc->device > 0) {\n        usbdev->u.hostdev.hostbus = usbsrc->bus;\n        usbdev->u.hostdev.hostaddr = usbsrc->device;\n    } else {\n        if (virHostdevFindUSBDevice(hostdev, true, &usb) < 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"failed to find USB device busnum:devnum \"\n                             \"for %x:%x\"),\n                           usbsrc->vendor, usbsrc->product);\n            goto cleanup;\n        }\n\n        usbdev->u.hostdev.hostbus = virUSBDeviceGetBus(usb);\n        usbdev->u.hostdev.hostaddr = virUSBDeviceGetDevno(usb);\n    }\n\n    ret = 0;\n\n cleanup:\n    virUSBDeviceFree(usb);\n\n    return ret;\n}"
  },
  {
    "function_name": "libxlMakeUSBControllerList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "2108-2152",
    "snippet": "static int\nlibxlMakeUSBControllerList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainControllerDefPtr *l_controllers = def->controllers;\n    size_t ncontrollers = def->ncontrollers;\n    size_t nusbctrls = 0;\n    libxl_device_usbctrl *x_usbctrls;\n    size_t i, j;\n\n    for (i = 0; i < ncontrollers; i++) {\n        if (l_controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB)\n            nusbctrls++;\n    }\n\n    if (nusbctrls == 0)\n        return libxlMakeDefaultUSBControllers(def, d_config);\n\n    if (VIR_ALLOC_N(x_usbctrls, nusbctrls) < 0)\n        return -1;\n\n    for (i = 0, j = 0; i < ncontrollers && j < nusbctrls; i++) {\n        if (l_controllers[i]->type != VIR_DOMAIN_CONTROLLER_TYPE_USB)\n            continue;\n\n        libxl_device_usbctrl_init(&x_usbctrls[j]);\n\n        if (libxlMakeUSBController(l_controllers[i],\n                                   &x_usbctrls[j]) < 0)\n            goto error;\n\n        j++;\n    }\n\n    d_config->usbctrls = x_usbctrls;\n    d_config->num_usbctrls = nusbctrls;\n\n    return 0;\n\n error:\n    for (i = 0; i < nusbctrls; i++)\n        libxl_device_usbctrl_dispose(&x_usbctrls[i]);\n\n    VIR_FREE(x_usbctrls);\n    return -1;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "x_usbctrls"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_device_usbctrl_dispose",
          "args": [
            "&x_usbctrls[i]"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlMakeUSBController",
          "args": [
            "l_controllers[i]",
            "&x_usbctrls[j]"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeUSBControllerList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "2108-2152",
          "snippet": "static int\nlibxlMakeUSBControllerList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainControllerDefPtr *l_controllers = def->controllers;\n    size_t ncontrollers = def->ncontrollers;\n    size_t nusbctrls = 0;\n    libxl_device_usbctrl *x_usbctrls;\n    size_t i, j;\n\n    for (i = 0; i < ncontrollers; i++) {\n        if (l_controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB)\n            nusbctrls++;\n    }\n\n    if (nusbctrls == 0)\n        return libxlMakeDefaultUSBControllers(def, d_config);\n\n    if (VIR_ALLOC_N(x_usbctrls, nusbctrls) < 0)\n        return -1;\n\n    for (i = 0, j = 0; i < ncontrollers && j < nusbctrls; i++) {\n        if (l_controllers[i]->type != VIR_DOMAIN_CONTROLLER_TYPE_USB)\n            continue;\n\n        libxl_device_usbctrl_init(&x_usbctrls[j]);\n\n        if (libxlMakeUSBController(l_controllers[i],\n                                   &x_usbctrls[j]) < 0)\n            goto error;\n\n        j++;\n    }\n\n    d_config->usbctrls = x_usbctrls;\n    d_config->num_usbctrls = nusbctrls;\n\n    return 0;\n\n error:\n    for (i = 0; i < nusbctrls; i++)\n        libxl_device_usbctrl_dispose(&x_usbctrls[i]);\n\n    VIR_FREE(x_usbctrls);\n    return -1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "libxl_device_usbctrl_init",
          "args": [
            "&x_usbctrls[j]"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "x_usbctrls",
            "nusbctrls"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlMakeDefaultUSBControllers",
          "args": [
            "def",
            "d_config"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeDefaultUSBControllers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "2052-2106",
          "snippet": "static int\nlibxlMakeDefaultUSBControllers(virDomainDefPtr def,\n                               libxl_domain_config *d_config)\n{\n    virDomainControllerDefPtr l_controller = NULL;\n    libxl_device_usbctrl *x_controllers = NULL;\n    size_t nusbdevs = 0;\n    size_t ncontrollers;\n    size_t i;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            nusbdevs++;\n    }\n\n    /* No controllers needed if there are no USB devs */\n    if (nusbdevs == 0)\n        return 0;\n\n    /* Create USB controllers with 8 ports */\n    ncontrollers = VIR_DIV_UP(nusbdevs, 8);\n    if (VIR_ALLOC_N(x_controllers, ncontrollers) < 0)\n        return -1;\n\n    for (i = 0; i < ncontrollers; i++) {\n        if (!(l_controller = virDomainControllerDefNew(VIR_DOMAIN_CONTROLLER_TYPE_USB)))\n            goto error;\n\n        l_controller->model = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2;\n        l_controller->idx = i;\n        l_controller->opts.usbopts.ports = 8;\n\n        libxl_device_usbctrl_init(&x_controllers[i]);\n\n        if (libxlMakeUSBController(l_controller, &x_controllers[i]) < 0)\n            goto error;\n\n        if (virDomainControllerInsert(def, l_controller) < 0)\n            goto error;\n\n        l_controller = NULL;\n    }\n\n    d_config->usbctrls = x_controllers;\n    d_config->num_usbctrls = ncontrollers;\n    return 0;\n\n error:\n     virDomainControllerDefFree(l_controller);\n     for (i = 0; i < ncontrollers; i++)\n         libxl_device_usbctrl_dispose(&x_controllers[i]);\n     VIR_FREE(x_controllers);\n     return -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeDefaultUSBControllers(virDomainDefPtr def,\n                               libxl_domain_config *d_config)\n{\n    virDomainControllerDefPtr l_controller = NULL;\n    libxl_device_usbctrl *x_controllers = NULL;\n    size_t nusbdevs = 0;\n    size_t ncontrollers;\n    size_t i;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            nusbdevs++;\n    }\n\n    /* No controllers needed if there are no USB devs */\n    if (nusbdevs == 0)\n        return 0;\n\n    /* Create USB controllers with 8 ports */\n    ncontrollers = VIR_DIV_UP(nusbdevs, 8);\n    if (VIR_ALLOC_N(x_controllers, ncontrollers) < 0)\n        return -1;\n\n    for (i = 0; i < ncontrollers; i++) {\n        if (!(l_controller = virDomainControllerDefNew(VIR_DOMAIN_CONTROLLER_TYPE_USB)))\n            goto error;\n\n        l_controller->model = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2;\n        l_controller->idx = i;\n        l_controller->opts.usbopts.ports = 8;\n\n        libxl_device_usbctrl_init(&x_controllers[i]);\n\n        if (libxlMakeUSBController(l_controller, &x_controllers[i]) < 0)\n            goto error;\n\n        if (virDomainControllerInsert(def, l_controller) < 0)\n            goto error;\n\n        l_controller = NULL;\n    }\n\n    d_config->usbctrls = x_controllers;\n    d_config->num_usbctrls = ncontrollers;\n    return 0;\n\n error:\n     virDomainControllerDefFree(l_controller);\n     for (i = 0; i < ncontrollers; i++)\n         libxl_device_usbctrl_dispose(&x_controllers[i]);\n     VIR_FREE(x_controllers);\n     return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeUSBControllerList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainControllerDefPtr *l_controllers = def->controllers;\n    size_t ncontrollers = def->ncontrollers;\n    size_t nusbctrls = 0;\n    libxl_device_usbctrl *x_usbctrls;\n    size_t i, j;\n\n    for (i = 0; i < ncontrollers; i++) {\n        if (l_controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB)\n            nusbctrls++;\n    }\n\n    if (nusbctrls == 0)\n        return libxlMakeDefaultUSBControllers(def, d_config);\n\n    if (VIR_ALLOC_N(x_usbctrls, nusbctrls) < 0)\n        return -1;\n\n    for (i = 0, j = 0; i < ncontrollers && j < nusbctrls; i++) {\n        if (l_controllers[i]->type != VIR_DOMAIN_CONTROLLER_TYPE_USB)\n            continue;\n\n        libxl_device_usbctrl_init(&x_usbctrls[j]);\n\n        if (libxlMakeUSBController(l_controllers[i],\n                                   &x_usbctrls[j]) < 0)\n            goto error;\n\n        j++;\n    }\n\n    d_config->usbctrls = x_usbctrls;\n    d_config->num_usbctrls = nusbctrls;\n\n    return 0;\n\n error:\n    for (i = 0; i < nusbctrls; i++)\n        libxl_device_usbctrl_dispose(&x_usbctrls[i]);\n\n    VIR_FREE(x_usbctrls);\n    return -1;\n}"
  },
  {
    "function_name": "libxlMakeDefaultUSBControllers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "2052-2106",
    "snippet": "static int\nlibxlMakeDefaultUSBControllers(virDomainDefPtr def,\n                               libxl_domain_config *d_config)\n{\n    virDomainControllerDefPtr l_controller = NULL;\n    libxl_device_usbctrl *x_controllers = NULL;\n    size_t nusbdevs = 0;\n    size_t ncontrollers;\n    size_t i;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            nusbdevs++;\n    }\n\n    /* No controllers needed if there are no USB devs */\n    if (nusbdevs == 0)\n        return 0;\n\n    /* Create USB controllers with 8 ports */\n    ncontrollers = VIR_DIV_UP(nusbdevs, 8);\n    if (VIR_ALLOC_N(x_controllers, ncontrollers) < 0)\n        return -1;\n\n    for (i = 0; i < ncontrollers; i++) {\n        if (!(l_controller = virDomainControllerDefNew(VIR_DOMAIN_CONTROLLER_TYPE_USB)))\n            goto error;\n\n        l_controller->model = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2;\n        l_controller->idx = i;\n        l_controller->opts.usbopts.ports = 8;\n\n        libxl_device_usbctrl_init(&x_controllers[i]);\n\n        if (libxlMakeUSBController(l_controller, &x_controllers[i]) < 0)\n            goto error;\n\n        if (virDomainControllerInsert(def, l_controller) < 0)\n            goto error;\n\n        l_controller = NULL;\n    }\n\n    d_config->usbctrls = x_controllers;\n    d_config->num_usbctrls = ncontrollers;\n    return 0;\n\n error:\n     virDomainControllerDefFree(l_controller);\n     for (i = 0; i < ncontrollers; i++)\n         libxl_device_usbctrl_dispose(&x_controllers[i]);\n     VIR_FREE(x_controllers);\n     return -1;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "x_controllers"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_device_usbctrl_dispose",
          "args": [
            "&x_controllers[i]"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainControllerDefFree",
          "args": [
            "l_controller"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainControllerDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2262-2271",
          "snippet": "void virDomainControllerDefFree(virDomainControllerDefPtr def)\n{\n    if (!def)\n        return;\n\n    virDomainDeviceInfoClear(&def->info);\n    VIR_FREE(def->virtio);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def)\n{\n    if (!def)\n        return;\n\n    virDomainDeviceInfoClear(&def->info);\n    VIR_FREE(def->virtio);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainControllerInsert",
          "args": [
            "def",
            "l_controller"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainControllerInsertPreAlloced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17752-17801",
          "snippet": "void virDomainControllerInsertPreAlloced(virDomainDefPtr def,\n                                         virDomainControllerDefPtr controller)\n{\n    int idx;\n    /* Tentatively plan to insert controller at the end. */\n    int insertAt = -1;\n    virDomainControllerDefPtr current = NULL;\n\n    /* Then work backwards looking for controllers of\n     * the same type. If we find a controller with a\n     * index greater than the new one, insert at\n     * that position\n     */\n    for (idx = (def->ncontrollers - 1); idx >= 0; idx--) {\n        current = def->controllers[idx];\n        if (current->type == controller->type) {\n            if (controller->idx == -1) {\n                /* If the new controller doesn't have an index set\n                 * yet, put it just past this controller, which until\n                 * now was the last controller of this type.\n                 */\n                insertAt = idx + 1;\n                break;\n            }\n            if (current->idx > controller->idx) {\n                /* If bus matches and current controller is after\n                 * new controller, then new controller should go here\n                 * */\n                insertAt = idx;\n            } else if (controller->info.mastertype == VIR_DOMAIN_CONTROLLER_MASTER_NONE &&\n                       current->info.mastertype != VIR_DOMAIN_CONTROLLER_MASTER_NONE &&\n                       current->idx == controller->idx) {\n                /* If bus matches and index matches and new controller is\n                 * master and current isn't a master, then new controller\n                 * should go here to be placed before its companion\n                 */\n                insertAt = idx;\n            } else if (insertAt == -1) {\n                /* Last controller with match bus is before the\n                 * new controller, then put new controller just after\n                 */\n                insertAt = idx + 1;\n            }\n        }\n    }\n\n    /* VIR_INSERT_ELEMENT_INPLACE will never return an error here. */\n    ignore_value(VIR_INSERT_ELEMENT_INPLACE(def->controllers, insertAt,\n                                            def->ncontrollers, controller));\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainControllerInsertPreAlloced(virDomainDefPtr def,\n                                         virDomainControllerDefPtr controller)\n{\n    int idx;\n    /* Tentatively plan to insert controller at the end. */\n    int insertAt = -1;\n    virDomainControllerDefPtr current = NULL;\n\n    /* Then work backwards looking for controllers of\n     * the same type. If we find a controller with a\n     * index greater than the new one, insert at\n     * that position\n     */\n    for (idx = (def->ncontrollers - 1); idx >= 0; idx--) {\n        current = def->controllers[idx];\n        if (current->type == controller->type) {\n            if (controller->idx == -1) {\n                /* If the new controller doesn't have an index set\n                 * yet, put it just past this controller, which until\n                 * now was the last controller of this type.\n                 */\n                insertAt = idx + 1;\n                break;\n            }\n            if (current->idx > controller->idx) {\n                /* If bus matches and current controller is after\n                 * new controller, then new controller should go here\n                 * */\n                insertAt = idx;\n            } else if (controller->info.mastertype == VIR_DOMAIN_CONTROLLER_MASTER_NONE &&\n                       current->info.mastertype != VIR_DOMAIN_CONTROLLER_MASTER_NONE &&\n                       current->idx == controller->idx) {\n                /* If bus matches and index matches and new controller is\n                 * master and current isn't a master, then new controller\n                 * should go here to be placed before its companion\n                 */\n                insertAt = idx;\n            } else if (insertAt == -1) {\n                /* Last controller with match bus is before the\n                 * new controller, then put new controller just after\n                 */\n                insertAt = idx + 1;\n            }\n        }\n    }\n\n    /* VIR_INSERT_ELEMENT_INPLACE will never return an error here. */\n    ignore_value(VIR_INSERT_ELEMENT_INPLACE(def->controllers, insertAt,\n                                            def->ncontrollers, controller));\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMakeUSBController",
          "args": [
            "l_controller",
            "&x_controllers[i]"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeUSBControllerList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "2108-2152",
          "snippet": "static int\nlibxlMakeUSBControllerList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainControllerDefPtr *l_controllers = def->controllers;\n    size_t ncontrollers = def->ncontrollers;\n    size_t nusbctrls = 0;\n    libxl_device_usbctrl *x_usbctrls;\n    size_t i, j;\n\n    for (i = 0; i < ncontrollers; i++) {\n        if (l_controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB)\n            nusbctrls++;\n    }\n\n    if (nusbctrls == 0)\n        return libxlMakeDefaultUSBControllers(def, d_config);\n\n    if (VIR_ALLOC_N(x_usbctrls, nusbctrls) < 0)\n        return -1;\n\n    for (i = 0, j = 0; i < ncontrollers && j < nusbctrls; i++) {\n        if (l_controllers[i]->type != VIR_DOMAIN_CONTROLLER_TYPE_USB)\n            continue;\n\n        libxl_device_usbctrl_init(&x_usbctrls[j]);\n\n        if (libxlMakeUSBController(l_controllers[i],\n                                   &x_usbctrls[j]) < 0)\n            goto error;\n\n        j++;\n    }\n\n    d_config->usbctrls = x_usbctrls;\n    d_config->num_usbctrls = nusbctrls;\n\n    return 0;\n\n error:\n    for (i = 0; i < nusbctrls; i++)\n        libxl_device_usbctrl_dispose(&x_usbctrls[i]);\n\n    VIR_FREE(x_usbctrls);\n    return -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeUSBControllerList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainControllerDefPtr *l_controllers = def->controllers;\n    size_t ncontrollers = def->ncontrollers;\n    size_t nusbctrls = 0;\n    libxl_device_usbctrl *x_usbctrls;\n    size_t i, j;\n\n    for (i = 0; i < ncontrollers; i++) {\n        if (l_controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB)\n            nusbctrls++;\n    }\n\n    if (nusbctrls == 0)\n        return libxlMakeDefaultUSBControllers(def, d_config);\n\n    if (VIR_ALLOC_N(x_usbctrls, nusbctrls) < 0)\n        return -1;\n\n    for (i = 0, j = 0; i < ncontrollers && j < nusbctrls; i++) {\n        if (l_controllers[i]->type != VIR_DOMAIN_CONTROLLER_TYPE_USB)\n            continue;\n\n        libxl_device_usbctrl_init(&x_usbctrls[j]);\n\n        if (libxlMakeUSBController(l_controllers[i],\n                                   &x_usbctrls[j]) < 0)\n            goto error;\n\n        j++;\n    }\n\n    d_config->usbctrls = x_usbctrls;\n    d_config->num_usbctrls = nusbctrls;\n\n    return 0;\n\n error:\n    for (i = 0; i < nusbctrls; i++)\n        libxl_device_usbctrl_dispose(&x_usbctrls[i]);\n\n    VIR_FREE(x_usbctrls);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_device_usbctrl_init",
          "args": [
            "&x_controllers[i]"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainControllerDefNew",
          "args": [
            "VIR_DOMAIN_CONTROLLER_TYPE_USB"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainControllerDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2216-2259",
          "snippet": "virDomainControllerDefPtr\nvirDomainControllerDefNew(virDomainControllerType type)\n{\n    virDomainControllerDefPtr def;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->type = type;\n\n    /* initialize anything that has a non-0 default */\n    def->model = -1;\n    def->idx = -1;\n\n    switch ((virDomainControllerType) def->type) {\n    case VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL:\n        def->opts.vioserial.ports = -1;\n        def->opts.vioserial.vectors = -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n        def->opts.usbopts.ports = -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n        def->opts.pciopts.chassisNr = -1;\n        def->opts.pciopts.chassis = -1;\n        def->opts.pciopts.port = -1;\n        def->opts.pciopts.busNr = -1;\n        def->opts.pciopts.targetIndex = -1;\n        def->opts.pciopts.numaNode = -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_XENBUS:\n        def->opts.xenbusopts.maxGrantFrames = -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_IDE:\n    case VIR_DOMAIN_CONTROLLER_TYPE_FDC:\n    case VIR_DOMAIN_CONTROLLER_TYPE_SCSI:\n    case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n    case VIR_DOMAIN_CONTROLLER_TYPE_CCID:\n    case VIR_DOMAIN_CONTROLLER_TYPE_LAST:\n        break;\n    }\n\n    return def;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainControllerDefPtr\nvirDomainControllerDefNew(virDomainControllerType type)\n{\n    virDomainControllerDefPtr def;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->type = type;\n\n    /* initialize anything that has a non-0 default */\n    def->model = -1;\n    def->idx = -1;\n\n    switch ((virDomainControllerType) def->type) {\n    case VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL:\n        def->opts.vioserial.ports = -1;\n        def->opts.vioserial.vectors = -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n        def->opts.usbopts.ports = -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n        def->opts.pciopts.chassisNr = -1;\n        def->opts.pciopts.chassis = -1;\n        def->opts.pciopts.port = -1;\n        def->opts.pciopts.busNr = -1;\n        def->opts.pciopts.targetIndex = -1;\n        def->opts.pciopts.numaNode = -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_XENBUS:\n        def->opts.xenbusopts.maxGrantFrames = -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_IDE:\n    case VIR_DOMAIN_CONTROLLER_TYPE_FDC:\n    case VIR_DOMAIN_CONTROLLER_TYPE_SCSI:\n    case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n    case VIR_DOMAIN_CONTROLLER_TYPE_CCID:\n    case VIR_DOMAIN_CONTROLLER_TYPE_LAST:\n        break;\n    }\n\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "x_controllers",
            "ncontrollers"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "nusbdevs",
            "8"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeDefaultUSBControllers(virDomainDefPtr def,\n                               libxl_domain_config *d_config)\n{\n    virDomainControllerDefPtr l_controller = NULL;\n    libxl_device_usbctrl *x_controllers = NULL;\n    size_t nusbdevs = 0;\n    size_t ncontrollers;\n    size_t i;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            nusbdevs++;\n    }\n\n    /* No controllers needed if there are no USB devs */\n    if (nusbdevs == 0)\n        return 0;\n\n    /* Create USB controllers with 8 ports */\n    ncontrollers = VIR_DIV_UP(nusbdevs, 8);\n    if (VIR_ALLOC_N(x_controllers, ncontrollers) < 0)\n        return -1;\n\n    for (i = 0; i < ncontrollers; i++) {\n        if (!(l_controller = virDomainControllerDefNew(VIR_DOMAIN_CONTROLLER_TYPE_USB)))\n            goto error;\n\n        l_controller->model = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2;\n        l_controller->idx = i;\n        l_controller->opts.usbopts.ports = 8;\n\n        libxl_device_usbctrl_init(&x_controllers[i]);\n\n        if (libxlMakeUSBController(l_controller, &x_controllers[i]) < 0)\n            goto error;\n\n        if (virDomainControllerInsert(def, l_controller) < 0)\n            goto error;\n\n        l_controller = NULL;\n    }\n\n    d_config->usbctrls = x_controllers;\n    d_config->num_usbctrls = ncontrollers;\n    return 0;\n\n error:\n     virDomainControllerDefFree(l_controller);\n     for (i = 0; i < ncontrollers; i++)\n         libxl_device_usbctrl_dispose(&x_controllers[i]);\n     VIR_FREE(x_controllers);\n     return -1;\n}"
  },
  {
    "function_name": "libxlMakeUSBController",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "2013-2050",
    "snippet": "int\nlibxlMakeUSBController(virDomainControllerDefPtr controller,\n                       libxl_device_usbctrl *usbctrl)\n{\n    usbctrl->devid = controller->idx;\n\n    if (controller->type != VIR_DOMAIN_CONTROLLER_TYPE_USB)\n        return -1;\n\n    if (controller->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT) {\n        usbctrl->version = 2;\n        usbctrl->type = LIBXL_USBCTRL_TYPE_QUSB;\n    } else {\n        switch (controller->model) {\n        case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1:\n            usbctrl->version = 1;\n            usbctrl->type = LIBXL_USBCTRL_TYPE_QUSB;\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2:\n            usbctrl->version = 2;\n            usbctrl->type = LIBXL_USBCTRL_TYPE_QUSB;\n            break;\n\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported usb model\"));\n            return -1;\n        }\n    }\n\n    if (controller->opts.usbopts.ports == -1)\n        usbctrl->ports = 8;\n    else\n        usbctrl->ports = controller->opts.usbopts.ports;\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unsupported usb model\")"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported usb model\""
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nint\nlibxlMakeUSBController(virDomainControllerDefPtr controller,\n                       libxl_device_usbctrl *usbctrl)\n{\n    usbctrl->devid = controller->idx;\n\n    if (controller->type != VIR_DOMAIN_CONTROLLER_TYPE_USB)\n        return -1;\n\n    if (controller->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT) {\n        usbctrl->version = 2;\n        usbctrl->type = LIBXL_USBCTRL_TYPE_QUSB;\n    } else {\n        switch (controller->model) {\n        case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1:\n            usbctrl->version = 1;\n            usbctrl->type = LIBXL_USBCTRL_TYPE_QUSB;\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2:\n            usbctrl->version = 2;\n            usbctrl->type = LIBXL_USBCTRL_TYPE_QUSB;\n            break;\n\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported usb model\"));\n            return -1;\n        }\n    }\n\n    if (controller->opts.usbopts.ports == -1)\n        usbctrl->ports = 8;\n    else\n        usbctrl->ports = controller->opts.usbopts.ports;\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlMakeChannelList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "1972-2009",
    "snippet": "static int\nlibxlMakeChannelList(const char *channelDir,\n                     virDomainDefPtr def,\n                     libxl_domain_config *d_config)\n{\n    virDomainChrDefPtr *l_channels = def->channels;\n    size_t nchannels = def->nchannels;\n    libxl_device_channel *x_channels;\n    size_t i, nvchannels = 0;\n\n    if (VIR_ALLOC_N(x_channels, nchannels) < 0)\n        return -1;\n\n    for (i = 0; i < nchannels; i++) {\n        if (l_channels[i]->deviceType != VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL)\n            continue;\n\n        if (libxlPrepareChannel(l_channels[i], channelDir, def->name) < 0)\n            goto error;\n\n        if (libxlMakeChannel(l_channels[i], &x_channels[nvchannels]) < 0)\n            goto error;\n\n        nvchannels++;\n    }\n\n    VIR_SHRINK_N(x_channels, nchannels, nchannels - nvchannels);\n    d_config->channels = x_channels;\n    d_config->num_channels = nvchannels;\n\n    return 0;\n\n error:\n    for (i = 0; i < nchannels; i++)\n        libxl_device_channel_dispose(&x_channels[i]);\n    VIR_FREE(x_channels);\n    return -1;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "x_channels"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_device_channel_dispose",
          "args": [
            "&x_channels[i]"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SHRINK_N",
          "args": [
            "x_channels",
            "nchannels",
            "nchannels - nvchannels"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlMakeChannel",
          "args": [
            "l_channels[i]",
            "&x_channels[nvchannels]"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeChannel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1935-1970",
          "snippet": "static int\nlibxlMakeChannel(virDomainChrDefPtr l_channel,\n                 libxl_device_channel *x_channel)\n{\n    libxl_device_channel_init(x_channel);\n\n    if (l_channel->targetType != VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"channel target type not supported\"));\n        return -1;\n    }\n\n    switch (l_channel->source->type) {\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        x_channel->connection = LIBXL_CHANNEL_CONNECTION_PTY;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        x_channel->connection = LIBXL_CHANNEL_CONNECTION_SOCKET;\n        x_channel->u.socket.path = g_strdup(l_channel->source->data.nix.path);\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"channel source type not supported\"));\n        break;\n    }\n\n    if (!l_channel->target.name) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"channel target name missing\"));\n        return -1;\n    }\n\n    x_channel->name = g_strdup(l_channel->target.name);\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeChannel(virDomainChrDefPtr l_channel,\n                 libxl_device_channel *x_channel)\n{\n    libxl_device_channel_init(x_channel);\n\n    if (l_channel->targetType != VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"channel target type not supported\"));\n        return -1;\n    }\n\n    switch (l_channel->source->type) {\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        x_channel->connection = LIBXL_CHANNEL_CONNECTION_PTY;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        x_channel->connection = LIBXL_CHANNEL_CONNECTION_SOCKET;\n        x_channel->u.socket.path = g_strdup(l_channel->source->data.nix.path);\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"channel source type not supported\"));\n        break;\n    }\n\n    if (!l_channel->target.name) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"channel target name missing\"));\n        return -1;\n    }\n\n    x_channel->name = g_strdup(l_channel->target.name);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlPrepareChannel",
          "args": [
            "l_channels[i]",
            "channelDir",
            "def->name"
          ],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "libxlPrepareChannel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1914-1933",
          "snippet": "static int\nlibxlPrepareChannel(virDomainChrDefPtr channel,\n                    const char *channelDir,\n                    const char *domainName)\n{\n    if (channel->targetType == VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN &&\n        channel->source->type == VIR_DOMAIN_CHR_TYPE_UNIX &&\n        !channel->source->data.nix.path) {\n        const char *target = channel->target.name;\n        if (!target)\n            target = \"unknown.sock\";\n        channel->source->data.nix.path = g_strdup_printf(\"%s/%s-%s\", channelDir,\n                                                         domainName,\n                                                         target);\n\n        channel->source->data.nix.listen = true;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlPrepareChannel(virDomainChrDefPtr channel,\n                    const char *channelDir,\n                    const char *domainName)\n{\n    if (channel->targetType == VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN &&\n        channel->source->type == VIR_DOMAIN_CHR_TYPE_UNIX &&\n        !channel->source->data.nix.path) {\n        const char *target = channel->target.name;\n        if (!target)\n            target = \"unknown.sock\";\n        channel->source->data.nix.path = g_strdup_printf(\"%s/%s-%s\", channelDir,\n                                                         domainName,\n                                                         target);\n\n        channel->source->data.nix.listen = true;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "x_channels",
            "nchannels"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeChannelList(const char *channelDir,\n                     virDomainDefPtr def,\n                     libxl_domain_config *d_config)\n{\n    virDomainChrDefPtr *l_channels = def->channels;\n    size_t nchannels = def->nchannels;\n    libxl_device_channel *x_channels;\n    size_t i, nvchannels = 0;\n\n    if (VIR_ALLOC_N(x_channels, nchannels) < 0)\n        return -1;\n\n    for (i = 0; i < nchannels; i++) {\n        if (l_channels[i]->deviceType != VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL)\n            continue;\n\n        if (libxlPrepareChannel(l_channels[i], channelDir, def->name) < 0)\n            goto error;\n\n        if (libxlMakeChannel(l_channels[i], &x_channels[nvchannels]) < 0)\n            goto error;\n\n        nvchannels++;\n    }\n\n    VIR_SHRINK_N(x_channels, nchannels, nchannels - nvchannels);\n    d_config->channels = x_channels;\n    d_config->num_channels = nvchannels;\n\n    return 0;\n\n error:\n    for (i = 0; i < nchannels; i++)\n        libxl_device_channel_dispose(&x_channels[i]);\n    VIR_FREE(x_channels);\n    return -1;\n}"
  },
  {
    "function_name": "libxlMakeChannel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "1935-1970",
    "snippet": "static int\nlibxlMakeChannel(virDomainChrDefPtr l_channel,\n                 libxl_device_channel *x_channel)\n{\n    libxl_device_channel_init(x_channel);\n\n    if (l_channel->targetType != VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"channel target type not supported\"));\n        return -1;\n    }\n\n    switch (l_channel->source->type) {\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        x_channel->connection = LIBXL_CHANNEL_CONNECTION_PTY;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        x_channel->connection = LIBXL_CHANNEL_CONNECTION_SOCKET;\n        x_channel->u.socket.path = g_strdup(l_channel->source->data.nix.path);\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"channel source type not supported\"));\n        break;\n    }\n\n    if (!l_channel->target.name) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"channel target name missing\"));\n        return -1;\n    }\n\n    x_channel->name = g_strdup(l_channel->target.name);\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "l_channel->target.name"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"channel target name missing\")"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"channel target name missing\""
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"channel source type not supported\")"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"channel target type not supported\")"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_device_channel_init",
          "args": [
            "x_channel"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeChannel(virDomainChrDefPtr l_channel,\n                 libxl_device_channel *x_channel)\n{\n    libxl_device_channel_init(x_channel);\n\n    if (l_channel->targetType != VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"channel target type not supported\"));\n        return -1;\n    }\n\n    switch (l_channel->source->type) {\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        x_channel->connection = LIBXL_CHANNEL_CONNECTION_PTY;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        x_channel->connection = LIBXL_CHANNEL_CONNECTION_SOCKET;\n        x_channel->u.socket.path = g_strdup(l_channel->source->data.nix.path);\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"channel source type not supported\"));\n        break;\n    }\n\n    if (!l_channel->target.name) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"channel target name missing\"));\n        return -1;\n    }\n\n    x_channel->name = g_strdup(l_channel->target.name);\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlPrepareChannel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "1914-1933",
    "snippet": "static int\nlibxlPrepareChannel(virDomainChrDefPtr channel,\n                    const char *channelDir,\n                    const char *domainName)\n{\n    if (channel->targetType == VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN &&\n        channel->source->type == VIR_DOMAIN_CHR_TYPE_UNIX &&\n        !channel->source->data.nix.path) {\n        const char *target = channel->target.name;\n        if (!target)\n            target = \"unknown.sock\";\n        channel->source->data.nix.path = g_strdup_printf(\"%s/%s-%s\", channelDir,\n                                                         domainName,\n                                                         target);\n\n        channel->source->data.nix.listen = true;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s-%s\"",
            "channelDir",
            "domainName",
            "target"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlPrepareChannel(virDomainChrDefPtr channel,\n                    const char *channelDir,\n                    const char *domainName)\n{\n    if (channel->targetType == VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN &&\n        channel->source->type == VIR_DOMAIN_CHR_TYPE_UNIX &&\n        !channel->source->data.nix.path) {\n        const char *target = channel->target.name;\n        if (!target)\n            target = \"unknown.sock\";\n        channel->source->data.nix.path = g_strdup_printf(\"%s/%s-%s\", channelDir,\n                                                         domainName,\n                                                         target);\n\n        channel->source->data.nix.listen = true;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlDriverGetDom0MaxmemConf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "1840-1910",
    "snippet": "int\nlibxlDriverGetDom0MaxmemConf(libxlDriverConfigPtr cfg,\n                             unsigned long long *maxmem)\n{\n    char **cmd_tokens = NULL;\n    char **mem_tokens = NULL;\n    size_t i;\n    size_t j;\n    libxl_physinfo physinfo;\n    int ret = -1;\n\n    if (cfg->verInfo->commandline == NULL ||\n        !(cmd_tokens = virStringSplit(cfg->verInfo->commandline, \" \", 0)))\n        goto physmem;\n\n    for (i = 0; cmd_tokens[i] != NULL; i++) {\n        if (!STRPREFIX(cmd_tokens[i], \"dom0_mem=\"))\n            continue;\n\n        if (!(mem_tokens = virStringSplit(cmd_tokens[i], \",\", 0)))\n            break;\n        for (j = 0; mem_tokens[j] != NULL; j++) {\n            if (STRPREFIX(mem_tokens[j], \"max:\")) {\n                char *p = mem_tokens[j] + 4;\n                unsigned long long multiplier = 1;\n\n                while (g_ascii_isdigit(*p))\n                    p++;\n                if (virStrToLong_ull(mem_tokens[j] + 4, &p, 10, maxmem) < 0)\n                    break;\n                if (*p) {\n                    switch (*p) {\n                    case 'm':\n                    case 'M':\n                        multiplier = 1024;\n                        break;\n                    case 'g':\n                    case 'G':\n                        multiplier = 1024 * 1024;\n                        break;\n                    case 't':\n                    case 'T':\n                        multiplier = 1024 * 1024 * 1024;\n                        break;\n                    }\n                }\n                *maxmem = *maxmem * multiplier;\n                ret = 0;\n                goto cleanup;\n            }\n        }\n        virStringListFree(mem_tokens);\n        mem_tokens = NULL;\n    }\n\n physmem:\n    /* No 'max' specified in dom0_mem, so dom0 can use all physical memory */\n    libxl_physinfo_init(&physinfo);\n    if (libxl_get_physinfo(cfg->ctx, &physinfo)) {\n        VIR_WARN(\"libxl_get_physinfo failed\");\n        goto cleanup;\n    }\n    *maxmem = (physinfo.total_pages * cfg->verInfo->pagesize) / 1024;\n    libxl_physinfo_dispose(&physinfo);\n    ret = 0;\n\n cleanup:\n    virStringListFree(cmd_tokens);\n    virStringListFree(mem_tokens);\n    return ret;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "mem_tokens"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_physinfo_dispose",
          "args": [
            "&physinfo"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"libxl_get_physinfo failed\""
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_get_physinfo",
          "args": [
            "cfg->ctx",
            "&physinfo"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_physinfo_init",
          "args": [
            "&physinfo"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ull",
          "args": [
            "mem_tokens[j] + 4",
            "&p",
            "10",
            "maxmem"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ullp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "568-586",
          "snippet": "int\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_ascii_isdigit",
          "args": [
            "*p"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "mem_tokens[j]",
            "\"max:\""
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSplit",
          "args": [
            "cmd_tokens[i]",
            "\",\"",
            "0"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "126-132",
          "snippet": "char **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "cmd_tokens[i]",
            "\"dom0_mem=\""
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nint\nlibxlDriverGetDom0MaxmemConf(libxlDriverConfigPtr cfg,\n                             unsigned long long *maxmem)\n{\n    char **cmd_tokens = NULL;\n    char **mem_tokens = NULL;\n    size_t i;\n    size_t j;\n    libxl_physinfo physinfo;\n    int ret = -1;\n\n    if (cfg->verInfo->commandline == NULL ||\n        !(cmd_tokens = virStringSplit(cfg->verInfo->commandline, \" \", 0)))\n        goto physmem;\n\n    for (i = 0; cmd_tokens[i] != NULL; i++) {\n        if (!STRPREFIX(cmd_tokens[i], \"dom0_mem=\"))\n            continue;\n\n        if (!(mem_tokens = virStringSplit(cmd_tokens[i], \",\", 0)))\n            break;\n        for (j = 0; mem_tokens[j] != NULL; j++) {\n            if (STRPREFIX(mem_tokens[j], \"max:\")) {\n                char *p = mem_tokens[j] + 4;\n                unsigned long long multiplier = 1;\n\n                while (g_ascii_isdigit(*p))\n                    p++;\n                if (virStrToLong_ull(mem_tokens[j] + 4, &p, 10, maxmem) < 0)\n                    break;\n                if (*p) {\n                    switch (*p) {\n                    case 'm':\n                    case 'M':\n                        multiplier = 1024;\n                        break;\n                    case 'g':\n                    case 'G':\n                        multiplier = 1024 * 1024;\n                        break;\n                    case 't':\n                    case 'T':\n                        multiplier = 1024 * 1024 * 1024;\n                        break;\n                    }\n                }\n                *maxmem = *maxmem * multiplier;\n                ret = 0;\n                goto cleanup;\n            }\n        }\n        virStringListFree(mem_tokens);\n        mem_tokens = NULL;\n    }\n\n physmem:\n    /* No 'max' specified in dom0_mem, so dom0 can use all physical memory */\n    libxl_physinfo_init(&physinfo);\n    if (libxl_get_physinfo(cfg->ctx, &physinfo)) {\n        VIR_WARN(\"libxl_get_physinfo failed\");\n        goto cleanup;\n    }\n    *maxmem = (physinfo.total_pages * cfg->verInfo->pagesize) / 1024;\n    libxl_physinfo_dispose(&physinfo);\n    ret = 0;\n\n cleanup:\n    virStringListFree(cmd_tokens);\n    virStringListFree(mem_tokens);\n    return ret;\n}"
  },
  {
    "function_name": "libxlDriverConfigLoadFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "1794-1827",
    "snippet": "int libxlDriverConfigLoadFile(libxlDriverConfigPtr cfg,\n                              const char *filename)\n{\n    g_autoptr(virConf) conf = NULL;\n\n    /* Check the file is readable before opening it, otherwise\n     * libvirt emits an error.\n     */\n    if (access(filename, R_OK) == -1) {\n        VIR_INFO(\"Could not read libxl config file %s\", filename);\n        return 0;\n    }\n\n    if (!(conf = virConfReadFile(filename, 0)))\n        return -1;\n\n    /* setup autoballoon */\n    if (libxlGetAutoballoonConf(cfg, conf) < 0)\n        return -1;\n\n    if (virConfGetValueString(conf, \"lock_manager\", &cfg->lockManagerName) < 0)\n        return -1;\n\n    if (virConfGetValueInt(conf, \"keepalive_interval\", &cfg->keepAliveInterval) < 0)\n        return -1;\n\n    if (virConfGetValueUInt(conf, \"keepalive_count\", &cfg->keepAliveCount) < 0)\n        return -1;\n\n    if (virConfGetValueBool(conf, \"nested_hvm\", &cfg->nested_hvm) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virConfGetValueBool",
          "args": [
            "conf",
            "\"nested_hvm\"",
            "&cfg->nested_hvm"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueBool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1002-1031",
          "snippet": "int virConfGetValueBool(virConfPtr conf,\n                        const char *setting,\n                        bool *value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value bool %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_ULLONG) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a bool for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    if (((unsigned long long)cval->l) > 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: value for '%s' parameter must be 0 or 1\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    *value = cval->l == 1;\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueBool(virConfPtr conf,\n                        const char *setting,\n                        bool *value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value bool %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_ULLONG) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a bool for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    if (((unsigned long long)cval->l) > 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: value for '%s' parameter must be 0 or 1\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    *value = cval->l == 1;\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValueUInt",
          "args": [
            "conf",
            "\"keepalive_count\"",
            "&cfg->keepAliveCount"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueUInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1099-1128",
          "snippet": "int virConfGetValueUInt(virConfPtr conf,\n                        const char *setting,\n                        unsigned int *value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value uint %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_ULLONG) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected an unsigned integer for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    if (((unsigned long long)cval->l) > UINT_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: value for '%s' parameter must be in range 0:%u\"),\n                       conf->filename, setting, UINT_MAX);\n        return -1;\n    }\n\n    *value = (unsigned int)cval->l;\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueUInt(virConfPtr conf,\n                        const char *setting,\n                        unsigned int *value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value uint %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_ULLONG) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected an unsigned integer for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    if (((unsigned long long)cval->l) > UINT_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: value for '%s' parameter must be in range 0:%u\"),\n                       conf->filename, setting, UINT_MAX);\n        return -1;\n    }\n\n    *value = (unsigned int)cval->l;\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValueInt",
          "args": [
            "conf",
            "\"keepalive_interval\"",
            "&cfg->keepAliveInterval"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1050-1080",
          "snippet": "int virConfGetValueInt(virConfPtr conf,\n                       const char *setting,\n                       int *value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value int %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_LLONG &&\n        cval->type != VIR_CONF_ULLONG) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a signed integer for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    if (cval->l > INT_MAX || cval->l < INT_MIN) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: value for '%s' parameter must be in range %d:%d\"),\n                       conf->filename, setting, INT_MIN, INT_MAX);\n        return -1;\n    }\n\n    *value = (int)cval->l;\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueInt(virConfPtr conf,\n                       const char *setting,\n                       int *value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value int %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_LLONG &&\n        cval->type != VIR_CONF_ULLONG) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a signed integer for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    if (cval->l > INT_MAX || cval->l < INT_MIN) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: value for '%s' parameter must be in range %d:%d\"),\n                       conf->filename, setting, INT_MIN, INT_MAX);\n        return -1;\n    }\n\n    *value = (int)cval->l;\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValueString",
          "args": [
            "conf",
            "\"lock_manager\"",
            "&cfg->lockManagerName"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "875-898",
          "snippet": "int virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlGetAutoballoonConf",
          "args": [
            "cfg",
            "conf"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "libxlGetAutoballoonConf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1659-1683",
          "snippet": "static int\nlibxlGetAutoballoonConf(libxlDriverConfigPtr cfg,\n                        virConfPtr conf)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    int res;\n\n    res = virConfGetValueBool(conf, \"autoballoon\", &cfg->autoballoon);\n    if (res < 0)\n        return -1;\n    else if (res == 1)\n        return 0;\n\n    regex = g_regex_new(\"(^| )dom0_mem=((|min:|max:)[0-9]+[bBkKmMgG]?,?)+($| )\",\n                        0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    cfg->autoballoon = !g_regex_match(regex, cfg->verInfo->commandline, 0, NULL);\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlGetAutoballoonConf(libxlDriverConfigPtr cfg,\n                        virConfPtr conf)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    int res;\n\n    res = virConfGetValueBool(conf, \"autoballoon\", &cfg->autoballoon);\n    if (res < 0)\n        return -1;\n    else if (res == 1)\n        return 0;\n\n    regex = g_regex_new(\"(^| )dom0_mem=((|min:|max:)[0-9]+[bBkKmMgG]?,?)+($| )\",\n                        0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    cfg->autoballoon = !g_regex_match(regex, cfg->verInfo->commandline, 0, NULL);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfReadFile",
          "args": [
            "filename",
            "0"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "virConfReadFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "730-752",
          "snippet": "virConfPtr\nvirConfReadFile(const char *filename, unsigned int flags)\n{\n    char *content;\n    int len;\n    virConfPtr conf;\n\n    VIR_DEBUG(\"filename=%s\", NULLSTR(filename));\n\n    if (filename == NULL) {\n        virConfError(NULL, VIR_ERR_INVALID_ARG, __FUNCTION__);\n        return NULL;\n    }\n\n    if ((len = virFileReadAll(filename, MAX_CONFIG_FILE_SIZE, &content)) < 0)\n        return NULL;\n\n    conf = virConfParse(filename, content, len, flags);\n\n    VIR_FREE(content);\n\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_CONFIG_FILE_SIZE (1024*1024*10)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\n#define MAX_CONFIG_FILE_SIZE (1024*1024*10)\n\nvirConfPtr\nvirConfReadFile(const char *filename, unsigned int flags)\n{\n    char *content;\n    int len;\n    virConfPtr conf;\n\n    VIR_DEBUG(\"filename=%s\", NULLSTR(filename));\n\n    if (filename == NULL) {\n        virConfError(NULL, VIR_ERR_INVALID_ARG, __FUNCTION__);\n        return NULL;\n    }\n\n    if ((len = virFileReadAll(filename, MAX_CONFIG_FILE_SIZE, &content)) < 0)\n        return NULL;\n\n    conf = virConfParse(filename, content, len, flags);\n\n    VIR_FREE(content);\n\n    return conf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Could not read libxl config file %s\"",
            "filename"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "filename",
            "R_OK"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nint libxlDriverConfigLoadFile(libxlDriverConfigPtr cfg,\n                              const char *filename)\n{\n    g_autoptr(virConf) conf = NULL;\n\n    /* Check the file is readable before opening it, otherwise\n     * libvirt emits an error.\n     */\n    if (access(filename, R_OK) == -1) {\n        VIR_INFO(\"Could not read libxl config file %s\", filename);\n        return 0;\n    }\n\n    if (!(conf = virConfReadFile(filename, 0)))\n        return -1;\n\n    /* setup autoballoon */\n    if (libxlGetAutoballoonConf(cfg, conf) < 0)\n        return -1;\n\n    if (virConfGetValueString(conf, \"lock_manager\", &cfg->lockManagerName) < 0)\n        return -1;\n\n    if (virConfGetValueInt(conf, \"keepalive_interval\", &cfg->keepAliveInterval) < 0)\n        return -1;\n\n    if (virConfGetValueUInt(conf, \"keepalive_count\", &cfg->keepAliveCount) < 0)\n        return -1;\n\n    if (virConfGetValueBool(conf, \"nested_hvm\", &cfg->nested_hvm) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlDriverConfigGet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "1783-1792",
    "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libxlDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.h",
          "lines": "231-235",
          "snippet": "static inline void\nlibxlDriverUnlock(libxlDriverPrivatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"libxl_logger.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"virfirmware.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virchrdev.h\"",
            "#include \"virobject.h\"",
            "#include \"virportallocator.h\"",
            "#include \"configmake.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver);",
            "virDomainXMLOptionPtr\nlibxlCreateXMLConf(libxlDriverPrivatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libxl_logger.h\"\n#include \"libxl_capabilities.h\"\n#include \"virfirmware.h\"\n#include \"locking/lock_manager.h\"\n#include \"virhostdev.h\"\n#include \"virchrdev.h\"\n#include \"virobject.h\"\n#include \"virportallocator.h\"\n#include \"configmake.h\"\n#include \"capabilities.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <libxl.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver);\nvirDomainXMLOptionPtr\nlibxlCreateXMLConf(libxlDriverPrivatePtr driver);\n\nstatic inline void\nlibxlDriverUnlock(libxlDriverPrivatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "driver->config"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDriverLock",
          "args": [
            "driver"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.h",
          "lines": "225-229",
          "snippet": "static inline void\nlibxlDriverLock(libxlDriverPrivatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"libxl_logger.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"virfirmware.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virchrdev.h\"",
            "#include \"virobject.h\"",
            "#include \"virportallocator.h\"",
            "#include \"configmake.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver);",
            "virDomainXMLOptionPtr\nlibxlCreateXMLConf(libxlDriverPrivatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libxl_logger.h\"\n#include \"libxl_capabilities.h\"\n#include \"virfirmware.h\"\n#include \"locking/lock_manager.h\"\n#include \"virhostdev.h\"\n#include \"virchrdev.h\"\n#include \"virobject.h\"\n#include \"virportallocator.h\"\n#include \"configmake.h\"\n#include \"capabilities.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <libxl.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver);\nvirDomainXMLOptionPtr\nlibxlCreateXMLConf(libxlDriverPrivatePtr driver);\n\nstatic inline void\nlibxlDriverLock(libxlDriverPrivatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
  },
  {
    "function_name": "libxlDriverConfigInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "1740-1781",
    "snippet": "int\nlibxlDriverConfigInit(libxlDriverConfigPtr cfg)\n{\n    unsigned int free_mem;\n\n    if (virFileMakePath(cfg->logDir) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to create log dir '%s': %s\"),\n                       cfg->logDir,\n                       g_strerror(errno));\n        return -1;\n    }\n\n    cfg->logger = libxlLoggerNew(cfg->logDir, virLogGetDefaultPriority());\n    if (!cfg->logger) {\n        VIR_ERROR(_(\"cannot create logger for libxenlight, disabling driver\"));\n        return -1;\n    }\n\n    if (libxl_ctx_alloc(&cfg->ctx, LIBXL_VERSION, 0, (xentoollog_logger *)cfg->logger)) {\n        VIR_ERROR(_(\"cannot initialize libxenlight context, probably not \"\n                    \"running in a Xen Dom0, disabling driver\"));\n        return -1;\n    }\n\n    if ((cfg->verInfo = libxl_get_version_info(cfg->ctx)) == NULL) {\n        VIR_ERROR(_(\"cannot version information from libxenlight, \"\n                    \"disabling driver\"));\n        return -1;\n    }\n    cfg->version = (cfg->verInfo->xen_version_major * 1000000) +\n        (cfg->verInfo->xen_version_minor * 1000);\n\n    /* This will fill xenstore info about free and dom0 memory if missing,\n     * should be called before starting first domain */\n    if (libxl_get_free_memory(cfg->ctx, &free_mem)) {\n        VIR_ERROR(_(\"Unable to configure libxl's memory management parameters\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Unable to configure libxl's memory management parameters\")"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to configure libxl's memory management parameters\""
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_get_free_memory",
          "args": [
            "cfg->ctx",
            "&free_mem"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"cannot version information from libxenlight, \"\n                    \"disabling driver\")"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_get_version_info",
          "args": [
            "cfg->ctx"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"cannot initialize libxenlight context, probably not \"\n                    \"running in a Xen Dom0, disabling driver\")"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_ctx_alloc",
          "args": [
            "&cfg->ctx",
            "LIBXL_VERSION",
            "0",
            "(xentoollog_logger *)cfg->logger"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"cannot create logger for libxenlight, disabling driver\")"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlLoggerNew",
          "args": [
            "cfg->logDir",
            "virLogGetDefaultPriority()"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "libxlLoggerNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "133-173",
          "snippet": "libxlLoggerPtr\nlibxlLoggerNew(const char *logDir, virLogPriority minLevel)\n{\n    xentoollog_logger_libvirt logger;\n    libxlLoggerPtr logger_out = NULL;\n    char *path = NULL;\n\n    switch (minLevel) {\n    case VIR_LOG_DEBUG:\n        logger.minLevel = XTL_DEBUG;\n        break;\n    case VIR_LOG_INFO:\n        logger.minLevel = XTL_INFO;\n        break;\n    case VIR_LOG_WARN:\n        logger.minLevel = XTL_WARN;\n        break;\n    case VIR_LOG_ERROR:\n        logger.minLevel = XTL_ERROR;\n        break;\n    }\n    logger.logDir = logDir;\n\n    if ((logger.files = virHashCreate(3, libxlLoggerFileFree)) == NULL)\n        return NULL;\n\n    path = g_strdup_printf(\"%s/libxl-driver.log\", logDir);\n\n    if ((logger.defaultLogFile = fopen(path, \"a\")) == NULL)\n        goto error;\n\n    logger_out = XTL_NEW_LOGGER(libvirt, logger);\n\n cleanup:\n    VIR_FREE(path);\n    return logger_out;\n\n error:\n    virHashFree(logger.files);\n    goto cleanup;\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nlibxlLoggerPtr\nlibxlLoggerNew(const char *logDir, virLogPriority minLevel)\n{\n    xentoollog_logger_libvirt logger;\n    libxlLoggerPtr logger_out = NULL;\n    char *path = NULL;\n\n    switch (minLevel) {\n    case VIR_LOG_DEBUG:\n        logger.minLevel = XTL_DEBUG;\n        break;\n    case VIR_LOG_INFO:\n        logger.minLevel = XTL_INFO;\n        break;\n    case VIR_LOG_WARN:\n        logger.minLevel = XTL_WARN;\n        break;\n    case VIR_LOG_ERROR:\n        logger.minLevel = XTL_ERROR;\n        break;\n    }\n    logger.logDir = logDir;\n\n    if ((logger.files = virHashCreate(3, libxlLoggerFileFree)) == NULL)\n        return NULL;\n\n    path = g_strdup_printf(\"%s/libxl-driver.log\", logDir);\n\n    if ((logger.defaultLogFile = fopen(path, \"a\")) == NULL)\n        goto error;\n\n    logger_out = XTL_NEW_LOGGER(libvirt, logger);\n\n cleanup:\n    VIR_FREE(path);\n    return logger_out;\n\n error:\n    virHashFree(logger.files);\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogGetDefaultPriority",
          "args": [],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "virLogGetDefaultPriority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1063-1067",
          "snippet": "virLogPriority\nvirLogGetDefaultPriority(void)\n{\n    return virLogDefaultPriority;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLogPriority virLogDefaultPriority = VIR_LOG_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic virLogPriority virLogDefaultPriority = VIR_LOG_DEFAULT;\n\nvirLogPriority\nvirLogGetDefaultPriority(void)\n{\n    return virLogDefaultPriority;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to create log dir '%s': %s\")",
            "cfg->logDir",
            "g_strerror(errno)"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileMakePath",
          "args": [
            "cfg->logDir"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3076-3080",
          "snippet": "int\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nint\nlibxlDriverConfigInit(libxlDriverConfigPtr cfg)\n{\n    unsigned int free_mem;\n\n    if (virFileMakePath(cfg->logDir) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to create log dir '%s': %s\"),\n                       cfg->logDir,\n                       g_strerror(errno));\n        return -1;\n    }\n\n    cfg->logger = libxlLoggerNew(cfg->logDir, virLogGetDefaultPriority());\n    if (!cfg->logger) {\n        VIR_ERROR(_(\"cannot create logger for libxenlight, disabling driver\"));\n        return -1;\n    }\n\n    if (libxl_ctx_alloc(&cfg->ctx, LIBXL_VERSION, 0, (xentoollog_logger *)cfg->logger)) {\n        VIR_ERROR(_(\"cannot initialize libxenlight context, probably not \"\n                    \"running in a Xen Dom0, disabling driver\"));\n        return -1;\n    }\n\n    if ((cfg->verInfo = libxl_get_version_info(cfg->ctx)) == NULL) {\n        VIR_ERROR(_(\"cannot version information from libxenlight, \"\n                    \"disabling driver\"));\n        return -1;\n    }\n    cfg->version = (cfg->verInfo->xen_version_major * 1000000) +\n        (cfg->verInfo->xen_version_minor * 1000);\n\n    /* This will fill xenstore info about free and dom0 memory if missing,\n     * should be called before starting first domain */\n    if (libxl_get_free_memory(cfg->ctx, &free_mem)) {\n        VIR_ERROR(_(\"Unable to configure libxl's memory management parameters\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlDriverConfigNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "1685-1738",
    "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigNew(void)\n{\n    libxlDriverConfigPtr cfg;\n\n    if (libxlConfigInitialize() < 0)\n        return NULL;\n\n    if (!(cfg = virObjectNew(libxlDriverConfigClass)))\n        return NULL;\n\n    cfg->configBaseDir = g_strdup(LIBXL_CONFIG_BASE_DIR);\n    cfg->configDir = g_strdup(LIBXL_CONFIG_DIR);\n    cfg->autostartDir = g_strdup(LIBXL_AUTOSTART_DIR);\n    cfg->logDir = g_strdup(LIBXL_LOG_DIR);\n    cfg->stateDir = g_strdup(LIBXL_STATE_DIR);\n    cfg->libDir = g_strdup(LIBXL_LIB_DIR);\n    cfg->saveDir = g_strdup(LIBXL_SAVE_DIR);\n    cfg->autoDumpDir = g_strdup(LIBXL_DUMP_DIR);\n    cfg->channelDir = g_strdup(LIBXL_CHANNEL_DIR);\n\n#ifdef DEFAULT_LOADER_NVRAM\n    if (virFirmwareParseList(DEFAULT_LOADER_NVRAM,\n                             &cfg->firmwares,\n                             &cfg->nfirmwares) < 0)\n        goto error;\n\n#else\n    if (VIR_ALLOC_N(cfg->firmwares, 1) < 0)\n        goto error;\n    cfg->nfirmwares = 1;\n    if (VIR_ALLOC(cfg->firmwares[0]) < 0)\n        goto error;\n    cfg->firmwares[0]->name = g_strdup(LIBXL_FIRMWARE_DIR \"/ovmf.bin\");\n#endif\n\n    /* Always add hvmloader to firmwares */\n    if (VIR_REALLOC_N(cfg->firmwares, cfg->nfirmwares + 1) < 0)\n        goto error;\n    cfg->nfirmwares++;\n    if (VIR_ALLOC(cfg->firmwares[cfg->nfirmwares - 1]) < 0)\n        goto error;\n    cfg->firmwares[cfg->nfirmwares - 1]->name = g_strdup(LIBXL_FIRMWARE_DIR \"/hvmloader\");\n\n    /* defaults for keepalive messages */\n    cfg->keepAliveInterval = 5;\n    cfg->keepAliveCount = 5;\n\n    return cfg;\n\n error:\n    virObjectUnref(cfg);\n    return NULL;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr libxlDriverConfigClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "LIBXL_FIRMWARE_DIR \"/hvmloader\""
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "cfg->firmwares[cfg->nfirmwares - 1]"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "cfg->firmwares",
            "cfg->nfirmwares + 1"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "cfg->firmwares[0]"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "cfg->firmwares",
            "1"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirmwareParseList",
          "args": [
            "DEFAULT_LOADER_NVRAM",
            "&cfg->firmwares",
            "&cfg->nfirmwares"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "virFirmwareParseList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirmware.c",
          "lines": "92-133",
          "snippet": "int\nvirFirmwareParseList(const char *list,\n                     virFirmwarePtr **firmwares,\n                     size_t *nfirmwares)\n{\n    int ret = -1;\n    char **token;\n    size_t i, j;\n\n    if (!(token = virStringSplit(list, \":\", 0)))\n        goto cleanup;\n\n    for (i = 0; token[i]; i += 2) {\n        if (!token[i] || !token[i + 1] ||\n            STREQ(token[i], \"\") || STREQ(token[i + 1], \"\")) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid --with-loader-nvram list: %s\"),\n                           list);\n            goto cleanup;\n        }\n    }\n\n    if (i) {\n        if (VIR_ALLOC_N(*firmwares, i / 2) < 0)\n            goto cleanup;\n        *nfirmwares = i / 2;\n\n        for (j = 0; j < i / 2; j++) {\n            virFirmwarePtr *fws = *firmwares;\n\n            if (VIR_ALLOC(fws[j]) < 0)\n                goto cleanup;\n            fws[j]->name = g_strdup(token[2 * j]);\n            fws[j]->nvram = g_strdup(token[2 * j + 1]);\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virStringListFree(token);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfirmware.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfirmware.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirFirmwareParseList(const char *list,\n                     virFirmwarePtr **firmwares,\n                     size_t *nfirmwares)\n{\n    int ret = -1;\n    char **token;\n    size_t i, j;\n\n    if (!(token = virStringSplit(list, \":\", 0)))\n        goto cleanup;\n\n    for (i = 0; token[i]; i += 2) {\n        if (!token[i] || !token[i + 1] ||\n            STREQ(token[i], \"\") || STREQ(token[i + 1], \"\")) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid --with-loader-nvram list: %s\"),\n                           list);\n            goto cleanup;\n        }\n    }\n\n    if (i) {\n        if (VIR_ALLOC_N(*firmwares, i / 2) < 0)\n            goto cleanup;\n        *nfirmwares = i / 2;\n\n        for (j = 0; j < i / 2; j++) {\n            virFirmwarePtr *fws = *firmwares;\n\n            if (VIR_ALLOC(fws[j]) < 0)\n                goto cleanup;\n            fws[j]->name = g_strdup(token[2 * j]);\n            fws[j]->nvram = g_strdup(token[2 * j + 1]);\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virStringListFree(token);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "libxlDriverConfigClass"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlConfigInitialize",
          "args": [],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic virClassPtr libxlDriverConfigClass;\n\nlibxlDriverConfigPtr\nlibxlDriverConfigNew(void)\n{\n    libxlDriverConfigPtr cfg;\n\n    if (libxlConfigInitialize() < 0)\n        return NULL;\n\n    if (!(cfg = virObjectNew(libxlDriverConfigClass)))\n        return NULL;\n\n    cfg->configBaseDir = g_strdup(LIBXL_CONFIG_BASE_DIR);\n    cfg->configDir = g_strdup(LIBXL_CONFIG_DIR);\n    cfg->autostartDir = g_strdup(LIBXL_AUTOSTART_DIR);\n    cfg->logDir = g_strdup(LIBXL_LOG_DIR);\n    cfg->stateDir = g_strdup(LIBXL_STATE_DIR);\n    cfg->libDir = g_strdup(LIBXL_LIB_DIR);\n    cfg->saveDir = g_strdup(LIBXL_SAVE_DIR);\n    cfg->autoDumpDir = g_strdup(LIBXL_DUMP_DIR);\n    cfg->channelDir = g_strdup(LIBXL_CHANNEL_DIR);\n\n#ifdef DEFAULT_LOADER_NVRAM\n    if (virFirmwareParseList(DEFAULT_LOADER_NVRAM,\n                             &cfg->firmwares,\n                             &cfg->nfirmwares) < 0)\n        goto error;\n\n#else\n    if (VIR_ALLOC_N(cfg->firmwares, 1) < 0)\n        goto error;\n    cfg->nfirmwares = 1;\n    if (VIR_ALLOC(cfg->firmwares[0]) < 0)\n        goto error;\n    cfg->firmwares[0]->name = g_strdup(LIBXL_FIRMWARE_DIR \"/ovmf.bin\");\n#endif\n\n    /* Always add hvmloader to firmwares */\n    if (VIR_REALLOC_N(cfg->firmwares, cfg->nfirmwares + 1) < 0)\n        goto error;\n    cfg->nfirmwares++;\n    if (VIR_ALLOC(cfg->firmwares[cfg->nfirmwares - 1]) < 0)\n        goto error;\n    cfg->firmwares[cfg->nfirmwares - 1]->name = g_strdup(LIBXL_FIRMWARE_DIR \"/hvmloader\");\n\n    /* defaults for keepalive messages */\n    cfg->keepAliveInterval = 5;\n    cfg->keepAliveCount = 5;\n\n    return cfg;\n\n error:\n    virObjectUnref(cfg);\n    return NULL;\n}"
  },
  {
    "function_name": "libxlGetAutoballoonConf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "1659-1683",
    "snippet": "static int\nlibxlGetAutoballoonConf(libxlDriverConfigPtr cfg,\n                        virConfPtr conf)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    int res;\n\n    res = virConfGetValueBool(conf, \"autoballoon\", &cfg->autoballoon);\n    if (res < 0)\n        return -1;\n    else if (res == 1)\n        return 0;\n\n    regex = g_regex_new(\"(^| )dom0_mem=((|min:|max:)[0-9]+[bBkKmMgG]?,?)+($| )\",\n                        0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    cfg->autoballoon = !g_regex_match(regex, cfg->verInfo->commandline, 0, NULL);\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_regex_match",
          "args": [
            "regex",
            "cfg->verInfo->commandline",
            "0",
            "NULL"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to compile regex %s\")",
            "err->message"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to compile regex %s\""
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_regex_new",
          "args": [
            "\"(^| )dom0_mem=((|min:|max:)[0-9]+[bBkKmMgG]?,?)+($| )\"",
            "0",
            "0",
            "&err"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfGetValueBool",
          "args": [
            "conf",
            "\"autoballoon\"",
            "&cfg->autoballoon"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueBool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1002-1031",
          "snippet": "int virConfGetValueBool(virConfPtr conf,\n                        const char *setting,\n                        bool *value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value bool %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_ULLONG) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a bool for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    if (((unsigned long long)cval->l) > 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: value for '%s' parameter must be 0 or 1\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    *value = cval->l == 1;\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueBool(virConfPtr conf,\n                        const char *setting,\n                        bool *value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value bool %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_ULLONG) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a bool for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    if (((unsigned long long)cval->l) > 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: value for '%s' parameter must be 0 or 1\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    *value = cval->l == 1;\n\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlGetAutoballoonConf(libxlDriverConfigPtr cfg,\n                        virConfPtr conf)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    int res;\n\n    res = virConfGetValueBool(conf, \"autoballoon\", &cfg->autoballoon);\n    if (res < 0)\n        return -1;\n    else if (res == 1)\n        return 0;\n\n    regex = g_regex_new(\"(^| )dom0_mem=((|min:|max:)[0-9]+[bBkKmMgG]?,?)+($| )\",\n                        0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    cfg->autoballoon = !g_regex_match(regex, cfg->verInfo->commandline, 0, NULL);\n    return 0;\n}"
  },
  {
    "function_name": "libxlMakeBuildInfoVfb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "1551-1651",
    "snippet": "static int\nlibxlMakeBuildInfoVfb(virPortAllocatorRangePtr graphicsports,\n                      virDomainDefPtr def,\n                      libxl_domain_config *d_config)\n{\n    libxl_domain_build_info *b_info = &d_config->b_info;\n    libxl_device_vfb x_vfb;\n    size_t i;\n\n    if (def->os.type != VIR_DOMAIN_OSTYPE_HVM)\n        return 0;\n\n    if (def->ngraphics == 0)\n        return 0;\n\n    /*\n     * Prefer SPICE, otherwise use first libxl_device_vfb device in\n     * libxl_domain_config->vfbs. Prior to calling this function,\n     */\n    for (i = 0; i < def->ngraphics; i++) {\n        virDomainGraphicsDefPtr l_vfb = def->graphics[i];\n        unsigned short port;\n        virDomainGraphicsListenDefPtr glisten = NULL;\n\n        if (l_vfb->type != VIR_DOMAIN_GRAPHICS_TYPE_SPICE)\n            continue;\n\n        libxl_defbool_set(&b_info->u.hvm.spice.enable, true);\n\n        if (l_vfb->data.spice.autoport) {\n            if (virPortAllocatorAcquire(graphicsports, &port) < 0)\n                return -1;\n            l_vfb->data.spice.port = port;\n        }\n        b_info->u.hvm.spice.port = l_vfb->data.spice.port;\n\n        if ((glisten = virDomainGraphicsGetListen(l_vfb, 0))) {\n            if (glisten->address) {\n                b_info->u.hvm.spice.host = g_strdup(glisten->address);\n            } else {\n                b_info->u.hvm.spice.host = g_strdup(VIR_LOOPBACK_IPV4_ADDR);\n                glisten->address = g_strdup(VIR_LOOPBACK_IPV4_ADDR);\n            }\n        }\n\n        b_info->u.hvm.keymap = g_strdup(l_vfb->data.spice.keymap);\n\n        if (l_vfb->data.spice.auth.passwd) {\n            b_info->u.hvm.spice.passwd = g_strdup(l_vfb->data.spice.auth.passwd);\n            libxl_defbool_set(&b_info->u.hvm.spice.disable_ticketing, false);\n        } else {\n            libxl_defbool_set(&b_info->u.hvm.spice.disable_ticketing, true);\n        }\n\n        switch (l_vfb->data.spice.mousemode) {\n            /* client mouse mode is default in xl.cfg */\n        case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_DEFAULT:\n        case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_CLIENT:\n            libxl_defbool_set(&b_info->u.hvm.spice.agent_mouse, true);\n            break;\n        case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_SERVER:\n            libxl_defbool_set(&b_info->u.hvm.spice.agent_mouse, false);\n            break;\n        case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_LAST:\n            break;\n        }\n\n#ifdef LIBXL_HAVE_SPICE_VDAGENT\n        if (l_vfb->data.spice.copypaste == VIR_TRISTATE_BOOL_YES) {\n            libxl_defbool_set(&b_info->u.hvm.spice.vdagent, true);\n            libxl_defbool_set(&b_info->u.hvm.spice.clipboard_sharing, true);\n        } else {\n            libxl_defbool_set(&b_info->u.hvm.spice.vdagent, false);\n            libxl_defbool_set(&b_info->u.hvm.spice.clipboard_sharing, false);\n        }\n#endif\n\n        return 0;\n    }\n\n    x_vfb = d_config->vfbs[0];\n\n    if (libxl_defbool_val(x_vfb.vnc.enable)) {\n        libxl_defbool_set(&b_info->u.hvm.vnc.enable, true);\n        b_info->u.hvm.vnc.listen = g_strdup(x_vfb.vnc.listen);\n        b_info->u.hvm.vnc.passwd = g_strdup(x_vfb.vnc.passwd);\n        b_info->u.hvm.vnc.display = x_vfb.vnc.display;\n        libxl_defbool_set(&b_info->u.hvm.vnc.findunused,\n                          libxl_defbool_val(x_vfb.vnc.findunused));\n    } else if (libxl_defbool_val(x_vfb.sdl.enable)) {\n        libxl_defbool_set(&b_info->u.hvm.sdl.enable, true);\n        libxl_defbool_set(&b_info->u.hvm.sdl.opengl,\n                          libxl_defbool_val(x_vfb.sdl.opengl));\n        b_info->u.hvm.sdl.display = g_strdup(x_vfb.sdl.display);\n        b_info->u.hvm.sdl.xauthority = g_strdup(x_vfb.sdl.xauthority);\n    }\n\n    b_info->u.hvm.keymap = g_strdup(x_vfb.keymap);\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "x_vfb.keymap"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.sdl.opengl",
            "libxl_defbool_val(x_vfb.sdl.opengl)"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_val",
          "args": [
            "x_vfb.sdl.opengl"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.sdl.enable",
            "true"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_val",
          "args": [
            "x_vfb.sdl.enable"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.vnc.findunused",
            "libxl_defbool_val(x_vfb.vnc.findunused)"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_val",
          "args": [
            "x_vfb.vnc.findunused"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.vnc.enable",
            "true"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_val",
          "args": [
            "x_vfb.vnc.enable"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.spice.clipboard_sharing",
            "false"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.spice.vdagent",
            "false"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.spice.clipboard_sharing",
            "true"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.spice.vdagent",
            "true"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.spice.agent_mouse",
            "false"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.spice.agent_mouse",
            "true"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.spice.disable_ticketing",
            "true"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.spice.disable_ticketing",
            "false"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsGetListen",
          "args": [
            "l_vfb",
            "0"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsGetListen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30357-30364",
          "snippet": "virDomainGraphicsListenDefPtr\nvirDomainGraphicsGetListen(virDomainGraphicsDefPtr def, size_t i)\n{\n    if (!def->listens || (def->nListens <= i))\n        return NULL;\n\n    return &def->listens[i];\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainGraphicsListenDefPtr\nvirDomainGraphicsGetListen(virDomainGraphicsDefPtr def, size_t i)\n{\n    if (!def->listens || (def->nListens <= i))\n        return NULL;\n\n    return &def->listens[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPortAllocatorAcquire",
          "args": [
            "graphicsports",
            "&port"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "virPortAllocatorAcquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virportallocator.c",
          "lines": "209-254",
          "snippet": "int\nvirPortAllocatorAcquire(const virPortAllocatorRange *range,\n                        unsigned short *port)\n{\n    int ret = -1;\n    size_t i;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    *port = 0;\n\n    if (!pa)\n        return -1;\n\n    virObjectLock(pa);\n\n    for (i = range->start; i <= range->end && !*port; i++) {\n        bool used = false, v6used = false;\n\n        if (virBitmapIsBitSet(pa->bitmap, i))\n            continue;\n\n        if (virPortAllocatorBindToPort(&v6used, i, AF_INET6) < 0 ||\n            virPortAllocatorBindToPort(&used, i, AF_INET) < 0)\n            goto cleanup;\n\n        if (!used && !v6used) {\n            /* Add port to bitmap of reserved ports */\n            if (virBitmapSetBit(pa->bitmap, i) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to reserve port %zu\"), i);\n                goto cleanup;\n            }\n            *port = i;\n            ret = 0;\n        }\n    }\n\n    if (*port == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find an unused port in range '%s' (%d-%d)\"),\n                       range->name, range->start, range->end);\n    }\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virsocket.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virportallocator.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virsocket.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPortAllocatorAcquire(const virPortAllocatorRange *range,\n                        unsigned short *port)\n{\n    int ret = -1;\n    size_t i;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    *port = 0;\n\n    if (!pa)\n        return -1;\n\n    virObjectLock(pa);\n\n    for (i = range->start; i <= range->end && !*port; i++) {\n        bool used = false, v6used = false;\n\n        if (virBitmapIsBitSet(pa->bitmap, i))\n            continue;\n\n        if (virPortAllocatorBindToPort(&v6used, i, AF_INET6) < 0 ||\n            virPortAllocatorBindToPort(&used, i, AF_INET) < 0)\n            goto cleanup;\n\n        if (!used && !v6used) {\n            /* Add port to bitmap of reserved ports */\n            if (virBitmapSetBit(pa->bitmap, i) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to reserve port %zu\"), i);\n                goto cleanup;\n            }\n            *port = i;\n            ret = 0;\n        }\n    }\n\n    if (*port == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find an unused port in range '%s' (%d-%d)\"),\n                       range->name, range->start, range->end);\n    }\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.spice.enable",
            "true"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeBuildInfoVfb(virPortAllocatorRangePtr graphicsports,\n                      virDomainDefPtr def,\n                      libxl_domain_config *d_config)\n{\n    libxl_domain_build_info *b_info = &d_config->b_info;\n    libxl_device_vfb x_vfb;\n    size_t i;\n\n    if (def->os.type != VIR_DOMAIN_OSTYPE_HVM)\n        return 0;\n\n    if (def->ngraphics == 0)\n        return 0;\n\n    /*\n     * Prefer SPICE, otherwise use first libxl_device_vfb device in\n     * libxl_domain_config->vfbs. Prior to calling this function,\n     */\n    for (i = 0; i < def->ngraphics; i++) {\n        virDomainGraphicsDefPtr l_vfb = def->graphics[i];\n        unsigned short port;\n        virDomainGraphicsListenDefPtr glisten = NULL;\n\n        if (l_vfb->type != VIR_DOMAIN_GRAPHICS_TYPE_SPICE)\n            continue;\n\n        libxl_defbool_set(&b_info->u.hvm.spice.enable, true);\n\n        if (l_vfb->data.spice.autoport) {\n            if (virPortAllocatorAcquire(graphicsports, &port) < 0)\n                return -1;\n            l_vfb->data.spice.port = port;\n        }\n        b_info->u.hvm.spice.port = l_vfb->data.spice.port;\n\n        if ((glisten = virDomainGraphicsGetListen(l_vfb, 0))) {\n            if (glisten->address) {\n                b_info->u.hvm.spice.host = g_strdup(glisten->address);\n            } else {\n                b_info->u.hvm.spice.host = g_strdup(VIR_LOOPBACK_IPV4_ADDR);\n                glisten->address = g_strdup(VIR_LOOPBACK_IPV4_ADDR);\n            }\n        }\n\n        b_info->u.hvm.keymap = g_strdup(l_vfb->data.spice.keymap);\n\n        if (l_vfb->data.spice.auth.passwd) {\n            b_info->u.hvm.spice.passwd = g_strdup(l_vfb->data.spice.auth.passwd);\n            libxl_defbool_set(&b_info->u.hvm.spice.disable_ticketing, false);\n        } else {\n            libxl_defbool_set(&b_info->u.hvm.spice.disable_ticketing, true);\n        }\n\n        switch (l_vfb->data.spice.mousemode) {\n            /* client mouse mode is default in xl.cfg */\n        case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_DEFAULT:\n        case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_CLIENT:\n            libxl_defbool_set(&b_info->u.hvm.spice.agent_mouse, true);\n            break;\n        case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_SERVER:\n            libxl_defbool_set(&b_info->u.hvm.spice.agent_mouse, false);\n            break;\n        case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_LAST:\n            break;\n        }\n\n#ifdef LIBXL_HAVE_SPICE_VDAGENT\n        if (l_vfb->data.spice.copypaste == VIR_TRISTATE_BOOL_YES) {\n            libxl_defbool_set(&b_info->u.hvm.spice.vdagent, true);\n            libxl_defbool_set(&b_info->u.hvm.spice.clipboard_sharing, true);\n        } else {\n            libxl_defbool_set(&b_info->u.hvm.spice.vdagent, false);\n            libxl_defbool_set(&b_info->u.hvm.spice.clipboard_sharing, false);\n        }\n#endif\n\n        return 0;\n    }\n\n    x_vfb = d_config->vfbs[0];\n\n    if (libxl_defbool_val(x_vfb.vnc.enable)) {\n        libxl_defbool_set(&b_info->u.hvm.vnc.enable, true);\n        b_info->u.hvm.vnc.listen = g_strdup(x_vfb.vnc.listen);\n        b_info->u.hvm.vnc.passwd = g_strdup(x_vfb.vnc.passwd);\n        b_info->u.hvm.vnc.display = x_vfb.vnc.display;\n        libxl_defbool_set(&b_info->u.hvm.vnc.findunused,\n                          libxl_defbool_val(x_vfb.vnc.findunused));\n    } else if (libxl_defbool_val(x_vfb.sdl.enable)) {\n        libxl_defbool_set(&b_info->u.hvm.sdl.enable, true);\n        libxl_defbool_set(&b_info->u.hvm.sdl.opengl,\n                          libxl_defbool_val(x_vfb.sdl.opengl));\n        b_info->u.hvm.sdl.display = g_strdup(x_vfb.sdl.display);\n        b_info->u.hvm.sdl.xauthority = g_strdup(x_vfb.sdl.xauthority);\n    }\n\n    b_info->u.hvm.keymap = g_strdup(x_vfb.keymap);\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlMakeVfbList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "1502-1544",
    "snippet": "static int\nlibxlMakeVfbList(virPortAllocatorRangePtr graphicsports,\n                 virDomainDefPtr def,\n                 libxl_domain_config *d_config)\n{\n    virDomainGraphicsDefPtr *l_vfbs = def->graphics;\n    int nvfbs = def->ngraphics;\n    libxl_device_vfb *x_vfbs;\n    libxl_device_vkb *x_vkbs;\n    size_t i;\n\n    if (nvfbs == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(x_vfbs, nvfbs) < 0)\n        return -1;\n    if (VIR_ALLOC_N(x_vkbs, nvfbs) < 0) {\n        VIR_FREE(x_vfbs);\n        return -1;\n    }\n\n    for (i = 0; i < nvfbs; i++) {\n        libxl_device_vkb_init(&x_vkbs[i]);\n\n        if (libxlMakeVfb(graphicsports, l_vfbs[i], &x_vfbs[i]) < 0)\n            goto error;\n    }\n\n    d_config->vfbs = x_vfbs;\n    d_config->vkbs = x_vkbs;\n    d_config->num_vfbs = d_config->num_vkbs = nvfbs;\n\n    return 0;\n\n error:\n    for (i = 0; i < nvfbs; i++) {\n        libxl_device_vfb_dispose(&x_vfbs[i]);\n        libxl_device_vkb_dispose(&x_vkbs[i]);\n    }\n    VIR_FREE(x_vfbs);\n    VIR_FREE(x_vkbs);\n    return -1;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "x_vkbs"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "x_vfbs"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_device_vkb_dispose",
          "args": [
            "&x_vkbs[i]"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_device_vfb_dispose",
          "args": [
            "&x_vfbs[i]"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlMakeVfb",
          "args": [
            "graphicsports",
            "l_vfbs[i]",
            "&x_vfbs[i]"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeVfbList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1502-1544",
          "snippet": "static int\nlibxlMakeVfbList(virPortAllocatorRangePtr graphicsports,\n                 virDomainDefPtr def,\n                 libxl_domain_config *d_config)\n{\n    virDomainGraphicsDefPtr *l_vfbs = def->graphics;\n    int nvfbs = def->ngraphics;\n    libxl_device_vfb *x_vfbs;\n    libxl_device_vkb *x_vkbs;\n    size_t i;\n\n    if (nvfbs == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(x_vfbs, nvfbs) < 0)\n        return -1;\n    if (VIR_ALLOC_N(x_vkbs, nvfbs) < 0) {\n        VIR_FREE(x_vfbs);\n        return -1;\n    }\n\n    for (i = 0; i < nvfbs; i++) {\n        libxl_device_vkb_init(&x_vkbs[i]);\n\n        if (libxlMakeVfb(graphicsports, l_vfbs[i], &x_vfbs[i]) < 0)\n            goto error;\n    }\n\n    d_config->vfbs = x_vfbs;\n    d_config->vkbs = x_vkbs;\n    d_config->num_vfbs = d_config->num_vkbs = nvfbs;\n\n    return 0;\n\n error:\n    for (i = 0; i < nvfbs; i++) {\n        libxl_device_vfb_dispose(&x_vfbs[i]);\n        libxl_device_vkb_dispose(&x_vkbs[i]);\n    }\n    VIR_FREE(x_vfbs);\n    VIR_FREE(x_vkbs);\n    return -1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "libxl_device_vkb_init",
          "args": [
            "&x_vkbs[i]"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "x_vfbs"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "x_vkbs",
            "nvfbs"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "x_vfbs",
            "nvfbs"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeVfbList(virPortAllocatorRangePtr graphicsports,\n                 virDomainDefPtr def,\n                 libxl_domain_config *d_config)\n{\n    virDomainGraphicsDefPtr *l_vfbs = def->graphics;\n    int nvfbs = def->ngraphics;\n    libxl_device_vfb *x_vfbs;\n    libxl_device_vkb *x_vkbs;\n    size_t i;\n\n    if (nvfbs == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(x_vfbs, nvfbs) < 0)\n        return -1;\n    if (VIR_ALLOC_N(x_vkbs, nvfbs) < 0) {\n        VIR_FREE(x_vfbs);\n        return -1;\n    }\n\n    for (i = 0; i < nvfbs; i++) {\n        libxl_device_vkb_init(&x_vkbs[i]);\n\n        if (libxlMakeVfb(graphicsports, l_vfbs[i], &x_vfbs[i]) < 0)\n            goto error;\n    }\n\n    d_config->vfbs = x_vfbs;\n    d_config->vkbs = x_vkbs;\n    d_config->num_vfbs = d_config->num_vkbs = nvfbs;\n\n    return 0;\n\n error:\n    for (i = 0; i < nvfbs; i++) {\n        libxl_device_vfb_dispose(&x_vfbs[i]);\n        libxl_device_vkb_dispose(&x_vkbs[i]);\n    }\n    VIR_FREE(x_vfbs);\n    VIR_FREE(x_vkbs);\n    return -1;\n}"
  },
  {
    "function_name": "libxlMakeVfb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "1446-1500",
    "snippet": "int\nlibxlMakeVfb(virPortAllocatorRangePtr graphicsports,\n             virDomainGraphicsDefPtr l_vfb,\n             libxl_device_vfb *x_vfb)\n{\n    unsigned short port;\n    virDomainGraphicsListenDefPtr glisten = NULL;\n\n    libxl_device_vfb_init(x_vfb);\n\n    switch (l_vfb->type) {\n        case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n            libxl_defbool_set(&x_vfb->sdl.enable, 1);\n            libxl_defbool_set(&x_vfb->vnc.enable, 0);\n            libxl_defbool_set(&x_vfb->sdl.opengl, 0);\n            x_vfb->sdl.display = g_strdup(l_vfb->data.sdl.display);\n            x_vfb->sdl.xauthority = g_strdup(l_vfb->data.sdl.xauth);\n            break;\n        case  VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n            libxl_defbool_set(&x_vfb->vnc.enable, 1);\n            libxl_defbool_set(&x_vfb->sdl.enable, 0);\n            /* driver handles selection of free port */\n            libxl_defbool_set(&x_vfb->vnc.findunused, 0);\n            if (l_vfb->data.vnc.autoport) {\n\n                if (virPortAllocatorAcquire(graphicsports, &port) < 0)\n                    return -1;\n                l_vfb->data.vnc.port = port;\n            }\n            x_vfb->vnc.display = l_vfb->data.vnc.port - LIBXL_VNC_PORT_MIN;\n\n            if ((glisten = virDomainGraphicsGetListen(l_vfb, 0))) {\n                if (glisten->address) {\n                    /* libxl_device_vfb_init() does g_strdup(\"127.0.0.1\") */\n                    VIR_FREE(x_vfb->vnc.listen);\n                    x_vfb->vnc.listen = g_strdup(glisten->address);\n                } else {\n                    glisten->address = g_strdup(VIR_LOOPBACK_IPV4_ADDR);\n                }\n            }\n\n            x_vfb->vnc.passwd = g_strdup(l_vfb->data.vnc.auth.passwd);\n            x_vfb->keymap = g_strdup(l_vfb->data.vnc.keymap);\n            break;\n\n        case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n        case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n        case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n        case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n            break;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "l_vfb->data.vnc.keymap"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "x_vfb->vnc.listen"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsGetListen",
          "args": [
            "l_vfb",
            "0"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsGetListen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30357-30364",
          "snippet": "virDomainGraphicsListenDefPtr\nvirDomainGraphicsGetListen(virDomainGraphicsDefPtr def, size_t i)\n{\n    if (!def->listens || (def->nListens <= i))\n        return NULL;\n\n    return &def->listens[i];\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainGraphicsListenDefPtr\nvirDomainGraphicsGetListen(virDomainGraphicsDefPtr def, size_t i)\n{\n    if (!def->listens || (def->nListens <= i))\n        return NULL;\n\n    return &def->listens[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPortAllocatorAcquire",
          "args": [
            "graphicsports",
            "&port"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "virPortAllocatorAcquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virportallocator.c",
          "lines": "209-254",
          "snippet": "int\nvirPortAllocatorAcquire(const virPortAllocatorRange *range,\n                        unsigned short *port)\n{\n    int ret = -1;\n    size_t i;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    *port = 0;\n\n    if (!pa)\n        return -1;\n\n    virObjectLock(pa);\n\n    for (i = range->start; i <= range->end && !*port; i++) {\n        bool used = false, v6used = false;\n\n        if (virBitmapIsBitSet(pa->bitmap, i))\n            continue;\n\n        if (virPortAllocatorBindToPort(&v6used, i, AF_INET6) < 0 ||\n            virPortAllocatorBindToPort(&used, i, AF_INET) < 0)\n            goto cleanup;\n\n        if (!used && !v6used) {\n            /* Add port to bitmap of reserved ports */\n            if (virBitmapSetBit(pa->bitmap, i) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to reserve port %zu\"), i);\n                goto cleanup;\n            }\n            *port = i;\n            ret = 0;\n        }\n    }\n\n    if (*port == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find an unused port in range '%s' (%d-%d)\"),\n                       range->name, range->start, range->end);\n    }\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virsocket.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virportallocator.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virsocket.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPortAllocatorAcquire(const virPortAllocatorRange *range,\n                        unsigned short *port)\n{\n    int ret = -1;\n    size_t i;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    *port = 0;\n\n    if (!pa)\n        return -1;\n\n    virObjectLock(pa);\n\n    for (i = range->start; i <= range->end && !*port; i++) {\n        bool used = false, v6used = false;\n\n        if (virBitmapIsBitSet(pa->bitmap, i))\n            continue;\n\n        if (virPortAllocatorBindToPort(&v6used, i, AF_INET6) < 0 ||\n            virPortAllocatorBindToPort(&used, i, AF_INET) < 0)\n            goto cleanup;\n\n        if (!used && !v6used) {\n            /* Add port to bitmap of reserved ports */\n            if (virBitmapSetBit(pa->bitmap, i) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to reserve port %zu\"), i);\n                goto cleanup;\n            }\n            *port = i;\n            ret = 0;\n        }\n    }\n\n    if (*port == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find an unused port in range '%s' (%d-%d)\"),\n                       range->name, range->start, range->end);\n    }\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&x_vfb->vnc.findunused",
            "0"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&x_vfb->sdl.enable",
            "0"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&x_vfb->vnc.enable",
            "1"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&x_vfb->sdl.opengl",
            "0"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&x_vfb->vnc.enable",
            "0"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&x_vfb->sdl.enable",
            "1"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_device_vfb_init",
          "args": [
            "x_vfb"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nint\nlibxlMakeVfb(virPortAllocatorRangePtr graphicsports,\n             virDomainGraphicsDefPtr l_vfb,\n             libxl_device_vfb *x_vfb)\n{\n    unsigned short port;\n    virDomainGraphicsListenDefPtr glisten = NULL;\n\n    libxl_device_vfb_init(x_vfb);\n\n    switch (l_vfb->type) {\n        case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n            libxl_defbool_set(&x_vfb->sdl.enable, 1);\n            libxl_defbool_set(&x_vfb->vnc.enable, 0);\n            libxl_defbool_set(&x_vfb->sdl.opengl, 0);\n            x_vfb->sdl.display = g_strdup(l_vfb->data.sdl.display);\n            x_vfb->sdl.xauthority = g_strdup(l_vfb->data.sdl.xauth);\n            break;\n        case  VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n            libxl_defbool_set(&x_vfb->vnc.enable, 1);\n            libxl_defbool_set(&x_vfb->sdl.enable, 0);\n            /* driver handles selection of free port */\n            libxl_defbool_set(&x_vfb->vnc.findunused, 0);\n            if (l_vfb->data.vnc.autoport) {\n\n                if (virPortAllocatorAcquire(graphicsports, &port) < 0)\n                    return -1;\n                l_vfb->data.vnc.port = port;\n            }\n            x_vfb->vnc.display = l_vfb->data.vnc.port - LIBXL_VNC_PORT_MIN;\n\n            if ((glisten = virDomainGraphicsGetListen(l_vfb, 0))) {\n                if (glisten->address) {\n                    /* libxl_device_vfb_init() does g_strdup(\"127.0.0.1\") */\n                    VIR_FREE(x_vfb->vnc.listen);\n                    x_vfb->vnc.listen = g_strdup(glisten->address);\n                } else {\n                    glisten->address = g_strdup(VIR_LOOPBACK_IPV4_ADDR);\n                }\n            }\n\n            x_vfb->vnc.passwd = g_strdup(l_vfb->data.vnc.auth.passwd);\n            x_vfb->keymap = g_strdup(l_vfb->data.vnc.keymap);\n            break;\n\n        case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n        case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n        case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n        case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n            break;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlMakeNicList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "1405-1444",
    "snippet": "static int\nlibxlMakeNicList(virDomainDefPtr def,  libxl_domain_config *d_config)\n{\n    virDomainNetDefPtr *l_nics = def->nets;\n    size_t nnics = def->nnets;\n    libxl_device_nic *x_nics;\n    size_t i, nvnics = 0;\n\n    if (VIR_ALLOC_N(x_nics, nnics) < 0)\n        return -1;\n\n    for (i = 0; i < nnics; i++) {\n        if (virDomainNetGetActualType(l_nics[i]) == VIR_DOMAIN_NET_TYPE_HOSTDEV)\n            continue;\n\n        if (libxlMakeNic(def, l_nics[i], &x_nics[nvnics], false))\n            goto error;\n        /*\n         * The devid (at least right now) will not get initialized by\n         * libxl in the setup case but is required for starting the\n         * device-model.\n         */\n        if (x_nics[nvnics].devid < 0)\n            x_nics[nvnics].devid = nvnics;\n\n        nvnics++;\n    }\n\n    VIR_SHRINK_N(x_nics, nnics, nnics - nvnics);\n    d_config->nics = x_nics;\n    d_config->num_nics = nvnics;\n\n    return 0;\n\n error:\n    for (i = 0; i < nnics; i++)\n        libxl_device_nic_dispose(&x_nics[i]);\n    VIR_FREE(x_nics);\n    return -1;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "x_nics"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_device_nic_dispose",
          "args": [
            "&x_nics[i]"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SHRINK_N",
          "args": [
            "x_nics",
            "nnics",
            "nnics - nvnics"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlMakeNic",
          "args": [
            "def",
            "l_nics[i]",
            "&x_nics[nvnics]",
            "false"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeNic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1193-1403",
          "snippet": "int\nlibxlMakeNic(virDomainDefPtr def,\n             virDomainNetDefPtr l_nic,\n             libxl_device_nic *x_nic,\n             bool attach)\n{\n    virDomainNetType actual_type = virDomainNetGetActualType(l_nic);\n    virNetworkPtr network = NULL;\n    virConnectPtr conn = NULL;\n    const virNetDevBandwidth *actual_bw;\n    const virNetDevVPortProfile *port_profile;\n    const virNetDevVlan *virt_vlan;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    const char *script = NULL;\n    int ret = -1;\n\n    /* TODO: Where is mtu stored?\n     *\n     * x_nics[i].mtu = 1492;\n     */\n\n    if (l_nic->script && !(actual_type == VIR_DOMAIN_NET_TYPE_BRIDGE ||\n                           actual_type == VIR_DOMAIN_NET_TYPE_ETHERNET)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"specifying a script is only supported with \"\n                         \"interface types bridge and ethernet\"));\n        return -1;\n    }\n\n    libxl_device_nic_init(x_nic);\n\n    virMacAddrGetRaw(&l_nic->mac, x_nic->mac);\n\n    /*\n     * The nictype field of libxl_device_nic structure tells Xen which type of\n     * NIC device to create for the domain. LIBXL_NIC_TYPE_VIF specifies a\n     * PV NIC. LIBXL_NIC_TYPE_VIF_IOEMU specifies a PV and emulated NIC,\n     * allowing the domain to choose which NIC to use and unplug the unused\n     * one. LIBXL_NIC_TYPE_VIF_IOEMU is only valid for HVM domains. Further,\n     * if hotplugging the NIC, emulated NICs are currently not supported.\n     * Alternatively one could set LIBXL_NIC_TYPE_UNKNOWN and let libxl decide,\n     * but its behaviour might not be consistent across all libvirt supported\n     * versions. The other nictype values are well established already, hence\n     * we manually select our own default and mimic xl/libxl behaviour starting\n     * xen commit 32e9d0f (\"libxl: nic type defaults to vif in hotplug for\n     * hvm guest\").\n     */\n    if (virDomainNetGetModelString(l_nic)) {\n        if ((def->os.type == VIR_DOMAIN_OSTYPE_XEN ||\n            def->os.type == VIR_DOMAIN_OSTYPE_XENPVH) &&\n            l_nic->model != VIR_DOMAIN_NET_MODEL_NETFRONT) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only model 'netfront' is supported for \"\n                             \"Xen PV(H) domains\"));\n            return -1;\n        }\n        x_nic->model = g_strdup(virDomainNetGetModelString(l_nic));\n        if (l_nic->model == VIR_DOMAIN_NET_MODEL_NETFRONT)\n            x_nic->nictype = LIBXL_NIC_TYPE_VIF;\n        else\n            x_nic->nictype = LIBXL_NIC_TYPE_VIF_IOEMU;\n    } else {\n        if (def->os.type == VIR_DOMAIN_OSTYPE_HVM && !attach)\n            x_nic->nictype = LIBXL_NIC_TYPE_VIF_IOEMU;\n        else\n            x_nic->nictype = LIBXL_NIC_TYPE_VIF;\n    }\n\n    x_nic->ifname = g_strdup(l_nic->ifname);\n\n    port_profile = virDomainNetGetActualVirtPortProfile(l_nic);\n    virt_vlan = virDomainNetGetActualVlan(l_nic);\n    script = l_nic->script;\n    switch (actual_type) {\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n            virBufferAddStr(&buf, virDomainNetGetActualBridgeName(l_nic));\n            /*\n             * A bit of special handling if vif will be connected to an\n             * openvswitch bridge\n             */\n            if (port_profile &&\n                port_profile->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                /*\n                 * If a custom script is not specified for openvswitch, use\n                 * Xen's vif-openvswitch script\n                 */\n                if (!script)\n                    script = \"vif-openvswitch\";\n                /*\n                 * libxl_device_nic->bridge supports an extended format for\n                 * specifying VLAN tags and trunks when using openvswitch\n                 *\n                 * BRIDGE_NAME[.VLAN][:TRUNK:TRUNK]\n                 *\n                 * See Xen's networking wiki for more details\n                 * https://wiki.xenproject.org/wiki/Xen_Networking#Open_vSwitch\n                 */\n                if (virt_vlan && virt_vlan->nTags > 0) {\n                    if (virt_vlan->trunk) {\n                        for (i = 0; i < virt_vlan->nTags; i++)\n                            virBufferAsprintf(&buf, \":%d\", virt_vlan->tag[i]);\n                    } else {\n                        virBufferAsprintf(&buf, \".%d\", virt_vlan->tag[0]);\n                    }\n                }\n            }\n            x_nic->bridge = g_strdup(virBufferCurrentContent(&buf));\n            G_GNUC_FALLTHROUGH;\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            x_nic->script = g_strdup(script);\n            if (l_nic->guestIP.nips > 0) {\n                x_nic->ip = xenMakeIPList(&l_nic->guestIP);\n                if (!x_nic->ip)\n                    goto cleanup;\n            }\n            break;\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n        {\n            if (!(conn = virConnectOpen(\"xen:///system\")))\n                goto cleanup;\n\n            if (!(network =\n                  virNetworkLookupByName(conn, l_nic->data.network.name))) {\n                goto cleanup;\n            }\n\n            if (l_nic->guestIP.nips > 0) {\n                x_nic->ip = xenMakeIPList(&l_nic->guestIP);\n                if (!x_nic->ip)\n                    goto cleanup;\n            }\n\n            if (!(x_nic->bridge = virNetworkGetBridgeName(network)))\n                goto cleanup;\n            break;\n        }\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                    _(\"unsupported interface type %s\"),\n                    virDomainNetTypeToString(l_nic->type));\n            goto cleanup;\n    }\n\n    if (l_nic->domain_name) {\n#ifdef LIBXL_HAVE_DEVICE_BACKEND_DOMNAME\n        x_nic->backend_domname = g_strdup(l_nic->domain_name);\n#else\n        virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                _(\"this version of libxenlight does not \"\n                  \"support backend domain name\"));\n        goto cleanup;\n#endif\n    }\n\n    /*\n     * Set bandwidth.\n     * From $xen-sources/docs/misc/xl-network-configuration.markdown:\n     *\n     *\n     * Specifies the rate at which the outgoing traffic will be limited to.\n     * The default if this keyword is not specified is unlimited.\n     *\n     * The rate may be specified as \"<RATE>/s\" or optionally \"<RATE>/s@<INTERVAL>\".\n     *\n     * `RATE` is in bytes and can accept suffixes:\n     *     GB, MB, KB, B for bytes.\n     *     Gb, Mb, Kb, b for bits.\n     * `INTERVAL` is in microseconds and can accept suffixes: ms, us, s.\n     *     It determines the frequency at which the vif transmission credit\n     *     is replenished. The default is 50ms.\n\n     * Vif rate limiting is credit-based. It means that for \"1MB/s@20ms\",\n     * the available credit will be equivalent of the traffic you would have\n     * done at \"1MB/s\" during 20ms. This will results in a credit of 20,000\n     * bytes replenished every 20,000 us.\n     *\n     *\n     * libvirt doesn't support the notion of rate limiting over an interval.\n     * Similar to xl's behavior when interval is not specified, set a default\n     * interval of 50ms and calculate the number of bytes per interval based\n     * on the specified average bandwidth.\n     */\n    actual_bw = virDomainNetGetActualBandwidth(l_nic);\n    if (actual_bw && actual_bw->out && actual_bw->out->average) {\n        uint64_t bytes_per_sec = actual_bw->out->average * 1024;\n        uint64_t bytes_per_interval =\n            (((uint64_t) bytes_per_sec * 50000UL) / 1000000UL);\n\n        x_nic->rate_bytes_per_interval = bytes_per_interval;\n        x_nic->rate_interval_usecs =  50000UL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    virObjectUnref(network);\n    virObjectUnref(conn);\n\n    return ret;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nint\nlibxlMakeNic(virDomainDefPtr def,\n             virDomainNetDefPtr l_nic,\n             libxl_device_nic *x_nic,\n             bool attach)\n{\n    virDomainNetType actual_type = virDomainNetGetActualType(l_nic);\n    virNetworkPtr network = NULL;\n    virConnectPtr conn = NULL;\n    const virNetDevBandwidth *actual_bw;\n    const virNetDevVPortProfile *port_profile;\n    const virNetDevVlan *virt_vlan;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    const char *script = NULL;\n    int ret = -1;\n\n    /* TODO: Where is mtu stored?\n     *\n     * x_nics[i].mtu = 1492;\n     */\n\n    if (l_nic->script && !(actual_type == VIR_DOMAIN_NET_TYPE_BRIDGE ||\n                           actual_type == VIR_DOMAIN_NET_TYPE_ETHERNET)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"specifying a script is only supported with \"\n                         \"interface types bridge and ethernet\"));\n        return -1;\n    }\n\n    libxl_device_nic_init(x_nic);\n\n    virMacAddrGetRaw(&l_nic->mac, x_nic->mac);\n\n    /*\n     * The nictype field of libxl_device_nic structure tells Xen which type of\n     * NIC device to create for the domain. LIBXL_NIC_TYPE_VIF specifies a\n     * PV NIC. LIBXL_NIC_TYPE_VIF_IOEMU specifies a PV and emulated NIC,\n     * allowing the domain to choose which NIC to use and unplug the unused\n     * one. LIBXL_NIC_TYPE_VIF_IOEMU is only valid for HVM domains. Further,\n     * if hotplugging the NIC, emulated NICs are currently not supported.\n     * Alternatively one could set LIBXL_NIC_TYPE_UNKNOWN and let libxl decide,\n     * but its behaviour might not be consistent across all libvirt supported\n     * versions. The other nictype values are well established already, hence\n     * we manually select our own default and mimic xl/libxl behaviour starting\n     * xen commit 32e9d0f (\"libxl: nic type defaults to vif in hotplug for\n     * hvm guest\").\n     */\n    if (virDomainNetGetModelString(l_nic)) {\n        if ((def->os.type == VIR_DOMAIN_OSTYPE_XEN ||\n            def->os.type == VIR_DOMAIN_OSTYPE_XENPVH) &&\n            l_nic->model != VIR_DOMAIN_NET_MODEL_NETFRONT) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only model 'netfront' is supported for \"\n                             \"Xen PV(H) domains\"));\n            return -1;\n        }\n        x_nic->model = g_strdup(virDomainNetGetModelString(l_nic));\n        if (l_nic->model == VIR_DOMAIN_NET_MODEL_NETFRONT)\n            x_nic->nictype = LIBXL_NIC_TYPE_VIF;\n        else\n            x_nic->nictype = LIBXL_NIC_TYPE_VIF_IOEMU;\n    } else {\n        if (def->os.type == VIR_DOMAIN_OSTYPE_HVM && !attach)\n            x_nic->nictype = LIBXL_NIC_TYPE_VIF_IOEMU;\n        else\n            x_nic->nictype = LIBXL_NIC_TYPE_VIF;\n    }\n\n    x_nic->ifname = g_strdup(l_nic->ifname);\n\n    port_profile = virDomainNetGetActualVirtPortProfile(l_nic);\n    virt_vlan = virDomainNetGetActualVlan(l_nic);\n    script = l_nic->script;\n    switch (actual_type) {\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n            virBufferAddStr(&buf, virDomainNetGetActualBridgeName(l_nic));\n            /*\n             * A bit of special handling if vif will be connected to an\n             * openvswitch bridge\n             */\n            if (port_profile &&\n                port_profile->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                /*\n                 * If a custom script is not specified for openvswitch, use\n                 * Xen's vif-openvswitch script\n                 */\n                if (!script)\n                    script = \"vif-openvswitch\";\n                /*\n                 * libxl_device_nic->bridge supports an extended format for\n                 * specifying VLAN tags and trunks when using openvswitch\n                 *\n                 * BRIDGE_NAME[.VLAN][:TRUNK:TRUNK]\n                 *\n                 * See Xen's networking wiki for more details\n                 * https://wiki.xenproject.org/wiki/Xen_Networking#Open_vSwitch\n                 */\n                if (virt_vlan && virt_vlan->nTags > 0) {\n                    if (virt_vlan->trunk) {\n                        for (i = 0; i < virt_vlan->nTags; i++)\n                            virBufferAsprintf(&buf, \":%d\", virt_vlan->tag[i]);\n                    } else {\n                        virBufferAsprintf(&buf, \".%d\", virt_vlan->tag[0]);\n                    }\n                }\n            }\n            x_nic->bridge = g_strdup(virBufferCurrentContent(&buf));\n            G_GNUC_FALLTHROUGH;\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            x_nic->script = g_strdup(script);\n            if (l_nic->guestIP.nips > 0) {\n                x_nic->ip = xenMakeIPList(&l_nic->guestIP);\n                if (!x_nic->ip)\n                    goto cleanup;\n            }\n            break;\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n        {\n            if (!(conn = virConnectOpen(\"xen:///system\")))\n                goto cleanup;\n\n            if (!(network =\n                  virNetworkLookupByName(conn, l_nic->data.network.name))) {\n                goto cleanup;\n            }\n\n            if (l_nic->guestIP.nips > 0) {\n                x_nic->ip = xenMakeIPList(&l_nic->guestIP);\n                if (!x_nic->ip)\n                    goto cleanup;\n            }\n\n            if (!(x_nic->bridge = virNetworkGetBridgeName(network)))\n                goto cleanup;\n            break;\n        }\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                    _(\"unsupported interface type %s\"),\n                    virDomainNetTypeToString(l_nic->type));\n            goto cleanup;\n    }\n\n    if (l_nic->domain_name) {\n#ifdef LIBXL_HAVE_DEVICE_BACKEND_DOMNAME\n        x_nic->backend_domname = g_strdup(l_nic->domain_name);\n#else\n        virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                _(\"this version of libxenlight does not \"\n                  \"support backend domain name\"));\n        goto cleanup;\n#endif\n    }\n\n    /*\n     * Set bandwidth.\n     * From $xen-sources/docs/misc/xl-network-configuration.markdown:\n     *\n     *\n     * Specifies the rate at which the outgoing traffic will be limited to.\n     * The default if this keyword is not specified is unlimited.\n     *\n     * The rate may be specified as \"<RATE>/s\" or optionally \"<RATE>/s@<INTERVAL>\".\n     *\n     * `RATE` is in bytes and can accept suffixes:\n     *     GB, MB, KB, B for bytes.\n     *     Gb, Mb, Kb, b for bits.\n     * `INTERVAL` is in microseconds and can accept suffixes: ms, us, s.\n     *     It determines the frequency at which the vif transmission credit\n     *     is replenished. The default is 50ms.\n\n     * Vif rate limiting is credit-based. It means that for \"1MB/s@20ms\",\n     * the available credit will be equivalent of the traffic you would have\n     * done at \"1MB/s\" during 20ms. This will results in a credit of 20,000\n     * bytes replenished every 20,000 us.\n     *\n     *\n     * libvirt doesn't support the notion of rate limiting over an interval.\n     * Similar to xl's behavior when interval is not specified, set a default\n     * interval of 50ms and calculate the number of bytes per interval based\n     * on the specified average bandwidth.\n     */\n    actual_bw = virDomainNetGetActualBandwidth(l_nic);\n    if (actual_bw && actual_bw->out && actual_bw->out->average) {\n        uint64_t bytes_per_sec = actual_bw->out->average * 1024;\n        uint64_t bytes_per_interval =\n            (((uint64_t) bytes_per_sec * 50000UL) / 1000000UL);\n\n        x_nic->rate_bytes_per_interval = bytes_per_interval;\n        x_nic->rate_interval_usecs =  50000UL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    virObjectUnref(network);\n    virObjectUnref(conn);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualType",
          "args": [
            "l_nics[i]"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30154-30162",
          "snippet": "virDomainNetType\nvirDomainNetGetActualType(const virDomainNetDef *iface)\n{\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n    if (!iface->data.network.actual)\n        return iface->type;\n    return iface->data.network.actual->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainNetType\nvirDomainNetGetActualType(const virDomainNetDef *iface)\n{\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n    if (!iface->data.network.actual)\n        return iface->type;\n    return iface->data.network.actual->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "x_nics",
            "nnics"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeNicList(virDomainDefPtr def,  libxl_domain_config *d_config)\n{\n    virDomainNetDefPtr *l_nics = def->nets;\n    size_t nnics = def->nnets;\n    libxl_device_nic *x_nics;\n    size_t i, nvnics = 0;\n\n    if (VIR_ALLOC_N(x_nics, nnics) < 0)\n        return -1;\n\n    for (i = 0; i < nnics; i++) {\n        if (virDomainNetGetActualType(l_nics[i]) == VIR_DOMAIN_NET_TYPE_HOSTDEV)\n            continue;\n\n        if (libxlMakeNic(def, l_nics[i], &x_nics[nvnics], false))\n            goto error;\n        /*\n         * The devid (at least right now) will not get initialized by\n         * libxl in the setup case but is required for starting the\n         * device-model.\n         */\n        if (x_nics[nvnics].devid < 0)\n            x_nics[nvnics].devid = nvnics;\n\n        nvnics++;\n    }\n\n    VIR_SHRINK_N(x_nics, nnics, nnics - nvnics);\n    d_config->nics = x_nics;\n    d_config->num_nics = nvnics;\n\n    return 0;\n\n error:\n    for (i = 0; i < nnics; i++)\n        libxl_device_nic_dispose(&x_nics[i]);\n    VIR_FREE(x_nics);\n    return -1;\n}"
  },
  {
    "function_name": "libxlMakeNic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "1193-1403",
    "snippet": "int\nlibxlMakeNic(virDomainDefPtr def,\n             virDomainNetDefPtr l_nic,\n             libxl_device_nic *x_nic,\n             bool attach)\n{\n    virDomainNetType actual_type = virDomainNetGetActualType(l_nic);\n    virNetworkPtr network = NULL;\n    virConnectPtr conn = NULL;\n    const virNetDevBandwidth *actual_bw;\n    const virNetDevVPortProfile *port_profile;\n    const virNetDevVlan *virt_vlan;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    const char *script = NULL;\n    int ret = -1;\n\n    /* TODO: Where is mtu stored?\n     *\n     * x_nics[i].mtu = 1492;\n     */\n\n    if (l_nic->script && !(actual_type == VIR_DOMAIN_NET_TYPE_BRIDGE ||\n                           actual_type == VIR_DOMAIN_NET_TYPE_ETHERNET)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"specifying a script is only supported with \"\n                         \"interface types bridge and ethernet\"));\n        return -1;\n    }\n\n    libxl_device_nic_init(x_nic);\n\n    virMacAddrGetRaw(&l_nic->mac, x_nic->mac);\n\n    /*\n     * The nictype field of libxl_device_nic structure tells Xen which type of\n     * NIC device to create for the domain. LIBXL_NIC_TYPE_VIF specifies a\n     * PV NIC. LIBXL_NIC_TYPE_VIF_IOEMU specifies a PV and emulated NIC,\n     * allowing the domain to choose which NIC to use and unplug the unused\n     * one. LIBXL_NIC_TYPE_VIF_IOEMU is only valid for HVM domains. Further,\n     * if hotplugging the NIC, emulated NICs are currently not supported.\n     * Alternatively one could set LIBXL_NIC_TYPE_UNKNOWN and let libxl decide,\n     * but its behaviour might not be consistent across all libvirt supported\n     * versions. The other nictype values are well established already, hence\n     * we manually select our own default and mimic xl/libxl behaviour starting\n     * xen commit 32e9d0f (\"libxl: nic type defaults to vif in hotplug for\n     * hvm guest\").\n     */\n    if (virDomainNetGetModelString(l_nic)) {\n        if ((def->os.type == VIR_DOMAIN_OSTYPE_XEN ||\n            def->os.type == VIR_DOMAIN_OSTYPE_XENPVH) &&\n            l_nic->model != VIR_DOMAIN_NET_MODEL_NETFRONT) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only model 'netfront' is supported for \"\n                             \"Xen PV(H) domains\"));\n            return -1;\n        }\n        x_nic->model = g_strdup(virDomainNetGetModelString(l_nic));\n        if (l_nic->model == VIR_DOMAIN_NET_MODEL_NETFRONT)\n            x_nic->nictype = LIBXL_NIC_TYPE_VIF;\n        else\n            x_nic->nictype = LIBXL_NIC_TYPE_VIF_IOEMU;\n    } else {\n        if (def->os.type == VIR_DOMAIN_OSTYPE_HVM && !attach)\n            x_nic->nictype = LIBXL_NIC_TYPE_VIF_IOEMU;\n        else\n            x_nic->nictype = LIBXL_NIC_TYPE_VIF;\n    }\n\n    x_nic->ifname = g_strdup(l_nic->ifname);\n\n    port_profile = virDomainNetGetActualVirtPortProfile(l_nic);\n    virt_vlan = virDomainNetGetActualVlan(l_nic);\n    script = l_nic->script;\n    switch (actual_type) {\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n            virBufferAddStr(&buf, virDomainNetGetActualBridgeName(l_nic));\n            /*\n             * A bit of special handling if vif will be connected to an\n             * openvswitch bridge\n             */\n            if (port_profile &&\n                port_profile->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                /*\n                 * If a custom script is not specified for openvswitch, use\n                 * Xen's vif-openvswitch script\n                 */\n                if (!script)\n                    script = \"vif-openvswitch\";\n                /*\n                 * libxl_device_nic->bridge supports an extended format for\n                 * specifying VLAN tags and trunks when using openvswitch\n                 *\n                 * BRIDGE_NAME[.VLAN][:TRUNK:TRUNK]\n                 *\n                 * See Xen's networking wiki for more details\n                 * https://wiki.xenproject.org/wiki/Xen_Networking#Open_vSwitch\n                 */\n                if (virt_vlan && virt_vlan->nTags > 0) {\n                    if (virt_vlan->trunk) {\n                        for (i = 0; i < virt_vlan->nTags; i++)\n                            virBufferAsprintf(&buf, \":%d\", virt_vlan->tag[i]);\n                    } else {\n                        virBufferAsprintf(&buf, \".%d\", virt_vlan->tag[0]);\n                    }\n                }\n            }\n            x_nic->bridge = g_strdup(virBufferCurrentContent(&buf));\n            G_GNUC_FALLTHROUGH;\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            x_nic->script = g_strdup(script);\n            if (l_nic->guestIP.nips > 0) {\n                x_nic->ip = xenMakeIPList(&l_nic->guestIP);\n                if (!x_nic->ip)\n                    goto cleanup;\n            }\n            break;\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n        {\n            if (!(conn = virConnectOpen(\"xen:///system\")))\n                goto cleanup;\n\n            if (!(network =\n                  virNetworkLookupByName(conn, l_nic->data.network.name))) {\n                goto cleanup;\n            }\n\n            if (l_nic->guestIP.nips > 0) {\n                x_nic->ip = xenMakeIPList(&l_nic->guestIP);\n                if (!x_nic->ip)\n                    goto cleanup;\n            }\n\n            if (!(x_nic->bridge = virNetworkGetBridgeName(network)))\n                goto cleanup;\n            break;\n        }\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                    _(\"unsupported interface type %s\"),\n                    virDomainNetTypeToString(l_nic->type));\n            goto cleanup;\n    }\n\n    if (l_nic->domain_name) {\n#ifdef LIBXL_HAVE_DEVICE_BACKEND_DOMNAME\n        x_nic->backend_domname = g_strdup(l_nic->domain_name);\n#else\n        virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                _(\"this version of libxenlight does not \"\n                  \"support backend domain name\"));\n        goto cleanup;\n#endif\n    }\n\n    /*\n     * Set bandwidth.\n     * From $xen-sources/docs/misc/xl-network-configuration.markdown:\n     *\n     *\n     * Specifies the rate at which the outgoing traffic will be limited to.\n     * The default if this keyword is not specified is unlimited.\n     *\n     * The rate may be specified as \"<RATE>/s\" or optionally \"<RATE>/s@<INTERVAL>\".\n     *\n     * `RATE` is in bytes and can accept suffixes:\n     *     GB, MB, KB, B for bytes.\n     *     Gb, Mb, Kb, b for bits.\n     * `INTERVAL` is in microseconds and can accept suffixes: ms, us, s.\n     *     It determines the frequency at which the vif transmission credit\n     *     is replenished. The default is 50ms.\n\n     * Vif rate limiting is credit-based. It means that for \"1MB/s@20ms\",\n     * the available credit will be equivalent of the traffic you would have\n     * done at \"1MB/s\" during 20ms. This will results in a credit of 20,000\n     * bytes replenished every 20,000 us.\n     *\n     *\n     * libvirt doesn't support the notion of rate limiting over an interval.\n     * Similar to xl's behavior when interval is not specified, set a default\n     * interval of 50ms and calculate the number of bytes per interval based\n     * on the specified average bandwidth.\n     */\n    actual_bw = virDomainNetGetActualBandwidth(l_nic);\n    if (actual_bw && actual_bw->out && actual_bw->out->average) {\n        uint64_t bytes_per_sec = actual_bw->out->average * 1024;\n        uint64_t bytes_per_interval =\n            (((uint64_t) bytes_per_sec * 50000UL) / 1000000UL);\n\n        x_nic->rate_bytes_per_interval = bytes_per_interval;\n        x_nic->rate_interval_usecs =  50000UL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    virObjectUnref(network);\n    virObjectUnref(conn);\n\n    return ret;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "conn"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualBandwidth",
          "args": [
            "l_nic"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualBandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30257-30267",
          "snippet": "const virNetDevBandwidth *\nvirDomainNetGetActualBandwidth(const virDomainNetDef *iface)\n{\n    /* if there is an ActualNetDef, *always* return\n     * its bandwidth rather than the NetDef's bandwidth.\n     */\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual)\n        return iface->data.network.actual->bandwidth;\n    return iface->bandwidth;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevBandwidth *\nvirDomainNetGetActualBandwidth(const virDomainNetDef *iface)\n{\n    /* if there is an ActualNetDef, *always* return\n     * its bandwidth rather than the NetDef's bandwidth.\n     */\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual)\n        return iface->data.network.actual->bandwidth;\n    return iface->bandwidth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_DETAIL",
            "\"%s\"",
            "_(\"this version of libxenlight does not \"\n                  \"support backend domain name\")"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"this version of libxenlight does not \"\n                  \"support backend domain name\""
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "l_nic->domain_name"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unsupported interface type %s\")",
            "virDomainNetTypeToString(l_nic->type)"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetTypeToString",
          "args": [
            "l_nic->type"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkGetBridgeName",
          "args": [
            "network"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkGetBridgeName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-network.c",
          "lines": "827-851",
          "snippet": "char *\nvirNetworkGetBridgeName(virNetworkPtr network)\n{\n    virConnectPtr conn;\n    VIR_DEBUG(\"network=%p\", network);\n\n    virResetLastError();\n\n    virCheckNetworkReturn(network, NULL);\n    conn = network->conn;\n\n    if (conn->networkDriver && conn->networkDriver->networkGetBridgeName) {\n        char *ret;\n        ret = conn->networkDriver->networkGetBridgeName(network);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(network->conn);\n    return NULL;\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nchar *\nvirNetworkGetBridgeName(virNetworkPtr network)\n{\n    virConnectPtr conn;\n    VIR_DEBUG(\"network=%p\", network);\n\n    virResetLastError();\n\n    virCheckNetworkReturn(network, NULL);\n    conn = network->conn;\n\n    if (conn->networkDriver && conn->networkDriver->networkGetBridgeName) {\n        char *ret;\n        ret = conn->networkDriver->networkGetBridgeName(network);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(network->conn);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenMakeIPList",
          "args": [
            "&l_nic->guestIP"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "xenMakeIPList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1627-1647",
          "snippet": "char *\nxenMakeIPList(virNetDevIPInfoPtr guestIP)\n{\n    size_t i;\n    char **address_array;\n    char *ret = NULL;\n\n    if (VIR_ALLOC_N(address_array, guestIP->nips + 1) < 0)\n        return NULL;\n\n    for (i = 0; i < guestIP->nips; i++) {\n        address_array[i] = virSocketAddrFormat(&guestIP->ips[i]->address);\n        if (!address_array[i])\n            goto cleanup;\n    }\n    ret = virStringListJoin((const char**)address_array, \" \");\n\n cleanup:\n    virStringListFree(address_array);\n    return ret;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nxenMakeIPList(virNetDevIPInfoPtr guestIP)\n{\n    size_t i;\n    char **address_array;\n    char *ret = NULL;\n\n    if (VIR_ALLOC_N(address_array, guestIP->nips + 1) < 0)\n        return NULL;\n\n    for (i = 0; i < guestIP->nips; i++) {\n        address_array[i] = virSocketAddrFormat(&guestIP->ips[i]->address);\n        if (!address_array[i])\n            goto cleanup;\n    }\n    ret = virStringListJoin((const char**)address_array, \" \");\n\n cleanup:\n    virStringListFree(address_array);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkLookupByName",
          "args": [
            "conn",
            "l_nic->data.network.name"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkLookupByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-network.c",
          "lines": "287-310",
          "snippet": "virNetworkPtr\nvirNetworkLookupByName(virConnectPtr conn, const char *name)\n{\n    VIR_DEBUG(\"conn=%p, name=%s\", conn, NULLSTR(name));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(name, error);\n\n    if (conn->networkDriver && conn->networkDriver->networkLookupByName) {\n        virNetworkPtr ret;\n        ret = conn->networkDriver->networkLookupByName(conn, name);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirNetworkPtr\nvirNetworkLookupByName(virConnectPtr conn, const char *name)\n{\n    VIR_DEBUG(\"conn=%p, name=%s\", conn, NULLSTR(name));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(name, error);\n\n    if (conn->networkDriver && conn->networkDriver->networkLookupByName) {\n        virNetworkPtr ret;\n        ret = conn->networkDriver->networkLookupByName(conn, name);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectOpen",
          "args": [
            "\"xen:///system\""
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectOpenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "1181-1199",
          "snippet": "virConnectPtr\nvirConnectOpenReadOnly(const char *name)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s\", NULLSTR(name));\n    virResetLastError();\n    ret = virConnectOpenInternal(name, NULL, VIR_CONNECT_RO);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirConnectPtr\nvirConnectOpenReadOnly(const char *name)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s\", NULLSTR(name));\n    virResetLastError();\n    ret = virConnectOpenInternal(name, NULL, VIR_CONNECT_RO);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferCurrentContent",
          "args": [
            "&buf"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferCurrentContent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "222-233",
          "snippet": "const char *\nvirBufferCurrentContent(virBufferPtr buf)\n{\n    if (!buf)\n        return NULL;\n\n    if (!buf->str ||\n        buf->str->len == 0)\n        return \"\";\n\n    return buf->str->str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirBufferCurrentContent(virBufferPtr buf)\n{\n    if (!buf)\n        return NULL;\n\n    if (!buf->str ||\n        buf->str->len == 0)\n        return \"\";\n\n    return buf->str->str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\".%d\"",
            "virt_vlan->tag[0]"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddStr",
          "args": [
            "&buf",
            "virDomainNetGetActualBridgeName(l_nic)"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "718-736",
          "snippet": "void\nvirBufferAddStr(virBufferPtr buf,\n                const char *str)\n{\n    const char *end;\n\n    if (!buf || !str)\n        return;\n\n    while (*str) {\n        if ((end = strchr(str, '\\n'))) {\n            virBufferAdd(buf, str, (end - str) + 1);\n            str = end + 1;\n        } else {\n            virBufferAdd(buf, str, -1);\n            break;\n        }\n    }\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddStr(virBufferPtr buf,\n                const char *str)\n{\n    const char *end;\n\n    if (!buf || !str)\n        return;\n\n    while (*str) {\n        if ((end = strchr(str, '\\n'))) {\n            virBufferAdd(buf, str, (end - str) + 1);\n            str = end + 1;\n        } else {\n            virBufferAdd(buf, str, -1);\n            break;\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualBridgeName",
          "args": [
            "l_nic"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualBridgeName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30164-30175",
          "snippet": "const char *\nvirDomainNetGetActualBridgeName(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_BRIDGE)\n        return iface->data.bridge.brname;\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual &&\n        (iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_BRIDGE ||\n         iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_NETWORK))\n        return iface->data.network.actual->data.bridge.brname;\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainNetGetActualBridgeName(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_BRIDGE)\n        return iface->data.bridge.brname;\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual &&\n        (iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_BRIDGE ||\n         iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_NETWORK))\n        return iface->data.network.actual->data.bridge.brname;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualVlan",
          "args": [
            "l_nic"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualVlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30269-30284",
          "snippet": "const virNetDevVlan *\nvirDomainNetGetActualVlan(const virDomainNetDef *iface)\n{\n    const virNetDevVlan *vlan = &iface->vlan;\n\n    /* if there is an ActualNetDef, *always* return\n     * its vlan rather than the NetDef's vlan.\n     */\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual)\n        vlan = &iface->data.network.actual->vlan;\n\n    if (vlan->nTags > 0)\n        return vlan;\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevVlan *\nvirDomainNetGetActualVlan(const virDomainNetDef *iface)\n{\n    const virNetDevVlan *vlan = &iface->vlan;\n\n    /* if there is an ActualNetDef, *always* return\n     * its vlan rather than the NetDef's vlan.\n     */\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual)\n        vlan = &iface->data.network.actual->vlan;\n\n    if (vlan->nTags > 0)\n        return vlan;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualVirtPortProfile",
          "args": [
            "l_nic"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualVirtPortProfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30224-30255",
          "snippet": "const virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetModelString",
          "args": [
            "l_nic"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetModelString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30308-30314",
          "snippet": "const char *\nvirDomainNetGetModelString(const virDomainNetDef *net)\n{\n    if (net->model)\n        return virDomainNetModelTypeToString(net->model);\n    return net->modelstr;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainNetGetModelString(const virDomainNetDef *net)\n{\n    if (net->model)\n        return virDomainNetModelTypeToString(net->model);\n    return net->modelstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"only model 'netfront' is supported for \"\n                             \"Xen PV(H) domains\")"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrGetRaw",
          "args": [
            "&l_nic->mac",
            "x_nic->mac"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrGetRaw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "126-130",
          "snippet": "void\nvirMacAddrGetRaw(const virMacAddr *src, unsigned char dst[VIR_MAC_BUFLEN])\n{\n    memcpy(dst, src->addr, VIR_MAC_BUFLEN);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nvoid\nvirMacAddrGetRaw(const virMacAddr *src, unsigned char dst[VIR_MAC_BUFLEN])\n{\n    memcpy(dst, src->addr, VIR_MAC_BUFLEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_device_nic_init",
          "args": [
            "x_nic"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"specifying a script is only supported with \"\n                         \"interface types bridge and ethernet\")"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualType",
          "args": [
            "l_nic"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30154-30162",
          "snippet": "virDomainNetType\nvirDomainNetGetActualType(const virDomainNetDef *iface)\n{\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n    if (!iface->data.network.actual)\n        return iface->type;\n    return iface->data.network.actual->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainNetType\nvirDomainNetGetActualType(const virDomainNetDef *iface)\n{\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n    if (!iface->data.network.actual)\n        return iface->type;\n    return iface->data.network.actual->type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nint\nlibxlMakeNic(virDomainDefPtr def,\n             virDomainNetDefPtr l_nic,\n             libxl_device_nic *x_nic,\n             bool attach)\n{\n    virDomainNetType actual_type = virDomainNetGetActualType(l_nic);\n    virNetworkPtr network = NULL;\n    virConnectPtr conn = NULL;\n    const virNetDevBandwidth *actual_bw;\n    const virNetDevVPortProfile *port_profile;\n    const virNetDevVlan *virt_vlan;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    const char *script = NULL;\n    int ret = -1;\n\n    /* TODO: Where is mtu stored?\n     *\n     * x_nics[i].mtu = 1492;\n     */\n\n    if (l_nic->script && !(actual_type == VIR_DOMAIN_NET_TYPE_BRIDGE ||\n                           actual_type == VIR_DOMAIN_NET_TYPE_ETHERNET)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"specifying a script is only supported with \"\n                         \"interface types bridge and ethernet\"));\n        return -1;\n    }\n\n    libxl_device_nic_init(x_nic);\n\n    virMacAddrGetRaw(&l_nic->mac, x_nic->mac);\n\n    /*\n     * The nictype field of libxl_device_nic structure tells Xen which type of\n     * NIC device to create for the domain. LIBXL_NIC_TYPE_VIF specifies a\n     * PV NIC. LIBXL_NIC_TYPE_VIF_IOEMU specifies a PV and emulated NIC,\n     * allowing the domain to choose which NIC to use and unplug the unused\n     * one. LIBXL_NIC_TYPE_VIF_IOEMU is only valid for HVM domains. Further,\n     * if hotplugging the NIC, emulated NICs are currently not supported.\n     * Alternatively one could set LIBXL_NIC_TYPE_UNKNOWN and let libxl decide,\n     * but its behaviour might not be consistent across all libvirt supported\n     * versions. The other nictype values are well established already, hence\n     * we manually select our own default and mimic xl/libxl behaviour starting\n     * xen commit 32e9d0f (\"libxl: nic type defaults to vif in hotplug for\n     * hvm guest\").\n     */\n    if (virDomainNetGetModelString(l_nic)) {\n        if ((def->os.type == VIR_DOMAIN_OSTYPE_XEN ||\n            def->os.type == VIR_DOMAIN_OSTYPE_XENPVH) &&\n            l_nic->model != VIR_DOMAIN_NET_MODEL_NETFRONT) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"only model 'netfront' is supported for \"\n                             \"Xen PV(H) domains\"));\n            return -1;\n        }\n        x_nic->model = g_strdup(virDomainNetGetModelString(l_nic));\n        if (l_nic->model == VIR_DOMAIN_NET_MODEL_NETFRONT)\n            x_nic->nictype = LIBXL_NIC_TYPE_VIF;\n        else\n            x_nic->nictype = LIBXL_NIC_TYPE_VIF_IOEMU;\n    } else {\n        if (def->os.type == VIR_DOMAIN_OSTYPE_HVM && !attach)\n            x_nic->nictype = LIBXL_NIC_TYPE_VIF_IOEMU;\n        else\n            x_nic->nictype = LIBXL_NIC_TYPE_VIF;\n    }\n\n    x_nic->ifname = g_strdup(l_nic->ifname);\n\n    port_profile = virDomainNetGetActualVirtPortProfile(l_nic);\n    virt_vlan = virDomainNetGetActualVlan(l_nic);\n    script = l_nic->script;\n    switch (actual_type) {\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n            virBufferAddStr(&buf, virDomainNetGetActualBridgeName(l_nic));\n            /*\n             * A bit of special handling if vif will be connected to an\n             * openvswitch bridge\n             */\n            if (port_profile &&\n                port_profile->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                /*\n                 * If a custom script is not specified for openvswitch, use\n                 * Xen's vif-openvswitch script\n                 */\n                if (!script)\n                    script = \"vif-openvswitch\";\n                /*\n                 * libxl_device_nic->bridge supports an extended format for\n                 * specifying VLAN tags and trunks when using openvswitch\n                 *\n                 * BRIDGE_NAME[.VLAN][:TRUNK:TRUNK]\n                 *\n                 * See Xen's networking wiki for more details\n                 * https://wiki.xenproject.org/wiki/Xen_Networking#Open_vSwitch\n                 */\n                if (virt_vlan && virt_vlan->nTags > 0) {\n                    if (virt_vlan->trunk) {\n                        for (i = 0; i < virt_vlan->nTags; i++)\n                            virBufferAsprintf(&buf, \":%d\", virt_vlan->tag[i]);\n                    } else {\n                        virBufferAsprintf(&buf, \".%d\", virt_vlan->tag[0]);\n                    }\n                }\n            }\n            x_nic->bridge = g_strdup(virBufferCurrentContent(&buf));\n            G_GNUC_FALLTHROUGH;\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            x_nic->script = g_strdup(script);\n            if (l_nic->guestIP.nips > 0) {\n                x_nic->ip = xenMakeIPList(&l_nic->guestIP);\n                if (!x_nic->ip)\n                    goto cleanup;\n            }\n            break;\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n        {\n            if (!(conn = virConnectOpen(\"xen:///system\")))\n                goto cleanup;\n\n            if (!(network =\n                  virNetworkLookupByName(conn, l_nic->data.network.name))) {\n                goto cleanup;\n            }\n\n            if (l_nic->guestIP.nips > 0) {\n                x_nic->ip = xenMakeIPList(&l_nic->guestIP);\n                if (!x_nic->ip)\n                    goto cleanup;\n            }\n\n            if (!(x_nic->bridge = virNetworkGetBridgeName(network)))\n                goto cleanup;\n            break;\n        }\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                    _(\"unsupported interface type %s\"),\n                    virDomainNetTypeToString(l_nic->type));\n            goto cleanup;\n    }\n\n    if (l_nic->domain_name) {\n#ifdef LIBXL_HAVE_DEVICE_BACKEND_DOMNAME\n        x_nic->backend_domname = g_strdup(l_nic->domain_name);\n#else\n        virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                _(\"this version of libxenlight does not \"\n                  \"support backend domain name\"));\n        goto cleanup;\n#endif\n    }\n\n    /*\n     * Set bandwidth.\n     * From $xen-sources/docs/misc/xl-network-configuration.markdown:\n     *\n     *\n     * Specifies the rate at which the outgoing traffic will be limited to.\n     * The default if this keyword is not specified is unlimited.\n     *\n     * The rate may be specified as \"<RATE>/s\" or optionally \"<RATE>/s@<INTERVAL>\".\n     *\n     * `RATE` is in bytes and can accept suffixes:\n     *     GB, MB, KB, B for bytes.\n     *     Gb, Mb, Kb, b for bits.\n     * `INTERVAL` is in microseconds and can accept suffixes: ms, us, s.\n     *     It determines the frequency at which the vif transmission credit\n     *     is replenished. The default is 50ms.\n\n     * Vif rate limiting is credit-based. It means that for \"1MB/s@20ms\",\n     * the available credit will be equivalent of the traffic you would have\n     * done at \"1MB/s\" during 20ms. This will results in a credit of 20,000\n     * bytes replenished every 20,000 us.\n     *\n     *\n     * libvirt doesn't support the notion of rate limiting over an interval.\n     * Similar to xl's behavior when interval is not specified, set a default\n     * interval of 50ms and calculate the number of bytes per interval based\n     * on the specified average bandwidth.\n     */\n    actual_bw = virDomainNetGetActualBandwidth(l_nic);\n    if (actual_bw && actual_bw->out && actual_bw->out->average) {\n        uint64_t bytes_per_sec = actual_bw->out->average * 1024;\n        uint64_t bytes_per_interval =\n            (((uint64_t) bytes_per_sec * 50000UL) / 1000000UL);\n\n        x_nic->rate_bytes_per_interval = bytes_per_interval;\n        x_nic->rate_interval_usecs =  50000UL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    virObjectUnref(network);\n    virObjectUnref(conn);\n\n    return ret;\n}"
  },
  {
    "function_name": "libxlUpdateDiskDef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "1168-1191",
    "snippet": "void\nlibxlUpdateDiskDef(virDomainDiskDefPtr l_disk, libxl_device_disk *x_disk)\n{\n    const char *driver = NULL;\n\n    if (virDomainDiskGetDriver(l_disk))\n        return;\n\n    switch (x_disk->backend) {\n    case LIBXL_DISK_BACKEND_QDISK:\n        driver = \"qemu\";\n        break;\n    case LIBXL_DISK_BACKEND_TAP:\n        driver = \"tap\";\n        break;\n    case LIBXL_DISK_BACKEND_PHY:\n        driver = \"phy\";\n        break;\n    case LIBXL_DISK_BACKEND_UNKNOWN:\n        break;\n    }\n    if (driver)\n        ignore_value(virDomainDiskSetDriver(l_disk, driver));\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virDomainDiskSetDriver(l_disk, driver)"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskSetDriver",
          "args": [
            "l_disk",
            "driver"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskSetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2192-2199",
          "snippet": "int\nvirDomainDiskSetDriver(virDomainDiskDefPtr def, const char *name)\n{\n    char *tmp = g_strdup(name);\n    g_free(def->driverName);\n    def->driverName = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskSetDriver(virDomainDiskDefPtr def, const char *name)\n{\n    char *tmp = g_strdup(name);\n    g_free(def->driverName);\n    def->driverName = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetDriver",
          "args": [
            "l_disk"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2185-2189",
          "snippet": "const char *\nvirDomainDiskGetDriver(const virDomainDiskDef *def)\n{\n    return def->driverName;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetDriver(const virDomainDiskDef *def)\n{\n    return def->driverName;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nvoid\nlibxlUpdateDiskDef(virDomainDiskDefPtr l_disk, libxl_device_disk *x_disk)\n{\n    const char *driver = NULL;\n\n    if (virDomainDiskGetDriver(l_disk))\n        return;\n\n    switch (x_disk->backend) {\n    case LIBXL_DISK_BACKEND_QDISK:\n        driver = \"qemu\";\n        break;\n    case LIBXL_DISK_BACKEND_TAP:\n        driver = \"tap\";\n        break;\n    case LIBXL_DISK_BACKEND_PHY:\n        driver = \"phy\";\n        break;\n    case LIBXL_DISK_BACKEND_UNKNOWN:\n        break;\n    }\n    if (driver)\n        ignore_value(virDomainDiskSetDriver(l_disk, driver));\n}"
  },
  {
    "function_name": "libxlMakeDiskList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "1133-1159",
    "snippet": "static int\nlibxlMakeDiskList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainDiskDefPtr *l_disks = def->disks;\n    int ndisks = def->ndisks;\n    libxl_device_disk *x_disks;\n    size_t i;\n\n    if (VIR_ALLOC_N(x_disks, ndisks) < 0)\n        return -1;\n\n    for (i = 0; i < ndisks; i++) {\n        if (libxlMakeDisk(l_disks[i], &x_disks[i]) < 0)\n            goto error;\n    }\n\n    d_config->disks = x_disks;\n    d_config->num_disks = ndisks;\n\n    return 0;\n\n error:\n    for (i = 0; i < ndisks; i++)\n        libxl_device_disk_dispose(&x_disks[i]);\n    VIR_FREE(x_disks);\n    return -1;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "x_disks"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_device_disk_dispose",
          "args": [
            "&x_disks[i]"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlMakeDisk",
          "args": [
            "l_disks[i]",
            "&x_disks[i]"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeDiskList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1133-1159",
          "snippet": "static int\nlibxlMakeDiskList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainDiskDefPtr *l_disks = def->disks;\n    int ndisks = def->ndisks;\n    libxl_device_disk *x_disks;\n    size_t i;\n\n    if (VIR_ALLOC_N(x_disks, ndisks) < 0)\n        return -1;\n\n    for (i = 0; i < ndisks; i++) {\n        if (libxlMakeDisk(l_disks[i], &x_disks[i]) < 0)\n            goto error;\n    }\n\n    d_config->disks = x_disks;\n    d_config->num_disks = ndisks;\n\n    return 0;\n\n error:\n    for (i = 0; i < ndisks; i++)\n        libxl_device_disk_dispose(&x_disks[i]);\n    VIR_FREE(x_disks);\n    return -1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "x_disks",
            "ndisks"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeDiskList(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    virDomainDiskDefPtr *l_disks = def->disks;\n    int ndisks = def->ndisks;\n    libxl_device_disk *x_disks;\n    size_t i;\n\n    if (VIR_ALLOC_N(x_disks, ndisks) < 0)\n        return -1;\n\n    for (i = 0; i < ndisks; i++) {\n        if (libxlMakeDisk(l_disks[i], &x_disks[i]) < 0)\n            goto error;\n    }\n\n    d_config->disks = x_disks;\n    d_config->num_disks = ndisks;\n\n    return 0;\n\n error:\n    for (i = 0; i < ndisks; i++)\n        libxl_device_disk_dispose(&x_disks[i]);\n    VIR_FREE(x_disks);\n    return -1;\n}"
  },
  {
    "function_name": "libxlMakeDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "982-1131",
    "snippet": "int\nlibxlMakeDisk(virDomainDiskDefPtr l_disk, libxl_device_disk *x_disk)\n{\n    const char *driver = virDomainDiskGetDriver(l_disk);\n    int format = virDomainDiskGetFormat(l_disk);\n    int actual_type = virStorageSourceGetActualType(l_disk->src);\n\n    libxl_device_disk_init(x_disk);\n\n    if (actual_type == VIR_STORAGE_TYPE_NETWORK) {\n        if (STRNEQ_NULLABLE(driver, \"qemu\")) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"only the 'qemu' driver can be used with network disks\"));\n            return -1;\n        }\n        if (libxlMakeNetworkDiskSrc(l_disk->src, &x_disk->pdev_path) < 0)\n            return -1;\n    } else {\n        x_disk->pdev_path = g_strdup(virDomainDiskGetSource(l_disk));\n    }\n\n    x_disk->vdev = g_strdup(l_disk->dst);\n\n    if (driver) {\n        if (STREQ(driver, \"tap\") || STREQ(driver, \"tap2\")) {\n            switch (format) {\n            case VIR_STORAGE_FILE_QCOW:\n                x_disk->format = LIBXL_DISK_FORMAT_QCOW;\n                x_disk->backend = LIBXL_DISK_BACKEND_QDISK;\n                break;\n            case VIR_STORAGE_FILE_QCOW2:\n                x_disk->format = LIBXL_DISK_FORMAT_QCOW2;\n                x_disk->backend = LIBXL_DISK_BACKEND_QDISK;\n                break;\n            case VIR_STORAGE_FILE_VHD:\n                x_disk->format = LIBXL_DISK_FORMAT_VHD;\n                x_disk->backend = LIBXL_DISK_BACKEND_TAP;\n                break;\n            case VIR_STORAGE_FILE_RAW:\n                x_disk->format = LIBXL_DISK_FORMAT_RAW;\n                x_disk->backend = LIBXL_DISK_BACKEND_TAP;\n                break;\n#ifdef LIBXL_HAVE_QED\n            case VIR_STORAGE_FILE_QED:\n                x_disk->format = LIBXL_DISK_FORMAT_QED;\n                x_disk->backend = LIBXL_DISK_BACKEND_QDISK;\n                break;\n#endif\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"libxenlight does not support disk format %s \"\n                                 \"with disk driver %s\"),\n                               virStorageFileFormatTypeToString(format),\n                               driver);\n                return -1;\n            }\n        } else if (STREQ(driver, \"qemu\")) {\n            x_disk->backend = LIBXL_DISK_BACKEND_QDISK;\n            switch (format) {\n            case VIR_STORAGE_FILE_QCOW:\n                x_disk->format = LIBXL_DISK_FORMAT_QCOW;\n                break;\n            case VIR_STORAGE_FILE_QCOW2:\n                x_disk->format = LIBXL_DISK_FORMAT_QCOW2;\n                break;\n#ifdef LIBXL_HAVE_QED\n            case VIR_STORAGE_FILE_QED:\n                x_disk->format = LIBXL_DISK_FORMAT_QED;\n                break;\n#endif\n            case VIR_STORAGE_FILE_VHD:\n                x_disk->format = LIBXL_DISK_FORMAT_VHD;\n                break;\n            case VIR_STORAGE_FILE_RAW:\n                x_disk->format = LIBXL_DISK_FORMAT_RAW;\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"libxenlight does not support disk format %s \"\n                                 \"with disk driver %s\"),\n                               virStorageFileFormatTypeToString(format),\n                               driver);\n                return -1;\n            }\n        } else if (STREQ(driver, \"file\")) {\n            if (format != VIR_STORAGE_FILE_RAW) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"libxenlight does not support disk format %s \"\n                                 \"with disk driver %s\"),\n                               virStorageFileFormatTypeToString(format),\n                               driver);\n                return -1;\n            }\n            x_disk->format = LIBXL_DISK_FORMAT_RAW;\n            x_disk->backend = LIBXL_DISK_BACKEND_QDISK;\n        } else if (STREQ(driver, \"phy\")) {\n            if (format != VIR_STORAGE_FILE_RAW) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"libxenlight does not support disk format %s \"\n                                 \"with disk driver %s\"),\n                               virStorageFileFormatTypeToString(format),\n                               driver);\n                return -1;\n            }\n            x_disk->format = LIBXL_DISK_FORMAT_RAW;\n            x_disk->backend = LIBXL_DISK_BACKEND_PHY;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"libxenlight does not support disk driver %s\"),\n                           driver);\n            return -1;\n        }\n    } else {\n        /*\n         * If driverName is not specified, default to raw as per\n         * xl-disk-configuration.txt in the xen documentation and let\n         * libxl pick a suitable backend.\n         */\n        x_disk->format = LIBXL_DISK_FORMAT_RAW;\n        x_disk->backend = LIBXL_DISK_BACKEND_UNKNOWN;\n    }\n\n    /* XXX is this right? */\n    x_disk->removable = 1;\n    x_disk->readwrite = !l_disk->src->readonly;\n    x_disk->is_cdrom = l_disk->device == VIR_DOMAIN_DISK_DEVICE_CDROM ? 1 : 0;\n    if (libxlDiskSetDiscard(x_disk, l_disk->discard) < 0)\n        return -1;\n    /* An empty CDROM must have the empty format, otherwise libxl fails. */\n    if (x_disk->is_cdrom && !x_disk->pdev_path)\n        x_disk->format = LIBXL_DISK_FORMAT_EMPTY;\n    if (l_disk->transient) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libxenlight does not support transient disks\"));\n        return -1;\n    }\n\n    if (l_disk->domain_name) {\n#ifdef LIBXL_HAVE_DEVICE_BACKEND_DOMNAME\n        x_disk->backend_domname = g_strdup(l_disk->domain_name);\n#else\n        virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                _(\"this version of libxenlight does not \"\n                  \"support backend domain name\"));\n        return -1;\n#endif\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_DETAIL",
            "\"%s\"",
            "_(\"this version of libxenlight does not \"\n                  \"support backend domain name\")"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"this version of libxenlight does not \"\n                  \"support backend domain name\""
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "l_disk->domain_name"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"libxenlight does not support transient disks\")"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDiskSetDiscard",
          "args": [
            "x_disk",
            "l_disk->discard"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDiskSetDiscard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "841-867",
          "snippet": "static int\nlibxlDiskSetDiscard(libxl_device_disk *x_disk, int discard)\n{\n    if (!x_disk->readwrite)\n        return 0;\n#if defined(LIBXL_HAVE_LIBXL_DEVICE_DISK_DISCARD_ENABLE)\n    switch ((virDomainDiskDiscard)discard) {\n    case VIR_DOMAIN_DISK_DISCARD_DEFAULT:\n    case VIR_DOMAIN_DISK_DISCARD_LAST:\n        break;\n    case VIR_DOMAIN_DISK_DISCARD_UNMAP:\n        libxl_defbool_set(&x_disk->discard_enable, true);\n        break;\n    case VIR_DOMAIN_DISK_DISCARD_IGNORE:\n        libxl_defbool_set(&x_disk->discard_enable, false);\n        break;\n    }\n    return 0;\n#else\n    if (discard == VIR_DOMAIN_DISK_DISCARD_DEFAULT)\n        return 0;\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                   _(\"This version of libxenlight does not support \"\n                     \"disk 'discard' option passing\"));\n    return -1;\n#endif\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlDiskSetDiscard(libxl_device_disk *x_disk, int discard)\n{\n    if (!x_disk->readwrite)\n        return 0;\n#if defined(LIBXL_HAVE_LIBXL_DEVICE_DISK_DISCARD_ENABLE)\n    switch ((virDomainDiskDiscard)discard) {\n    case VIR_DOMAIN_DISK_DISCARD_DEFAULT:\n    case VIR_DOMAIN_DISK_DISCARD_LAST:\n        break;\n    case VIR_DOMAIN_DISK_DISCARD_UNMAP:\n        libxl_defbool_set(&x_disk->discard_enable, true);\n        break;\n    case VIR_DOMAIN_DISK_DISCARD_IGNORE:\n        libxl_defbool_set(&x_disk->discard_enable, false);\n        break;\n    }\n    return 0;\n#else\n    if (discard == VIR_DOMAIN_DISK_DISCARD_DEFAULT)\n        return 0;\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                   _(\"This version of libxenlight does not support \"\n                     \"disk 'discard' option passing\"));\n    return -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"libxenlight does not support disk driver %s\")",
            "driver"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"libxenlight does not support disk format %s \"\n                                 \"with disk driver %s\")",
            "virStorageFileFormatTypeToString(format)",
            "driver"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeToString",
          "args": [
            "format"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "driver",
            "\"phy\""
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"libxenlight does not support disk format %s \"\n                                 \"with disk driver %s\")",
            "virStorageFileFormatTypeToString(format)",
            "driver"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeToString",
          "args": [
            "format"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "driver",
            "\"file\""
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"libxenlight does not support disk format %s \"\n                                 \"with disk driver %s\")",
            "virStorageFileFormatTypeToString(format)",
            "driver"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeToString",
          "args": [
            "format"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "driver",
            "\"qemu\""
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"libxenlight does not support disk format %s \"\n                                 \"with disk driver %s\")",
            "virStorageFileFormatTypeToString(format)",
            "driver"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeToString",
          "args": [
            "format"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "driver",
            "\"tap2\""
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "driver",
            "\"tap\""
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "l_disk"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMakeNetworkDiskSrc",
          "args": [
            "l_disk->src",
            "&x_disk->pdev_path"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeNetworkDiskSrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "946-980",
          "snippet": "static int\nlibxlMakeNetworkDiskSrc(virStorageSourcePtr src, char **srcstr)\n{\n    virConnectPtr conn = NULL;\n    uint8_t *secret = NULL;\n    VIR_AUTODISPOSE_STR base64secret = NULL;\n    size_t secretlen = 0;\n    char *username = NULL;\n    int ret = -1;\n\n    *srcstr = NULL;\n    if (src->auth && src->protocol == VIR_STORAGE_NET_PROTOCOL_RBD) {\n        username = src->auth->username;\n        if (!(conn = virConnectOpen(\"xen:///system\")))\n            goto cleanup;\n\n        if (virSecretGetSecretString(conn, &src->auth->seclookupdef,\n                                     VIR_SECRET_USAGE_TYPE_CEPH,\n                                     &secret, &secretlen) < 0)\n            goto cleanup;\n\n        /* RBD expects an encoded secret */\n        base64secret = g_base64_encode(secret, secretlen);\n    }\n\n    if (!(*srcstr = libxlMakeNetworkDiskSrcStr(src, username, base64secret)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DISPOSE_N(secret, secretlen);\n    virObjectUnref(conn);\n    return ret;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeNetworkDiskSrc(virStorageSourcePtr src, char **srcstr)\n{\n    virConnectPtr conn = NULL;\n    uint8_t *secret = NULL;\n    VIR_AUTODISPOSE_STR base64secret = NULL;\n    size_t secretlen = 0;\n    char *username = NULL;\n    int ret = -1;\n\n    *srcstr = NULL;\n    if (src->auth && src->protocol == VIR_STORAGE_NET_PROTOCOL_RBD) {\n        username = src->auth->username;\n        if (!(conn = virConnectOpen(\"xen:///system\")))\n            goto cleanup;\n\n        if (virSecretGetSecretString(conn, &src->auth->seclookupdef,\n                                     VIR_SECRET_USAGE_TYPE_CEPH,\n                                     &secret, &secretlen) < 0)\n            goto cleanup;\n\n        /* RBD expects an encoded secret */\n        base64secret = g_base64_encode(secret, secretlen);\n    }\n\n    if (!(*srcstr = libxlMakeNetworkDiskSrcStr(src, username, base64secret)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DISPOSE_N(secret, secretlen);\n    virObjectUnref(conn);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"only the 'qemu' driver can be used with network disks\")"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "driver",
            "\"qemu\""
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_device_disk_init",
          "args": [
            "x_disk"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceGetActualType",
          "args": [
            "l_disk->src"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2574-2583",
          "snippet": "int\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetFormat",
          "args": [
            "l_disk"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2202-2206",
          "snippet": "int\nvirDomainDiskGetFormat(virDomainDiskDefPtr def)\n{\n    return def->src->format;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskGetFormat(virDomainDiskDefPtr def)\n{\n    return def->src->format;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetDriver",
          "args": [
            "l_disk"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2185-2189",
          "snippet": "const char *\nvirDomainDiskGetDriver(const virDomainDiskDef *def)\n{\n    return def->driverName;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetDriver(const virDomainDiskDef *def)\n{\n    return def->driverName;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nint\nlibxlMakeDisk(virDomainDiskDefPtr l_disk, libxl_device_disk *x_disk)\n{\n    const char *driver = virDomainDiskGetDriver(l_disk);\n    int format = virDomainDiskGetFormat(l_disk);\n    int actual_type = virStorageSourceGetActualType(l_disk->src);\n\n    libxl_device_disk_init(x_disk);\n\n    if (actual_type == VIR_STORAGE_TYPE_NETWORK) {\n        if (STRNEQ_NULLABLE(driver, \"qemu\")) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"only the 'qemu' driver can be used with network disks\"));\n            return -1;\n        }\n        if (libxlMakeNetworkDiskSrc(l_disk->src, &x_disk->pdev_path) < 0)\n            return -1;\n    } else {\n        x_disk->pdev_path = g_strdup(virDomainDiskGetSource(l_disk));\n    }\n\n    x_disk->vdev = g_strdup(l_disk->dst);\n\n    if (driver) {\n        if (STREQ(driver, \"tap\") || STREQ(driver, \"tap2\")) {\n            switch (format) {\n            case VIR_STORAGE_FILE_QCOW:\n                x_disk->format = LIBXL_DISK_FORMAT_QCOW;\n                x_disk->backend = LIBXL_DISK_BACKEND_QDISK;\n                break;\n            case VIR_STORAGE_FILE_QCOW2:\n                x_disk->format = LIBXL_DISK_FORMAT_QCOW2;\n                x_disk->backend = LIBXL_DISK_BACKEND_QDISK;\n                break;\n            case VIR_STORAGE_FILE_VHD:\n                x_disk->format = LIBXL_DISK_FORMAT_VHD;\n                x_disk->backend = LIBXL_DISK_BACKEND_TAP;\n                break;\n            case VIR_STORAGE_FILE_RAW:\n                x_disk->format = LIBXL_DISK_FORMAT_RAW;\n                x_disk->backend = LIBXL_DISK_BACKEND_TAP;\n                break;\n#ifdef LIBXL_HAVE_QED\n            case VIR_STORAGE_FILE_QED:\n                x_disk->format = LIBXL_DISK_FORMAT_QED;\n                x_disk->backend = LIBXL_DISK_BACKEND_QDISK;\n                break;\n#endif\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"libxenlight does not support disk format %s \"\n                                 \"with disk driver %s\"),\n                               virStorageFileFormatTypeToString(format),\n                               driver);\n                return -1;\n            }\n        } else if (STREQ(driver, \"qemu\")) {\n            x_disk->backend = LIBXL_DISK_BACKEND_QDISK;\n            switch (format) {\n            case VIR_STORAGE_FILE_QCOW:\n                x_disk->format = LIBXL_DISK_FORMAT_QCOW;\n                break;\n            case VIR_STORAGE_FILE_QCOW2:\n                x_disk->format = LIBXL_DISK_FORMAT_QCOW2;\n                break;\n#ifdef LIBXL_HAVE_QED\n            case VIR_STORAGE_FILE_QED:\n                x_disk->format = LIBXL_DISK_FORMAT_QED;\n                break;\n#endif\n            case VIR_STORAGE_FILE_VHD:\n                x_disk->format = LIBXL_DISK_FORMAT_VHD;\n                break;\n            case VIR_STORAGE_FILE_RAW:\n                x_disk->format = LIBXL_DISK_FORMAT_RAW;\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"libxenlight does not support disk format %s \"\n                                 \"with disk driver %s\"),\n                               virStorageFileFormatTypeToString(format),\n                               driver);\n                return -1;\n            }\n        } else if (STREQ(driver, \"file\")) {\n            if (format != VIR_STORAGE_FILE_RAW) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"libxenlight does not support disk format %s \"\n                                 \"with disk driver %s\"),\n                               virStorageFileFormatTypeToString(format),\n                               driver);\n                return -1;\n            }\n            x_disk->format = LIBXL_DISK_FORMAT_RAW;\n            x_disk->backend = LIBXL_DISK_BACKEND_QDISK;\n        } else if (STREQ(driver, \"phy\")) {\n            if (format != VIR_STORAGE_FILE_RAW) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"libxenlight does not support disk format %s \"\n                                 \"with disk driver %s\"),\n                               virStorageFileFormatTypeToString(format),\n                               driver);\n                return -1;\n            }\n            x_disk->format = LIBXL_DISK_FORMAT_RAW;\n            x_disk->backend = LIBXL_DISK_BACKEND_PHY;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"libxenlight does not support disk driver %s\"),\n                           driver);\n            return -1;\n        }\n    } else {\n        /*\n         * If driverName is not specified, default to raw as per\n         * xl-disk-configuration.txt in the xen documentation and let\n         * libxl pick a suitable backend.\n         */\n        x_disk->format = LIBXL_DISK_FORMAT_RAW;\n        x_disk->backend = LIBXL_DISK_BACKEND_UNKNOWN;\n    }\n\n    /* XXX is this right? */\n    x_disk->removable = 1;\n    x_disk->readwrite = !l_disk->src->readonly;\n    x_disk->is_cdrom = l_disk->device == VIR_DOMAIN_DISK_DEVICE_CDROM ? 1 : 0;\n    if (libxlDiskSetDiscard(x_disk, l_disk->discard) < 0)\n        return -1;\n    /* An empty CDROM must have the empty format, otherwise libxl fails. */\n    if (x_disk->is_cdrom && !x_disk->pdev_path)\n        x_disk->format = LIBXL_DISK_FORMAT_EMPTY;\n    if (l_disk->transient) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libxenlight does not support transient disks\"));\n        return -1;\n    }\n\n    if (l_disk->domain_name) {\n#ifdef LIBXL_HAVE_DEVICE_BACKEND_DOMNAME\n        x_disk->backend_domname = g_strdup(l_disk->domain_name);\n#else\n        virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                _(\"this version of libxenlight does not \"\n                  \"support backend domain name\"));\n        return -1;\n#endif\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlMakeNetworkDiskSrc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "946-980",
    "snippet": "static int\nlibxlMakeNetworkDiskSrc(virStorageSourcePtr src, char **srcstr)\n{\n    virConnectPtr conn = NULL;\n    uint8_t *secret = NULL;\n    VIR_AUTODISPOSE_STR base64secret = NULL;\n    size_t secretlen = 0;\n    char *username = NULL;\n    int ret = -1;\n\n    *srcstr = NULL;\n    if (src->auth && src->protocol == VIR_STORAGE_NET_PROTOCOL_RBD) {\n        username = src->auth->username;\n        if (!(conn = virConnectOpen(\"xen:///system\")))\n            goto cleanup;\n\n        if (virSecretGetSecretString(conn, &src->auth->seclookupdef,\n                                     VIR_SECRET_USAGE_TYPE_CEPH,\n                                     &secret, &secretlen) < 0)\n            goto cleanup;\n\n        /* RBD expects an encoded secret */\n        base64secret = g_base64_encode(secret, secretlen);\n    }\n\n    if (!(*srcstr = libxlMakeNetworkDiskSrcStr(src, username, base64secret)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DISPOSE_N(secret, secretlen);\n    virObjectUnref(conn);\n    return ret;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "conn"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DISPOSE_N",
          "args": [
            "secret",
            "secretlen"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlMakeNetworkDiskSrcStr",
          "args": [
            "src",
            "username",
            "base64secret"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeNetworkDiskSrcStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "869-944",
          "snippet": "static char *\nlibxlMakeNetworkDiskSrcStr(virStorageSourcePtr src,\n                           const char *username,\n                           const char *secret)\n{\n    char *ret = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n\n    switch ((virStorageNetProtocol) src->protocol) {\n    case VIR_STORAGE_NET_PROTOCOL_NBD:\n    case VIR_STORAGE_NET_PROTOCOL_HTTP:\n    case VIR_STORAGE_NET_PROTOCOL_HTTPS:\n    case VIR_STORAGE_NET_PROTOCOL_FTP:\n    case VIR_STORAGE_NET_PROTOCOL_FTPS:\n    case VIR_STORAGE_NET_PROTOCOL_TFTP:\n    case VIR_STORAGE_NET_PROTOCOL_ISCSI:\n    case VIR_STORAGE_NET_PROTOCOL_GLUSTER:\n    case VIR_STORAGE_NET_PROTOCOL_SHEEPDOG:\n    case VIR_STORAGE_NET_PROTOCOL_SSH:\n    case VIR_STORAGE_NET_PROTOCOL_VXHS:\n    case VIR_STORAGE_NET_PROTOCOL_LAST:\n    case VIR_STORAGE_NET_PROTOCOL_NONE:\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"Unsupported network block protocol '%s'\"),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        goto cleanup;\n\n    case VIR_STORAGE_NET_PROTOCOL_RBD:\n        if (strchr(src->path, ':')) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"':' not allowed in RBD source volume name '%s'\"),\n                           src->path);\n            goto cleanup;\n        }\n\n        virBufferStrcat(&buf, \"rbd:\", src->volume, \"/\", src->path, NULL);\n\n        if (username) {\n            virBufferEscape(&buf, '\\\\', \":\", \":id=%s\", username);\n            virBufferEscape(&buf, '\\\\', \":\",\n                            \":key=%s:auth_supported=cephx\\\\;none\",\n                            secret);\n        } else {\n            virBufferAddLit(&buf, \":auth_supported=none\");\n        }\n\n        if (src->nhosts > 0) {\n            virBufferAddLit(&buf, \":mon_host=\");\n            for (i = 0; i < src->nhosts; i++) {\n                if (i)\n                    virBufferAddLit(&buf, \"\\\\;\");\n\n                /* assume host containing : is ipv6 */\n                if (strchr(src->hosts[i].name, ':'))\n                    virBufferEscape(&buf, '\\\\', \":\", \"[%s]\",\n                                    src->hosts[i].name);\n                else\n                    virBufferAsprintf(&buf, \"%s\", src->hosts[i].name);\n\n                if (src->hosts[i].port)\n                    virBufferAsprintf(&buf, \"\\\\:%u\", src->hosts[i].port);\n            }\n        }\n\n        if (src->configFile)\n            virBufferEscape(&buf, '\\\\', \":\", \":conf=%s\", src->configFile);\n\n        ret = virBufferContentAndReset(&buf);\n        break;\n    }\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return ret;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic char *\nlibxlMakeNetworkDiskSrcStr(virStorageSourcePtr src,\n                           const char *username,\n                           const char *secret)\n{\n    char *ret = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n\n    switch ((virStorageNetProtocol) src->protocol) {\n    case VIR_STORAGE_NET_PROTOCOL_NBD:\n    case VIR_STORAGE_NET_PROTOCOL_HTTP:\n    case VIR_STORAGE_NET_PROTOCOL_HTTPS:\n    case VIR_STORAGE_NET_PROTOCOL_FTP:\n    case VIR_STORAGE_NET_PROTOCOL_FTPS:\n    case VIR_STORAGE_NET_PROTOCOL_TFTP:\n    case VIR_STORAGE_NET_PROTOCOL_ISCSI:\n    case VIR_STORAGE_NET_PROTOCOL_GLUSTER:\n    case VIR_STORAGE_NET_PROTOCOL_SHEEPDOG:\n    case VIR_STORAGE_NET_PROTOCOL_SSH:\n    case VIR_STORAGE_NET_PROTOCOL_VXHS:\n    case VIR_STORAGE_NET_PROTOCOL_LAST:\n    case VIR_STORAGE_NET_PROTOCOL_NONE:\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"Unsupported network block protocol '%s'\"),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        goto cleanup;\n\n    case VIR_STORAGE_NET_PROTOCOL_RBD:\n        if (strchr(src->path, ':')) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"':' not allowed in RBD source volume name '%s'\"),\n                           src->path);\n            goto cleanup;\n        }\n\n        virBufferStrcat(&buf, \"rbd:\", src->volume, \"/\", src->path, NULL);\n\n        if (username) {\n            virBufferEscape(&buf, '\\\\', \":\", \":id=%s\", username);\n            virBufferEscape(&buf, '\\\\', \":\",\n                            \":key=%s:auth_supported=cephx\\\\;none\",\n                            secret);\n        } else {\n            virBufferAddLit(&buf, \":auth_supported=none\");\n        }\n\n        if (src->nhosts > 0) {\n            virBufferAddLit(&buf, \":mon_host=\");\n            for (i = 0; i < src->nhosts; i++) {\n                if (i)\n                    virBufferAddLit(&buf, \"\\\\;\");\n\n                /* assume host containing : is ipv6 */\n                if (strchr(src->hosts[i].name, ':'))\n                    virBufferEscape(&buf, '\\\\', \":\", \"[%s]\",\n                                    src->hosts[i].name);\n                else\n                    virBufferAsprintf(&buf, \"%s\", src->hosts[i].name);\n\n                if (src->hosts[i].port)\n                    virBufferAsprintf(&buf, \"\\\\:%u\", src->hosts[i].port);\n            }\n        }\n\n        if (src->configFile)\n            virBufferEscape(&buf, '\\\\', \":\", \":conf=%s\", src->configFile);\n\n        ret = virBufferContentAndReset(&buf);\n        break;\n    }\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_base64_encode",
          "args": [
            "secret",
            "secretlen"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecretGetSecretString",
          "args": [
            "conn",
            "&src->auth->seclookupdef",
            "VIR_SECRET_USAGE_TYPE_CEPH",
            "&secret",
            "&secretlen"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "virSecretGetSecretString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsecret.c",
          "lines": "143-195",
          "snippet": "int\nvirSecretGetSecretString(virConnectPtr conn,\n                         virSecretLookupTypeDefPtr seclookupdef,\n                         virSecretUsageType secretUsageType,\n                         uint8_t **secret,\n                         size_t *secret_size)\n{\n    virSecretPtr sec = NULL;\n    int ret = -1;\n\n    switch (seclookupdef->type) {\n    case VIR_SECRET_LOOKUP_TYPE_UUID:\n        sec = conn->secretDriver->secretLookupByUUID(conn, seclookupdef->u.uuid);\n        break;\n\n    case VIR_SECRET_LOOKUP_TYPE_USAGE:\n        sec = conn->secretDriver->secretLookupByUsage(conn, secretUsageType,\n                                                      seclookupdef->u.usage);\n        break;\n    }\n\n    if (!sec)\n        goto cleanup;\n\n    /* NB: NONE is a byproduct of the qemuxml2argvtest test mocking\n     * for UUID lookups. Normal secret XML processing would fail if\n     * the usage type was NONE and since we have no way to set the\n     * expected usage in that environment, let's just accept NONE */\n    if (sec->usageType != VIR_SECRET_USAGE_TYPE_NONE &&\n        sec->usageType != secretUsageType) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(seclookupdef->u.uuid, uuidstr);\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"secret with uuid %s is of type '%s' not \"\n                         \"expected '%s' type\"),\n                       uuidstr, virSecretUsageTypeToString(sec->usageType),\n                       virSecretUsageTypeToString(secretUsageType));\n        goto cleanup;\n    }\n\n    *secret = conn->secretDriver->secretGetValue(sec, secret_size, 0,\n                                                 VIR_SECRET_GET_VALUE_INTERNAL_CALL);\n\n    if (!*secret)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(sec);\n    return ret;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirSecretGetSecretString(virConnectPtr conn,\n                         virSecretLookupTypeDefPtr seclookupdef,\n                         virSecretUsageType secretUsageType,\n                         uint8_t **secret,\n                         size_t *secret_size)\n{\n    virSecretPtr sec = NULL;\n    int ret = -1;\n\n    switch (seclookupdef->type) {\n    case VIR_SECRET_LOOKUP_TYPE_UUID:\n        sec = conn->secretDriver->secretLookupByUUID(conn, seclookupdef->u.uuid);\n        break;\n\n    case VIR_SECRET_LOOKUP_TYPE_USAGE:\n        sec = conn->secretDriver->secretLookupByUsage(conn, secretUsageType,\n                                                      seclookupdef->u.usage);\n        break;\n    }\n\n    if (!sec)\n        goto cleanup;\n\n    /* NB: NONE is a byproduct of the qemuxml2argvtest test mocking\n     * for UUID lookups. Normal secret XML processing would fail if\n     * the usage type was NONE and since we have no way to set the\n     * expected usage in that environment, let's just accept NONE */\n    if (sec->usageType != VIR_SECRET_USAGE_TYPE_NONE &&\n        sec->usageType != secretUsageType) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(seclookupdef->u.uuid, uuidstr);\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"secret with uuid %s is of type '%s' not \"\n                         \"expected '%s' type\"),\n                       uuidstr, virSecretUsageTypeToString(sec->usageType),\n                       virSecretUsageTypeToString(secretUsageType));\n        goto cleanup;\n    }\n\n    *secret = conn->secretDriver->secretGetValue(sec, secret_size, 0,\n                                                 VIR_SECRET_GET_VALUE_INTERNAL_CALL);\n\n    if (!*secret)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(sec);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectOpen",
          "args": [
            "\"xen:///system\""
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectOpenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "1181-1199",
          "snippet": "virConnectPtr\nvirConnectOpenReadOnly(const char *name)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s\", NULLSTR(name));\n    virResetLastError();\n    ret = virConnectOpenInternal(name, NULL, VIR_CONNECT_RO);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirConnectPtr\nvirConnectOpenReadOnly(const char *name)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s\", NULLSTR(name));\n    virResetLastError();\n    ret = virConnectOpenInternal(name, NULL, VIR_CONNECT_RO);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeNetworkDiskSrc(virStorageSourcePtr src, char **srcstr)\n{\n    virConnectPtr conn = NULL;\n    uint8_t *secret = NULL;\n    VIR_AUTODISPOSE_STR base64secret = NULL;\n    size_t secretlen = 0;\n    char *username = NULL;\n    int ret = -1;\n\n    *srcstr = NULL;\n    if (src->auth && src->protocol == VIR_STORAGE_NET_PROTOCOL_RBD) {\n        username = src->auth->username;\n        if (!(conn = virConnectOpen(\"xen:///system\")))\n            goto cleanup;\n\n        if (virSecretGetSecretString(conn, &src->auth->seclookupdef,\n                                     VIR_SECRET_USAGE_TYPE_CEPH,\n                                     &secret, &secretlen) < 0)\n            goto cleanup;\n\n        /* RBD expects an encoded secret */\n        base64secret = g_base64_encode(secret, secretlen);\n    }\n\n    if (!(*srcstr = libxlMakeNetworkDiskSrcStr(src, username, base64secret)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DISPOSE_N(secret, secretlen);\n    virObjectUnref(conn);\n    return ret;\n}"
  },
  {
    "function_name": "libxlMakeNetworkDiskSrcStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "869-944",
    "snippet": "static char *\nlibxlMakeNetworkDiskSrcStr(virStorageSourcePtr src,\n                           const char *username,\n                           const char *secret)\n{\n    char *ret = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n\n    switch ((virStorageNetProtocol) src->protocol) {\n    case VIR_STORAGE_NET_PROTOCOL_NBD:\n    case VIR_STORAGE_NET_PROTOCOL_HTTP:\n    case VIR_STORAGE_NET_PROTOCOL_HTTPS:\n    case VIR_STORAGE_NET_PROTOCOL_FTP:\n    case VIR_STORAGE_NET_PROTOCOL_FTPS:\n    case VIR_STORAGE_NET_PROTOCOL_TFTP:\n    case VIR_STORAGE_NET_PROTOCOL_ISCSI:\n    case VIR_STORAGE_NET_PROTOCOL_GLUSTER:\n    case VIR_STORAGE_NET_PROTOCOL_SHEEPDOG:\n    case VIR_STORAGE_NET_PROTOCOL_SSH:\n    case VIR_STORAGE_NET_PROTOCOL_VXHS:\n    case VIR_STORAGE_NET_PROTOCOL_LAST:\n    case VIR_STORAGE_NET_PROTOCOL_NONE:\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"Unsupported network block protocol '%s'\"),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        goto cleanup;\n\n    case VIR_STORAGE_NET_PROTOCOL_RBD:\n        if (strchr(src->path, ':')) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"':' not allowed in RBD source volume name '%s'\"),\n                           src->path);\n            goto cleanup;\n        }\n\n        virBufferStrcat(&buf, \"rbd:\", src->volume, \"/\", src->path, NULL);\n\n        if (username) {\n            virBufferEscape(&buf, '\\\\', \":\", \":id=%s\", username);\n            virBufferEscape(&buf, '\\\\', \":\",\n                            \":key=%s:auth_supported=cephx\\\\;none\",\n                            secret);\n        } else {\n            virBufferAddLit(&buf, \":auth_supported=none\");\n        }\n\n        if (src->nhosts > 0) {\n            virBufferAddLit(&buf, \":mon_host=\");\n            for (i = 0; i < src->nhosts; i++) {\n                if (i)\n                    virBufferAddLit(&buf, \"\\\\;\");\n\n                /* assume host containing : is ipv6 */\n                if (strchr(src->hosts[i].name, ':'))\n                    virBufferEscape(&buf, '\\\\', \":\", \"[%s]\",\n                                    src->hosts[i].name);\n                else\n                    virBufferAsprintf(&buf, \"%s\", src->hosts[i].name);\n\n                if (src->hosts[i].port)\n                    virBufferAsprintf(&buf, \"\\\\:%u\", src->hosts[i].port);\n            }\n        }\n\n        if (src->configFile)\n            virBufferEscape(&buf, '\\\\', \":\", \":conf=%s\", src->configFile);\n\n        ret = virBufferContentAndReset(&buf);\n        break;\n    }\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return ret;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscape",
          "args": [
            "&buf",
            "'\\\\'",
            "\":\"",
            "\":conf=%s\"",
            "src->configFile"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "491-522",
          "snippet": "void\nvirBufferEscape(virBufferPtr buf, char escape, const char *toescape,\n                const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, toescape) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 2);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (strchr(toescape, *cur))\n            *out++ = escape;\n        *out++ = *cur;\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscape(virBufferPtr buf, char escape, const char *toescape,\n                const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, toescape) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 2);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (strchr(toescape, *cur))\n            *out++ = escape;\n        *out++ = *cur;\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"\\\\:%u\"",
            "src->hosts[i].port"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "src->hosts[i].name",
            "':'"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"\\\\;\""
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\":mon_host=\""
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\":auth_supported=none\""
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferStrcat",
          "args": [
            "&buf",
            "\"rbd:\"",
            "src->volume",
            "\"/\"",
            "src->path",
            "NULL"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferStrcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "624-635",
          "snippet": "void\nvirBufferStrcat(virBufferPtr buf, ...)\n{\n    va_list ap;\n\n    if (!buf)\n        return;\n\n    va_start(ap, buf);\n    virBufferStrcatVArgs(buf, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferStrcat(virBufferPtr buf, ...)\n{\n    va_list ap;\n\n    if (!buf)\n        return;\n\n    va_start(ap, buf);\n    virBufferStrcatVArgs(buf, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"':' not allowed in RBD source volume name '%s'\")",
            "src->path"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"':' not allowed in RBD source volume name '%s'\""
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "src->path",
            "':'"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"Unsupported network block protocol '%s'\")",
            "virStorageNetProtocolTypeToString(src->protocol)"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageNetProtocolTypeToString",
          "args": [
            "src->protocol"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic char *\nlibxlMakeNetworkDiskSrcStr(virStorageSourcePtr src,\n                           const char *username,\n                           const char *secret)\n{\n    char *ret = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n\n    switch ((virStorageNetProtocol) src->protocol) {\n    case VIR_STORAGE_NET_PROTOCOL_NBD:\n    case VIR_STORAGE_NET_PROTOCOL_HTTP:\n    case VIR_STORAGE_NET_PROTOCOL_HTTPS:\n    case VIR_STORAGE_NET_PROTOCOL_FTP:\n    case VIR_STORAGE_NET_PROTOCOL_FTPS:\n    case VIR_STORAGE_NET_PROTOCOL_TFTP:\n    case VIR_STORAGE_NET_PROTOCOL_ISCSI:\n    case VIR_STORAGE_NET_PROTOCOL_GLUSTER:\n    case VIR_STORAGE_NET_PROTOCOL_SHEEPDOG:\n    case VIR_STORAGE_NET_PROTOCOL_SSH:\n    case VIR_STORAGE_NET_PROTOCOL_VXHS:\n    case VIR_STORAGE_NET_PROTOCOL_LAST:\n    case VIR_STORAGE_NET_PROTOCOL_NONE:\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"Unsupported network block protocol '%s'\"),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        goto cleanup;\n\n    case VIR_STORAGE_NET_PROTOCOL_RBD:\n        if (strchr(src->path, ':')) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"':' not allowed in RBD source volume name '%s'\"),\n                           src->path);\n            goto cleanup;\n        }\n\n        virBufferStrcat(&buf, \"rbd:\", src->volume, \"/\", src->path, NULL);\n\n        if (username) {\n            virBufferEscape(&buf, '\\\\', \":\", \":id=%s\", username);\n            virBufferEscape(&buf, '\\\\', \":\",\n                            \":key=%s:auth_supported=cephx\\\\;none\",\n                            secret);\n        } else {\n            virBufferAddLit(&buf, \":auth_supported=none\");\n        }\n\n        if (src->nhosts > 0) {\n            virBufferAddLit(&buf, \":mon_host=\");\n            for (i = 0; i < src->nhosts; i++) {\n                if (i)\n                    virBufferAddLit(&buf, \"\\\\;\");\n\n                /* assume host containing : is ipv6 */\n                if (strchr(src->hosts[i].name, ':'))\n                    virBufferEscape(&buf, '\\\\', \":\", \"[%s]\",\n                                    src->hosts[i].name);\n                else\n                    virBufferAsprintf(&buf, \"%s\", src->hosts[i].name);\n\n                if (src->hosts[i].port)\n                    virBufferAsprintf(&buf, \"\\\\:%u\", src->hosts[i].port);\n            }\n        }\n\n        if (src->configFile)\n            virBufferEscape(&buf, '\\\\', \":\", \":conf=%s\", src->configFile);\n\n        ret = virBufferContentAndReset(&buf);\n        break;\n    }\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return ret;\n}"
  },
  {
    "function_name": "libxlDiskSetDiscard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "841-867",
    "snippet": "static int\nlibxlDiskSetDiscard(libxl_device_disk *x_disk, int discard)\n{\n    if (!x_disk->readwrite)\n        return 0;\n#if defined(LIBXL_HAVE_LIBXL_DEVICE_DISK_DISCARD_ENABLE)\n    switch ((virDomainDiskDiscard)discard) {\n    case VIR_DOMAIN_DISK_DISCARD_DEFAULT:\n    case VIR_DOMAIN_DISK_DISCARD_LAST:\n        break;\n    case VIR_DOMAIN_DISK_DISCARD_UNMAP:\n        libxl_defbool_set(&x_disk->discard_enable, true);\n        break;\n    case VIR_DOMAIN_DISK_DISCARD_IGNORE:\n        libxl_defbool_set(&x_disk->discard_enable, false);\n        break;\n    }\n    return 0;\n#else\n    if (discard == VIR_DOMAIN_DISK_DISCARD_DEFAULT)\n        return 0;\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                   _(\"This version of libxenlight does not support \"\n                     \"disk 'discard' option passing\"));\n    return -1;\n#endif\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"This version of libxenlight does not support \"\n                     \"disk 'discard' option passing\")"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"This version of libxenlight does not support \"\n                     \"disk 'discard' option passing\""
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&x_disk->discard_enable",
            "false"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&x_disk->discard_enable",
            "true"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlDiskSetDiscard(libxl_device_disk *x_disk, int discard)\n{\n    if (!x_disk->readwrite)\n        return 0;\n#if defined(LIBXL_HAVE_LIBXL_DEVICE_DISK_DISCARD_ENABLE)\n    switch ((virDomainDiskDiscard)discard) {\n    case VIR_DOMAIN_DISK_DISCARD_DEFAULT:\n    case VIR_DOMAIN_DISK_DISCARD_LAST:\n        break;\n    case VIR_DOMAIN_DISK_DISCARD_UNMAP:\n        libxl_defbool_set(&x_disk->discard_enable, true);\n        break;\n    case VIR_DOMAIN_DISK_DISCARD_IGNORE:\n        libxl_defbool_set(&x_disk->discard_enable, false);\n        break;\n    }\n    return 0;\n#else\n    if (discard == VIR_DOMAIN_DISK_DISCARD_DEFAULT)\n        return 0;\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                   _(\"This version of libxenlight does not support \"\n                     \"disk 'discard' option passing\"));\n    return -1;\n#endif\n}"
  },
  {
    "function_name": "libxlMakeVnumaList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "728-838",
    "snippet": "static int\nlibxlMakeVnumaList(virDomainDefPtr def,\n                   libxl_ctx *ctx,\n                   libxl_domain_config *d_config)\n{\n    int ret = -1;\n    size_t i, j;\n    size_t nr_nodes;\n    size_t num_vnuma;\n    bool simulate = false;\n    virBitmapPtr bitmap = NULL;\n    virDomainNumaPtr numa = def->numa;\n    libxl_domain_build_info *b_info = &d_config->b_info;\n    libxl_physinfo physinfo;\n    libxl_vnode_info *vnuma_nodes = NULL;\n\n    if (!numa)\n        return 0;\n\n    num_vnuma = virDomainNumaGetNodeCount(numa);\n    if (!num_vnuma)\n        return 0;\n\n    libxl_physinfo_init(&physinfo);\n    if (libxl_get_physinfo(ctx, &physinfo) < 0) {\n        libxl_physinfo_dispose(&physinfo);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libxl_get_physinfo_info failed\"));\n        return -1;\n    }\n    nr_nodes = physinfo.nr_nodes;\n    libxl_physinfo_dispose(&physinfo);\n\n    if (num_vnuma > nr_nodes) {\n        VIR_WARN(\"Number of configured numa cells %zu exceeds available physical nodes %zu. All cells will use physical node 0\",\n                 num_vnuma, nr_nodes);\n        simulate = true;\n    }\n\n    /*\n     * allocate the vnuma_nodes for assignment under b_info.\n     */\n    if (VIR_ALLOC_N(vnuma_nodes, num_vnuma) < 0)\n        return -1;\n\n    /*\n     * parse the vnuma vnodes data.\n     */\n    for (i = 0; i < num_vnuma; i++) {\n        int cpu;\n        libxl_bitmap vcpu_bitmap;\n        libxl_vnode_info *p = &vnuma_nodes[i];\n\n        libxl_vnode_info_init(p);\n\n        /* pnode */\n        p->pnode = simulate ? 0 : i;\n\n        /* memory size */\n        p->memkb = virDomainNumaGetNodeMemorySize(numa, i);\n\n        /* vcpus */\n        bitmap = virDomainNumaGetNodeCpumask(numa, i);\n        if (bitmap == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"vnuma sibling %zu missing vcpus set\"), i);\n            goto cleanup;\n        }\n\n        if ((cpu = virBitmapNextSetBit(bitmap, -1)) < 0)\n            goto cleanup;\n\n        libxl_bitmap_init(&vcpu_bitmap);\n        if (libxl_cpu_bitmap_alloc(ctx, &vcpu_bitmap, b_info->max_vcpus)) {\n            virReportOOMError();\n            goto cleanup;\n        }\n\n        do {\n            libxl_bitmap_set(&vcpu_bitmap, cpu);\n        } while ((cpu = virBitmapNextSetBit(bitmap, cpu)) >= 0);\n\n        libxl_bitmap_copy_alloc(ctx, &p->vcpus, &vcpu_bitmap);\n        libxl_bitmap_dispose(&vcpu_bitmap);\n\n        /* vdistances */\n        if (VIR_ALLOC_N(p->distances, num_vnuma) < 0)\n            goto cleanup;\n        p->num_distances = num_vnuma;\n\n        for (j = 0; j < num_vnuma; j++)\n            p->distances[j] = virDomainNumaGetNodeDistance(numa, i, j);\n    }\n\n    b_info->vnuma_nodes = vnuma_nodes;\n    b_info->num_vnuma_nodes = num_vnuma;\n\n    ret = 0;\n\n cleanup:\n    if (ret) {\n        for (i = 0; i < num_vnuma; i++) {\n            libxl_vnode_info *p = &vnuma_nodes[i];\n\n            VIR_FREE(p->distances);\n        }\n        VIR_FREE(vnuma_nodes);\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vnuma_nodes"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "p->distances"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeDistance",
          "args": [
            "numa",
            "i",
            "j"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeDistance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1210-1231",
          "snippet": "size_t\nvirDomainNumaGetNodeDistance(virDomainNumaPtr numa,\n                             size_t node,\n                             size_t cellid)\n{\n    virDomainNumaDistancePtr distances = NULL;\n\n    if (node < numa->nmem_nodes)\n        distances = numa->mem_nodes[node].distances;\n\n    /*\n     * Present the configured distance value. If\n     * out of range or not available set the platform\n     * defined default for local and remote nodes.\n     */\n    if (!distances ||\n        cellid >= numa->nmem_nodes ||\n        !distances[cellid].value)\n        return (node == cellid) ? LOCAL_DISTANCE : REMOTE_DISTANCE;\n\n    return distances[cellid].value;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define REMOTE_DISTANCE         20",
            "#define LOCAL_DISTANCE          10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\n#define REMOTE_DISTANCE         20\n#define LOCAL_DISTANCE          10\n\nsize_t\nvirDomainNumaGetNodeDistance(virDomainNumaPtr numa,\n                             size_t node,\n                             size_t cellid)\n{\n    virDomainNumaDistancePtr distances = NULL;\n\n    if (node < numa->nmem_nodes)\n        distances = numa->mem_nodes[node].distances;\n\n    /*\n     * Present the configured distance value. If\n     * out of range or not available set the platform\n     * defined default for local and remote nodes.\n     */\n    if (!distances ||\n        cellid >= numa->nmem_nodes ||\n        !distances[cellid].value)\n        return (node == cellid) ? LOCAL_DISTANCE : REMOTE_DISTANCE;\n\n    return distances[cellid].value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "p->distances",
            "num_vnuma"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_bitmap_dispose",
          "args": [
            "&vcpu_bitmap"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_bitmap_copy_alloc",
          "args": [
            "ctx",
            "&p->vcpus",
            "&vcpu_bitmap"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapNextSetBit",
          "args": [
            "bitmap",
            "cpu"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNextSetBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "986-1014",
          "snippet": "ssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_bitmap_set",
          "args": [
            "&vcpu_bitmap",
            "cpu"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_cpu_bitmap_alloc",
          "args": [
            "ctx",
            "&vcpu_bitmap",
            "b_info->max_vcpus"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_bitmap_init",
          "args": [
            "&vcpu_bitmap"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"vnuma sibling %zu missing vcpus set\")",
            "i"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"vnuma sibling %zu missing vcpus set\""
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeCpumask",
          "args": [
            "numa",
            "i"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeCpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1313-1318",
          "snippet": "virBitmapPtr\nvirDomainNumaGetNodeCpumask(virDomainNumaPtr numa,\n                            size_t node)\n{\n    return numa->mem_nodes[node].cpumask;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirBitmapPtr\nvirDomainNumaGetNodeCpumask(virDomainNumaPtr numa,\n                            size_t node)\n{\n    return numa->mem_nodes[node].cpumask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeMemorySize",
          "args": [
            "numa",
            "i"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeMemorySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1348-1353",
          "snippet": "unsigned long long\nvirDomainNumaGetNodeMemorySize(virDomainNumaPtr numa,\n                               size_t node)\n{\n    return numa->mem_nodes[node].mem;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nunsigned long long\nvirDomainNumaGetNodeMemorySize(virDomainNumaPtr numa,\n                               size_t node)\n{\n    return numa->mem_nodes[node].mem;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_vnode_info_init",
          "args": [
            "p"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "vnuma_nodes",
            "num_vnuma"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Number of configured numa cells %zu exceeds available physical nodes %zu. All cells will use physical node 0\"",
            "num_vnuma",
            "nr_nodes"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_physinfo_dispose",
          "args": [
            "&physinfo"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"libxl_get_physinfo_info failed\")"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_physinfo_dispose",
          "args": [
            "&physinfo"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_get_physinfo",
          "args": [
            "ctx",
            "&physinfo"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_physinfo_init",
          "args": [
            "&physinfo"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeCount",
          "args": [
            "numa"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1137-1144",
          "snippet": "size_t\nvirDomainNumaGetNodeCount(virDomainNumaPtr numa)\n{\n    if (!numa)\n        return 0;\n\n    return numa->nmem_nodes;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nsize_t\nvirDomainNumaGetNodeCount(virDomainNumaPtr numa)\n{\n    if (!numa)\n        return 0;\n\n    return numa->nmem_nodes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeVnumaList(virDomainDefPtr def,\n                   libxl_ctx *ctx,\n                   libxl_domain_config *d_config)\n{\n    int ret = -1;\n    size_t i, j;\n    size_t nr_nodes;\n    size_t num_vnuma;\n    bool simulate = false;\n    virBitmapPtr bitmap = NULL;\n    virDomainNumaPtr numa = def->numa;\n    libxl_domain_build_info *b_info = &d_config->b_info;\n    libxl_physinfo physinfo;\n    libxl_vnode_info *vnuma_nodes = NULL;\n\n    if (!numa)\n        return 0;\n\n    num_vnuma = virDomainNumaGetNodeCount(numa);\n    if (!num_vnuma)\n        return 0;\n\n    libxl_physinfo_init(&physinfo);\n    if (libxl_get_physinfo(ctx, &physinfo) < 0) {\n        libxl_physinfo_dispose(&physinfo);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libxl_get_physinfo_info failed\"));\n        return -1;\n    }\n    nr_nodes = physinfo.nr_nodes;\n    libxl_physinfo_dispose(&physinfo);\n\n    if (num_vnuma > nr_nodes) {\n        VIR_WARN(\"Number of configured numa cells %zu exceeds available physical nodes %zu. All cells will use physical node 0\",\n                 num_vnuma, nr_nodes);\n        simulate = true;\n    }\n\n    /*\n     * allocate the vnuma_nodes for assignment under b_info.\n     */\n    if (VIR_ALLOC_N(vnuma_nodes, num_vnuma) < 0)\n        return -1;\n\n    /*\n     * parse the vnuma vnodes data.\n     */\n    for (i = 0; i < num_vnuma; i++) {\n        int cpu;\n        libxl_bitmap vcpu_bitmap;\n        libxl_vnode_info *p = &vnuma_nodes[i];\n\n        libxl_vnode_info_init(p);\n\n        /* pnode */\n        p->pnode = simulate ? 0 : i;\n\n        /* memory size */\n        p->memkb = virDomainNumaGetNodeMemorySize(numa, i);\n\n        /* vcpus */\n        bitmap = virDomainNumaGetNodeCpumask(numa, i);\n        if (bitmap == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"vnuma sibling %zu missing vcpus set\"), i);\n            goto cleanup;\n        }\n\n        if ((cpu = virBitmapNextSetBit(bitmap, -1)) < 0)\n            goto cleanup;\n\n        libxl_bitmap_init(&vcpu_bitmap);\n        if (libxl_cpu_bitmap_alloc(ctx, &vcpu_bitmap, b_info->max_vcpus)) {\n            virReportOOMError();\n            goto cleanup;\n        }\n\n        do {\n            libxl_bitmap_set(&vcpu_bitmap, cpu);\n        } while ((cpu = virBitmapNextSetBit(bitmap, cpu)) >= 0);\n\n        libxl_bitmap_copy_alloc(ctx, &p->vcpus, &vcpu_bitmap);\n        libxl_bitmap_dispose(&vcpu_bitmap);\n\n        /* vdistances */\n        if (VIR_ALLOC_N(p->distances, num_vnuma) < 0)\n            goto cleanup;\n        p->num_distances = num_vnuma;\n\n        for (j = 0; j < num_vnuma; j++)\n            p->distances[j] = virDomainNumaGetNodeDistance(numa, i, j);\n    }\n\n    b_info->vnuma_nodes = vnuma_nodes;\n    b_info->num_vnuma_nodes = num_vnuma;\n\n    ret = 0;\n\n cleanup:\n    if (ret) {\n        for (i = 0; i < num_vnuma; i++) {\n            libxl_vnode_info *p = &vnuma_nodes[i];\n\n            VIR_FREE(p->distances);\n        }\n        VIR_FREE(vnuma_nodes);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "libxlMakeDomBuildInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "263-725",
    "snippet": "static int\nlibxlMakeDomBuildInfo(virDomainDefPtr def,\n                      libxlDriverConfigPtr cfg,\n                      virCapsPtr caps,\n                      libxl_domain_config *d_config)\n{\n    virDomainClockDef clock = def->clock;\n    libxl_ctx *ctx = cfg->ctx;\n    libxl_domain_build_info *b_info = &d_config->b_info;\n    bool hvm = def->os.type == VIR_DOMAIN_OSTYPE_HVM;\n    bool pvh = def->os.type == VIR_DOMAIN_OSTYPE_XENPVH;\n    size_t i;\n    size_t nusbdevice = 0;\n\n    libxl_domain_build_info_init(b_info);\n\n    if (hvm) {\n        libxl_domain_build_info_init_type(b_info, LIBXL_DOMAIN_TYPE_HVM);\n    } else if (pvh) {\n#ifdef HAVE_XEN_PVH\n        libxl_domain_build_info_init_type(b_info, LIBXL_DOMAIN_TYPE_PVH);\n#else\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                _(\"PVH guest os type not supported\"));\n        return -1;\n#endif\n    } else {\n        libxl_domain_build_info_init_type(b_info, LIBXL_DOMAIN_TYPE_PV);\n    }\n\n    b_info->max_vcpus = virDomainDefGetVcpusMax(def);\n    if (libxl_cpu_bitmap_alloc(ctx, &b_info->avail_vcpus, b_info->max_vcpus))\n        return -1;\n    libxl_bitmap_set_none(&b_info->avail_vcpus);\n    for (i = 0; i < virDomainDefGetVcpus(def); i++)\n        libxl_bitmap_set((&b_info->avail_vcpus), i);\n\n    switch ((virDomainClockOffsetType) clock.offset) {\n    case VIR_DOMAIN_CLOCK_OFFSET_VARIABLE:\n        if (clock.data.variable.basis == VIR_DOMAIN_CLOCK_BASIS_LOCALTIME)\n            libxl_defbool_set(&b_info->localtime, true);\n        b_info->rtc_timeoffset = clock.data.variable.adjustment;\n        break;\n\n    case VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME:\n        libxl_defbool_set(&b_info->localtime, true);\n        break;\n\n    /* Nothing to do since UTC is the default in libxl */\n    case VIR_DOMAIN_CLOCK_OFFSET_UTC:\n        break;\n\n    case VIR_DOMAIN_CLOCK_OFFSET_TIMEZONE:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unsupported clock offset '%s'\"),\n                       virDomainClockOffsetTypeToString(clock.offset));\n        return -1;\n\n    case VIR_DOMAIN_CLOCK_OFFSET_LAST:\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unexpected clock offset '%d'\"), clock.offset);\n        return -1;\n    }\n\n    for (i = 0; i < clock.ntimers; i++) {\n        switch ((virDomainTimerNameType) clock.timers[i]->name) {\n        case VIR_DOMAIN_TIMER_NAME_TSC:\n            switch (clock.timers[i]->mode) {\n            case VIR_DOMAIN_TIMER_MODE_NATIVE:\n                b_info->tsc_mode = LIBXL_TSC_MODE_NATIVE;\n                break;\n            case VIR_DOMAIN_TIMER_MODE_PARAVIRT:\n                b_info->tsc_mode = LIBXL_TSC_MODE_NATIVE_PARAVIRT;\n                break;\n            case VIR_DOMAIN_TIMER_MODE_EMULATE:\n                b_info->tsc_mode = LIBXL_TSC_MODE_ALWAYS_EMULATE;\n                break;\n            default:\n                b_info->tsc_mode = LIBXL_TSC_MODE_DEFAULT;\n            }\n            break;\n\n        case VIR_DOMAIN_TIMER_NAME_HPET:\n            if (!hvm) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unsupported timer type (name) '%s'\"),\n                               virDomainTimerNameTypeToString(clock.timers[i]->name));\n                return -1;\n            }\n            if (clock.timers[i]->present == 1)\n                libxl_defbool_set(&b_info->u.hvm.hpet, 1);\n            break;\n\n        case VIR_DOMAIN_TIMER_NAME_PLATFORM:\n        case VIR_DOMAIN_TIMER_NAME_KVMCLOCK:\n        case VIR_DOMAIN_TIMER_NAME_HYPERVCLOCK:\n        case VIR_DOMAIN_TIMER_NAME_RTC:\n        case VIR_DOMAIN_TIMER_NAME_PIT:\n        case VIR_DOMAIN_TIMER_NAME_ARMVTIMER:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported timer type (name) '%s'\"),\n                           virDomainTimerNameTypeToString(clock.timers[i]->name));\n            return -1;\n\n        case VIR_DOMAIN_TIMER_NAME_LAST:\n            break;\n        }\n    }\n\n    if (def->cputune.sharesSpecified)\n        b_info->sched_params.weight = def->cputune.shares;\n\n    /* Xen requires the memory sizes to be rounded to 1MiB increments */\n    virDomainDefSetMemoryTotal(def,\n                               VIR_ROUND_UP(virDomainDefGetMemoryInitial(def), 1024));\n    def->mem.cur_balloon = VIR_ROUND_UP(def->mem.cur_balloon, 1024);\n    b_info->max_memkb = virDomainDefGetMemoryInitial(def);\n    b_info->target_memkb = def->mem.cur_balloon;\n\n#ifdef LIBXL_HAVE_BUILDINFO_GRANT_LIMITS\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_XENBUS &&\n            def->controllers[i]->opts.xenbusopts.maxGrantFrames > 0)\n            b_info->max_grant_frames = def->controllers[i]->opts.xenbusopts.maxGrantFrames;\n    }\n#endif\n\n    if (hvm || pvh) {\n        if (caps &&\n            def->cpu && def->cpu->mode == (VIR_CPU_MODE_HOST_PASSTHROUGH)) {\n            bool hasHwVirt = false;\n            bool svm = false, vmx = false;\n            char xlCPU[32];\n\n            /* enable nested HVM only if global nested_hvm option enable it and\n             * host support it */\n            if (ARCH_IS_X86(def->os.arch)) {\n                vmx = virCPUCheckFeature(caps->host.arch, caps->host.cpu, \"vmx\");\n                svm = virCPUCheckFeature(caps->host.arch, caps->host.cpu, \"svm\");\n                hasHwVirt = cfg->nested_hvm && (vmx | svm);\n            }\n\n            if (def->cpu->nfeatures) {\n                for (i = 0; i < def->cpu->nfeatures; i++) {\n\n                    switch (def->cpu->features[i].policy) {\n\n                        case VIR_CPU_FEATURE_DISABLE:\n                        case VIR_CPU_FEATURE_FORBID:\n                            if ((vmx && STREQ(def->cpu->features[i].name, \"vmx\")) ||\n                                (svm && STREQ(def->cpu->features[i].name, \"svm\"))) {\n                                hasHwVirt = false;\n                                continue;\n                            }\n\n                            g_snprintf(xlCPU,\n                                       sizeof(xlCPU),\n                                       \"%s=0\",\n                                       xenTranslateCPUFeature(\n                                           def->cpu->features[i].name,\n                                           false));\n                            if (libxl_cpuid_parse_config(&b_info->cpuid, xlCPU)) {\n                                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                        _(\"unsupported cpu feature '%s'\"),\n                                        def->cpu->features[i].name);\n                                return -1;\n                            }\n                            break;\n\n                        case VIR_CPU_FEATURE_FORCE:\n                        case VIR_CPU_FEATURE_REQUIRE:\n                            if ((vmx && STREQ(def->cpu->features[i].name, \"vmx\")) ||\n                                (svm && STREQ(def->cpu->features[i].name, \"svm\"))) {\n                                hasHwVirt = true;\n                                continue;\n                            }\n\n                            g_snprintf(xlCPU,\n                                       sizeof(xlCPU),\n                                       \"%s=1\",\n                                       xenTranslateCPUFeature(\n                                           def->cpu->features[i].name, false));\n                            if (libxl_cpuid_parse_config(&b_info->cpuid, xlCPU)) {\n                                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                        _(\"unsupported cpu feature '%s'\"),\n                                        def->cpu->features[i].name);\n                                return -1;\n                            }\n                            break;\n                        case VIR_CPU_FEATURE_OPTIONAL:\n                        case VIR_CPU_FEATURE_LAST:\n                            break;\n                    }\n                }\n            }\n#ifdef LIBXL_HAVE_BUILDINFO_NESTED_HVM\n            libxl_defbool_set(&b_info->nested_hvm, hasHwVirt);\n#else\n            if (hvm) {\n                libxl_defbool_set(&b_info->u.hvm.nested_hvm, hasHwVirt);\n            } else {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                        _(\"unsupported nested HVM setting for %s machine on this Xen version\"),\n                        def->os.machine);\n                return -1;\n            }\n#endif\n        }\n\n        if (def->cpu && def->cpu->mode == VIR_CPU_MODE_CUSTOM) {\n            VIR_WARN(\"Ignoring CPU with mode=custom, update your config to \"\n                     \"mode=host-passthrough to avoid risk of changed guest \"\n                     \"semantics when mode=custom is supported in the future\");\n        }\n    }\n\n    if (hvm) {\n        char bootorder[VIR_DOMAIN_BOOT_LAST + 1];\n\n        libxl_defbool_set(&b_info->u.hvm.pae,\n                          def->features[VIR_DOMAIN_FEATURE_PAE] ==\n                          VIR_TRISTATE_SWITCH_ON);\n        libxl_defbool_set(&b_info->u.hvm.apic,\n                          def->features[VIR_DOMAIN_FEATURE_APIC] ==\n                          VIR_TRISTATE_SWITCH_ON);\n        libxl_defbool_set(&b_info->u.hvm.acpi,\n                          def->features[VIR_DOMAIN_FEATURE_ACPI] ==\n                          VIR_TRISTATE_SWITCH_ON);\n\n        /* copy SLIC table path to acpi_firmware */\n        if (def->os.slic_table)\n            b_info->u.hvm.acpi_firmware = g_strdup(def->os.slic_table);\n\n        if (def->nsounds > 0) {\n            /*\n             * Use first sound device.  man xl.cfg(5) describes soundhw as\n             * a single device.  From the man page: soundhw=DEVICE\n             */\n            virDomainSoundDefPtr snd = def->sounds[0];\n\n            b_info->u.hvm.soundhw = g_strdup(virDomainSoundModelTypeToString(snd->model));\n        }\n\n        for (i = 0; i < def->os.nBootDevs; i++) {\n            switch (def->os.bootDevs[i]) {\n                case VIR_DOMAIN_BOOT_FLOPPY:\n                    bootorder[i] = 'a';\n                    break;\n                default:\n                case VIR_DOMAIN_BOOT_DISK:\n                    bootorder[i] = 'c';\n                    break;\n                case VIR_DOMAIN_BOOT_CDROM:\n                    bootorder[i] = 'd';\n                    break;\n                case VIR_DOMAIN_BOOT_NET:\n                    bootorder[i] = 'n';\n                    break;\n            }\n        }\n        if (def->os.nBootDevs == 0) {\n            bootorder[0] = 'c';\n            bootorder[1] = '\\0';\n        } else {\n            bootorder[def->os.nBootDevs] = '\\0';\n        }\n        b_info->u.hvm.boot = g_strdup(bootorder);\n\n#ifdef LIBXL_HAVE_BUILDINFO_KERNEL\n        b_info->cmdline = g_strdup(def->os.cmdline);\n        b_info->kernel = g_strdup(def->os.kernel);\n        b_info->ramdisk = g_strdup(def->os.initrd);\n#endif\n\n        /*\n         * Currently libxl only allows specifying the type of BIOS.\n         * If the type is PFLASH, we assume OVMF and set libxl_bios_type\n         * to LIBXL_BIOS_TYPE_OVMF. The path to the OVMF firmware is\n         * configured when building Xen using '--with-system-ovmf='. If\n         * not specified, LIBXL_FIRMWARE_DIR/ovmf.bin is used. In the\n         * future, Xen will support a user-specified firmware path. See\n         * http://lists.xenproject.org/archives/html/xen-devel/2016-03/msg01628.html\n         */\n        if (virDomainDefHasOldStyleUEFI(def))\n            b_info->u.hvm.bios = LIBXL_BIOS_TYPE_OVMF;\n\n        if (def->emulator) {\n            if (!virFileExists(def->emulator)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"emulator '%s' not found\"),\n                               def->emulator);\n                return -1;\n            }\n\n            if (!virFileIsExecutable(def->emulator)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"emulator '%s' is not executable\"),\n                               def->emulator);\n                return -1;\n            }\n\n            VIR_FREE(b_info->device_model);\n            b_info->device_model = g_strdup(def->emulator);\n\n            b_info->device_model_version = libxlDomainGetEmulatorType(def);\n        }\n\n        if (def->nserials) {\n            if (def->nserials == 1) {\n                if (libxlMakeChrdevStr(def->serials[0], &b_info->u.hvm.serial) <\n                    0)\n                    return -1;\n            } else {\n#ifdef LIBXL_HAVE_BUILDINFO_SERIAL_LIST\n                if (VIR_ALLOC_N(b_info->u.hvm.serial_list, def->nserials + 1) <\n                    0)\n                    return -1;\n                for (i = 0; i < def->nserials; i++) {\n                    if (libxlMakeChrdevStr(def->serials[i],\n                                           &b_info->u.hvm.serial_list[i]) < 0)\n                    {\n                        libxl_string_list_dispose(&b_info->u.hvm.serial_list);\n                        return -1;\n                    }\n                }\n                b_info->u.hvm.serial_list[i] = NULL;\n#else\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               \"%s\",\n                               _(\"Only one serial device is supported by libxl\"));\n                return -1;\n#endif\n            }\n        }\n\n        if (def->nparallels) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           \"%s\",\n                           _(\"Parallel devices are not supported by libxl\"));\n            return -1;\n        }\n\n        /* Disable VNC and SDL until explicitly enabled */\n        libxl_defbool_set(&b_info->u.hvm.vnc.enable, 0);\n        libxl_defbool_set(&b_info->u.hvm.sdl.enable, 0);\n\n        for (i = 0; i < def->ninputs; i++) {\n            char **usbdevice;\n\n            if (def->inputs[i]->bus != VIR_DOMAIN_INPUT_BUS_USB)\n                continue;\n\n#ifdef LIBXL_HAVE_BUILDINFO_USBDEVICE_LIST\n            if (VIR_EXPAND_N(b_info->u.hvm.usbdevice_list, nusbdevice, 1) < 0)\n                return -1;\n#else\n            nusbdevice++;\n            if (nusbdevice > 1) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                        _(\"libxenlight supports only one input device\"));\n                return -1;\n            }\n#endif\n\n#ifdef LIBXL_HAVE_BUILDINFO_USBDEVICE_LIST\n            usbdevice = &b_info->u.hvm.usbdevice_list[nusbdevice - 1];\n#else\n            usbdevice = &b_info->u.hvm.usbdevice;\n#endif\n            switch (def->inputs[i]->type) {\n                case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n                    VIR_FREE(*usbdevice);\n                    *usbdevice = g_strdup(\"mouse\");\n                    break;\n                case VIR_DOMAIN_INPUT_TYPE_TABLET:\n                    VIR_FREE(*usbdevice);\n                    *usbdevice = g_strdup(\"tablet\");\n                    break;\n                default:\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                            _(\"Unknown input device type\"));\n                    return -1;\n            }\n        }\n\n#ifdef LIBXL_HAVE_BUILDINFO_USBDEVICE_LIST\n        /* NULL-terminate usbdevice_list */\n        if (nusbdevice > 0 &&\n            VIR_EXPAND_N(b_info->u.hvm.usbdevice_list, nusbdevice, 1) < 0) {\n            VIR_DISPOSE_N(b_info->u.hvm.usbdevice_list, nusbdevice);\n            return -1;\n        }\n#endif\n    } else if (pvh) {\n        b_info->cmdline = g_strdup(def->os.cmdline);\n        b_info->kernel = g_strdup(def->os.kernel);\n        b_info->ramdisk = g_strdup(def->os.initrd);\n#ifdef LIBXL_HAVE_BUILDINFO_BOOTLOADER\n        b_info->bootloader = g_strdup(def->os.bootloader);\n        if (def->os.bootloaderArgs) {\n            if (!(b_info->bootloader_args =\n                  virStringSplit(def->os.bootloaderArgs, \" \\t\\n\", 0)))\n                return -1;\n        }\n#endif\n    } else {\n        /*\n         * For compatibility with the legacy xen toolstack, default to pygrub\n         * if bootloader is not specified AND direct kernel boot is not specified.\n         */\n        if (def->os.bootloader) {\n            b_info->u.pv.bootloader = g_strdup(def->os.bootloader);\n        } else if (def->os.kernel == NULL) {\n            b_info->u.pv.bootloader = g_strdup(LIBXL_BOOTLOADER_PATH);\n        }\n        if (def->os.bootloaderArgs) {\n            if (!(b_info->u.pv.bootloader_args =\n                  virStringSplit(def->os.bootloaderArgs, \" \\t\\n\", 0)))\n                return -1;\n        }\n        b_info->u.pv.cmdline = g_strdup(def->os.cmdline);\n        if (def->os.kernel) {\n            /* libxl_init_build_info() sets kernel.path = g_strdup(\"hvmloader\") */\n            VIR_FREE(b_info->u.pv.kernel);\n            b_info->u.pv.kernel = g_strdup(def->os.kernel);\n        }\n        b_info->u.pv.ramdisk = g_strdup(def->os.initrd);\n    }\n\n    /* only the 'xen' balloon device model is supported */\n    if (def->memballoon) {\n        int model = def->memballoon->model;\n\n        switch ((virDomainMemballoonModel)model) {\n        case VIR_DOMAIN_MEMBALLOON_MODEL_XEN:\n            break;\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_TRANSITIONAL:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_NON_TRANSITIONAL:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported balloon device model '%s'\"),\n                           virDomainMemballoonModelTypeToString(model));\n            return -1;\n        case VIR_DOMAIN_MEMBALLOON_MODEL_NONE:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           \"%s\",\n                           _(\"balloon device cannot be disabled\"));\n            return -1;\n        case VIR_DOMAIN_MEMBALLOON_MODEL_LAST:\n        default:\n            virReportEnumRangeError(virDomainMemballoonModel, model);\n            return -1;\n        }\n    }\n\n    /* Allow libxl to calculate shadow memory requirements */\n    b_info->shadow_memkb =\n        libxl_get_required_shadow_memory(b_info->max_memkb,\n                                         b_info->max_vcpus);\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libxl_get_required_shadow_memory",
          "args": [
            "b_info->max_memkb",
            "b_info->max_vcpus"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virDomainMemballoonModel",
            "model"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"balloon device cannot be disabled\")"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"balloon device cannot be disabled\""
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unsupported balloon device model '%s'\")",
            "virDomainMemballoonModelTypeToString(model)"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainMemballoonModelTypeToString",
          "args": [
            "model"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "def->os.initrd"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "b_info->u.pv.kernel"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSplit",
          "args": [
            "def->os.bootloaderArgs",
            "\" \\t\\n\"",
            "0"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "126-132",
          "snippet": "char **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DISPOSE_N",
          "args": [
            "b_info->u.hvm.usbdevice_list",
            "nusbdevice"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "b_info->u.hvm.usbdevice_list",
            "nusbdevice",
            "1"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Unknown input device type\")"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*usbdevice"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*usbdevice"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"libxenlight supports only one input device\")"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "b_info->u.hvm.usbdevice_list",
            "nusbdevice",
            "1"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.sdl.enable",
            "0"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.vnc.enable",
            "0"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Parallel devices are not supported by libxl\")"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Only one serial device is supported by libxl\")"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_string_list_dispose",
          "args": [
            "&b_info->u.hvm.serial_list"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlMakeChrdevStr",
          "args": [
            "def->serials[i]",
            "&b_info->u.hvm.serial_list[i]"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeChrdevStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "189-261",
          "snippet": "static int\nlibxlMakeChrdevStr(virDomainChrDefPtr def, char **buf)\n{\n    virDomainChrSourceDefPtr srcdef = def->source;\n    const char *type = virDomainChrTypeToString(srcdef->type);\n\n    if (!type) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       \"%s\", _(\"unknown chrdev type\"));\n        return -1;\n    }\n\n    switch (srcdef->type) {\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        *buf = g_strdup(type);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        *buf = g_strdup_printf(\"%s:%s\", type, srcdef->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n        *buf = g_strdup(srcdef->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UDP: {\n        const char *connectHost = srcdef->data.udp.connectHost;\n        const char *bindHost = srcdef->data.udp.bindHost;\n        const char *bindService  = srcdef->data.udp.bindService;\n\n        if (connectHost == NULL)\n            connectHost = \"\";\n        if (bindHost == NULL)\n            bindHost = \"\";\n        if (bindService == NULL)\n            bindService = \"0\";\n\n        *buf = g_strdup_printf(\"udp:%s:%s@%s:%s\", connectHost,\n                               srcdef->data.udp.connectService, bindHost, bindService);\n        break;\n    }\n\n    case VIR_DOMAIN_CHR_TYPE_TCP: {\n        const char *prefix;\n\n        if (srcdef->data.tcp.protocol == VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNET)\n            prefix = \"telnet\";\n        else\n            prefix = \"tcp\";\n\n        *buf = g_strdup_printf(\"%s:%s:%s%s\", prefix, srcdef->data.tcp.host,\n                               srcdef->data.tcp.service,\n                               srcdef->data.tcp.listen ? \",server,nowait\" : \"\");\n        break;\n    }\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        *buf = g_strdup_printf(\"unix:%s%s\", srcdef->data.nix.path,\n                               srcdef->data.nix.listen ? \",server,nowait\" : \"\");\n        break;\n\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unsupported chardev '%s'\"), type);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeChrdevStr(virDomainChrDefPtr def, char **buf)\n{\n    virDomainChrSourceDefPtr srcdef = def->source;\n    const char *type = virDomainChrTypeToString(srcdef->type);\n\n    if (!type) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       \"%s\", _(\"unknown chrdev type\"));\n        return -1;\n    }\n\n    switch (srcdef->type) {\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        *buf = g_strdup(type);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        *buf = g_strdup_printf(\"%s:%s\", type, srcdef->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n        *buf = g_strdup(srcdef->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UDP: {\n        const char *connectHost = srcdef->data.udp.connectHost;\n        const char *bindHost = srcdef->data.udp.bindHost;\n        const char *bindService  = srcdef->data.udp.bindService;\n\n        if (connectHost == NULL)\n            connectHost = \"\";\n        if (bindHost == NULL)\n            bindHost = \"\";\n        if (bindService == NULL)\n            bindService = \"0\";\n\n        *buf = g_strdup_printf(\"udp:%s:%s@%s:%s\", connectHost,\n                               srcdef->data.udp.connectService, bindHost, bindService);\n        break;\n    }\n\n    case VIR_DOMAIN_CHR_TYPE_TCP: {\n        const char *prefix;\n\n        if (srcdef->data.tcp.protocol == VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNET)\n            prefix = \"telnet\";\n        else\n            prefix = \"tcp\";\n\n        *buf = g_strdup_printf(\"%s:%s:%s%s\", prefix, srcdef->data.tcp.host,\n                               srcdef->data.tcp.service,\n                               srcdef->data.tcp.listen ? \",server,nowait\" : \"\");\n        break;\n    }\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        *buf = g_strdup_printf(\"unix:%s%s\", srcdef->data.nix.path,\n                               srcdef->data.nix.listen ? \",server,nowait\" : \"\");\n        break;\n\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unsupported chardev '%s'\"), type);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "b_info->u.hvm.serial_list",
            "def->nserials + 1"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDomainGetEmulatorType",
          "args": [
            "def"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainGetEmulatorType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
          "lines": "777-806",
          "snippet": "int\nlibxlDomainGetEmulatorType(const virDomainDef *def)\n{\n    int ret = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN;\n    virCommandPtr cmd = NULL;\n    char *output = NULL;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (def->emulator) {\n            if (!virFileExists(def->emulator))\n                goto cleanup;\n\n            cmd = virCommandNew(def->emulator);\n\n            virCommandAddArgList(cmd, \"-help\", NULL);\n            virCommandSetOutputBuffer(cmd, &output);\n\n            if (virCommandRun(cmd, NULL) < 0)\n                goto cleanup;\n\n            if (strstr(output, LIBXL_QEMU_DM_STR))\n                ret = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN_TRADITIONAL;\n        }\n    }\n\n cleanup:\n    VIR_FREE(output);\n    virCommandFree(cmd);\n    return ret;\n}",
          "includes": [
            "#include \"cpu/cpu_x86_data.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBXL_QEMU_DM_STR  \"Options specific to the Xen version:\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\n#define LIBXL_QEMU_DM_STR  \"Options specific to the Xen version:\"\n\nint\nlibxlDomainGetEmulatorType(const virDomainDef *def)\n{\n    int ret = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN;\n    virCommandPtr cmd = NULL;\n    char *output = NULL;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (def->emulator) {\n            if (!virFileExists(def->emulator))\n                goto cleanup;\n\n            cmd = virCommandNew(def->emulator);\n\n            virCommandAddArgList(cmd, \"-help\", NULL);\n            virCommandSetOutputBuffer(cmd, &output);\n\n            if (virCommandRun(cmd, NULL) < 0)\n                goto cleanup;\n\n            if (strstr(output, LIBXL_QEMU_DM_STR))\n                ret = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN_TRADITIONAL;\n        }\n    }\n\n cleanup:\n    VIR_FREE(output);\n    virCommandFree(cmd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "b_info->device_model"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"emulator '%s' is not executable\")",
            "def->emulator"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileIsExecutable",
          "args": [
            "def->emulator"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "virFileIsExecutable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1886-1899",
          "snippet": "bool\nvirFileIsExecutable(const char *file)\n{\n    struct stat sb;\n\n    /* We would also want to check faccessat if we cared about ACLs,\n     * but we don't.  */\n    if (stat(file, &sb) < 0)\n        return false;\n    if (S_ISREG(sb.st_mode) && (sb.st_mode & 0111) != 0)\n        return true;\n    errno = S_ISDIR(sb.st_mode) ? EISDIR : EACCES;\n    return false;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileIsExecutable(const char *file)\n{\n    struct stat sb;\n\n    /* We would also want to check faccessat if we cared about ACLs,\n     * but we don't.  */\n    if (stat(file, &sb) < 0)\n        return false;\n    if (S_ISREG(sb.st_mode) && (sb.st_mode & 0111) != 0)\n        return true;\n    errno = S_ISDIR(sb.st_mode) ? EISDIR : EACCES;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"emulator '%s' not found\")",
            "def->emulator"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "def->emulator"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefHasOldStyleUEFI",
          "args": [
            "def"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefHasOldStyleUEFI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "32082-32087",
          "snippet": "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def)\n{\n    return def->os.loader &&\n           def->os.loader->type == VIR_DOMAIN_LOADER_TYPE_PFLASH;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def)\n{\n    return def->os.loader &&\n           def->os.loader->type == VIR_DOMAIN_LOADER_TYPE_PFLASH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainSoundModelTypeToString",
          "args": [
            "snd->model"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.acpi",
            "def->features[VIR_DOMAIN_FEATURE_ACPI] ==\n                          VIR_TRISTATE_SWITCH_ON"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.apic",
            "def->features[VIR_DOMAIN_FEATURE_APIC] ==\n                          VIR_TRISTATE_SWITCH_ON"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.pae",
            "def->features[VIR_DOMAIN_FEATURE_PAE] ==\n                          VIR_TRISTATE_SWITCH_ON"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Ignoring CPU with mode=custom, update your config to \"\n                     \"mode=host-passthrough to avoid risk of changed guest \"\n                     \"semantics when mode=custom is supported in the future\""
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unsupported nested HVM setting for %s machine on this Xen version\")",
            "def->os.machine"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.nested_hvm",
            "hasHwVirt"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->nested_hvm",
            "hasHwVirt"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unsupported cpu feature '%s'\")",
            "def->cpu->features[i].name"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_cpuid_parse_config",
          "args": [
            "&b_info->cpuid",
            "xlCPU"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "xlCPU",
            "sizeof(xlCPU)",
            "\"%s=1\"",
            "xenTranslateCPUFeature(\n                                           def->cpu->features[i].name, false)"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenTranslateCPUFeature",
          "args": [
            "def->cpu->features[i].name",
            "false"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "xenTranslateCPUFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "218-247",
          "snippet": "const char *\nxenTranslateCPUFeature(const char *feature_name, bool from_libxl)\n{\n    static const char *translation_table[][2] = {\n        /* libvirt name, libxl name */\n        { \"cx16\", \"cmpxchg16\" },\n        { \"cid\", \"cntxid\" },\n        { \"ds_cpl\", \"dscpl\" },\n        { \"pclmuldq\", \"pclmulqdq\" },\n        { \"pni\", \"sse3\" },\n        { \"ht\", \"htt\" },\n        { \"pn\", \"psn\" },\n        { \"clflush\", \"clfsh\" },\n        { \"sep\", \"sysenter\" },\n        { \"cx8\", \"cmpxchg8\" },\n        { \"nodeid_msr\", \"nodeid\" },\n        { \"cr8legacy\", \"altmovcr8\" },\n        { \"lahf_lm\", \"lahfsahf\" },\n        { \"cmp_legacy\", \"cmplegacy\" },\n        { \"fxsr_opt\", \"ffxsr\" },\n        { \"pdpe1gb\", \"page1gb\" },\n        { \"spec-ctrl\", \"ibrsb\" },\n    };\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(translation_table); i++)\n        if (STREQ(translation_table[i][from_libxl], feature_name))\n            return translation_table[i][!from_libxl];\n    return feature_name;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nconst char *\nxenTranslateCPUFeature(const char *feature_name, bool from_libxl)\n{\n    static const char *translation_table[][2] = {\n        /* libvirt name, libxl name */\n        { \"cx16\", \"cmpxchg16\" },\n        { \"cid\", \"cntxid\" },\n        { \"ds_cpl\", \"dscpl\" },\n        { \"pclmuldq\", \"pclmulqdq\" },\n        { \"pni\", \"sse3\" },\n        { \"ht\", \"htt\" },\n        { \"pn\", \"psn\" },\n        { \"clflush\", \"clfsh\" },\n        { \"sep\", \"sysenter\" },\n        { \"cx8\", \"cmpxchg8\" },\n        { \"nodeid_msr\", \"nodeid\" },\n        { \"cr8legacy\", \"altmovcr8\" },\n        { \"lahf_lm\", \"lahfsahf\" },\n        { \"cmp_legacy\", \"cmplegacy\" },\n        { \"fxsr_opt\", \"ffxsr\" },\n        { \"pdpe1gb\", \"page1gb\" },\n        { \"spec-ctrl\", \"ibrsb\" },\n    };\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(translation_table); i++)\n        if (STREQ(translation_table[i][from_libxl], feature_name))\n            return translation_table[i][!from_libxl];\n    return feature_name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->cpu->features[i].name",
            "\"svm\""
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->cpu->features[i].name",
            "\"vmx\""
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unsupported cpu feature '%s'\")",
            "def->cpu->features[i].name"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_cpuid_parse_config",
          "args": [
            "&b_info->cpuid",
            "xlCPU"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "xlCPU",
            "sizeof(xlCPU)",
            "\"%s=0\"",
            "xenTranslateCPUFeature(\n                                           def->cpu->features[i].name,\n                                           false)"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->cpu->features[i].name",
            "\"svm\""
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->cpu->features[i].name",
            "\"vmx\""
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUCheckFeature",
          "args": [
            "caps->host.arch",
            "caps->host.cpu",
            "\"svm\""
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUCheckFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "674-695",
          "snippet": "int\nvirCPUCheckFeature(virArch arch,\n                   const virCPUDef *cpu,\n                   const char *feature)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, feature=%s\",\n              virArchToString(arch), cpu, feature);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->checkFeature) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot check guest CPU feature for %s architecture\"),\n                       virArchToString(arch));\n        return -1;\n    }\n\n    return driver->checkFeature(cpu, feature);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUCheckFeature(virArch arch,\n                   const virCPUDef *cpu,\n                   const char *feature)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, feature=%s\",\n              virArchToString(arch), cpu, feature);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->checkFeature) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot check guest CPU feature for %s architecture\"),\n                       virArchToString(arch));\n        return -1;\n    }\n\n    return driver->checkFeature(cpu, feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_X86",
          "args": [
            "def->os.arch"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetMemoryInitial",
          "args": [
            "def"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetMemoryInitial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10910-10920",
          "snippet": "unsigned long long\nvirDomainDefGetMemoryInitial(const virDomainDef *def)\n{\n    size_t i;\n    unsigned long long ret = def->mem.total_memory;\n\n    for (i = 0; i < def->nmems; i++)\n        ret -= def->mems[i]->size;\n\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned long long\nvirDomainDefGetMemoryInitial(const virDomainDef *def)\n{\n    size_t i;\n    unsigned long long ret = def->mem.total_memory;\n\n    for (i = 0; i < def->nmems; i++)\n        ret -= def->mems[i]->size;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ROUND_UP",
          "args": [
            "def->mem.cur_balloon",
            "1024"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefSetMemoryTotal",
          "args": [
            "def",
            "VIR_ROUND_UP(virDomainDefGetMemoryInitial(def), 1024)"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetMemoryTotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10931-10936",
          "snippet": "void\nvirDomainDefSetMemoryTotal(virDomainDefPtr def,\n                           unsigned long long size)\n{\n    def->mem.total_memory = size;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDefSetMemoryTotal(virDomainDefPtr def,\n                           unsigned long long size)\n{\n    def->mem.total_memory = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ROUND_UP",
          "args": [
            "virDomainDefGetMemoryInitial(def)",
            "1024"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unsupported timer type (name) '%s'\")",
            "virDomainTimerNameTypeToString(clock.timers[i]->name)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainTimerNameTypeToString",
          "args": [
            "clock.timers[i]->name"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->u.hvm.hpet",
            "1"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unsupported timer type (name) '%s'\")",
            "virDomainTimerNameTypeToString(clock.timers[i]->name)"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainTimerNameTypeToString",
          "args": [
            "clock.timers[i]->name"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unexpected clock offset '%d'\")",
            "clock.offset"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unsupported clock offset '%s'\")",
            "virDomainClockOffsetTypeToString(clock.offset)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainClockOffsetTypeToString",
          "args": [
            "clock.offset"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->localtime",
            "true"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&b_info->localtime",
            "true"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_bitmap_set",
          "args": [
            "(&b_info->avail_vcpus)",
            "i"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetVcpus",
          "args": [
            "def"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetVcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1912-1924",
          "snippet": "unsigned int\nvirDomainDefGetVcpus(const virDomainDef *def)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (def->vcpus[i]->online)\n            ret++;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned int\nvirDomainDefGetVcpus(const virDomainDef *def)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (def->vcpus[i]->online)\n            ret++;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_bitmap_set_none",
          "args": [
            "&b_info->avail_vcpus"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_cpu_bitmap_alloc",
          "args": [
            "ctx",
            "&b_info->avail_vcpus",
            "b_info->max_vcpus"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetVcpusMax",
          "args": [
            "def"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetVcpusMax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1882-1886",
          "snippet": "unsigned int\nvirDomainDefGetVcpusMax(const virDomainDef *def)\n{\n    return def->maxvcpus;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned int\nvirDomainDefGetVcpusMax(const virDomainDef *def)\n{\n    return def->maxvcpus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_domain_build_info_init_type",
          "args": [
            "b_info",
            "LIBXL_DOMAIN_TYPE_PV"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"PVH guest os type not supported\")"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_domain_build_info_init_type",
          "args": [
            "b_info",
            "LIBXL_DOMAIN_TYPE_PVH"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_domain_build_info_init_type",
          "args": [
            "b_info",
            "LIBXL_DOMAIN_TYPE_HVM"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_domain_build_info_init",
          "args": [
            "b_info"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeDomBuildInfo(virDomainDefPtr def,\n                      libxlDriverConfigPtr cfg,\n                      virCapsPtr caps,\n                      libxl_domain_config *d_config)\n{\n    virDomainClockDef clock = def->clock;\n    libxl_ctx *ctx = cfg->ctx;\n    libxl_domain_build_info *b_info = &d_config->b_info;\n    bool hvm = def->os.type == VIR_DOMAIN_OSTYPE_HVM;\n    bool pvh = def->os.type == VIR_DOMAIN_OSTYPE_XENPVH;\n    size_t i;\n    size_t nusbdevice = 0;\n\n    libxl_domain_build_info_init(b_info);\n\n    if (hvm) {\n        libxl_domain_build_info_init_type(b_info, LIBXL_DOMAIN_TYPE_HVM);\n    } else if (pvh) {\n#ifdef HAVE_XEN_PVH\n        libxl_domain_build_info_init_type(b_info, LIBXL_DOMAIN_TYPE_PVH);\n#else\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                _(\"PVH guest os type not supported\"));\n        return -1;\n#endif\n    } else {\n        libxl_domain_build_info_init_type(b_info, LIBXL_DOMAIN_TYPE_PV);\n    }\n\n    b_info->max_vcpus = virDomainDefGetVcpusMax(def);\n    if (libxl_cpu_bitmap_alloc(ctx, &b_info->avail_vcpus, b_info->max_vcpus))\n        return -1;\n    libxl_bitmap_set_none(&b_info->avail_vcpus);\n    for (i = 0; i < virDomainDefGetVcpus(def); i++)\n        libxl_bitmap_set((&b_info->avail_vcpus), i);\n\n    switch ((virDomainClockOffsetType) clock.offset) {\n    case VIR_DOMAIN_CLOCK_OFFSET_VARIABLE:\n        if (clock.data.variable.basis == VIR_DOMAIN_CLOCK_BASIS_LOCALTIME)\n            libxl_defbool_set(&b_info->localtime, true);\n        b_info->rtc_timeoffset = clock.data.variable.adjustment;\n        break;\n\n    case VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME:\n        libxl_defbool_set(&b_info->localtime, true);\n        break;\n\n    /* Nothing to do since UTC is the default in libxl */\n    case VIR_DOMAIN_CLOCK_OFFSET_UTC:\n        break;\n\n    case VIR_DOMAIN_CLOCK_OFFSET_TIMEZONE:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unsupported clock offset '%s'\"),\n                       virDomainClockOffsetTypeToString(clock.offset));\n        return -1;\n\n    case VIR_DOMAIN_CLOCK_OFFSET_LAST:\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unexpected clock offset '%d'\"), clock.offset);\n        return -1;\n    }\n\n    for (i = 0; i < clock.ntimers; i++) {\n        switch ((virDomainTimerNameType) clock.timers[i]->name) {\n        case VIR_DOMAIN_TIMER_NAME_TSC:\n            switch (clock.timers[i]->mode) {\n            case VIR_DOMAIN_TIMER_MODE_NATIVE:\n                b_info->tsc_mode = LIBXL_TSC_MODE_NATIVE;\n                break;\n            case VIR_DOMAIN_TIMER_MODE_PARAVIRT:\n                b_info->tsc_mode = LIBXL_TSC_MODE_NATIVE_PARAVIRT;\n                break;\n            case VIR_DOMAIN_TIMER_MODE_EMULATE:\n                b_info->tsc_mode = LIBXL_TSC_MODE_ALWAYS_EMULATE;\n                break;\n            default:\n                b_info->tsc_mode = LIBXL_TSC_MODE_DEFAULT;\n            }\n            break;\n\n        case VIR_DOMAIN_TIMER_NAME_HPET:\n            if (!hvm) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unsupported timer type (name) '%s'\"),\n                               virDomainTimerNameTypeToString(clock.timers[i]->name));\n                return -1;\n            }\n            if (clock.timers[i]->present == 1)\n                libxl_defbool_set(&b_info->u.hvm.hpet, 1);\n            break;\n\n        case VIR_DOMAIN_TIMER_NAME_PLATFORM:\n        case VIR_DOMAIN_TIMER_NAME_KVMCLOCK:\n        case VIR_DOMAIN_TIMER_NAME_HYPERVCLOCK:\n        case VIR_DOMAIN_TIMER_NAME_RTC:\n        case VIR_DOMAIN_TIMER_NAME_PIT:\n        case VIR_DOMAIN_TIMER_NAME_ARMVTIMER:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported timer type (name) '%s'\"),\n                           virDomainTimerNameTypeToString(clock.timers[i]->name));\n            return -1;\n\n        case VIR_DOMAIN_TIMER_NAME_LAST:\n            break;\n        }\n    }\n\n    if (def->cputune.sharesSpecified)\n        b_info->sched_params.weight = def->cputune.shares;\n\n    /* Xen requires the memory sizes to be rounded to 1MiB increments */\n    virDomainDefSetMemoryTotal(def,\n                               VIR_ROUND_UP(virDomainDefGetMemoryInitial(def), 1024));\n    def->mem.cur_balloon = VIR_ROUND_UP(def->mem.cur_balloon, 1024);\n    b_info->max_memkb = virDomainDefGetMemoryInitial(def);\n    b_info->target_memkb = def->mem.cur_balloon;\n\n#ifdef LIBXL_HAVE_BUILDINFO_GRANT_LIMITS\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_XENBUS &&\n            def->controllers[i]->opts.xenbusopts.maxGrantFrames > 0)\n            b_info->max_grant_frames = def->controllers[i]->opts.xenbusopts.maxGrantFrames;\n    }\n#endif\n\n    if (hvm || pvh) {\n        if (caps &&\n            def->cpu && def->cpu->mode == (VIR_CPU_MODE_HOST_PASSTHROUGH)) {\n            bool hasHwVirt = false;\n            bool svm = false, vmx = false;\n            char xlCPU[32];\n\n            /* enable nested HVM only if global nested_hvm option enable it and\n             * host support it */\n            if (ARCH_IS_X86(def->os.arch)) {\n                vmx = virCPUCheckFeature(caps->host.arch, caps->host.cpu, \"vmx\");\n                svm = virCPUCheckFeature(caps->host.arch, caps->host.cpu, \"svm\");\n                hasHwVirt = cfg->nested_hvm && (vmx | svm);\n            }\n\n            if (def->cpu->nfeatures) {\n                for (i = 0; i < def->cpu->nfeatures; i++) {\n\n                    switch (def->cpu->features[i].policy) {\n\n                        case VIR_CPU_FEATURE_DISABLE:\n                        case VIR_CPU_FEATURE_FORBID:\n                            if ((vmx && STREQ(def->cpu->features[i].name, \"vmx\")) ||\n                                (svm && STREQ(def->cpu->features[i].name, \"svm\"))) {\n                                hasHwVirt = false;\n                                continue;\n                            }\n\n                            g_snprintf(xlCPU,\n                                       sizeof(xlCPU),\n                                       \"%s=0\",\n                                       xenTranslateCPUFeature(\n                                           def->cpu->features[i].name,\n                                           false));\n                            if (libxl_cpuid_parse_config(&b_info->cpuid, xlCPU)) {\n                                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                        _(\"unsupported cpu feature '%s'\"),\n                                        def->cpu->features[i].name);\n                                return -1;\n                            }\n                            break;\n\n                        case VIR_CPU_FEATURE_FORCE:\n                        case VIR_CPU_FEATURE_REQUIRE:\n                            if ((vmx && STREQ(def->cpu->features[i].name, \"vmx\")) ||\n                                (svm && STREQ(def->cpu->features[i].name, \"svm\"))) {\n                                hasHwVirt = true;\n                                continue;\n                            }\n\n                            g_snprintf(xlCPU,\n                                       sizeof(xlCPU),\n                                       \"%s=1\",\n                                       xenTranslateCPUFeature(\n                                           def->cpu->features[i].name, false));\n                            if (libxl_cpuid_parse_config(&b_info->cpuid, xlCPU)) {\n                                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                        _(\"unsupported cpu feature '%s'\"),\n                                        def->cpu->features[i].name);\n                                return -1;\n                            }\n                            break;\n                        case VIR_CPU_FEATURE_OPTIONAL:\n                        case VIR_CPU_FEATURE_LAST:\n                            break;\n                    }\n                }\n            }\n#ifdef LIBXL_HAVE_BUILDINFO_NESTED_HVM\n            libxl_defbool_set(&b_info->nested_hvm, hasHwVirt);\n#else\n            if (hvm) {\n                libxl_defbool_set(&b_info->u.hvm.nested_hvm, hasHwVirt);\n            } else {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                        _(\"unsupported nested HVM setting for %s machine on this Xen version\"),\n                        def->os.machine);\n                return -1;\n            }\n#endif\n        }\n\n        if (def->cpu && def->cpu->mode == VIR_CPU_MODE_CUSTOM) {\n            VIR_WARN(\"Ignoring CPU with mode=custom, update your config to \"\n                     \"mode=host-passthrough to avoid risk of changed guest \"\n                     \"semantics when mode=custom is supported in the future\");\n        }\n    }\n\n    if (hvm) {\n        char bootorder[VIR_DOMAIN_BOOT_LAST + 1];\n\n        libxl_defbool_set(&b_info->u.hvm.pae,\n                          def->features[VIR_DOMAIN_FEATURE_PAE] ==\n                          VIR_TRISTATE_SWITCH_ON);\n        libxl_defbool_set(&b_info->u.hvm.apic,\n                          def->features[VIR_DOMAIN_FEATURE_APIC] ==\n                          VIR_TRISTATE_SWITCH_ON);\n        libxl_defbool_set(&b_info->u.hvm.acpi,\n                          def->features[VIR_DOMAIN_FEATURE_ACPI] ==\n                          VIR_TRISTATE_SWITCH_ON);\n\n        /* copy SLIC table path to acpi_firmware */\n        if (def->os.slic_table)\n            b_info->u.hvm.acpi_firmware = g_strdup(def->os.slic_table);\n\n        if (def->nsounds > 0) {\n            /*\n             * Use first sound device.  man xl.cfg(5) describes soundhw as\n             * a single device.  From the man page: soundhw=DEVICE\n             */\n            virDomainSoundDefPtr snd = def->sounds[0];\n\n            b_info->u.hvm.soundhw = g_strdup(virDomainSoundModelTypeToString(snd->model));\n        }\n\n        for (i = 0; i < def->os.nBootDevs; i++) {\n            switch (def->os.bootDevs[i]) {\n                case VIR_DOMAIN_BOOT_FLOPPY:\n                    bootorder[i] = 'a';\n                    break;\n                default:\n                case VIR_DOMAIN_BOOT_DISK:\n                    bootorder[i] = 'c';\n                    break;\n                case VIR_DOMAIN_BOOT_CDROM:\n                    bootorder[i] = 'd';\n                    break;\n                case VIR_DOMAIN_BOOT_NET:\n                    bootorder[i] = 'n';\n                    break;\n            }\n        }\n        if (def->os.nBootDevs == 0) {\n            bootorder[0] = 'c';\n            bootorder[1] = '\\0';\n        } else {\n            bootorder[def->os.nBootDevs] = '\\0';\n        }\n        b_info->u.hvm.boot = g_strdup(bootorder);\n\n#ifdef LIBXL_HAVE_BUILDINFO_KERNEL\n        b_info->cmdline = g_strdup(def->os.cmdline);\n        b_info->kernel = g_strdup(def->os.kernel);\n        b_info->ramdisk = g_strdup(def->os.initrd);\n#endif\n\n        /*\n         * Currently libxl only allows specifying the type of BIOS.\n         * If the type is PFLASH, we assume OVMF and set libxl_bios_type\n         * to LIBXL_BIOS_TYPE_OVMF. The path to the OVMF firmware is\n         * configured when building Xen using '--with-system-ovmf='. If\n         * not specified, LIBXL_FIRMWARE_DIR/ovmf.bin is used. In the\n         * future, Xen will support a user-specified firmware path. See\n         * http://lists.xenproject.org/archives/html/xen-devel/2016-03/msg01628.html\n         */\n        if (virDomainDefHasOldStyleUEFI(def))\n            b_info->u.hvm.bios = LIBXL_BIOS_TYPE_OVMF;\n\n        if (def->emulator) {\n            if (!virFileExists(def->emulator)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"emulator '%s' not found\"),\n                               def->emulator);\n                return -1;\n            }\n\n            if (!virFileIsExecutable(def->emulator)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"emulator '%s' is not executable\"),\n                               def->emulator);\n                return -1;\n            }\n\n            VIR_FREE(b_info->device_model);\n            b_info->device_model = g_strdup(def->emulator);\n\n            b_info->device_model_version = libxlDomainGetEmulatorType(def);\n        }\n\n        if (def->nserials) {\n            if (def->nserials == 1) {\n                if (libxlMakeChrdevStr(def->serials[0], &b_info->u.hvm.serial) <\n                    0)\n                    return -1;\n            } else {\n#ifdef LIBXL_HAVE_BUILDINFO_SERIAL_LIST\n                if (VIR_ALLOC_N(b_info->u.hvm.serial_list, def->nserials + 1) <\n                    0)\n                    return -1;\n                for (i = 0; i < def->nserials; i++) {\n                    if (libxlMakeChrdevStr(def->serials[i],\n                                           &b_info->u.hvm.serial_list[i]) < 0)\n                    {\n                        libxl_string_list_dispose(&b_info->u.hvm.serial_list);\n                        return -1;\n                    }\n                }\n                b_info->u.hvm.serial_list[i] = NULL;\n#else\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               \"%s\",\n                               _(\"Only one serial device is supported by libxl\"));\n                return -1;\n#endif\n            }\n        }\n\n        if (def->nparallels) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           \"%s\",\n                           _(\"Parallel devices are not supported by libxl\"));\n            return -1;\n        }\n\n        /* Disable VNC and SDL until explicitly enabled */\n        libxl_defbool_set(&b_info->u.hvm.vnc.enable, 0);\n        libxl_defbool_set(&b_info->u.hvm.sdl.enable, 0);\n\n        for (i = 0; i < def->ninputs; i++) {\n            char **usbdevice;\n\n            if (def->inputs[i]->bus != VIR_DOMAIN_INPUT_BUS_USB)\n                continue;\n\n#ifdef LIBXL_HAVE_BUILDINFO_USBDEVICE_LIST\n            if (VIR_EXPAND_N(b_info->u.hvm.usbdevice_list, nusbdevice, 1) < 0)\n                return -1;\n#else\n            nusbdevice++;\n            if (nusbdevice > 1) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                        _(\"libxenlight supports only one input device\"));\n                return -1;\n            }\n#endif\n\n#ifdef LIBXL_HAVE_BUILDINFO_USBDEVICE_LIST\n            usbdevice = &b_info->u.hvm.usbdevice_list[nusbdevice - 1];\n#else\n            usbdevice = &b_info->u.hvm.usbdevice;\n#endif\n            switch (def->inputs[i]->type) {\n                case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n                    VIR_FREE(*usbdevice);\n                    *usbdevice = g_strdup(\"mouse\");\n                    break;\n                case VIR_DOMAIN_INPUT_TYPE_TABLET:\n                    VIR_FREE(*usbdevice);\n                    *usbdevice = g_strdup(\"tablet\");\n                    break;\n                default:\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                            _(\"Unknown input device type\"));\n                    return -1;\n            }\n        }\n\n#ifdef LIBXL_HAVE_BUILDINFO_USBDEVICE_LIST\n        /* NULL-terminate usbdevice_list */\n        if (nusbdevice > 0 &&\n            VIR_EXPAND_N(b_info->u.hvm.usbdevice_list, nusbdevice, 1) < 0) {\n            VIR_DISPOSE_N(b_info->u.hvm.usbdevice_list, nusbdevice);\n            return -1;\n        }\n#endif\n    } else if (pvh) {\n        b_info->cmdline = g_strdup(def->os.cmdline);\n        b_info->kernel = g_strdup(def->os.kernel);\n        b_info->ramdisk = g_strdup(def->os.initrd);\n#ifdef LIBXL_HAVE_BUILDINFO_BOOTLOADER\n        b_info->bootloader = g_strdup(def->os.bootloader);\n        if (def->os.bootloaderArgs) {\n            if (!(b_info->bootloader_args =\n                  virStringSplit(def->os.bootloaderArgs, \" \\t\\n\", 0)))\n                return -1;\n        }\n#endif\n    } else {\n        /*\n         * For compatibility with the legacy xen toolstack, default to pygrub\n         * if bootloader is not specified AND direct kernel boot is not specified.\n         */\n        if (def->os.bootloader) {\n            b_info->u.pv.bootloader = g_strdup(def->os.bootloader);\n        } else if (def->os.kernel == NULL) {\n            b_info->u.pv.bootloader = g_strdup(LIBXL_BOOTLOADER_PATH);\n        }\n        if (def->os.bootloaderArgs) {\n            if (!(b_info->u.pv.bootloader_args =\n                  virStringSplit(def->os.bootloaderArgs, \" \\t\\n\", 0)))\n                return -1;\n        }\n        b_info->u.pv.cmdline = g_strdup(def->os.cmdline);\n        if (def->os.kernel) {\n            /* libxl_init_build_info() sets kernel.path = g_strdup(\"hvmloader\") */\n            VIR_FREE(b_info->u.pv.kernel);\n            b_info->u.pv.kernel = g_strdup(def->os.kernel);\n        }\n        b_info->u.pv.ramdisk = g_strdup(def->os.initrd);\n    }\n\n    /* only the 'xen' balloon device model is supported */\n    if (def->memballoon) {\n        int model = def->memballoon->model;\n\n        switch ((virDomainMemballoonModel)model) {\n        case VIR_DOMAIN_MEMBALLOON_MODEL_XEN:\n            break;\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_TRANSITIONAL:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_NON_TRANSITIONAL:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported balloon device model '%s'\"),\n                           virDomainMemballoonModelTypeToString(model));\n            return -1;\n        case VIR_DOMAIN_MEMBALLOON_MODEL_NONE:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           \"%s\",\n                           _(\"balloon device cannot be disabled\"));\n            return -1;\n        case VIR_DOMAIN_MEMBALLOON_MODEL_LAST:\n        default:\n            virReportEnumRangeError(virDomainMemballoonModel, model);\n            return -1;\n        }\n    }\n\n    /* Allow libxl to calculate shadow memory requirements */\n    b_info->shadow_memkb =\n        libxl_get_required_shadow_memory(b_info->max_memkb,\n                                         b_info->max_vcpus);\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlMakeChrdevStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "189-261",
    "snippet": "static int\nlibxlMakeChrdevStr(virDomainChrDefPtr def, char **buf)\n{\n    virDomainChrSourceDefPtr srcdef = def->source;\n    const char *type = virDomainChrTypeToString(srcdef->type);\n\n    if (!type) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       \"%s\", _(\"unknown chrdev type\"));\n        return -1;\n    }\n\n    switch (srcdef->type) {\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        *buf = g_strdup(type);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        *buf = g_strdup_printf(\"%s:%s\", type, srcdef->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n        *buf = g_strdup(srcdef->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UDP: {\n        const char *connectHost = srcdef->data.udp.connectHost;\n        const char *bindHost = srcdef->data.udp.bindHost;\n        const char *bindService  = srcdef->data.udp.bindService;\n\n        if (connectHost == NULL)\n            connectHost = \"\";\n        if (bindHost == NULL)\n            bindHost = \"\";\n        if (bindService == NULL)\n            bindService = \"0\";\n\n        *buf = g_strdup_printf(\"udp:%s:%s@%s:%s\", connectHost,\n                               srcdef->data.udp.connectService, bindHost, bindService);\n        break;\n    }\n\n    case VIR_DOMAIN_CHR_TYPE_TCP: {\n        const char *prefix;\n\n        if (srcdef->data.tcp.protocol == VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNET)\n            prefix = \"telnet\";\n        else\n            prefix = \"tcp\";\n\n        *buf = g_strdup_printf(\"%s:%s:%s%s\", prefix, srcdef->data.tcp.host,\n                               srcdef->data.tcp.service,\n                               srcdef->data.tcp.listen ? \",server,nowait\" : \"\");\n        break;\n    }\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        *buf = g_strdup_printf(\"unix:%s%s\", srcdef->data.nix.path,\n                               srcdef->data.nix.listen ? \",server,nowait\" : \"\");\n        break;\n\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unsupported chardev '%s'\"), type);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unsupported chardev '%s'\")",
            "type"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported chardev '%s'\""
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"unix:%s%s\"",
            "srcdef->data.nix.path",
            "srcdef->data.nix.listen ? \",server,nowait\" : \"\""
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unknown chrdev type\")"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrTypeToString",
          "args": [
            "srcdef->type"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeChrdevStr(virDomainChrDefPtr def, char **buf)\n{\n    virDomainChrSourceDefPtr srcdef = def->source;\n    const char *type = virDomainChrTypeToString(srcdef->type);\n\n    if (!type) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       \"%s\", _(\"unknown chrdev type\"));\n        return -1;\n    }\n\n    switch (srcdef->type) {\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        *buf = g_strdup(type);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        *buf = g_strdup_printf(\"%s:%s\", type, srcdef->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n        *buf = g_strdup(srcdef->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UDP: {\n        const char *connectHost = srcdef->data.udp.connectHost;\n        const char *bindHost = srcdef->data.udp.bindHost;\n        const char *bindService  = srcdef->data.udp.bindService;\n\n        if (connectHost == NULL)\n            connectHost = \"\";\n        if (bindHost == NULL)\n            bindHost = \"\";\n        if (bindService == NULL)\n            bindService = \"0\";\n\n        *buf = g_strdup_printf(\"udp:%s:%s@%s:%s\", connectHost,\n                               srcdef->data.udp.connectService, bindHost, bindService);\n        break;\n    }\n\n    case VIR_DOMAIN_CHR_TYPE_TCP: {\n        const char *prefix;\n\n        if (srcdef->data.tcp.protocol == VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNET)\n            prefix = \"telnet\";\n        else\n            prefix = \"tcp\";\n\n        *buf = g_strdup_printf(\"%s:%s:%s%s\", prefix, srcdef->data.tcp.host,\n                               srcdef->data.tcp.service,\n                               srcdef->data.tcp.listen ? \",server,nowait\" : \"\");\n        break;\n    }\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        *buf = g_strdup_printf(\"unix:%s%s\", srcdef->data.nix.path,\n                               srcdef->data.nix.listen ? \",server,nowait\" : \"\");\n        break;\n\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unsupported chardev '%s'\"), type);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlMakeDomCreateInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "122-187",
    "snippet": "static int\nlibxlMakeDomCreateInfo(libxl_ctx *ctx,\n                       virDomainDefPtr def,\n                       libxl_domain_create_info *c_info)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    libxl_domain_create_info_init(c_info);\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM ||\n        def->os.type == VIR_DOMAIN_OSTYPE_XENPVH) {\n#ifdef HAVE_XEN_PVH\n        c_info->type = def->os.type == VIR_DOMAIN_OSTYPE_HVM ?\n            LIBXL_DOMAIN_TYPE_HVM : LIBXL_DOMAIN_TYPE_PVH;\n#else\n        if (def->os.type == VIR_DOMAIN_OSTYPE_XENPVH) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                    _(\"PVH guest os type not supported\"));\n            return -1;\n        }\n        c_info->type = LIBXL_DOMAIN_TYPE_HVM;\n#endif\n        switch ((virTristateSwitch) def->features[VIR_DOMAIN_FEATURE_HAP]) {\n        case VIR_TRISTATE_SWITCH_OFF:\n            libxl_defbool_set(&c_info->hap, false);\n            break;\n\n        case VIR_TRISTATE_SWITCH_ON:\n            libxl_defbool_set(&c_info->hap, true);\n            break;\n\n        case VIR_TRISTATE_SWITCH_ABSENT:\n        case VIR_TRISTATE_SWITCH_LAST:\n            break;\n        }\n    } else {\n        c_info->type = LIBXL_DOMAIN_TYPE_PV;\n    }\n\n    c_info->name = g_strdup(def->name);\n\n    if (def->nseclabels &&\n        def->seclabels[0]->type == VIR_DOMAIN_SECLABEL_STATIC) {\n        if (libxl_flask_context_to_sid(ctx,\n                                       def->seclabels[0]->label,\n                                       strlen(def->seclabels[0]->label),\n                                       &c_info->ssidref)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"libxenlight failed to resolve security label '%s'\"),\n                           def->seclabels[0]->label);\n        }\n    }\n\n    virUUIDFormat(def->uuid, uuidstr);\n    if (libxl_uuid_from_string(&c_info->uuid, uuidstr)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"libxenlight failed to parse UUID '%s'\"), uuidstr);\n        goto error;\n    }\n\n    return 0;\n\n error:\n    libxl_domain_create_info_dispose(c_info);\n    return -1;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libxl_domain_create_info_dispose",
          "args": [
            "c_info"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"libxenlight failed to parse UUID '%s'\")",
            "uuidstr"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"libxenlight failed to parse UUID '%s'\""
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_uuid_from_string",
          "args": [
            "&c_info->uuid",
            "uuidstr"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "def->uuid",
            "uuidstr"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"libxenlight failed to resolve security label '%s'\")",
            "def->seclabels[0]->label"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_flask_context_to_sid",
          "args": [
            "ctx",
            "def->seclabels[0]->label",
            "strlen(def->seclabels[0]->label)",
            "&c_info->ssidref"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "def->seclabels[0]->label"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "def->name"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&c_info->hap",
            "true"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_defbool_set",
          "args": [
            "&c_info->hap",
            "false"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"PVH guest os type not supported\")"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_domain_create_info_init",
          "args": [
            "c_info"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeDomCreateInfo(libxl_ctx *ctx,\n                       virDomainDefPtr def,\n                       libxl_domain_create_info *c_info)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    libxl_domain_create_info_init(c_info);\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM ||\n        def->os.type == VIR_DOMAIN_OSTYPE_XENPVH) {\n#ifdef HAVE_XEN_PVH\n        c_info->type = def->os.type == VIR_DOMAIN_OSTYPE_HVM ?\n            LIBXL_DOMAIN_TYPE_HVM : LIBXL_DOMAIN_TYPE_PVH;\n#else\n        if (def->os.type == VIR_DOMAIN_OSTYPE_XENPVH) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                    _(\"PVH guest os type not supported\"));\n            return -1;\n        }\n        c_info->type = LIBXL_DOMAIN_TYPE_HVM;\n#endif\n        switch ((virTristateSwitch) def->features[VIR_DOMAIN_FEATURE_HAP]) {\n        case VIR_TRISTATE_SWITCH_OFF:\n            libxl_defbool_set(&c_info->hap, false);\n            break;\n\n        case VIR_TRISTATE_SWITCH_ON:\n            libxl_defbool_set(&c_info->hap, true);\n            break;\n\n        case VIR_TRISTATE_SWITCH_ABSENT:\n        case VIR_TRISTATE_SWITCH_LAST:\n            break;\n        }\n    } else {\n        c_info->type = LIBXL_DOMAIN_TYPE_PV;\n    }\n\n    c_info->name = g_strdup(def->name);\n\n    if (def->nseclabels &&\n        def->seclabels[0]->type == VIR_DOMAIN_SECLABEL_STATIC) {\n        if (libxl_flask_context_to_sid(ctx,\n                                       def->seclabels[0]->label,\n                                       strlen(def->seclabels[0]->label),\n                                       &c_info->ssidref)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"libxenlight failed to resolve security label '%s'\"),\n                           def->seclabels[0]->label);\n        }\n    }\n\n    virUUIDFormat(def->uuid, uuidstr);\n    if (libxl_uuid_from_string(&c_info->uuid, uuidstr)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"libxenlight failed to parse UUID '%s'\"), uuidstr);\n        goto error;\n    }\n\n    return 0;\n\n error:\n    libxl_domain_create_info_dispose(c_info);\n    return -1;\n}"
  },
  {
    "function_name": "libxlActionFromVirLifecycle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "92-119",
    "snippet": "static libxl_action_on_shutdown\nlibxlActionFromVirLifecycle(virDomainLifecycleAction action)\n{\n    switch (action) {\n    case VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY:\n        return LIBXL_ACTION_ON_SHUTDOWN_DESTROY;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART:\n        return LIBXL_ACTION_ON_SHUTDOWN_RESTART;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART_RENAME:\n        return LIBXL_ACTION_ON_SHUTDOWN_RESTART_RENAME;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_PRESERVE:\n        return LIBXL_ACTION_ON_SHUTDOWN_PRESERVE;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_DESTROY:\n        return LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_DESTROY;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_RESTART:\n        return LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_RESTART;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_LAST:\n        break;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic libxl_action_on_shutdown\nlibxlActionFromVirLifecycle(virDomainLifecycleAction action)\n{\n    switch (action) {\n    case VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY:\n        return LIBXL_ACTION_ON_SHUTDOWN_DESTROY;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART:\n        return LIBXL_ACTION_ON_SHUTDOWN_RESTART;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART_RENAME:\n        return LIBXL_ACTION_ON_SHUTDOWN_RESTART_RENAME;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_PRESERVE:\n        return LIBXL_ACTION_ON_SHUTDOWN_PRESERVE;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_DESTROY:\n        return LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_DESTROY;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_RESTART:\n        return LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_RESTART;\n\n    case VIR_DOMAIN_LIFECYCLE_ACTION_LAST:\n        break;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlDriverConfigDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "68-89",
    "snippet": "static void\nlibxlDriverConfigDispose(void *obj)\n{\n    libxlDriverConfigPtr cfg = obj;\n\n    virObjectUnref(cfg->caps);\n    libxl_ctx_free(cfg->ctx);\n    if (cfg->logger)\n        libxlLoggerFree(cfg->logger);\n\n    VIR_FREE(cfg->configBaseDir);\n    VIR_FREE(cfg->configDir);\n    VIR_FREE(cfg->autostartDir);\n    VIR_FREE(cfg->logDir);\n    VIR_FREE(cfg->stateDir);\n    VIR_FREE(cfg->libDir);\n    VIR_FREE(cfg->saveDir);\n    VIR_FREE(cfg->autoDumpDir);\n    VIR_FREE(cfg->lockManagerName);\n    VIR_FREE(cfg->channelDir);\n    virFirmwareFreeList(cfg->firmwares, cfg->nfirmwares);\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void libxlDriverConfigDispose(void *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirmwareFreeList",
          "args": [
            "cfg->firmwares",
            "cfg->nfirmwares"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "virFirmwareFreeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirmware.c",
          "lines": "46-55",
          "snippet": "void\nvirFirmwareFreeList(virFirmwarePtr *firmwares, size_t nfirmwares)\n{\n    size_t i;\n\n    for (i = 0; i < nfirmwares; i++)\n        virFirmwareFree(firmwares[i]);\n\n    VIR_FREE(firmwares);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfirmware.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfirmware.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirFirmwareFreeList(virFirmwarePtr *firmwares, size_t nfirmwares)\n{\n    size_t i;\n\n    for (i = 0; i < nfirmwares; i++)\n        virFirmwareFree(firmwares[i]);\n\n    VIR_FREE(firmwares);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cfg->channelDir"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cfg->lockManagerName"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cfg->autoDumpDir"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cfg->saveDir"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cfg->libDir"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cfg->stateDir"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cfg->logDir"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cfg->autostartDir"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cfg->configDir"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cfg->configBaseDir"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlLoggerFree",
          "args": [
            "cfg->logger"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "libxlLoggerFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "175-183",
          "snippet": "void\nlibxlLoggerFree(libxlLoggerPtr logger)\n{\n    xentoollog_logger *xtl_logger = (xentoollog_logger*)logger;\n    if (logger->defaultLogFile)\n        VIR_FORCE_FCLOSE(logger->defaultLogFile);\n    virHashFree(logger->files);\n    xtl_logger_destroy(xtl_logger);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nvoid\nlibxlLoggerFree(libxlLoggerPtr logger)\n{\n    xentoollog_logger *xtl_logger = (xentoollog_logger*)logger;\n    if (logger->defaultLogFile)\n        VIR_FORCE_FCLOSE(logger->defaultLogFile);\n    virHashFree(logger->files);\n    xtl_logger_destroy(xtl_logger);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_ctx_free",
          "args": [
            "cfg->ctx"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg->caps"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic void libxlDriverConfigDispose(void *obj);\n\nstatic void\nlibxlDriverConfigDispose(void *obj)\n{\n    libxlDriverConfigPtr cfg = obj;\n\n    virObjectUnref(cfg->caps);\n    libxl_ctx_free(cfg->ctx);\n    if (cfg->logger)\n        libxlLoggerFree(cfg->logger);\n\n    VIR_FREE(cfg->configBaseDir);\n    VIR_FREE(cfg->configDir);\n    VIR_FREE(cfg->autostartDir);\n    VIR_FREE(cfg->logDir);\n    VIR_FREE(cfg->stateDir);\n    VIR_FREE(cfg->libDir);\n    VIR_FREE(cfg->saveDir);\n    VIR_FREE(cfg->autoDumpDir);\n    VIR_FREE(cfg->lockManagerName);\n    VIR_FREE(cfg->channelDir);\n    virFirmwareFreeList(cfg->firmwares, cfg->nfirmwares);\n}"
  },
  {
    "function_name": "libxlConfigOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
    "lines": "58-64",
    "snippet": "static int libxlConfigOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(libxlDriverConfig, virClassForObject()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"xen_xl.h\"",
      "#include \"xen_common.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virsecret.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"libxl_utils.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virconf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <sys/types.h>",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "libxlDriverConfig",
            "virClassForObject()"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObject",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectRWLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "131-138",
          "snippet": "virClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectRWLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectRWLockableClass;\n\nvirClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nstatic int libxlConfigOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(libxlDriverConfig, virClassForObject()))\n        return -1;\n\n    return 0;\n}"
  }
]