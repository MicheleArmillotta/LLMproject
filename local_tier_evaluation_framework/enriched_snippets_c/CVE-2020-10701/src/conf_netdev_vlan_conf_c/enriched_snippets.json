[
  {
    "function_name": "virNetDevVlanFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_vlan_conf.c",
    "lines": "140-174",
    "snippet": "int\nvirNetDevVlanFormat(const virNetDevVlan *def, virBufferPtr buf)\n{\n    size_t i;\n\n    if (!(def && def->nTags))\n        return 0;\n\n    if (!def->tag) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing vlan tag data\"));\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<vlan%s>\\n\", def->trunk ? \" trunk='yes'\" : \"\");\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < def->nTags; i++) {\n        if (def->nativeMode != VIR_NATIVE_VLAN_MODE_DEFAULT &&\n            def->nativeTag == def->tag[i]) {\n            /* check the nativeMode in case we get <tag id='0'/>*/\n            const char *mode = virNativeVlanModeTypeToString(def->nativeMode);\n            if (!mode) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Bad value for nativeMode\"));\n            }\n            virBufferAsprintf(buf, \"<tag id='%u' nativeMode='%s'/>\\n\",\n                              def->tag[i], mode);\n        } else {\n            virBufferAsprintf(buf, \"<tag id='%u'/>\\n\", def->tag[i]);\n        }\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</vlan>\\n\");\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</vlan>\\n\""
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<tag id='%u'/>\\n\"",
            "def->tag[i]"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Bad value for nativeMode\")"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Bad value for nativeMode\""
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNativeVlanModeTypeToString",
          "args": [
            "def->nativeMode"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing vlan tag data\")"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_vlan_conf.h\"\n#include <config.h>\n\nint\nvirNetDevVlanFormat(const virNetDevVlan *def, virBufferPtr buf)\n{\n    size_t i;\n\n    if (!(def && def->nTags))\n        return 0;\n\n    if (!def->tag) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing vlan tag data\"));\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<vlan%s>\\n\", def->trunk ? \" trunk='yes'\" : \"\");\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < def->nTags; i++) {\n        if (def->nativeMode != VIR_NATIVE_VLAN_MODE_DEFAULT &&\n            def->nativeTag == def->tag[i]) {\n            /* check the nativeMode in case we get <tag id='0'/>*/\n            const char *mode = virNativeVlanModeTypeToString(def->nativeMode);\n            if (!mode) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Bad value for nativeMode\"));\n            }\n            virBufferAsprintf(buf, \"<tag id='%u' nativeMode='%s'/>\\n\",\n                              def->tag[i], mode);\n        } else {\n            virBufferAsprintf(buf, \"<tag id='%u'/>\\n\", def->tag[i]);\n        }\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</vlan>\\n\");\n    return 0;\n}"
  },
  {
    "function_name": "virNetDevVlanParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_vlan_conf.c",
    "lines": "32-138",
    "snippet": "int\nvirNetDevVlanParse(xmlNodePtr node, xmlXPathContextPtr ctxt, virNetDevVlanPtr def)\n{\n    int ret = -1;\n    xmlNodePtr save = ctxt->node;\n    char *trunk = NULL;\n    char *nativeMode = NULL;\n    xmlNodePtr *tagNodes = NULL;\n    int nTags;\n    size_t i;\n\n    ctxt->node = node;\n\n    nTags = virXPathNodeSet(\"./tag\", ctxt, &tagNodes);\n    if (nTags < 0)\n        goto cleanup;\n\n    if (nTags == 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing tag id - each <vlan> must have \"\n                         \"at least one <tag id='n'/> subelement\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(def->tag, nTags) < 0)\n        goto cleanup;\n\n    def->nativeMode = 0;\n    def->nativeTag = 0;\n    for (i = 0; i < nTags; i++) {\n        unsigned long id;\n\n        ctxt->node = tagNodes[i];\n        if (virXPathULong(\"string(./@id)\", ctxt, &id) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing or invalid vlan tag id attribute\"));\n            goto cleanup;\n        }\n        if (id > 4095) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"vlan tag id %lu too large (maximum 4095)\"), id);\n            goto cleanup;\n        }\n        if ((nativeMode = virXPathString(\"string(./@nativeMode)\", ctxt))) {\n            if (def->nativeMode != 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"duplicate native vlan setting\"));\n                goto cleanup;\n            }\n            if ((def->nativeMode\n                 = virNativeVlanModeTypeFromString(nativeMode)) <= 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid \\\"nativeMode='%s'\\\" \"\n                                 \"in vlan <tag> element\"),\n                               nativeMode);\n                goto cleanup;\n            }\n            VIR_FREE(nativeMode);\n            def->nativeTag = id;\n        }\n        def->tag[i] = id;\n    }\n\n    def->nTags = nTags;\n\n    /* now that we know how many tags there are, look for an explicit\n     * trunk setting.\n     */\n    if (nTags > 1)\n        def->trunk = true;\n\n    ctxt->node = node;\n    if ((trunk = virXPathString(\"string(./@trunk)\", ctxt)) != NULL) {\n        def->trunk = STRCASEEQ(trunk, \"yes\");\n        if (!def->trunk) {\n            if (nTags > 1) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"invalid \\\"trunk='%s'\\\" in <vlan> - trunk='yes' \"\n                                 \"is required for more than one vlan tag\"), trunk);\n                goto cleanup;\n            }\n            if (def->nativeMode != 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"invalid configuration in <vlan> - \\\"trunk='no'\\\" is \"\n                                 \"not allowed with a native vlan id\"));\n                goto cleanup;\n            }\n            /* allow (but discard) \"trunk='no' if there is a single tag */\n            if (STRCASENEQ(trunk, \"no\")) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"invalid \\\"trunk='%s'\\\" in <vlan> \"\n                                 \"- must be yes or no\"), trunk);\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    ctxt->node = save;\n    VIR_FREE(tagNodes);\n    VIR_FREE(trunk);\n    VIR_FREE(nativeMode);\n    if (ret < 0)\n        virNetDevVlanClear(def);\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"netdev_vlan_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDevVlanClear",
          "args": [
            "def"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVlanClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvlan.c",
          "lines": "28-35",
          "snippet": "void\nvirNetDevVlanClear(virNetDevVlanPtr vlan)\n{\n    VIR_FREE(vlan->tag);\n    vlan->nTags = 0;\n    vlan->nativeMode = 0;\n    vlan->nativeTag = 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virnetdevvlan.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirNetDevVlanClear(virNetDevVlanPtr vlan)\n{\n    VIR_FREE(vlan->tag);\n    vlan->nTags = 0;\n    vlan->nativeMode = 0;\n    vlan->nativeTag = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nativeMode"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "trunk"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tagNodes"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"invalid \\\"trunk='%s'\\\" in <vlan> \"\n                                 \"- must be yes or no\")",
            "trunk"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid \\\"trunk='%s'\\\" in <vlan> \"\n                                 \"- must be yes or no\""
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASENEQ",
          "args": [
            "trunk",
            "\"no\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"invalid configuration in <vlan> - \\\"trunk='no'\\\" is \"\n                                 \"not allowed with a native vlan id\")"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"invalid \\\"trunk='%s'\\\" in <vlan> - trunk='yes' \"\n                                 \"is required for more than one vlan tag\")",
            "trunk"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "trunk",
            "\"yes\""
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./@trunk)\"",
            "ctxt"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nativeMode"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Invalid \\\"nativeMode='%s'\\\" \"\n                                 \"in vlan <tag> element\")",
            "nativeMode"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNativeVlanModeTypeFromString",
          "args": [
            "nativeMode"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"duplicate native vlan setting\")"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"vlan tag id %lu too large (maximum 4095)\")",
            "id"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing or invalid vlan tag id attribute\")"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathULong",
          "args": [
            "\"string(./@id)\"",
            "ctxt",
            "&id"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "398-430",
          "snippet": "int\nvirXPathULongLong(const char *xpath,\n                  xmlXPathContextPtr ctxt,\n                  unsigned long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathULong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ull((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (unsigned long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathULongLong(const char *xpath,\n                  xmlXPathContextPtr ctxt,\n                  unsigned long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathULong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ull((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (unsigned long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->tag",
            "nTags"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing tag id - each <vlan> must have \"\n                         \"at least one <tag id='n'/> subelement\")"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./tag\"",
            "ctxt",
            "&tagNodes"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_vlan_conf.h\"\n#include <config.h>\n\nint\nvirNetDevVlanParse(xmlNodePtr node, xmlXPathContextPtr ctxt, virNetDevVlanPtr def)\n{\n    int ret = -1;\n    xmlNodePtr save = ctxt->node;\n    char *trunk = NULL;\n    char *nativeMode = NULL;\n    xmlNodePtr *tagNodes = NULL;\n    int nTags;\n    size_t i;\n\n    ctxt->node = node;\n\n    nTags = virXPathNodeSet(\"./tag\", ctxt, &tagNodes);\n    if (nTags < 0)\n        goto cleanup;\n\n    if (nTags == 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing tag id - each <vlan> must have \"\n                         \"at least one <tag id='n'/> subelement\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(def->tag, nTags) < 0)\n        goto cleanup;\n\n    def->nativeMode = 0;\n    def->nativeTag = 0;\n    for (i = 0; i < nTags; i++) {\n        unsigned long id;\n\n        ctxt->node = tagNodes[i];\n        if (virXPathULong(\"string(./@id)\", ctxt, &id) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing or invalid vlan tag id attribute\"));\n            goto cleanup;\n        }\n        if (id > 4095) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"vlan tag id %lu too large (maximum 4095)\"), id);\n            goto cleanup;\n        }\n        if ((nativeMode = virXPathString(\"string(./@nativeMode)\", ctxt))) {\n            if (def->nativeMode != 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"duplicate native vlan setting\"));\n                goto cleanup;\n            }\n            if ((def->nativeMode\n                 = virNativeVlanModeTypeFromString(nativeMode)) <= 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid \\\"nativeMode='%s'\\\" \"\n                                 \"in vlan <tag> element\"),\n                               nativeMode);\n                goto cleanup;\n            }\n            VIR_FREE(nativeMode);\n            def->nativeTag = id;\n        }\n        def->tag[i] = id;\n    }\n\n    def->nTags = nTags;\n\n    /* now that we know how many tags there are, look for an explicit\n     * trunk setting.\n     */\n    if (nTags > 1)\n        def->trunk = true;\n\n    ctxt->node = node;\n    if ((trunk = virXPathString(\"string(./@trunk)\", ctxt)) != NULL) {\n        def->trunk = STRCASEEQ(trunk, \"yes\");\n        if (!def->trunk) {\n            if (nTags > 1) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"invalid \\\"trunk='%s'\\\" in <vlan> - trunk='yes' \"\n                                 \"is required for more than one vlan tag\"), trunk);\n                goto cleanup;\n            }\n            if (def->nativeMode != 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"invalid configuration in <vlan> - \\\"trunk='no'\\\" is \"\n                                 \"not allowed with a native vlan id\"));\n                goto cleanup;\n            }\n            /* allow (but discard) \"trunk='no' if there is a single tag */\n            if (STRCASENEQ(trunk, \"no\")) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"invalid \\\"trunk='%s'\\\" in <vlan> \"\n                                 \"- must be yes or no\"), trunk);\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    ctxt->node = save;\n    VIR_FREE(tagNodes);\n    VIR_FREE(trunk);\n    VIR_FREE(nativeMode);\n    if (ret < 0)\n        virNetDevVlanClear(def);\n    return ret;\n}"
  }
]