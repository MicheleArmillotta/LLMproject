[
  {
    "function_name": "virDevMapperGetTargets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdevmapper.c",
    "lines": "197-203",
    "snippet": "int\nvirDevMapperGetTargets(const char *path G_GNUC_UNUSED,\n                       char ***devPaths G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthread.h\"",
      "#include \"internal.h\"",
      "#include \"virdevmapper.h\"",
      "# include <libdevmapper.h>",
      "# include <sys/sysmacros.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virdevmapper.h\"\n# include <libdevmapper.h>\n# include <sys/sysmacros.h>\n#include <config.h>\n\nint\nvirDevMapperGetTargets(const char *path G_GNUC_UNUSED,\n                       char ***devPaths G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}"
  },
  {
    "function_name": "virDevMapperGetTargets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdevmapper.c",
    "lines": "182-193",
    "snippet": "int\nvirDevMapperGetTargets(const char *path,\n                       char ***devPaths)\n{\n    const unsigned int ttl = 32;\n\n    /* Arbitrary limit on recursion level. A devmapper target can\n     * consist of devices or yet another targets. If that's the\n     * case, we have to stop recursion somewhere. */\n\n    return virDevMapperGetTargetsImpl(path, devPaths, ttl);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthread.h\"",
      "#include \"internal.h\"",
      "#include \"virdevmapper.h\"",
      "# include <libdevmapper.h>",
      "# include <sys/sysmacros.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDevMapperGetTargetsImpl",
          "args": [
            "path",
            "devPaths",
            "ttl"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "virDevMapperGetTargetsImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdevmapper.c",
          "lines": "62-157",
          "snippet": "static int\nvirDevMapperGetTargetsImpl(const char *path,\n                           char ***devPaths_ret,\n                           unsigned int ttl)\n{\n    struct dm_task *dmt = NULL;\n    struct dm_deps *deps;\n    struct dm_info info;\n    char **devPaths = NULL;\n    char **recursiveDevPaths = NULL;\n    size_t i;\n    int ret = -1;\n\n    *devPaths_ret = NULL;\n\n    if (virDevMapperInitialize() < 0)\n        return ret;\n\n    if (ttl == 0) {\n        errno = ELOOP;\n        return ret;\n    }\n\n    if (!(dmt = dm_task_create(DM_DEVICE_DEPS))) {\n        if (errno == ENOENT || errno == ENODEV) {\n            /* It's okay. Kernel is probably built without\n             * devmapper support. */\n            ret = 0;\n        }\n        return ret;\n    }\n\n    if (!dm_task_set_name(dmt, path)) {\n        if (errno == ENOENT) {\n            /* It's okay, @path is not managed by devmapper =>\n             * not a devmapper device. */\n            ret = 0;\n        }\n        goto cleanup;\n    }\n\n    dm_task_no_open_count(dmt);\n\n    if (!dm_task_run(dmt)) {\n        if (errno == ENXIO) {\n            /* If @path = \"/dev/mapper/control\" ENXIO is returned. */\n            ret = 0;\n        }\n        goto cleanup;\n    }\n\n    if (!dm_task_get_info(dmt, &info))\n        goto cleanup;\n\n    if (!info.exists) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(deps = dm_task_get_deps(dmt)))\n        goto cleanup;\n\n    if (VIR_ALLOC_N_QUIET(devPaths, deps->count + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < deps->count; i++) {\n        devPaths[i] = g_strdup_printf(\"/dev/block/%u:%u\",\n                                      major(deps->device[i]),\n                                      minor(deps->device[i]));\n    }\n\n    recursiveDevPaths = NULL;\n    for (i = 0; i < deps->count; i++) {\n        char **tmpPaths;\n\n        if (virDevMapperGetTargetsImpl(devPaths[i], &tmpPaths, ttl - 1) < 0)\n            goto cleanup;\n\n        if (tmpPaths &&\n            virStringListMerge(&recursiveDevPaths, &tmpPaths) < 0) {\n            virStringListFree(tmpPaths);\n            goto cleanup;\n        }\n    }\n\n    if (virStringListMerge(&devPaths, &recursiveDevPaths) < 0)\n        goto cleanup;\n\n    *devPaths_ret = g_steal_pointer(&devPaths);\n    ret = 0;\n cleanup:\n    virStringListFree(recursiveDevPaths);\n    virStringListFree(devPaths);\n    dm_task_destroy(dmt);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"internal.h\"",
            "#include \"virdevmapper.h\"",
            "# include <libdevmapper.h>",
            "# include <sys/sysmacros.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virdevmapper.h\"\n# include <libdevmapper.h>\n# include <sys/sysmacros.h>\n#include <config.h>\n\nstatic int\nvirDevMapperGetTargetsImpl(const char *path,\n                           char ***devPaths_ret,\n                           unsigned int ttl)\n{\n    struct dm_task *dmt = NULL;\n    struct dm_deps *deps;\n    struct dm_info info;\n    char **devPaths = NULL;\n    char **recursiveDevPaths = NULL;\n    size_t i;\n    int ret = -1;\n\n    *devPaths_ret = NULL;\n\n    if (virDevMapperInitialize() < 0)\n        return ret;\n\n    if (ttl == 0) {\n        errno = ELOOP;\n        return ret;\n    }\n\n    if (!(dmt = dm_task_create(DM_DEVICE_DEPS))) {\n        if (errno == ENOENT || errno == ENODEV) {\n            /* It's okay. Kernel is probably built without\n             * devmapper support. */\n            ret = 0;\n        }\n        return ret;\n    }\n\n    if (!dm_task_set_name(dmt, path)) {\n        if (errno == ENOENT) {\n            /* It's okay, @path is not managed by devmapper =>\n             * not a devmapper device. */\n            ret = 0;\n        }\n        goto cleanup;\n    }\n\n    dm_task_no_open_count(dmt);\n\n    if (!dm_task_run(dmt)) {\n        if (errno == ENXIO) {\n            /* If @path = \"/dev/mapper/control\" ENXIO is returned. */\n            ret = 0;\n        }\n        goto cleanup;\n    }\n\n    if (!dm_task_get_info(dmt, &info))\n        goto cleanup;\n\n    if (!info.exists) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(deps = dm_task_get_deps(dmt)))\n        goto cleanup;\n\n    if (VIR_ALLOC_N_QUIET(devPaths, deps->count + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < deps->count; i++) {\n        devPaths[i] = g_strdup_printf(\"/dev/block/%u:%u\",\n                                      major(deps->device[i]),\n                                      minor(deps->device[i]));\n    }\n\n    recursiveDevPaths = NULL;\n    for (i = 0; i < deps->count; i++) {\n        char **tmpPaths;\n\n        if (virDevMapperGetTargetsImpl(devPaths[i], &tmpPaths, ttl - 1) < 0)\n            goto cleanup;\n\n        if (tmpPaths &&\n            virStringListMerge(&recursiveDevPaths, &tmpPaths) < 0) {\n            virStringListFree(tmpPaths);\n            goto cleanup;\n        }\n    }\n\n    if (virStringListMerge(&devPaths, &recursiveDevPaths) < 0)\n        goto cleanup;\n\n    *devPaths_ret = g_steal_pointer(&devPaths);\n    ret = 0;\n cleanup:\n    virStringListFree(recursiveDevPaths);\n    virStringListFree(devPaths);\n    dm_task_destroy(dmt);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virdevmapper.h\"\n# include <libdevmapper.h>\n# include <sys/sysmacros.h>\n#include <config.h>\n\nint\nvirDevMapperGetTargets(const char *path,\n                       char ***devPaths)\n{\n    const unsigned int ttl = 32;\n\n    /* Arbitrary limit on recursion level. A devmapper target can\n     * consist of devices or yet another targets. If that's the\n     * case, we have to stop recursion somewhere. */\n\n    return virDevMapperGetTargetsImpl(path, devPaths, ttl);\n}"
  },
  {
    "function_name": "virDevMapperGetTargetsImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdevmapper.c",
    "lines": "62-157",
    "snippet": "static int\nvirDevMapperGetTargetsImpl(const char *path,\n                           char ***devPaths_ret,\n                           unsigned int ttl)\n{\n    struct dm_task *dmt = NULL;\n    struct dm_deps *deps;\n    struct dm_info info;\n    char **devPaths = NULL;\n    char **recursiveDevPaths = NULL;\n    size_t i;\n    int ret = -1;\n\n    *devPaths_ret = NULL;\n\n    if (virDevMapperInitialize() < 0)\n        return ret;\n\n    if (ttl == 0) {\n        errno = ELOOP;\n        return ret;\n    }\n\n    if (!(dmt = dm_task_create(DM_DEVICE_DEPS))) {\n        if (errno == ENOENT || errno == ENODEV) {\n            /* It's okay. Kernel is probably built without\n             * devmapper support. */\n            ret = 0;\n        }\n        return ret;\n    }\n\n    if (!dm_task_set_name(dmt, path)) {\n        if (errno == ENOENT) {\n            /* It's okay, @path is not managed by devmapper =>\n             * not a devmapper device. */\n            ret = 0;\n        }\n        goto cleanup;\n    }\n\n    dm_task_no_open_count(dmt);\n\n    if (!dm_task_run(dmt)) {\n        if (errno == ENXIO) {\n            /* If @path = \"/dev/mapper/control\" ENXIO is returned. */\n            ret = 0;\n        }\n        goto cleanup;\n    }\n\n    if (!dm_task_get_info(dmt, &info))\n        goto cleanup;\n\n    if (!info.exists) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(deps = dm_task_get_deps(dmt)))\n        goto cleanup;\n\n    if (VIR_ALLOC_N_QUIET(devPaths, deps->count + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < deps->count; i++) {\n        devPaths[i] = g_strdup_printf(\"/dev/block/%u:%u\",\n                                      major(deps->device[i]),\n                                      minor(deps->device[i]));\n    }\n\n    recursiveDevPaths = NULL;\n    for (i = 0; i < deps->count; i++) {\n        char **tmpPaths;\n\n        if (virDevMapperGetTargetsImpl(devPaths[i], &tmpPaths, ttl - 1) < 0)\n            goto cleanup;\n\n        if (tmpPaths &&\n            virStringListMerge(&recursiveDevPaths, &tmpPaths) < 0) {\n            virStringListFree(tmpPaths);\n            goto cleanup;\n        }\n    }\n\n    if (virStringListMerge(&devPaths, &recursiveDevPaths) < 0)\n        goto cleanup;\n\n    *devPaths_ret = g_steal_pointer(&devPaths);\n    ret = 0;\n cleanup:\n    virStringListFree(recursiveDevPaths);\n    virStringListFree(devPaths);\n    dm_task_destroy(dmt);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthread.h\"",
      "#include \"internal.h\"",
      "#include \"virdevmapper.h\"",
      "# include <libdevmapper.h>",
      "# include <sys/sysmacros.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dm_task_destroy",
          "args": [
            "dmt"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "devPaths"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&devPaths"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListMerge",
          "args": [
            "&devPaths",
            "&recursiveDevPaths"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListMerge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "237-259",
          "snippet": "int\nvirStringListMerge(char ***dst,\n                   char ***src)\n{\n    size_t dst_len, src_len, i;\n\n    if (!src || !*src)\n        return 0;\n\n    dst_len = virStringListLength((const char **) *dst);\n    src_len = virStringListLength((const char **) *src);\n\n    if (VIR_REALLOC_N(*dst, dst_len + src_len + 1) < 0)\n        return -1;\n\n    for (i = 0; i <= src_len; i++)\n        (*dst)[i + dst_len] = (*src)[i];\n\n    /* Don't call virStringListFree() as it would free strings in\n     * @src. */\n    VIR_FREE(*src);\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStringListMerge(char ***dst,\n                   char ***src)\n{\n    size_t dst_len, src_len, i;\n\n    if (!src || !*src)\n        return 0;\n\n    dst_len = virStringListLength((const char **) *dst);\n    src_len = virStringListLength((const char **) *src);\n\n    if (VIR_REALLOC_N(*dst, dst_len + src_len + 1) < 0)\n        return -1;\n\n    for (i = 0; i <= src_len; i++)\n        (*dst)[i + dst_len] = (*src)[i];\n\n    /* Don't call virStringListFree() as it would free strings in\n     * @src. */\n    VIR_FREE(*src);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDevMapperGetTargetsImpl",
          "args": [
            "devPaths[i]",
            "&tmpPaths",
            "ttl - 1"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "virDevMapperGetTargetsImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdevmapper.c",
          "lines": "62-157",
          "snippet": "static int\nvirDevMapperGetTargetsImpl(const char *path,\n                           char ***devPaths_ret,\n                           unsigned int ttl)\n{\n    struct dm_task *dmt = NULL;\n    struct dm_deps *deps;\n    struct dm_info info;\n    char **devPaths = NULL;\n    char **recursiveDevPaths = NULL;\n    size_t i;\n    int ret = -1;\n\n    *devPaths_ret = NULL;\n\n    if (virDevMapperInitialize() < 0)\n        return ret;\n\n    if (ttl == 0) {\n        errno = ELOOP;\n        return ret;\n    }\n\n    if (!(dmt = dm_task_create(DM_DEVICE_DEPS))) {\n        if (errno == ENOENT || errno == ENODEV) {\n            /* It's okay. Kernel is probably built without\n             * devmapper support. */\n            ret = 0;\n        }\n        return ret;\n    }\n\n    if (!dm_task_set_name(dmt, path)) {\n        if (errno == ENOENT) {\n            /* It's okay, @path is not managed by devmapper =>\n             * not a devmapper device. */\n            ret = 0;\n        }\n        goto cleanup;\n    }\n\n    dm_task_no_open_count(dmt);\n\n    if (!dm_task_run(dmt)) {\n        if (errno == ENXIO) {\n            /* If @path = \"/dev/mapper/control\" ENXIO is returned. */\n            ret = 0;\n        }\n        goto cleanup;\n    }\n\n    if (!dm_task_get_info(dmt, &info))\n        goto cleanup;\n\n    if (!info.exists) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(deps = dm_task_get_deps(dmt)))\n        goto cleanup;\n\n    if (VIR_ALLOC_N_QUIET(devPaths, deps->count + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < deps->count; i++) {\n        devPaths[i] = g_strdup_printf(\"/dev/block/%u:%u\",\n                                      major(deps->device[i]),\n                                      minor(deps->device[i]));\n    }\n\n    recursiveDevPaths = NULL;\n    for (i = 0; i < deps->count; i++) {\n        char **tmpPaths;\n\n        if (virDevMapperGetTargetsImpl(devPaths[i], &tmpPaths, ttl - 1) < 0)\n            goto cleanup;\n\n        if (tmpPaths &&\n            virStringListMerge(&recursiveDevPaths, &tmpPaths) < 0) {\n            virStringListFree(tmpPaths);\n            goto cleanup;\n        }\n    }\n\n    if (virStringListMerge(&devPaths, &recursiveDevPaths) < 0)\n        goto cleanup;\n\n    *devPaths_ret = g_steal_pointer(&devPaths);\n    ret = 0;\n cleanup:\n    virStringListFree(recursiveDevPaths);\n    virStringListFree(devPaths);\n    dm_task_destroy(dmt);\n    return ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"/dev/block/%u:%u\"",
            "major(deps->device[i])",
            "minor(deps->device[i])"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "deps->device[i]"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "major",
          "args": [
            "deps->device[i]"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N_QUIET",
          "args": [
            "devPaths",
            "deps->count + 1"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dm_task_get_deps",
          "args": [
            "dmt"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dm_task_get_info",
          "args": [
            "dmt",
            "&info"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dm_task_run",
          "args": [
            "dmt"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dm_task_no_open_count",
          "args": [
            "dmt"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dm_task_set_name",
          "args": [
            "dmt",
            "path"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dm_task_create",
          "args": [
            "DM_DEVICE_DEPS"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDevMapperInitialize",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virdevmapper.h\"\n# include <libdevmapper.h>\n# include <sys/sysmacros.h>\n#include <config.h>\n\nstatic int\nvirDevMapperGetTargetsImpl(const char *path,\n                           char ***devPaths_ret,\n                           unsigned int ttl)\n{\n    struct dm_task *dmt = NULL;\n    struct dm_deps *deps;\n    struct dm_info info;\n    char **devPaths = NULL;\n    char **recursiveDevPaths = NULL;\n    size_t i;\n    int ret = -1;\n\n    *devPaths_ret = NULL;\n\n    if (virDevMapperInitialize() < 0)\n        return ret;\n\n    if (ttl == 0) {\n        errno = ELOOP;\n        return ret;\n    }\n\n    if (!(dmt = dm_task_create(DM_DEVICE_DEPS))) {\n        if (errno == ENOENT || errno == ENODEV) {\n            /* It's okay. Kernel is probably built without\n             * devmapper support. */\n            ret = 0;\n        }\n        return ret;\n    }\n\n    if (!dm_task_set_name(dmt, path)) {\n        if (errno == ENOENT) {\n            /* It's okay, @path is not managed by devmapper =>\n             * not a devmapper device. */\n            ret = 0;\n        }\n        goto cleanup;\n    }\n\n    dm_task_no_open_count(dmt);\n\n    if (!dm_task_run(dmt)) {\n        if (errno == ENXIO) {\n            /* If @path = \"/dev/mapper/control\" ENXIO is returned. */\n            ret = 0;\n        }\n        goto cleanup;\n    }\n\n    if (!dm_task_get_info(dmt, &info))\n        goto cleanup;\n\n    if (!info.exists) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(deps = dm_task_get_deps(dmt)))\n        goto cleanup;\n\n    if (VIR_ALLOC_N_QUIET(devPaths, deps->count + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < deps->count; i++) {\n        devPaths[i] = g_strdup_printf(\"/dev/block/%u:%u\",\n                                      major(deps->device[i]),\n                                      minor(deps->device[i]));\n    }\n\n    recursiveDevPaths = NULL;\n    for (i = 0; i < deps->count; i++) {\n        char **tmpPaths;\n\n        if (virDevMapperGetTargetsImpl(devPaths[i], &tmpPaths, ttl - 1) < 0)\n            goto cleanup;\n\n        if (tmpPaths &&\n            virStringListMerge(&recursiveDevPaths, &tmpPaths) < 0) {\n            virStringListFree(tmpPaths);\n            goto cleanup;\n        }\n    }\n\n    if (virStringListMerge(&devPaths, &recursiveDevPaths) < 0)\n        goto cleanup;\n\n    *devPaths_ret = g_steal_pointer(&devPaths);\n    ret = 0;\n cleanup:\n    virStringListFree(recursiveDevPaths);\n    virStringListFree(devPaths);\n    dm_task_destroy(dmt);\n    return ret;\n}"
  },
  {
    "function_name": "virDevMapperOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdevmapper.c",
    "lines": "49-56",
    "snippet": "static int\nvirDevMapperOnceInit(void)\n{\n    /* Ideally, we would not need this. But libdevmapper prints\n     * error messages to stderr by default. Sad but true. */\n    dm_log_with_errno_init(virDevMapperDummyLogger);\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthread.h\"",
      "#include \"internal.h\"",
      "#include \"virdevmapper.h\"",
      "# include <libdevmapper.h>",
      "# include <sys/sysmacros.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dm_log_with_errno_init",
          "args": [
            "virDevMapperDummyLogger"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virdevmapper.h\"\n# include <libdevmapper.h>\n# include <sys/sysmacros.h>\n#include <config.h>\n\nstatic int\nvirDevMapperOnceInit(void)\n{\n    /* Ideally, we would not need this. But libdevmapper prints\n     * error messages to stderr by default. Sad but true. */\n    dm_log_with_errno_init(virDevMapperDummyLogger);\n    return 0;\n}"
  },
  {
    "function_name": "virDevMapperDummyLogger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdevmapper.c",
    "lines": "38-47",
    "snippet": "static void\nvirDevMapperDummyLogger(int level G_GNUC_UNUSED,\n                        const char *file G_GNUC_UNUSED,\n                        int line G_GNUC_UNUSED,\n                        int dm_errno G_GNUC_UNUSED,\n                        const char *fmt G_GNUC_UNUSED,\n                        ...)\n{\n    return;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthread.h\"",
      "#include \"internal.h\"",
      "#include \"virdevmapper.h\"",
      "# include <libdevmapper.h>",
      "# include <sys/sysmacros.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virdevmapper.h\"\n# include <libdevmapper.h>\n# include <sys/sysmacros.h>\n#include <config.h>\n\nstatic void\nvirDevMapperDummyLogger(int level G_GNUC_UNUSED,\n                        const char *file G_GNUC_UNUSED,\n                        int line G_GNUC_UNUSED,\n                        int dm_errno G_GNUC_UNUSED,\n                        const char *fmt G_GNUC_UNUSED,\n                        ...)\n{\n    return;\n}"
  }
]