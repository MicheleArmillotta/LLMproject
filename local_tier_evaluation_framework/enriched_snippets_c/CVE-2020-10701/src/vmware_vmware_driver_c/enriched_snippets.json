[
  {
    "function_name": "vmwareRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "1197-1202",
    "snippet": "int\nvmwareRegister(void)\n{\n    return virRegisterConnectDriver(&vmwareConnectDriver,\n                                    false);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virConnectDriver vmwareConnectDriver = {\n    .localOnly = true,\n    .uriSchemes = (const char *[]){ \"vmwareplayer\", \"vmwarews\", \"vmwarefusion\", NULL },\n    .hypervisorDriver = &vmwareHypervisorDriver,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virRegisterConnectDriver",
          "args": [
            "&vmwareConnectDriver",
            "false"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "virRegisterConnectDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "515-550",
          "snippet": "int\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_DRIVERS 21"
          ],
          "globals_used": [
            "static virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];",
            "static int virConnectDriverTabCount;",
            "static virNetworkDriverPtr virSharedNetworkDriver;",
            "static virInterfaceDriverPtr virSharedInterfaceDriver;",
            "static virStorageDriverPtr virSharedStorageDriver;",
            "static virNodeDeviceDriverPtr virSharedNodeDeviceDriver;",
            "static virSecretDriverPtr virSharedSecretDriver;",
            "static virNWFilterDriverPtr virSharedNWFilterDriver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define MAX_DRIVERS 21\n\nstatic virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];\nstatic int virConnectDriverTabCount;\nstatic virNetworkDriverPtr virSharedNetworkDriver;\nstatic virInterfaceDriverPtr virSharedInterfaceDriver;\nstatic virStorageDriverPtr virSharedStorageDriver;\nstatic virNodeDeviceDriverPtr virSharedNodeDeviceDriver;\nstatic virSecretDriverPtr virSharedSecretDriver;\nstatic virNWFilterDriverPtr virSharedNWFilterDriver;\n\nint\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virConnectDriver vmwareConnectDriver = {\n    .localOnly = true,\n    .uriSchemes = (const char *[]){ \"vmwareplayer\", \"vmwarews\", \"vmwarefusion\", NULL },\n    .hypervisorDriver = &vmwareHypervisorDriver,\n};\n\nint\nvmwareRegister(void)\n{\n    return virRegisterConnectDriver(&vmwareConnectDriver,\n                                    false);\n}"
  },
  {
    "function_name": "vmwareDomainHasManagedSaveImage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "1132-1148",
    "snippet": "static int\nvmwareDomainHasManagedSaveImage(virDomainPtr dom, unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr obj;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    if (!(obj = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return -1;\n\n    ret = 0;\n\n    virDomainObjEndAPI(&obj);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomObjFromDomain",
          "args": [
            "driver",
            "dom->uuid"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomObjFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "82-92",
          "snippet": "static virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainHasManagedSaveImage(virDomainPtr dom, unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr obj;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    if (!(obj = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return -1;\n\n    ret = 0;\n\n    virDomainObjEndAPI(&obj);\n    return ret;\n}"
  },
  {
    "function_name": "vmwareConnectListAllDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "1114-1130",
    "snippet": "static int\nvmwareConnectListAllDomains(virConnectPtr conn,\n                            virDomainPtr **domains,\n                            unsigned int flags)\n{\n    struct vmware_driver *driver = conn->privateData;\n    int ret = -1;\n\n    virCheckFlags(VIR_CONNECT_LIST_DOMAINS_FILTERS_ALL, -1);\n\n    vmwareDriverLock(driver);\n    vmwareDomainObjListUpdateAll(driver->domains, driver);\n    ret = virDomainObjListExport(driver->domains, conn, domains,\n                                 NULL, flags);\n    vmwareDriverUnlock(driver);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "56-60",
          "snippet": "static void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListExport",
          "args": [
            "driver->domains",
            "conn",
            "domains",
            "NULL",
            "flags"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListExport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "1060-1101",
          "snippet": "int\nvirDomainObjListExport(virDomainObjListPtr domlist,\n                       virConnectPtr conn,\n                       virDomainPtr **domains,\n                       virDomainObjListACLFilter filter,\n                       unsigned int flags)\n{\n    virDomainObjPtr *vms = NULL;\n    virDomainPtr *doms = NULL;\n    size_t nvms = 0;\n    size_t i;\n    int ret = -1;\n\n    if (virDomainObjListCollect(domlist, conn, &vms, &nvms, filter, flags) < 0)\n        return -1;\n\n    if (domains) {\n        if (VIR_ALLOC_N(doms, nvms + 1) < 0)\n            goto cleanup;\n\n        for (i = 0; i < nvms; i++) {\n            virDomainObjPtr vm = vms[i];\n\n            virObjectLock(vm);\n            doms[i] = virGetDomain(conn, vm->def->name, vm->def->uuid, vm->def->id);\n            virObjectUnlock(vm);\n\n            if (!doms[i])\n                goto cleanup;\n        }\n\n        *domains = doms;\n        doms = NULL;\n    }\n\n    ret = nvms;\n\n cleanup:\n    virObjectListFree(doms);\n    virObjectListFreeCount(vms, nvms);\n    return ret;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDomainObjListExport(virDomainObjListPtr domlist,\n                       virConnectPtr conn,\n                       virDomainPtr **domains,\n                       virDomainObjListACLFilter filter,\n                       unsigned int flags)\n{\n    virDomainObjPtr *vms = NULL;\n    virDomainPtr *doms = NULL;\n    size_t nvms = 0;\n    size_t i;\n    int ret = -1;\n\n    if (virDomainObjListCollect(domlist, conn, &vms, &nvms, filter, flags) < 0)\n        return -1;\n\n    if (domains) {\n        if (VIR_ALLOC_N(doms, nvms + 1) < 0)\n            goto cleanup;\n\n        for (i = 0; i < nvms; i++) {\n            virDomainObjPtr vm = vms[i];\n\n            virObjectLock(vm);\n            doms[i] = virGetDomain(conn, vm->def->name, vm->def->uuid, vm->def->id);\n            virObjectUnlock(vm);\n\n            if (!doms[i])\n                goto cleanup;\n        }\n\n        *domains = doms;\n        doms = NULL;\n    }\n\n    ret = nvms;\n\n cleanup:\n    virObjectListFree(doms);\n    virObjectListFreeCount(vms, nvms);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomainObjListUpdateAll",
          "args": [
            "driver->domains",
            "driver"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomainObjListUpdateAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "993-997",
          "snippet": "static void\nvmwareDomainObjListUpdateAll(virDomainObjListPtr doms, struct vmware_driver *driver)\n{\n    virDomainObjListForEach(doms, false, vmwareDomainObjListUpdateDomain, driver);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDomainObjListUpdateAll(virDomainObjListPtr doms, struct vmware_driver *driver)\n{\n    virDomainObjListForEach(doms, false, vmwareDomainObjListUpdateDomain, driver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverLock",
          "args": [
            "driver"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "50-54",
          "snippet": "static void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_FILTERS_ALL",
            "-1"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareConnectListAllDomains(virConnectPtr conn,\n                            virDomainPtr **domains,\n                            unsigned int flags)\n{\n    struct vmware_driver *driver = conn->privateData;\n    int ret = -1;\n\n    virCheckFlags(VIR_CONNECT_LIST_DOMAINS_FILTERS_ALL, -1);\n\n    vmwareDriverLock(driver);\n    vmwareDomainObjListUpdateAll(driver->domains, driver);\n    ret = virDomainObjListExport(driver->domains, conn, domains,\n                                 NULL, flags);\n    vmwareDriverUnlock(driver);\n    return ret;\n}"
  },
  {
    "function_name": "vmwareConnectIsAlive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "1108-1112",
    "snippet": "static int\nvmwareConnectIsAlive(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return 1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareConnectIsAlive(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return 1;\n}"
  },
  {
    "function_name": "vmwareDomainGetState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "1082-1106",
    "snippet": "static int\nvmwareDomainGetState(virDomainPtr dom,\n                     int *state,\n                     int *reason,\n                     unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    if (!(vm = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return -1;\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    *state = virDomainObjGetState(vm, reason);\n    ret = 0;\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "reason"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareUpdateVMStatus",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareUpdateVMStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "282-339",
          "snippet": "static int\nvmwareUpdateVMStatus(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    virCommandPtr cmd;\n    char *outbuf = NULL;\n    char *vmxAbsolutePath = NULL;\n    char *parsedVmxPath = NULL;\n    char *str;\n    char *saveptr = NULL;\n    bool found = false;\n    int oldState = virDomainObjGetState(vm, NULL);\n    int newState;\n    int ret = -1;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virFileResolveAllLinks(((vmwareDomainPtr) vm->privateData)->vmxPath,\n                               &vmxAbsolutePath) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (parsedVmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n         str = NULL) {\n\n        if (parsedVmxPath[0] != '/')\n            continue;\n\n        if (STREQ(parsedVmxPath, vmxAbsolutePath)) {\n            found = true;\n            /* If the vmx path is in the output, the domain is running or\n             * is paused but we have no way to detect if it is paused or not. */\n            if (oldState == VIR_DOMAIN_PAUSED)\n                newState = oldState;\n            else\n                newState = VIR_DOMAIN_RUNNING;\n            break;\n        }\n    }\n\n    if (!found) {\n        vm->def->id = -1;\n        newState = VIR_DOMAIN_SHUTOFF;\n    }\n\n    virDomainObjSetState(vm, newState, 0);\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(vmxAbsolutePath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareUpdateVMStatus(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    virCommandPtr cmd;\n    char *outbuf = NULL;\n    char *vmxAbsolutePath = NULL;\n    char *parsedVmxPath = NULL;\n    char *str;\n    char *saveptr = NULL;\n    bool found = false;\n    int oldState = virDomainObjGetState(vm, NULL);\n    int newState;\n    int ret = -1;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virFileResolveAllLinks(((vmwareDomainPtr) vm->privateData)->vmxPath,\n                               &vmxAbsolutePath) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (parsedVmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n         str = NULL) {\n\n        if (parsedVmxPath[0] != '/')\n            continue;\n\n        if (STREQ(parsedVmxPath, vmxAbsolutePath)) {\n            found = true;\n            /* If the vmx path is in the output, the domain is running or\n             * is paused but we have no way to detect if it is paused or not. */\n            if (oldState == VIR_DOMAIN_PAUSED)\n                newState = oldState;\n            else\n                newState = VIR_DOMAIN_RUNNING;\n            break;\n        }\n    }\n\n    if (!found) {\n        vm->def->id = -1;\n        newState = VIR_DOMAIN_SHUTOFF;\n    }\n\n    virDomainObjSetState(vm, newState, 0);\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(vmxAbsolutePath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomObjFromDomain",
          "args": [
            "driver",
            "dom->uuid"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomObjFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "82-92",
          "snippet": "static virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainGetState(virDomainPtr dom,\n                     int *state,\n                     int *reason,\n                     unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    if (!(vm = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return -1;\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    *state = virDomainObjGetState(vm, reason);\n    ret = 0;\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return ret;\n}"
  },
  {
    "function_name": "vmwareDomainGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "1057-1080",
    "snippet": "static int\nvmwareDomainGetInfo(virDomainPtr dom, virDomainInfoPtr info)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    if (!(vm = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return -1;\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    info->state = virDomainObjGetState(vm, NULL);\n    info->cpuTime = 0;\n    info->maxMem = virDomainDefGetMemoryTotal(vm->def);\n    info->memory = vm->def->mem.cur_balloon;\n    info->nrVirtCpu = virDomainDefGetVcpus(vm->def);\n    ret = 0;\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetVcpus",
          "args": [
            "vm->def"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetVcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1912-1924",
          "snippet": "unsigned int\nvirDomainDefGetVcpus(const virDomainDef *def)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (def->vcpus[i]->online)\n            ret++;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned int\nvirDomainDefGetVcpus(const virDomainDef *def)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (def->vcpus[i]->online)\n            ret++;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetMemoryTotal",
          "args": [
            "vm->def"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetMemoryTotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10946-10950",
          "snippet": "unsigned long long\nvirDomainDefGetMemoryTotal(const virDomainDef *def)\n{\n    return def->mem.total_memory;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned long long\nvirDomainDefGetMemoryTotal(const virDomainDef *def)\n{\n    return def->mem.total_memory;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "NULL"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareUpdateVMStatus",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareUpdateVMStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "282-339",
          "snippet": "static int\nvmwareUpdateVMStatus(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    virCommandPtr cmd;\n    char *outbuf = NULL;\n    char *vmxAbsolutePath = NULL;\n    char *parsedVmxPath = NULL;\n    char *str;\n    char *saveptr = NULL;\n    bool found = false;\n    int oldState = virDomainObjGetState(vm, NULL);\n    int newState;\n    int ret = -1;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virFileResolveAllLinks(((vmwareDomainPtr) vm->privateData)->vmxPath,\n                               &vmxAbsolutePath) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (parsedVmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n         str = NULL) {\n\n        if (parsedVmxPath[0] != '/')\n            continue;\n\n        if (STREQ(parsedVmxPath, vmxAbsolutePath)) {\n            found = true;\n            /* If the vmx path is in the output, the domain is running or\n             * is paused but we have no way to detect if it is paused or not. */\n            if (oldState == VIR_DOMAIN_PAUSED)\n                newState = oldState;\n            else\n                newState = VIR_DOMAIN_RUNNING;\n            break;\n        }\n    }\n\n    if (!found) {\n        vm->def->id = -1;\n        newState = VIR_DOMAIN_SHUTOFF;\n    }\n\n    virDomainObjSetState(vm, newState, 0);\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(vmxAbsolutePath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareUpdateVMStatus(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    virCommandPtr cmd;\n    char *outbuf = NULL;\n    char *vmxAbsolutePath = NULL;\n    char *parsedVmxPath = NULL;\n    char *str;\n    char *saveptr = NULL;\n    bool found = false;\n    int oldState = virDomainObjGetState(vm, NULL);\n    int newState;\n    int ret = -1;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virFileResolveAllLinks(((vmwareDomainPtr) vm->privateData)->vmxPath,\n                               &vmxAbsolutePath) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (parsedVmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n         str = NULL) {\n\n        if (parsedVmxPath[0] != '/')\n            continue;\n\n        if (STREQ(parsedVmxPath, vmxAbsolutePath)) {\n            found = true;\n            /* If the vmx path is in the output, the domain is running or\n             * is paused but we have no way to detect if it is paused or not. */\n            if (oldState == VIR_DOMAIN_PAUSED)\n                newState = oldState;\n            else\n                newState = VIR_DOMAIN_RUNNING;\n            break;\n        }\n    }\n\n    if (!found) {\n        vm->def->id = -1;\n        newState = VIR_DOMAIN_SHUTOFF;\n    }\n\n    virDomainObjSetState(vm, newState, 0);\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(vmxAbsolutePath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomObjFromDomain",
          "args": [
            "driver",
            "dom->uuid"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomObjFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "82-92",
          "snippet": "static virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainGetInfo(virDomainPtr dom, virDomainInfoPtr info)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    if (!(vm = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return -1;\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    info->state = virDomainObjGetState(vm, NULL);\n    info->cpuTime = 0;\n    info->maxMem = virDomainDefGetMemoryTotal(vm->def);\n    info->memory = vm->def->mem.cur_balloon;\n    info->nrVirtCpu = virDomainDefGetVcpus(vm->def);\n    ret = 0;\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return ret;\n}"
  },
  {
    "function_name": "vmwareConnectListDefinedDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "1042-1055",
    "snippet": "static int\nvmwareConnectListDefinedDomains(virConnectPtr conn,\n                                char **const names, int nnames)\n{\n    struct vmware_driver *driver = conn->privateData;\n    int n;\n\n    vmwareDriverLock(driver);\n    vmwareDomainObjListUpdateAll(driver->domains, driver);\n    n = virDomainObjListGetInactiveNames(driver->domains, names, nnames,\n                                         NULL, NULL);\n    vmwareDriverUnlock(driver);\n    return n;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "56-60",
          "snippet": "static void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListGetInactiveNames",
          "args": [
            "driver->domains",
            "names",
            "nnames",
            "NULL",
            "NULL"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListGetInactiveNames",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "768-788",
          "snippet": "int\nvirDomainObjListGetInactiveNames(virDomainObjListPtr doms,\n                                 char **const names,\n                                 int maxnames,\n                                 virDomainObjListACLFilter filter,\n                                 virConnectPtr conn)\n{\n    struct virDomainNameData data = { filter, conn,\n                                      0, 0, maxnames, names };\n    size_t i;\n    virObjectRWLockRead(doms);\n    virHashForEach(doms->objs, virDomainObjListCopyInactiveNames, &data);\n    virObjectRWUnlock(doms);\n    if (data.oom) {\n        for (i = 0; i < data.numnames; i++)\n            VIR_FREE(data.names[i]);\n        return -1;\n    }\n\n    return data.numnames;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDomainObjListGetInactiveNames(virDomainObjListPtr doms,\n                                 char **const names,\n                                 int maxnames,\n                                 virDomainObjListACLFilter filter,\n                                 virConnectPtr conn)\n{\n    struct virDomainNameData data = { filter, conn,\n                                      0, 0, maxnames, names };\n    size_t i;\n    virObjectRWLockRead(doms);\n    virHashForEach(doms->objs, virDomainObjListCopyInactiveNames, &data);\n    virObjectRWUnlock(doms);\n    if (data.oom) {\n        for (i = 0; i < data.numnames; i++)\n            VIR_FREE(data.names[i]);\n        return -1;\n    }\n\n    return data.numnames;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomainObjListUpdateAll",
          "args": [
            "driver->domains",
            "driver"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomainObjListUpdateAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "993-997",
          "snippet": "static void\nvmwareDomainObjListUpdateAll(virDomainObjListPtr doms, struct vmware_driver *driver)\n{\n    virDomainObjListForEach(doms, false, vmwareDomainObjListUpdateDomain, driver);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDomainObjListUpdateAll(virDomainObjListPtr doms, struct vmware_driver *driver)\n{\n    virDomainObjListForEach(doms, false, vmwareDomainObjListUpdateDomain, driver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverLock",
          "args": [
            "driver"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "50-54",
          "snippet": "static void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareConnectListDefinedDomains(virConnectPtr conn,\n                                char **const names, int nnames)\n{\n    struct vmware_driver *driver = conn->privateData;\n    int n;\n\n    vmwareDriverLock(driver);\n    vmwareDomainObjListUpdateAll(driver->domains, driver);\n    n = virDomainObjListGetInactiveNames(driver->domains, names, nnames,\n                                         NULL, NULL);\n    vmwareDriverUnlock(driver);\n    return n;\n}"
  },
  {
    "function_name": "vmwareConnectListDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "1028-1040",
    "snippet": "static int\nvmwareConnectListDomains(virConnectPtr conn, int *ids, int nids)\n{\n    struct vmware_driver *driver = conn->privateData;\n    int n;\n\n    vmwareDriverLock(driver);\n    vmwareDomainObjListUpdateAll(driver->domains, driver);\n    n = virDomainObjListGetActiveIDs(driver->domains, ids, nids, NULL, NULL);\n    vmwareDriverUnlock(driver);\n\n    return n;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "56-60",
          "snippet": "static void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListGetActiveIDs",
          "args": [
            "driver->domains",
            "ids",
            "nids",
            "NULL",
            "NULL"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListGetActiveIDs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "716-729",
          "snippet": "int\nvirDomainObjListGetActiveIDs(virDomainObjListPtr doms,\n                             int *ids,\n                             int maxids,\n                             virDomainObjListACLFilter filter,\n                             virConnectPtr conn)\n{\n    struct virDomainIDData data = { filter, conn,\n                                    0, maxids, ids };\n    virObjectRWLockRead(doms);\n    virHashForEach(doms->objs, virDomainObjListCopyActiveIDs, &data);\n    virObjectRWUnlock(doms);\n    return data.numids;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDomainObjListGetActiveIDs(virDomainObjListPtr doms,\n                             int *ids,\n                             int maxids,\n                             virDomainObjListACLFilter filter,\n                             virConnectPtr conn)\n{\n    struct virDomainIDData data = { filter, conn,\n                                    0, maxids, ids };\n    virObjectRWLockRead(doms);\n    virHashForEach(doms->objs, virDomainObjListCopyActiveIDs, &data);\n    virObjectRWUnlock(doms);\n    return data.numids;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomainObjListUpdateAll",
          "args": [
            "driver->domains",
            "driver"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomainObjListUpdateAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "993-997",
          "snippet": "static void\nvmwareDomainObjListUpdateAll(virDomainObjListPtr doms, struct vmware_driver *driver)\n{\n    virDomainObjListForEach(doms, false, vmwareDomainObjListUpdateDomain, driver);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDomainObjListUpdateAll(virDomainObjListPtr doms, struct vmware_driver *driver)\n{\n    virDomainObjListForEach(doms, false, vmwareDomainObjListUpdateDomain, driver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverLock",
          "args": [
            "driver"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "50-54",
          "snippet": "static void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareConnectListDomains(virConnectPtr conn, int *ids, int nids)\n{\n    struct vmware_driver *driver = conn->privateData;\n    int n;\n\n    vmwareDriverLock(driver);\n    vmwareDomainObjListUpdateAll(driver->domains, driver);\n    n = virDomainObjListGetActiveIDs(driver->domains, ids, nids, NULL, NULL);\n    vmwareDriverUnlock(driver);\n\n    return n;\n}"
  },
  {
    "function_name": "vmwareConnectNumOfDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "1013-1025",
    "snippet": "static int\nvmwareConnectNumOfDomains(virConnectPtr conn)\n{\n    struct vmware_driver *driver = conn->privateData;\n    int n;\n\n    vmwareDriverLock(driver);\n    vmwareDomainObjListUpdateAll(driver->domains, driver);\n    n = virDomainObjListNumOfDomains(driver->domains, true, NULL, NULL);\n    vmwareDriverUnlock(driver);\n\n    return n;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "56-60",
          "snippet": "static void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListNumOfDomains",
          "args": [
            "driver->domains",
            "true",
            "NULL",
            "NULL"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListNumOfDomains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "674-685",
          "snippet": "int\nvirDomainObjListNumOfDomains(virDomainObjListPtr doms,\n                             bool active,\n                             virDomainObjListACLFilter filter,\n                             virConnectPtr conn)\n{\n    struct virDomainObjListData data = { filter, conn, active, 0 };\n    virObjectRWLockRead(doms);\n    virHashForEach(doms->objs, virDomainObjListCount, &data);\n    virObjectRWUnlock(doms);\n    return data.count;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDomainObjListNumOfDomains(virDomainObjListPtr doms,\n                             bool active,\n                             virDomainObjListACLFilter filter,\n                             virConnectPtr conn)\n{\n    struct virDomainObjListData data = { filter, conn, active, 0 };\n    virObjectRWLockRead(doms);\n    virHashForEach(doms->objs, virDomainObjListCount, &data);\n    virObjectRWUnlock(doms);\n    return data.count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomainObjListUpdateAll",
          "args": [
            "driver->domains",
            "driver"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomainObjListUpdateAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "993-997",
          "snippet": "static void\nvmwareDomainObjListUpdateAll(virDomainObjListPtr doms, struct vmware_driver *driver)\n{\n    virDomainObjListForEach(doms, false, vmwareDomainObjListUpdateDomain, driver);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDomainObjListUpdateAll(virDomainObjListPtr doms, struct vmware_driver *driver)\n{\n    virDomainObjListForEach(doms, false, vmwareDomainObjListUpdateDomain, driver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverLock",
          "args": [
            "driver"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "50-54",
          "snippet": "static void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareConnectNumOfDomains(virConnectPtr conn)\n{\n    struct vmware_driver *driver = conn->privateData;\n    int n;\n\n    vmwareDriverLock(driver);\n    vmwareDomainObjListUpdateAll(driver->domains, driver);\n    n = virDomainObjListNumOfDomains(driver->domains, true, NULL, NULL);\n    vmwareDriverUnlock(driver);\n\n    return n;\n}"
  },
  {
    "function_name": "vmwareConnectNumOfDefinedDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "999-1011",
    "snippet": "static int\nvmwareConnectNumOfDefinedDomains(virConnectPtr conn)\n{\n    struct vmware_driver *driver = conn->privateData;\n    int n;\n\n    vmwareDriverLock(driver);\n    vmwareDomainObjListUpdateAll(driver->domains, driver);\n    n = virDomainObjListNumOfDomains(driver->domains, false, NULL, NULL);\n    vmwareDriverUnlock(driver);\n\n    return n;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "56-60",
          "snippet": "static void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListNumOfDomains",
          "args": [
            "driver->domains",
            "false",
            "NULL",
            "NULL"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListNumOfDomains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "674-685",
          "snippet": "int\nvirDomainObjListNumOfDomains(virDomainObjListPtr doms,\n                             bool active,\n                             virDomainObjListACLFilter filter,\n                             virConnectPtr conn)\n{\n    struct virDomainObjListData data = { filter, conn, active, 0 };\n    virObjectRWLockRead(doms);\n    virHashForEach(doms->objs, virDomainObjListCount, &data);\n    virObjectRWUnlock(doms);\n    return data.count;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDomainObjListNumOfDomains(virDomainObjListPtr doms,\n                             bool active,\n                             virDomainObjListACLFilter filter,\n                             virConnectPtr conn)\n{\n    struct virDomainObjListData data = { filter, conn, active, 0 };\n    virObjectRWLockRead(doms);\n    virHashForEach(doms->objs, virDomainObjListCount, &data);\n    virObjectRWUnlock(doms);\n    return data.count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomainObjListUpdateAll",
          "args": [
            "driver->domains",
            "driver"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomainObjListUpdateAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "993-997",
          "snippet": "static void\nvmwareDomainObjListUpdateAll(virDomainObjListPtr doms, struct vmware_driver *driver)\n{\n    virDomainObjListForEach(doms, false, vmwareDomainObjListUpdateDomain, driver);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDomainObjListUpdateAll(virDomainObjListPtr doms, struct vmware_driver *driver)\n{\n    virDomainObjListForEach(doms, false, vmwareDomainObjListUpdateDomain, driver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverLock",
          "args": [
            "driver"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "50-54",
          "snippet": "static void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareConnectNumOfDefinedDomains(virConnectPtr conn)\n{\n    struct vmware_driver *driver = conn->privateData;\n    int n;\n\n    vmwareDriverLock(driver);\n    vmwareDomainObjListUpdateAll(driver->domains, driver);\n    n = virDomainObjListNumOfDomains(driver->domains, false, NULL, NULL);\n    vmwareDriverUnlock(driver);\n\n    return n;\n}"
  },
  {
    "function_name": "vmwareDomainObjListUpdateAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "993-997",
    "snippet": "static void\nvmwareDomainObjListUpdateAll(virDomainObjListPtr doms, struct vmware_driver *driver)\n{\n    virDomainObjListForEach(doms, false, vmwareDomainObjListUpdateDomain, driver);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjListForEach",
          "args": [
            "doms",
            "false",
            "vmwareDomainObjListUpdateDomain",
            "driver"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListForEach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "827-844",
          "snippet": "int\nvirDomainObjListForEach(virDomainObjListPtr doms,\n                        bool modify,\n                        virDomainObjListIterator callback,\n                        void *opaque)\n{\n    struct virDomainListIterData data = {\n        callback, opaque, 0,\n    };\n\n    if (modify)\n        virObjectRWLockWrite(doms);\n    else\n        virObjectRWLockRead(doms);\n    virHashForEach(doms->objs, virDomainObjListHelper, &data);\n    virObjectRWUnlock(doms);\n    return data.ret;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDomainObjListForEach(virDomainObjListPtr doms,\n                        bool modify,\n                        virDomainObjListIterator callback,\n                        void *opaque)\n{\n    struct virDomainListIterData data = {\n        callback, opaque, 0,\n    };\n\n    if (modify)\n        virObjectRWLockWrite(doms);\n    else\n        virObjectRWLockRead(doms);\n    virHashForEach(doms->objs, virDomainObjListHelper, &data);\n    virObjectRWUnlock(doms);\n    return data.ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDomainObjListUpdateAll(virDomainObjListPtr doms, struct vmware_driver *driver)\n{\n    virDomainObjListForEach(doms, false, vmwareDomainObjListUpdateDomain, driver);\n}"
  },
  {
    "function_name": "vmwareDomainObjListUpdateDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "984-991",
    "snippet": "static int vmwareDomainObjListUpdateDomain(virDomainObjPtr dom, void *data)\n{\n    struct vmware_driver *driver = data;\n    virObjectLock(dom);\n    ignore_value(vmwareUpdateVMStatus(driver, dom));\n    virObjectUnlock(dom);\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "dom"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "vmwareUpdateVMStatus(driver, dom)"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmwareUpdateVMStatus",
          "args": [
            "driver",
            "dom"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareUpdateVMStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "282-339",
          "snippet": "static int\nvmwareUpdateVMStatus(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    virCommandPtr cmd;\n    char *outbuf = NULL;\n    char *vmxAbsolutePath = NULL;\n    char *parsedVmxPath = NULL;\n    char *str;\n    char *saveptr = NULL;\n    bool found = false;\n    int oldState = virDomainObjGetState(vm, NULL);\n    int newState;\n    int ret = -1;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virFileResolveAllLinks(((vmwareDomainPtr) vm->privateData)->vmxPath,\n                               &vmxAbsolutePath) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (parsedVmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n         str = NULL) {\n\n        if (parsedVmxPath[0] != '/')\n            continue;\n\n        if (STREQ(parsedVmxPath, vmxAbsolutePath)) {\n            found = true;\n            /* If the vmx path is in the output, the domain is running or\n             * is paused but we have no way to detect if it is paused or not. */\n            if (oldState == VIR_DOMAIN_PAUSED)\n                newState = oldState;\n            else\n                newState = VIR_DOMAIN_RUNNING;\n            break;\n        }\n    }\n\n    if (!found) {\n        vm->def->id = -1;\n        newState = VIR_DOMAIN_SHUTOFF;\n    }\n\n    virDomainObjSetState(vm, newState, 0);\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(vmxAbsolutePath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareUpdateVMStatus(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    virCommandPtr cmd;\n    char *outbuf = NULL;\n    char *vmxAbsolutePath = NULL;\n    char *parsedVmxPath = NULL;\n    char *str;\n    char *saveptr = NULL;\n    bool found = false;\n    int oldState = virDomainObjGetState(vm, NULL);\n    int newState;\n    int ret = -1;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virFileResolveAllLinks(((vmwareDomainPtr) vm->privateData)->vmxPath,\n                               &vmxAbsolutePath) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (parsedVmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n         str = NULL) {\n\n        if (parsedVmxPath[0] != '/')\n            continue;\n\n        if (STREQ(parsedVmxPath, vmxAbsolutePath)) {\n            found = true;\n            /* If the vmx path is in the output, the domain is running or\n             * is paused but we have no way to detect if it is paused or not. */\n            if (oldState == VIR_DOMAIN_PAUSED)\n                newState = oldState;\n            else\n                newState = VIR_DOMAIN_RUNNING;\n            break;\n        }\n    }\n\n    if (!found) {\n        vm->def->id = -1;\n        newState = VIR_DOMAIN_SHUTOFF;\n    }\n\n    virDomainObjSetState(vm, newState, 0);\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(vmxAbsolutePath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "dom"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int vmwareDomainObjListUpdateDomain(virDomainObjPtr dom, void *data)\n{\n    struct vmware_driver *driver = data;\n    virObjectLock(dom);\n    ignore_value(vmwareUpdateVMStatus(driver, dom));\n    virObjectUnlock(dom);\n    return 0;\n}"
  },
  {
    "function_name": "vmwareConnectDomainXMLFromNative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "950-982",
    "snippet": "static char *\nvmwareConnectDomainXMLFromNative(virConnectPtr conn, const char *nativeFormat,\n                                 const char *nativeConfig,\n                                 unsigned int flags)\n{\n    struct vmware_driver *driver = conn->privateData;\n    virVMXContext ctx;\n    virDomainDefPtr def = NULL;\n    char *xml = NULL;\n\n    virCheckFlags(0, NULL);\n\n    if (STRNEQ(nativeFormat, VMX_CONFIG_FORMAT_ARGV)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unsupported config format '%s'\"), nativeFormat);\n        return NULL;\n    }\n\n    ctx.parseFileName = vmwareCopyVMXFileName;\n    ctx.formatFileName = NULL;\n    ctx.autodetectSCSIControllerModel = NULL;\n    ctx.datacenterPath = NULL;\n\n    def = virVMXParseConfig(&ctx, driver->xmlopt, driver->caps, nativeConfig);\n\n    if (def != NULL)\n        xml = virDomainDefFormat(def, driver->xmlopt,\n                                 VIR_DOMAIN_DEF_FORMAT_INACTIVE);\n\n    virDomainDefFree(def);\n\n    return xml;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "def"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFormat",
          "args": [
            "def",
            "driver->xmlopt",
            "VIR_DOMAIN_DEF_FORMAT_INACTIVE"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29496-29508",
          "snippet": "char *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)\n\nchar *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXParseConfig",
          "args": [
            "&ctx",
            "driver->xmlopt",
            "driver->caps",
            "nativeConfig"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXParseConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "1275-1867",
          "snippet": "virDomainDefPtr\nvirVMXParseConfig(virVMXContext *ctx,\n                  virDomainXMLOptionPtr xmlopt,\n                  virCapsPtr caps G_GNUC_UNUSED,\n                  const char *vmx)\n{\n    bool success = false;\n    g_autoptr(virConf) conf = NULL;\n    char *encoding = NULL;\n    char *utf8;\n    virDomainDefPtr def = NULL;\n    long long config_version = 0;\n    long long virtualHW_version = 0;\n    long long memsize = 0;\n    long long sched_mem_max = 0;\n    long long sched_mem_minsize = 0;\n    long long numvcpus = 0;\n    char *sched_cpu_affinity = NULL;\n    char *sched_cpu_shares = NULL;\n    char *guestOS = NULL;\n    bool smbios_reflecthost = false;\n    int controller;\n    int bus;\n    int port;\n    bool present;\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    int unit;\n    bool hgfs_disabled = true;\n    long long sharedFolder_maxNum = 0;\n    struct virVMXConfigScanResults results = { -1 };\n    long long coresPerSocket = 0;\n    virCPUDefPtr cpu = NULL;\n    char *firmware = NULL;\n\n    if (ctx->parseFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no parseFileName function set\"));\n        return NULL;\n    }\n\n    conf = virConfReadString(vmx, VIR_CONF_FLAG_VMX_FORMAT);\n\n    if (conf == NULL)\n        return NULL;\n\n    /* vmx:.encoding */\n    if (virVMXGetConfigString(conf, \".encoding\", &encoding, true) < 0)\n        goto cleanup;\n\n    if (encoding == NULL || STRCASEEQ(encoding, \"UTF-8\")) {\n        /* nothing */\n    } else {\n        virConfFree(conf);\n        conf = NULL;\n\n        utf8 = virVMXConvertToUTF8(encoding, vmx);\n\n        if (utf8 == NULL)\n            goto cleanup;\n\n        conf = virConfReadString(utf8, VIR_CONF_FLAG_VMX_FORMAT);\n\n        VIR_FREE(utf8);\n\n        if (conf == NULL)\n            goto cleanup;\n    }\n\n    if (virConfWalk(conf, virVMXConfigScanResultsCollector, &results) < 0)\n        goto cleanup;\n\n    /* Allocate domain def */\n    if (!(def = virDomainDefNew()))\n        goto cleanup;\n\n    def->virtType = VIR_DOMAIN_VIRT_VMWARE;\n    def->id = -1;\n\n    /* vmx:config.version */\n    if (virVMXGetConfigLong(conf, \"config.version\", &config_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (config_version != 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'config.version' to be 8 but found \"\n                         \"%lld\"), config_version);\n        goto cleanup;\n    }\n\n    /* vmx:virtualHW.version */\n    if (virVMXGetConfigLong(conf, \"virtualHW.version\", &virtualHW_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualHW_version < 4) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'virtualHW.version' to be \"\n                         \"4 or higher but found %lld\"),\n                       virtualHW_version);\n        goto cleanup;\n    }\n\n    /* vmx:uuid.bios -> def:uuid */\n    /* FIXME: Need to handle 'uuid.action = \"create\"' */\n    if (virVMXGetConfigUUID(conf, \"uuid.bios\", def->uuid, true) < 0)\n        goto cleanup;\n\n    /* vmx:displayName -> def:name */\n    if (virVMXGetConfigString(conf, \"displayName\", &def->name, true) < 0)\n        goto cleanup;\n\n    if (def->name != NULL) {\n        if (virVMXUnescapeHexPercent(def->name) < 0 ||\n            virVMXUnescapeHexPipe(def->name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'name' contains invalid escape sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:annotation -> def:description */\n    if (virVMXGetConfigString(conf, \"annotation\", &def->description,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (def->description != NULL) {\n        if (virVMXUnescapeHexPipe(def->description) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'annotation' contains invalid escape \"\n                             \"sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:memsize -> def:mem.max_balloon */\n    if (virVMXGetConfigLong(conf, \"memsize\", &memsize, 32, true) < 0)\n        goto cleanup;\n\n    if (memsize <= 0 || memsize % 4 != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'memsize' to be an unsigned \"\n                         \"integer (multiple of 4) but found %lld\"), memsize);\n        goto cleanup;\n    }\n\n    virDomainDefSetMemoryTotal(def, memsize * 1024); /* Scale from megabytes to kilobytes */\n\n    /* vmx:sched.mem.max -> def:mem.cur_balloon */\n    if (virVMXGetConfigLong(conf, \"sched.mem.max\", &sched_mem_max, memsize,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_max < 0)\n        sched_mem_max = memsize;\n\n    def->mem.cur_balloon = sched_mem_max * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.cur_balloon > virDomainDefGetMemoryTotal(def))\n        def->mem.cur_balloon = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:sched.mem.minsize -> def:mem.min_guarantee */\n    if (virVMXGetConfigLong(conf, \"sched.mem.minsize\", &sched_mem_minsize, 0,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_minsize < 0)\n        sched_mem_minsize = 0;\n\n    def->mem.min_guarantee = sched_mem_minsize * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.min_guarantee > virDomainDefGetMemoryTotal(def))\n        def->mem.min_guarantee = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:numvcpus -> def:vcpus */\n    if (virVMXGetConfigLong(conf, \"numvcpus\", &numvcpus, 1, true) < 0)\n        goto cleanup;\n\n    if (numvcpus <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'numvcpus' to be an unsigned \"\n                         \"integer greater than 0 but found %lld\"), numvcpus);\n        goto cleanup;\n    }\n\n    if (virDomainDefSetVcpusMax(def, numvcpus, xmlopt) < 0)\n        goto cleanup;\n\n    if (virDomainDefSetVcpus(def, numvcpus) < 0)\n        goto cleanup;\n\n    /* vmx:cpuid.coresPerSocket -> def:cpu */\n    if (virVMXGetConfigLong(conf, \"cpuid.coresPerSocket\", &coresPerSocket, 1,\n                            true) < 0)\n        goto cleanup;\n\n    if (coresPerSocket > 1) {\n        cpu = virCPUDefNew();\n\n        cpu->type = VIR_CPU_TYPE_GUEST;\n        cpu->mode = VIR_CPU_MODE_CUSTOM;\n\n        cpu->sockets = numvcpus / coresPerSocket;\n        if (cpu->sockets <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'cpuid.coresPerSocket' smaller than \"\n                             \"'numvcpus'\"));\n            goto cleanup;\n        }\n        cpu->dies = 1;\n        cpu->cores = coresPerSocket;\n        cpu->threads = 1;\n\n        def->cpu = g_steal_pointer(&cpu);\n    }\n\n    /* vmx:sched.cpu.affinity -> def:cpumask */\n    /* NOTE: maps to VirtualMachine:config.cpuAffinity.affinitySet */\n    if (virVMXGetConfigString(conf, \"sched.cpu.affinity\", &sched_cpu_affinity,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_affinity != NULL && STRCASENEQ(sched_cpu_affinity, \"all\")) {\n        VIR_AUTOSTRINGLIST afflist = NULL;\n        char **aff;\n        size_t naffs;\n\n        def->cpumask = virBitmapNew(VIR_DOMAIN_CPUMASK_LEN);\n        if (!def->cpumask)\n            goto cleanup;\n\n        if (!(afflist = virStringSplitCount(sched_cpu_affinity, \",\", 0, &naffs)))\n            goto cleanup;\n\n        if (naffs < numvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.affinity' to contain \"\n                             \"at least as many values as 'numvcpus' (%lld) but \"\n                             \"found only %zu value(s)\"), numvcpus, naffs);\n            goto cleanup;\n        }\n\n        for (aff = afflist; *aff; aff++) {\n            const char *current = *aff;\n            unsigned int number;\n            int rc;\n\n            virSkipSpaces(&current);\n            rc = virStrToLong_uip(current, (char **) &current, 10, &number);\n            virSkipSpaces(&current);\n\n            if (rc < 0 || *current != '\\0') {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry 'sched.cpu.affinity' to be \"\n                                 \"a comma separated list of unsigned integers but \"\n                                 \"found '%s'\"), sched_cpu_affinity);\n                goto cleanup;\n            }\n\n            if (number >= VIR_DOMAIN_CPUMASK_LEN) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"VMX entry 'sched.cpu.affinity' contains a %d, \"\n                                 \"this value is too large\"), number);\n                goto cleanup;\n            }\n\n            ignore_value(virBitmapSetBit(def->cpumask, number));\n        }\n    }\n\n    /* vmx:sched.cpu.shares -> def:cputune.shares */\n    if (virVMXGetConfigString(conf, \"sched.cpu.shares\", &sched_cpu_shares,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_shares != NULL) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (STRCASEEQ(sched_cpu_shares, \"low\")) {\n            def->cputune.shares = vcpus * 500;\n        } else if (STRCASEEQ(sched_cpu_shares, \"normal\")) {\n            def->cputune.shares = vcpus * 1000;\n        } else if (STRCASEEQ(sched_cpu_shares, \"high\")) {\n            def->cputune.shares = vcpus * 2000;\n        } else if (virStrToLong_ull(sched_cpu_shares, NULL, 10,\n                                    &def->cputune.shares) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.shares' to be an \"\n                             \"unsigned integer or 'low', 'normal' or 'high' but \"\n                             \"found '%s'\"), sched_cpu_shares);\n            goto cleanup;\n        }\n        def->cputune.sharesSpecified = true;\n    }\n\n    /* def:lifecycle */\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* def:os */\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    /* vmx:guestOS -> def:os.arch */\n    if (virVMXGetConfigString(conf, \"guestOS\", &guestOS, true) < 0)\n        goto cleanup;\n\n    if (guestOS != NULL && virStringHasSuffix(guestOS, \"-64\")) {\n        def->os.arch = VIR_ARCH_X86_64;\n    } else {\n        def->os.arch = VIR_ARCH_I686;\n    }\n\n    /* vmx:smbios.reflecthost -> def:os.smbios_mode */\n    if (virVMXGetConfigBoolean(conf, \"smbios.reflecthost\",\n                               &smbios_reflecthost, false, true) < 0) {\n        goto cleanup;\n    }\n\n    if (smbios_reflecthost)\n        def->os.smbios_mode = VIR_DOMAIN_SMBIOS_HOST;\n\n    /* def:features */\n    /* FIXME */\n\n    /* def:clock */\n    /* FIXME */\n\n    /* def:graphics */\n    if (VIR_ALLOC_N(def->graphics, 1) < 0)\n        goto cleanup;\n\n    def->ngraphics = 0;\n\n    if (virVMXParseVNC(conf, &def->graphics[def->ngraphics]) < 0)\n        goto cleanup;\n\n    if (def->graphics[def->ngraphics] != NULL)\n        ++def->ngraphics;\n\n    /* def:disks: 4 * 15 scsi + 2 * 2 ide + 2 floppy = 66 */\n    if (VIR_ALLOC_N(def->disks, 66) < 0)\n        goto cleanup;\n\n    def->ndisks = 0;\n\n    /* def:disks (scsi) */\n    for (controller = 0; controller < 4; ++controller) {\n        if (virVMXParseSCSIController(conf, controller, &present,\n                                      &scsi_virtualDev[controller]) < 0) {\n            goto cleanup;\n        }\n\n        if (! present)\n            continue;\n\n        for (unit = 0; unit < 16; ++unit) {\n            if (unit == 7) {\n                /*\n                 * SCSI unit 7 is assigned to the SCSI controller and cannot be\n                 * used for disk devices.\n                 */\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                 VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                 &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n\n    }\n\n    /* add all the SCSI controllers we've seen, up until the last one that is\n     * currently used by a disk */\n    if (def->ndisks != 0) {\n        virDomainDeviceInfoPtr info = &def->disks[def->ndisks - 1]->info;\n        for (controller = 0; controller <= info->addr.drive.controller; controller++) {\n            if (!virDomainDefAddController(def, VIR_DOMAIN_CONTROLLER_TYPE_SCSI,\n                                           controller, scsi_virtualDev[controller]))\n                goto cleanup;\n        }\n    }\n\n    /* def:disks (ide) */\n    for (bus = 0; bus < 2; ++bus) {\n        for (unit = 0; unit < 2; ++unit) {\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n    }\n\n    /* def:disks (floppy) */\n    for (unit = 0; unit < 2; ++unit) {\n        if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_FLOPPY,\n                            VIR_DOMAIN_DISK_BUS_FDC, 0, unit,\n                            &def->disks[def->ndisks], def) < 0) {\n            goto cleanup;\n        }\n\n        if (def->disks[def->ndisks] != NULL)\n            ++def->ndisks;\n    }\n\n    /* def:fss */\n    if (virVMXGetConfigBoolean(conf, \"isolation.tools.hgfs.disable\",\n                               &hgfs_disabled, true, true) < 0) {\n        goto cleanup;\n    }\n\n    if (!hgfs_disabled) {\n        if (virVMXGetConfigLong(conf, \"sharedFolder.maxNum\", &sharedFolder_maxNum,\n                                0, true) < 0) {\n            goto cleanup;\n        }\n\n        if (sharedFolder_maxNum > 0) {\n            int number;\n\n            if (VIR_ALLOC_N(def->fss, sharedFolder_maxNum) < 0)\n                goto cleanup;\n\n            def->nfss = 0;\n\n            for (number = 0; number < sharedFolder_maxNum; ++number) {\n                if (virVMXParseFileSystem(conf, number,\n                                          &def->fss[def->nfss]) < 0) {\n                    goto cleanup;\n                }\n\n                if (def->fss[def->nfss] != NULL)\n                    ++def->nfss;\n            }\n        }\n    }\n\n    /* def:nets */\n    for (controller = 0; controller <= results.networks_max_index; ++controller) {\n        virDomainNetDefPtr net = NULL;\n        if (virVMXParseEthernet(conf, controller, &net) < 0)\n            goto cleanup;\n\n        if (!net)\n            continue;\n\n        if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:videos */\n    if (VIR_ALLOC_N(def->videos, 1) < 0)\n        goto cleanup;\n\n    def->nvideos = 0;\n\n    if (virVMXParseSVGA(conf, &def->videos[def->nvideos]) < 0)\n        goto cleanup;\n\n    def->nvideos = 1;\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    if (VIR_ALLOC_N(def->serials, 4) < 0)\n        goto cleanup;\n\n    def->nserials = 0;\n\n    for (port = 0; port < 4; ++port) {\n        if (virVMXParseSerial(ctx, conf, port,\n                              &def->serials[def->nserials]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->serials[def->nserials] != NULL)\n            ++def->nserials;\n    }\n\n    /* def:parallels */\n    if (VIR_ALLOC_N(def->parallels, 3) < 0)\n        goto cleanup;\n\n    def->nparallels = 0;\n\n    for (port = 0; port < 3; ++port) {\n        if (virVMXParseParallel(ctx, conf, port,\n                                &def->parallels[def->nparallels]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->parallels[def->nparallels] != NULL)\n            ++def->nparallels;\n    }\n\n    /* ctx:datacenterPath -> def:namespaceData */\n    if (ctx->datacenterPath || ctx->moref) {\n        struct virVMXDomainDefNamespaceData *nsdata = NULL;\n\n        if (VIR_ALLOC(nsdata) < 0) {\n            virVMXDomainDefNamespaceFree(nsdata);\n            goto cleanup;\n        }\n\n        nsdata->datacenterPath = g_strdup(ctx->datacenterPath);\n\n        nsdata->moref = g_strdup(ctx->moref);\n\n        def->ns = *virDomainXMLOptionGetNamespace(xmlopt);\n        def->namespaceData = nsdata;\n    }\n\n    /* vmx:firmware */\n    if (virVMXGetConfigString(conf, \"firmware\", &firmware, true) < 0)\n        goto cleanup;\n\n    if (firmware != NULL) {\n        if (STREQ(firmware, \"efi\")) {\n            def->os.firmware = VIR_DOMAIN_OS_DEF_FIRMWARE_EFI;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"VMX entry 'firmware' has unknown value '%s'\"),\n                           firmware);\n            goto cleanup;\n        }\n    }\n\n    if (virDomainDefPostParse(def, VIR_DOMAIN_DEF_PARSE_ABI_UPDATE,\n                              xmlopt, NULL) < 0)\n        goto cleanup;\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        virDomainDefFree(def);\n        def = NULL;\n    }\n\n    VIR_FREE(encoding);\n    VIR_FREE(sched_cpu_affinity);\n    VIR_FREE(sched_cpu_shares);\n    VIR_FREE(guestOS);\n    virCPUDefFree(cpu);\n    VIR_FREE(firmware);\n\n    return def;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirDomainDefPtr\nvirVMXParseConfig(virVMXContext *ctx,\n                  virDomainXMLOptionPtr xmlopt,\n                  virCapsPtr caps G_GNUC_UNUSED,\n                  const char *vmx)\n{\n    bool success = false;\n    g_autoptr(virConf) conf = NULL;\n    char *encoding = NULL;\n    char *utf8;\n    virDomainDefPtr def = NULL;\n    long long config_version = 0;\n    long long virtualHW_version = 0;\n    long long memsize = 0;\n    long long sched_mem_max = 0;\n    long long sched_mem_minsize = 0;\n    long long numvcpus = 0;\n    char *sched_cpu_affinity = NULL;\n    char *sched_cpu_shares = NULL;\n    char *guestOS = NULL;\n    bool smbios_reflecthost = false;\n    int controller;\n    int bus;\n    int port;\n    bool present;\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    int unit;\n    bool hgfs_disabled = true;\n    long long sharedFolder_maxNum = 0;\n    struct virVMXConfigScanResults results = { -1 };\n    long long coresPerSocket = 0;\n    virCPUDefPtr cpu = NULL;\n    char *firmware = NULL;\n\n    if (ctx->parseFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no parseFileName function set\"));\n        return NULL;\n    }\n\n    conf = virConfReadString(vmx, VIR_CONF_FLAG_VMX_FORMAT);\n\n    if (conf == NULL)\n        return NULL;\n\n    /* vmx:.encoding */\n    if (virVMXGetConfigString(conf, \".encoding\", &encoding, true) < 0)\n        goto cleanup;\n\n    if (encoding == NULL || STRCASEEQ(encoding, \"UTF-8\")) {\n        /* nothing */\n    } else {\n        virConfFree(conf);\n        conf = NULL;\n\n        utf8 = virVMXConvertToUTF8(encoding, vmx);\n\n        if (utf8 == NULL)\n            goto cleanup;\n\n        conf = virConfReadString(utf8, VIR_CONF_FLAG_VMX_FORMAT);\n\n        VIR_FREE(utf8);\n\n        if (conf == NULL)\n            goto cleanup;\n    }\n\n    if (virConfWalk(conf, virVMXConfigScanResultsCollector, &results) < 0)\n        goto cleanup;\n\n    /* Allocate domain def */\n    if (!(def = virDomainDefNew()))\n        goto cleanup;\n\n    def->virtType = VIR_DOMAIN_VIRT_VMWARE;\n    def->id = -1;\n\n    /* vmx:config.version */\n    if (virVMXGetConfigLong(conf, \"config.version\", &config_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (config_version != 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'config.version' to be 8 but found \"\n                         \"%lld\"), config_version);\n        goto cleanup;\n    }\n\n    /* vmx:virtualHW.version */\n    if (virVMXGetConfigLong(conf, \"virtualHW.version\", &virtualHW_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualHW_version < 4) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'virtualHW.version' to be \"\n                         \"4 or higher but found %lld\"),\n                       virtualHW_version);\n        goto cleanup;\n    }\n\n    /* vmx:uuid.bios -> def:uuid */\n    /* FIXME: Need to handle 'uuid.action = \"create\"' */\n    if (virVMXGetConfigUUID(conf, \"uuid.bios\", def->uuid, true) < 0)\n        goto cleanup;\n\n    /* vmx:displayName -> def:name */\n    if (virVMXGetConfigString(conf, \"displayName\", &def->name, true) < 0)\n        goto cleanup;\n\n    if (def->name != NULL) {\n        if (virVMXUnescapeHexPercent(def->name) < 0 ||\n            virVMXUnescapeHexPipe(def->name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'name' contains invalid escape sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:annotation -> def:description */\n    if (virVMXGetConfigString(conf, \"annotation\", &def->description,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (def->description != NULL) {\n        if (virVMXUnescapeHexPipe(def->description) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'annotation' contains invalid escape \"\n                             \"sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:memsize -> def:mem.max_balloon */\n    if (virVMXGetConfigLong(conf, \"memsize\", &memsize, 32, true) < 0)\n        goto cleanup;\n\n    if (memsize <= 0 || memsize % 4 != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'memsize' to be an unsigned \"\n                         \"integer (multiple of 4) but found %lld\"), memsize);\n        goto cleanup;\n    }\n\n    virDomainDefSetMemoryTotal(def, memsize * 1024); /* Scale from megabytes to kilobytes */\n\n    /* vmx:sched.mem.max -> def:mem.cur_balloon */\n    if (virVMXGetConfigLong(conf, \"sched.mem.max\", &sched_mem_max, memsize,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_max < 0)\n        sched_mem_max = memsize;\n\n    def->mem.cur_balloon = sched_mem_max * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.cur_balloon > virDomainDefGetMemoryTotal(def))\n        def->mem.cur_balloon = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:sched.mem.minsize -> def:mem.min_guarantee */\n    if (virVMXGetConfigLong(conf, \"sched.mem.minsize\", &sched_mem_minsize, 0,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_minsize < 0)\n        sched_mem_minsize = 0;\n\n    def->mem.min_guarantee = sched_mem_minsize * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.min_guarantee > virDomainDefGetMemoryTotal(def))\n        def->mem.min_guarantee = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:numvcpus -> def:vcpus */\n    if (virVMXGetConfigLong(conf, \"numvcpus\", &numvcpus, 1, true) < 0)\n        goto cleanup;\n\n    if (numvcpus <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'numvcpus' to be an unsigned \"\n                         \"integer greater than 0 but found %lld\"), numvcpus);\n        goto cleanup;\n    }\n\n    if (virDomainDefSetVcpusMax(def, numvcpus, xmlopt) < 0)\n        goto cleanup;\n\n    if (virDomainDefSetVcpus(def, numvcpus) < 0)\n        goto cleanup;\n\n    /* vmx:cpuid.coresPerSocket -> def:cpu */\n    if (virVMXGetConfigLong(conf, \"cpuid.coresPerSocket\", &coresPerSocket, 1,\n                            true) < 0)\n        goto cleanup;\n\n    if (coresPerSocket > 1) {\n        cpu = virCPUDefNew();\n\n        cpu->type = VIR_CPU_TYPE_GUEST;\n        cpu->mode = VIR_CPU_MODE_CUSTOM;\n\n        cpu->sockets = numvcpus / coresPerSocket;\n        if (cpu->sockets <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'cpuid.coresPerSocket' smaller than \"\n                             \"'numvcpus'\"));\n            goto cleanup;\n        }\n        cpu->dies = 1;\n        cpu->cores = coresPerSocket;\n        cpu->threads = 1;\n\n        def->cpu = g_steal_pointer(&cpu);\n    }\n\n    /* vmx:sched.cpu.affinity -> def:cpumask */\n    /* NOTE: maps to VirtualMachine:config.cpuAffinity.affinitySet */\n    if (virVMXGetConfigString(conf, \"sched.cpu.affinity\", &sched_cpu_affinity,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_affinity != NULL && STRCASENEQ(sched_cpu_affinity, \"all\")) {\n        VIR_AUTOSTRINGLIST afflist = NULL;\n        char **aff;\n        size_t naffs;\n\n        def->cpumask = virBitmapNew(VIR_DOMAIN_CPUMASK_LEN);\n        if (!def->cpumask)\n            goto cleanup;\n\n        if (!(afflist = virStringSplitCount(sched_cpu_affinity, \",\", 0, &naffs)))\n            goto cleanup;\n\n        if (naffs < numvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.affinity' to contain \"\n                             \"at least as many values as 'numvcpus' (%lld) but \"\n                             \"found only %zu value(s)\"), numvcpus, naffs);\n            goto cleanup;\n        }\n\n        for (aff = afflist; *aff; aff++) {\n            const char *current = *aff;\n            unsigned int number;\n            int rc;\n\n            virSkipSpaces(&current);\n            rc = virStrToLong_uip(current, (char **) &current, 10, &number);\n            virSkipSpaces(&current);\n\n            if (rc < 0 || *current != '\\0') {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry 'sched.cpu.affinity' to be \"\n                                 \"a comma separated list of unsigned integers but \"\n                                 \"found '%s'\"), sched_cpu_affinity);\n                goto cleanup;\n            }\n\n            if (number >= VIR_DOMAIN_CPUMASK_LEN) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"VMX entry 'sched.cpu.affinity' contains a %d, \"\n                                 \"this value is too large\"), number);\n                goto cleanup;\n            }\n\n            ignore_value(virBitmapSetBit(def->cpumask, number));\n        }\n    }\n\n    /* vmx:sched.cpu.shares -> def:cputune.shares */\n    if (virVMXGetConfigString(conf, \"sched.cpu.shares\", &sched_cpu_shares,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_shares != NULL) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (STRCASEEQ(sched_cpu_shares, \"low\")) {\n            def->cputune.shares = vcpus * 500;\n        } else if (STRCASEEQ(sched_cpu_shares, \"normal\")) {\n            def->cputune.shares = vcpus * 1000;\n        } else if (STRCASEEQ(sched_cpu_shares, \"high\")) {\n            def->cputune.shares = vcpus * 2000;\n        } else if (virStrToLong_ull(sched_cpu_shares, NULL, 10,\n                                    &def->cputune.shares) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.shares' to be an \"\n                             \"unsigned integer or 'low', 'normal' or 'high' but \"\n                             \"found '%s'\"), sched_cpu_shares);\n            goto cleanup;\n        }\n        def->cputune.sharesSpecified = true;\n    }\n\n    /* def:lifecycle */\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* def:os */\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    /* vmx:guestOS -> def:os.arch */\n    if (virVMXGetConfigString(conf, \"guestOS\", &guestOS, true) < 0)\n        goto cleanup;\n\n    if (guestOS != NULL && virStringHasSuffix(guestOS, \"-64\")) {\n        def->os.arch = VIR_ARCH_X86_64;\n    } else {\n        def->os.arch = VIR_ARCH_I686;\n    }\n\n    /* vmx:smbios.reflecthost -> def:os.smbios_mode */\n    if (virVMXGetConfigBoolean(conf, \"smbios.reflecthost\",\n                               &smbios_reflecthost, false, true) < 0) {\n        goto cleanup;\n    }\n\n    if (smbios_reflecthost)\n        def->os.smbios_mode = VIR_DOMAIN_SMBIOS_HOST;\n\n    /* def:features */\n    /* FIXME */\n\n    /* def:clock */\n    /* FIXME */\n\n    /* def:graphics */\n    if (VIR_ALLOC_N(def->graphics, 1) < 0)\n        goto cleanup;\n\n    def->ngraphics = 0;\n\n    if (virVMXParseVNC(conf, &def->graphics[def->ngraphics]) < 0)\n        goto cleanup;\n\n    if (def->graphics[def->ngraphics] != NULL)\n        ++def->ngraphics;\n\n    /* def:disks: 4 * 15 scsi + 2 * 2 ide + 2 floppy = 66 */\n    if (VIR_ALLOC_N(def->disks, 66) < 0)\n        goto cleanup;\n\n    def->ndisks = 0;\n\n    /* def:disks (scsi) */\n    for (controller = 0; controller < 4; ++controller) {\n        if (virVMXParseSCSIController(conf, controller, &present,\n                                      &scsi_virtualDev[controller]) < 0) {\n            goto cleanup;\n        }\n\n        if (! present)\n            continue;\n\n        for (unit = 0; unit < 16; ++unit) {\n            if (unit == 7) {\n                /*\n                 * SCSI unit 7 is assigned to the SCSI controller and cannot be\n                 * used for disk devices.\n                 */\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                 VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                 &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n\n    }\n\n    /* add all the SCSI controllers we've seen, up until the last one that is\n     * currently used by a disk */\n    if (def->ndisks != 0) {\n        virDomainDeviceInfoPtr info = &def->disks[def->ndisks - 1]->info;\n        for (controller = 0; controller <= info->addr.drive.controller; controller++) {\n            if (!virDomainDefAddController(def, VIR_DOMAIN_CONTROLLER_TYPE_SCSI,\n                                           controller, scsi_virtualDev[controller]))\n                goto cleanup;\n        }\n    }\n\n    /* def:disks (ide) */\n    for (bus = 0; bus < 2; ++bus) {\n        for (unit = 0; unit < 2; ++unit) {\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n    }\n\n    /* def:disks (floppy) */\n    for (unit = 0; unit < 2; ++unit) {\n        if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_FLOPPY,\n                            VIR_DOMAIN_DISK_BUS_FDC, 0, unit,\n                            &def->disks[def->ndisks], def) < 0) {\n            goto cleanup;\n        }\n\n        if (def->disks[def->ndisks] != NULL)\n            ++def->ndisks;\n    }\n\n    /* def:fss */\n    if (virVMXGetConfigBoolean(conf, \"isolation.tools.hgfs.disable\",\n                               &hgfs_disabled, true, true) < 0) {\n        goto cleanup;\n    }\n\n    if (!hgfs_disabled) {\n        if (virVMXGetConfigLong(conf, \"sharedFolder.maxNum\", &sharedFolder_maxNum,\n                                0, true) < 0) {\n            goto cleanup;\n        }\n\n        if (sharedFolder_maxNum > 0) {\n            int number;\n\n            if (VIR_ALLOC_N(def->fss, sharedFolder_maxNum) < 0)\n                goto cleanup;\n\n            def->nfss = 0;\n\n            for (number = 0; number < sharedFolder_maxNum; ++number) {\n                if (virVMXParseFileSystem(conf, number,\n                                          &def->fss[def->nfss]) < 0) {\n                    goto cleanup;\n                }\n\n                if (def->fss[def->nfss] != NULL)\n                    ++def->nfss;\n            }\n        }\n    }\n\n    /* def:nets */\n    for (controller = 0; controller <= results.networks_max_index; ++controller) {\n        virDomainNetDefPtr net = NULL;\n        if (virVMXParseEthernet(conf, controller, &net) < 0)\n            goto cleanup;\n\n        if (!net)\n            continue;\n\n        if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:videos */\n    if (VIR_ALLOC_N(def->videos, 1) < 0)\n        goto cleanup;\n\n    def->nvideos = 0;\n\n    if (virVMXParseSVGA(conf, &def->videos[def->nvideos]) < 0)\n        goto cleanup;\n\n    def->nvideos = 1;\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    if (VIR_ALLOC_N(def->serials, 4) < 0)\n        goto cleanup;\n\n    def->nserials = 0;\n\n    for (port = 0; port < 4; ++port) {\n        if (virVMXParseSerial(ctx, conf, port,\n                              &def->serials[def->nserials]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->serials[def->nserials] != NULL)\n            ++def->nserials;\n    }\n\n    /* def:parallels */\n    if (VIR_ALLOC_N(def->parallels, 3) < 0)\n        goto cleanup;\n\n    def->nparallels = 0;\n\n    for (port = 0; port < 3; ++port) {\n        if (virVMXParseParallel(ctx, conf, port,\n                                &def->parallels[def->nparallels]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->parallels[def->nparallels] != NULL)\n            ++def->nparallels;\n    }\n\n    /* ctx:datacenterPath -> def:namespaceData */\n    if (ctx->datacenterPath || ctx->moref) {\n        struct virVMXDomainDefNamespaceData *nsdata = NULL;\n\n        if (VIR_ALLOC(nsdata) < 0) {\n            virVMXDomainDefNamespaceFree(nsdata);\n            goto cleanup;\n        }\n\n        nsdata->datacenterPath = g_strdup(ctx->datacenterPath);\n\n        nsdata->moref = g_strdup(ctx->moref);\n\n        def->ns = *virDomainXMLOptionGetNamespace(xmlopt);\n        def->namespaceData = nsdata;\n    }\n\n    /* vmx:firmware */\n    if (virVMXGetConfigString(conf, \"firmware\", &firmware, true) < 0)\n        goto cleanup;\n\n    if (firmware != NULL) {\n        if (STREQ(firmware, \"efi\")) {\n            def->os.firmware = VIR_DOMAIN_OS_DEF_FIRMWARE_EFI;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"VMX entry 'firmware' has unknown value '%s'\"),\n                           firmware);\n            goto cleanup;\n        }\n    }\n\n    if (virDomainDefPostParse(def, VIR_DOMAIN_DEF_PARSE_ABI_UPDATE,\n                              xmlopt, NULL) < 0)\n        goto cleanup;\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        virDomainDefFree(def);\n        def = NULL;\n    }\n\n    VIR_FREE(encoding);\n    VIR_FREE(sched_cpu_affinity);\n    VIR_FREE(sched_cpu_shares);\n    VIR_FREE(guestOS);\n    virCPUDefFree(cpu);\n    VIR_FREE(firmware);\n\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Unsupported config format '%s'\")",
            "nativeFormat"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported config format '%s'\""
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "nativeFormat",
            "VMX_CONFIG_FORMAT_ARGV"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic char *\nvmwareConnectDomainXMLFromNative(virConnectPtr conn, const char *nativeFormat,\n                                 const char *nativeConfig,\n                                 unsigned int flags)\n{\n    struct vmware_driver *driver = conn->privateData;\n    virVMXContext ctx;\n    virDomainDefPtr def = NULL;\n    char *xml = NULL;\n\n    virCheckFlags(0, NULL);\n\n    if (STRNEQ(nativeFormat, VMX_CONFIG_FORMAT_ARGV)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unsupported config format '%s'\"), nativeFormat);\n        return NULL;\n    }\n\n    ctx.parseFileName = vmwareCopyVMXFileName;\n    ctx.formatFileName = NULL;\n    ctx.autodetectSCSIControllerModel = NULL;\n    ctx.datacenterPath = NULL;\n\n    def = virVMXParseConfig(&ctx, driver->xmlopt, driver->caps, nativeConfig);\n\n    if (def != NULL)\n        xml = virDomainDefFormat(def, driver->xmlopt,\n                                 VIR_DOMAIN_DEF_FORMAT_INACTIVE);\n\n    virDomainDefFree(def);\n\n    return xml;\n}"
  },
  {
    "function_name": "vmwareDomainGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "931-948",
    "snippet": "static char *\nvmwareDomainGetXMLDesc(virDomainPtr dom, unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    char *ret = NULL;\n\n    virCheckFlags(VIR_DOMAIN_XML_COMMON_FLAGS, NULL);\n\n    if (!(vm = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return NULL;\n\n    ret = virDomainDefFormat(vm->def, driver->xmlopt,\n                             virDomainDefFormatConvertXMLFlags(flags));\n\n    virDomainObjEndAPI(&vm);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFormat",
          "args": [
            "vm->def",
            "driver->xmlopt",
            "virDomainDefFormatConvertXMLFlags(flags)"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29496-29508",
          "snippet": "char *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)\n\nchar *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFormatConvertXMLFlags",
          "args": [
            "flags"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormatConvertXMLFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29481-29493",
          "snippet": "unsigned int virDomainDefFormatConvertXMLFlags(unsigned int flags)\n{\n    unsigned int formatFlags = 0;\n\n    if (flags & VIR_DOMAIN_XML_SECURE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_SECURE;\n    if (flags & VIR_DOMAIN_XML_INACTIVE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_INACTIVE;\n    if (flags & VIR_DOMAIN_XML_MIGRATABLE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_MIGRATABLE;\n\n    return formatFlags;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned int virDomainDefFormatConvertXMLFlags(unsigned int flags)\n{\n    unsigned int formatFlags = 0;\n\n    if (flags & VIR_DOMAIN_XML_SECURE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_SECURE;\n    if (flags & VIR_DOMAIN_XML_INACTIVE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_INACTIVE;\n    if (flags & VIR_DOMAIN_XML_MIGRATABLE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_MIGRATABLE;\n\n    return formatFlags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomObjFromDomain",
          "args": [
            "driver",
            "dom->uuid"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomObjFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "82-92",
          "snippet": "static virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_XML_COMMON_FLAGS",
            "NULL"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic char *\nvmwareDomainGetXMLDesc(virDomainPtr dom, unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    char *ret = NULL;\n\n    virCheckFlags(VIR_DOMAIN_XML_COMMON_FLAGS, NULL);\n\n    if (!(vm = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return NULL;\n\n    ret = virDomainDefFormat(vm->def, driver->xmlopt,\n                             virDomainDefFormatConvertXMLFlags(flags));\n\n    virDomainObjEndAPI(&vm);\n    return ret;\n}"
  },
  {
    "function_name": "vmwareDomainIsPersistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "914-928",
    "snippet": "static int\nvmwareDomainIsPersistent(virDomainPtr dom)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr obj;\n    int ret = -1;\n\n    if (!(obj = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return -1;\n\n    ret = obj->persistent;\n\n    virDomainObjEndAPI(&obj);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomObjFromDomain",
          "args": [
            "driver",
            "dom->uuid"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomObjFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "82-92",
          "snippet": "static virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainIsPersistent(virDomainPtr dom)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr obj;\n    int ret = -1;\n\n    if (!(obj = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return -1;\n\n    ret = obj->persistent;\n\n    virDomainObjEndAPI(&obj);\n    return ret;\n}"
  },
  {
    "function_name": "vmwareDomainIsActive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "897-911",
    "snippet": "static int\nvmwareDomainIsActive(virDomainPtr dom)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr obj;\n    int ret = -1;\n\n    if (!(obj = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return -1;\n\n    ret = virDomainObjIsActive(obj);\n\n    virDomainObjEndAPI(&obj);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjIsActive",
          "args": [
            "obj"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.h",
          "lines": "2845-2849",
          "snippet": "static inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virresctrl.h\"",
            "#include \"virsavecookie.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virperf.h\"",
            "#include \"virgic.h\"",
            "#include \"virprocess.h\"",
            "#include \"virseclabel.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virbitmap.h\"",
            "#include \"device_conf.h\"",
            "#include \"virobject.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"numa_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virthread.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"capabilities.h\"",
            "#include \"virconftypes.h\"",
            "#include \"internal.h\"",
            "#include <libxml/xpath.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parser.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void virDomainMemoryDefFree(virDomainMemoryDefPtr def);",
            "void virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);",
            "unsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);",
            "unsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);",
            "bool virDomainDefHasMemoryHotplug(const virDomainDef *def);",
            "int virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);",
            "bool virDomainDefHasUSB(const virDomainDef *def);",
            "int virDomainObjCheckActive(virDomainObjPtr dom);",
            "bool virDomainDefHasVcpusOffline(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpusMax(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpus(const virDomainDef *def);",
            "virBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);",
            "void virDomainDefVcpuOrderClear(virDomainDefPtr def);",
            "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);",
            "void virDomainInputDefFree(virDomainInputDefPtr def);",
            "void virDomainDiskDefFree(virDomainDiskDefPtr def);",
            "void virDomainLeaseDefFree(virDomainLeaseDefPtr def);",
            "int virDomainDiskGetType(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetSource(virDomainDiskDef const *def);",
            "void virDomainDiskEmptySource(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetDriver(const virDomainDiskDef *def);",
            "int virDomainDiskGetFormat(virDomainDiskDefPtr def);",
            "void virDomainControllerDefFree(virDomainControllerDefPtr def);",
            "void virDomainFSDefFree(virDomainFSDefPtr def);",
            "void virDomainActualNetDefFree(virDomainActualNetDefPtr def);",
            "void virDomainNetDefClear(virDomainNetDefPtr def);",
            "void virDomainNetDefFree(virDomainNetDefPtr def);",
            "void virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);",
            "void virDomainChrDefFree(virDomainChrDefPtr def);",
            "void virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);",
            "void virDomainSoundDefFree(virDomainSoundDefPtr def);",
            "void virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);",
            "void virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);",
            "void virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);",
            "void virDomainVideoDefFree(virDomainVideoDefPtr def);",
            "void virDomainVideoDefClear(virDomainVideoDefPtr def);",
            "void virDomainHostdevDefClear(virDomainHostdevDefPtr def);",
            "void virDomainHostdevDefFree(virDomainHostdevDefPtr def);",
            "void virDomainHubDefFree(virDomainHubDefPtr def);",
            "void virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);",
            "void virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);",
            "void virDomainShmemDefFree(virDomainShmemDefPtr def);",
            "void virDomainDeviceDefFree(virDomainDeviceDefPtr def);",
            "void virDomainTPMDefFree(virDomainTPMDefPtr def);",
            "void virDomainRNGDefFree(virDomainRNGDefPtr def);",
            "int virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);",
            "int virDomainVideoDefaultType(const virDomainDef *def);",
            "void virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);",
            "int virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);",
            "bool\nvirDomainDefHasManagedPR(const virDomainDef *def);",
            "bool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);",
            "bool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);",
            "bool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virresctrl.h\"\n#include \"virsavecookie.h\"\n#include \"virtypedparam.h\"\n#include \"virperf.h\"\n#include \"virgic.h\"\n#include \"virprocess.h\"\n#include \"virseclabel.h\"\n#include \"virstoragefile.h\"\n#include \"virbitmap.h\"\n#include \"device_conf.h\"\n#include \"virobject.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevvlan.h\"\n#include \"virnetdevbandwidth.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virsysinfo.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"numa_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"networkcommon_conf.h\"\n#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virthread.h\"\n#include \"cpu_conf.h\"\n#include \"virstorageencryption.h\"\n#include \"capabilities.h\"\n#include \"virconftypes.h\"\n#include \"internal.h\"\n#include <libxml/xpath.h>\n#include <libxml/tree.h>\n#include <libxml/parser.h>\n\nvoid virDomainMemoryDefFree(virDomainMemoryDefPtr def);\nvoid virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);\nunsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);\nunsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);\nbool virDomainDefHasMemoryHotplug(const virDomainDef *def);\nint virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);\nbool virDomainDefHasUSB(const virDomainDef *def);\nint virDomainObjCheckActive(virDomainObjPtr dom);\nbool virDomainDefHasVcpusOffline(const virDomainDef *def);\nunsigned int virDomainDefGetVcpusMax(const virDomainDef *def);\nunsigned int virDomainDefGetVcpus(const virDomainDef *def);\nvirBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);\nvoid virDomainDefVcpuOrderClear(virDomainDefPtr def);\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);\nvoid virDomainInputDefFree(virDomainInputDefPtr def);\nvoid virDomainDiskDefFree(virDomainDiskDefPtr def);\nvoid virDomainLeaseDefFree(virDomainLeaseDefPtr def);\nint virDomainDiskGetType(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetSource(virDomainDiskDef const *def);\nvoid virDomainDiskEmptySource(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetDriver(const virDomainDiskDef *def);\nint virDomainDiskGetFormat(virDomainDiskDefPtr def);\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def);\nvoid virDomainFSDefFree(virDomainFSDefPtr def);\nvoid virDomainActualNetDefFree(virDomainActualNetDefPtr def);\nvoid virDomainNetDefClear(virDomainNetDefPtr def);\nvoid virDomainNetDefFree(virDomainNetDefPtr def);\nvoid virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);\nvoid virDomainChrDefFree(virDomainChrDefPtr def);\nvoid virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);\nvoid virDomainSoundDefFree(virDomainSoundDefPtr def);\nvoid virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);\nvoid virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);\nvoid virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def);\nvoid virDomainVideoDefClear(virDomainVideoDefPtr def);\nvoid virDomainHostdevDefClear(virDomainHostdevDefPtr def);\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def);\nvoid virDomainHubDefFree(virDomainHubDefPtr def);\nvoid virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);\nvoid virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);\nvoid virDomainShmemDefFree(virDomainShmemDefPtr def);\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def);\nvoid virDomainTPMDefFree(virDomainTPMDefPtr def);\nvoid virDomainRNGDefFree(virDomainRNGDefPtr def);\nint virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);\nint virDomainVideoDefaultType(const virDomainDef *def);\nvoid virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);\nint virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);\nbool\nvirDomainDefHasManagedPR(const virDomainDef *def);\nbool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);\nbool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);\nbool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);\n\nstatic inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomObjFromDomain",
          "args": [
            "driver",
            "dom->uuid"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomObjFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "82-92",
          "snippet": "static virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainIsActive(virDomainPtr dom)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr obj;\n    int ret = -1;\n\n    if (!(obj = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return -1;\n\n    ret = virDomainObjIsActive(obj);\n\n    virDomainObjEndAPI(&obj);\n    return ret;\n}"
  },
  {
    "function_name": "vmwareDomainLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "873-895",
    "snippet": "static virDomainPtr\nvmwareDomainLookupByName(virConnectPtr conn, const char *name)\n{\n    struct vmware_driver *driver = conn->privateData;\n    virDomainObjPtr vm;\n    virDomainPtr dom = NULL;\n\n    vmwareDriverLock(driver);\n    vm = virDomainObjListFindByName(driver->domains, name);\n    vmwareDriverUnlock(driver);\n\n    if (!vm) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching name '%s'\"), name);\n        goto cleanup;\n    }\n\n    dom = virGetDomain(conn, vm->def->name, vm->def->uuid, vm->def->id);\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return dom;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetDomain",
          "args": [
            "conn",
            "vm->def->name",
            "vm->def->uuid",
            "vm->def->id"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "275-304",
          "snippet": "virDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainClass;\n\nvirDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "_(\"no domain with matching name '%s'\")",
            "name"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no domain with matching name '%s'\""
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "56-60",
          "snippet": "static void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListFindByName",
          "args": [
            "driver->domains",
            "name"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListFindByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "205-222",
          "snippet": "virDomainObjPtr\nvirDomainObjListFindByName(virDomainObjListPtr doms,\n                           const char *name)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByNameLocked(doms, name);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virDomainObjListDispose(void *obj);\n\nvirDomainObjPtr\nvirDomainObjListFindByName(virDomainObjListPtr doms,\n                           const char *name)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByNameLocked(doms, name);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverLock",
          "args": [
            "driver"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "50-54",
          "snippet": "static void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainPtr\nvmwareDomainLookupByName(virConnectPtr conn, const char *name)\n{\n    struct vmware_driver *driver = conn->privateData;\n    virDomainObjPtr vm;\n    virDomainPtr dom = NULL;\n\n    vmwareDriverLock(driver);\n    vm = virDomainObjListFindByName(driver->domains, name);\n    vmwareDriverUnlock(driver);\n\n    if (!vm) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching name '%s'\"), name);\n        goto cleanup;\n    }\n\n    dom = virGetDomain(conn, vm->def->name, vm->def->uuid, vm->def->id);\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return dom;\n}"
  },
  {
    "function_name": "vmwareDomainLookupByUUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "857-871",
    "snippet": "static virDomainPtr\nvmwareDomainLookupByUUID(virConnectPtr conn, const unsigned char *uuid)\n{\n    struct vmware_driver *driver = conn->privateData;\n    virDomainObjPtr vm;\n    virDomainPtr dom = NULL;\n\n    if (!(vm = vmwareDomObjFromDomain(driver, uuid)))\n        return NULL;\n\n    dom = virGetDomain(conn, vm->def->name, vm->def->uuid, vm->def->id);\n\n    virDomainObjEndAPI(&vm);\n    return dom;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetDomain",
          "args": [
            "conn",
            "vm->def->name",
            "vm->def->uuid",
            "vm->def->id"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "275-304",
          "snippet": "virDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainClass;\n\nvirDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomObjFromDomain",
          "args": [
            "driver",
            "uuid"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomObjFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "82-92",
          "snippet": "static virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainPtr\nvmwareDomainLookupByUUID(virConnectPtr conn, const unsigned char *uuid)\n{\n    struct vmware_driver *driver = conn->privateData;\n    virDomainObjPtr vm;\n    virDomainPtr dom = NULL;\n\n    if (!(vm = vmwareDomObjFromDomain(driver, uuid)))\n        return NULL;\n\n    dom = virGetDomain(conn, vm->def->name, vm->def->uuid, vm->def->id);\n\n    virDomainObjEndAPI(&vm);\n    return dom;\n}"
  },
  {
    "function_name": "vmwareDomainGetOSType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "840-854",
    "snippet": "static char *\nvmwareDomainGetOSType(virDomainPtr dom)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    char *ret = NULL;\n\n    if (!(vm = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return NULL;\n\n    ret = g_strdup(virDomainOSTypeToString(vm->def->os.type));\n\n    virDomainObjEndAPI(&vm);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "virDomainOSTypeToString(vm->def->os.type)"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainOSTypeToString",
          "args": [
            "vm->def->os.type"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmwareDomObjFromDomain",
          "args": [
            "driver",
            "dom->uuid"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomObjFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "82-92",
          "snippet": "static virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic char *\nvmwareDomainGetOSType(virDomainPtr dom)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    char *ret = NULL;\n\n    if (!(vm = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return NULL;\n\n    ret = g_strdup(virDomainOSTypeToString(vm->def->os.type));\n\n    virDomainObjEndAPI(&vm);\n    return ret;\n}"
  },
  {
    "function_name": "vmwareDomainLookupByID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "816-838",
    "snippet": "static virDomainPtr\nvmwareDomainLookupByID(virConnectPtr conn, int id)\n{\n    struct vmware_driver *driver = conn->privateData;\n    virDomainObjPtr vm;\n    virDomainPtr dom = NULL;\n\n    vmwareDriverLock(driver);\n    vm = virDomainObjListFindByID(driver->domains, id);\n    vmwareDriverUnlock(driver);\n\n    if (!vm) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching id '%d'\"), id);\n        goto cleanup;\n    }\n\n    dom = virGetDomain(conn, vm->def->name, vm->def->uuid, vm->def->id);\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return dom;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetDomain",
          "args": [
            "conn",
            "vm->def->name",
            "vm->def->uuid",
            "vm->def->id"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "275-304",
          "snippet": "virDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainClass;\n\nvirDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "_(\"no domain with matching id '%d'\")",
            "id"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no domain with matching id '%d'\""
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "56-60",
          "snippet": "static void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListFindByID",
          "args": [
            "driver->domains",
            "id"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListFindByID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "114-134",
          "snippet": "virDomainObjPtr\nvirDomainObjListFindByID(virDomainObjListPtr doms,\n                         int id)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virHashSearch(doms->objs, virDomainObjListSearchID, &id, NULL);\n    virObjectRef(obj);\n    virObjectRWUnlock(doms);\n    if (obj) {\n        virObjectLock(obj);\n        if (obj->removing) {\n            virObjectUnlock(obj);\n            virObjectUnref(obj);\n            obj = NULL;\n        }\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virDomainObjListDispose(void *obj);\n\nvirDomainObjPtr\nvirDomainObjListFindByID(virDomainObjListPtr doms,\n                         int id)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virHashSearch(doms->objs, virDomainObjListSearchID, &id, NULL);\n    virObjectRef(obj);\n    virObjectRWUnlock(doms);\n    if (obj) {\n        virObjectLock(obj);\n        if (obj->removing) {\n            virObjectUnlock(obj);\n            virObjectUnref(obj);\n            obj = NULL;\n        }\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverLock",
          "args": [
            "driver"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "50-54",
          "snippet": "static void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainPtr\nvmwareDomainLookupByID(virConnectPtr conn, int id)\n{\n    struct vmware_driver *driver = conn->privateData;\n    virDomainObjPtr vm;\n    virDomainPtr dom = NULL;\n\n    vmwareDriverLock(driver);\n    vm = virDomainObjListFindByID(driver->domains, id);\n    vmwareDriverUnlock(driver);\n\n    if (!vm) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching id '%d'\"), id);\n        goto cleanup;\n    }\n\n    dom = virGetDomain(conn, vm->def->name, vm->def->uuid, vm->def->id);\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return dom;\n}"
  },
  {
    "function_name": "vmwareDomainUndefine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "810-814",
    "snippet": "static int\nvmwareDomainUndefine(virDomainPtr dom)\n{\n    return vmwareDomainUndefineFlags(dom, 0);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareDomainUndefineFlags",
          "args": [
            "dom",
            "0"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomainUndefineFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "774-808",
          "snippet": "static int\nvmwareDomainUndefineFlags(virDomainPtr dom,\n                          unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    vmwareDriverLock(driver);\n    if (!(vm = vmwareDomObjFromDomainLocked(driver, dom->uuid)))\n        goto cleanup;\n\n    if (!vm->persistent) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"cannot undefine transient domain\"));\n        goto cleanup;\n    }\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    if (virDomainObjIsActive(vm))\n        vm->persistent = 0;\n    else\n        virDomainObjListRemove(driver->domains, vm);\n\n    ret = 0;\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    vmwareDriverUnlock(driver);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainUndefineFlags(virDomainPtr dom,\n                          unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    vmwareDriverLock(driver);\n    if (!(vm = vmwareDomObjFromDomainLocked(driver, dom->uuid)))\n        goto cleanup;\n\n    if (!vm->persistent) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"cannot undefine transient domain\"));\n        goto cleanup;\n    }\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    if (virDomainObjIsActive(vm))\n        vm->persistent = 0;\n    else\n        virDomainObjListRemove(driver->domains, vm);\n\n    ret = 0;\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    vmwareDriverUnlock(driver);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainUndefine(virDomainPtr dom)\n{\n    return vmwareDomainUndefineFlags(dom, 0);\n}"
  },
  {
    "function_name": "vmwareDomainUndefineFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "774-808",
    "snippet": "static int\nvmwareDomainUndefineFlags(virDomainPtr dom,\n                          unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    vmwareDriverLock(driver);\n    if (!(vm = vmwareDomObjFromDomainLocked(driver, dom->uuid)))\n        goto cleanup;\n\n    if (!vm->persistent) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"cannot undefine transient domain\"));\n        goto cleanup;\n    }\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    if (virDomainObjIsActive(vm))\n        vm->persistent = 0;\n    else\n        virDomainObjListRemove(driver->domains, vm);\n\n    ret = 0;\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    vmwareDriverUnlock(driver);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "56-60",
          "snippet": "static void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListRemove",
          "args": [
            "driver->domains",
            "vm"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "401-413",
          "snippet": "void\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjIsActive",
          "args": [
            "vm"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.h",
          "lines": "2845-2849",
          "snippet": "static inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virresctrl.h\"",
            "#include \"virsavecookie.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virperf.h\"",
            "#include \"virgic.h\"",
            "#include \"virprocess.h\"",
            "#include \"virseclabel.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virbitmap.h\"",
            "#include \"device_conf.h\"",
            "#include \"virobject.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"numa_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virthread.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"capabilities.h\"",
            "#include \"virconftypes.h\"",
            "#include \"internal.h\"",
            "#include <libxml/xpath.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parser.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void virDomainMemoryDefFree(virDomainMemoryDefPtr def);",
            "void virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);",
            "unsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);",
            "unsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);",
            "bool virDomainDefHasMemoryHotplug(const virDomainDef *def);",
            "int virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);",
            "bool virDomainDefHasUSB(const virDomainDef *def);",
            "int virDomainObjCheckActive(virDomainObjPtr dom);",
            "bool virDomainDefHasVcpusOffline(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpusMax(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpus(const virDomainDef *def);",
            "virBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);",
            "void virDomainDefVcpuOrderClear(virDomainDefPtr def);",
            "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);",
            "void virDomainInputDefFree(virDomainInputDefPtr def);",
            "void virDomainDiskDefFree(virDomainDiskDefPtr def);",
            "void virDomainLeaseDefFree(virDomainLeaseDefPtr def);",
            "int virDomainDiskGetType(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetSource(virDomainDiskDef const *def);",
            "void virDomainDiskEmptySource(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetDriver(const virDomainDiskDef *def);",
            "int virDomainDiskGetFormat(virDomainDiskDefPtr def);",
            "void virDomainControllerDefFree(virDomainControllerDefPtr def);",
            "void virDomainFSDefFree(virDomainFSDefPtr def);",
            "void virDomainActualNetDefFree(virDomainActualNetDefPtr def);",
            "void virDomainNetDefClear(virDomainNetDefPtr def);",
            "void virDomainNetDefFree(virDomainNetDefPtr def);",
            "void virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);",
            "void virDomainChrDefFree(virDomainChrDefPtr def);",
            "void virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);",
            "void virDomainSoundDefFree(virDomainSoundDefPtr def);",
            "void virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);",
            "void virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);",
            "void virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);",
            "void virDomainVideoDefFree(virDomainVideoDefPtr def);",
            "void virDomainVideoDefClear(virDomainVideoDefPtr def);",
            "void virDomainHostdevDefClear(virDomainHostdevDefPtr def);",
            "void virDomainHostdevDefFree(virDomainHostdevDefPtr def);",
            "void virDomainHubDefFree(virDomainHubDefPtr def);",
            "void virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);",
            "void virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);",
            "void virDomainShmemDefFree(virDomainShmemDefPtr def);",
            "void virDomainDeviceDefFree(virDomainDeviceDefPtr def);",
            "void virDomainTPMDefFree(virDomainTPMDefPtr def);",
            "void virDomainRNGDefFree(virDomainRNGDefPtr def);",
            "int virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);",
            "int virDomainVideoDefaultType(const virDomainDef *def);",
            "void virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);",
            "int virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);",
            "bool\nvirDomainDefHasManagedPR(const virDomainDef *def);",
            "bool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);",
            "bool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);",
            "bool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virresctrl.h\"\n#include \"virsavecookie.h\"\n#include \"virtypedparam.h\"\n#include \"virperf.h\"\n#include \"virgic.h\"\n#include \"virprocess.h\"\n#include \"virseclabel.h\"\n#include \"virstoragefile.h\"\n#include \"virbitmap.h\"\n#include \"device_conf.h\"\n#include \"virobject.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevvlan.h\"\n#include \"virnetdevbandwidth.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virsysinfo.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"numa_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"networkcommon_conf.h\"\n#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virthread.h\"\n#include \"cpu_conf.h\"\n#include \"virstorageencryption.h\"\n#include \"capabilities.h\"\n#include \"virconftypes.h\"\n#include \"internal.h\"\n#include <libxml/xpath.h>\n#include <libxml/tree.h>\n#include <libxml/parser.h>\n\nvoid virDomainMemoryDefFree(virDomainMemoryDefPtr def);\nvoid virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);\nunsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);\nunsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);\nbool virDomainDefHasMemoryHotplug(const virDomainDef *def);\nint virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);\nbool virDomainDefHasUSB(const virDomainDef *def);\nint virDomainObjCheckActive(virDomainObjPtr dom);\nbool virDomainDefHasVcpusOffline(const virDomainDef *def);\nunsigned int virDomainDefGetVcpusMax(const virDomainDef *def);\nunsigned int virDomainDefGetVcpus(const virDomainDef *def);\nvirBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);\nvoid virDomainDefVcpuOrderClear(virDomainDefPtr def);\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);\nvoid virDomainInputDefFree(virDomainInputDefPtr def);\nvoid virDomainDiskDefFree(virDomainDiskDefPtr def);\nvoid virDomainLeaseDefFree(virDomainLeaseDefPtr def);\nint virDomainDiskGetType(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetSource(virDomainDiskDef const *def);\nvoid virDomainDiskEmptySource(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetDriver(const virDomainDiskDef *def);\nint virDomainDiskGetFormat(virDomainDiskDefPtr def);\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def);\nvoid virDomainFSDefFree(virDomainFSDefPtr def);\nvoid virDomainActualNetDefFree(virDomainActualNetDefPtr def);\nvoid virDomainNetDefClear(virDomainNetDefPtr def);\nvoid virDomainNetDefFree(virDomainNetDefPtr def);\nvoid virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);\nvoid virDomainChrDefFree(virDomainChrDefPtr def);\nvoid virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);\nvoid virDomainSoundDefFree(virDomainSoundDefPtr def);\nvoid virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);\nvoid virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);\nvoid virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def);\nvoid virDomainVideoDefClear(virDomainVideoDefPtr def);\nvoid virDomainHostdevDefClear(virDomainHostdevDefPtr def);\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def);\nvoid virDomainHubDefFree(virDomainHubDefPtr def);\nvoid virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);\nvoid virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);\nvoid virDomainShmemDefFree(virDomainShmemDefPtr def);\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def);\nvoid virDomainTPMDefFree(virDomainTPMDefPtr def);\nvoid virDomainRNGDefFree(virDomainRNGDefPtr def);\nint virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);\nint virDomainVideoDefaultType(const virDomainDef *def);\nvoid virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);\nint virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);\nbool\nvirDomainDefHasManagedPR(const virDomainDef *def);\nbool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);\nbool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);\nbool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);\n\nstatic inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareUpdateVMStatus",
          "args": [
            "driver",
            "vm"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareUpdateVMStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "282-339",
          "snippet": "static int\nvmwareUpdateVMStatus(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    virCommandPtr cmd;\n    char *outbuf = NULL;\n    char *vmxAbsolutePath = NULL;\n    char *parsedVmxPath = NULL;\n    char *str;\n    char *saveptr = NULL;\n    bool found = false;\n    int oldState = virDomainObjGetState(vm, NULL);\n    int newState;\n    int ret = -1;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virFileResolveAllLinks(((vmwareDomainPtr) vm->privateData)->vmxPath,\n                               &vmxAbsolutePath) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (parsedVmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n         str = NULL) {\n\n        if (parsedVmxPath[0] != '/')\n            continue;\n\n        if (STREQ(parsedVmxPath, vmxAbsolutePath)) {\n            found = true;\n            /* If the vmx path is in the output, the domain is running or\n             * is paused but we have no way to detect if it is paused or not. */\n            if (oldState == VIR_DOMAIN_PAUSED)\n                newState = oldState;\n            else\n                newState = VIR_DOMAIN_RUNNING;\n            break;\n        }\n    }\n\n    if (!found) {\n        vm->def->id = -1;\n        newState = VIR_DOMAIN_SHUTOFF;\n    }\n\n    virDomainObjSetState(vm, newState, 0);\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(vmxAbsolutePath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareUpdateVMStatus(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    virCommandPtr cmd;\n    char *outbuf = NULL;\n    char *vmxAbsolutePath = NULL;\n    char *parsedVmxPath = NULL;\n    char *str;\n    char *saveptr = NULL;\n    bool found = false;\n    int oldState = virDomainObjGetState(vm, NULL);\n    int newState;\n    int ret = -1;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virFileResolveAllLinks(((vmwareDomainPtr) vm->privateData)->vmxPath,\n                               &vmxAbsolutePath) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (parsedVmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n         str = NULL) {\n\n        if (parsedVmxPath[0] != '/')\n            continue;\n\n        if (STREQ(parsedVmxPath, vmxAbsolutePath)) {\n            found = true;\n            /* If the vmx path is in the output, the domain is running or\n             * is paused but we have no way to detect if it is paused or not. */\n            if (oldState == VIR_DOMAIN_PAUSED)\n                newState = oldState;\n            else\n                newState = VIR_DOMAIN_RUNNING;\n            break;\n        }\n    }\n\n    if (!found) {\n        vm->def->id = -1;\n        newState = VIR_DOMAIN_SHUTOFF;\n    }\n\n    virDomainObjSetState(vm, newState, 0);\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(vmxAbsolutePath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"cannot undefine transient domain\")"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot undefine transient domain\""
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomObjFromDomainLocked",
          "args": [
            "driver",
            "dom->uuid"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomObjFromDomainLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "63-79",
          "snippet": "static virDomainObjPtr\nvmwareDomObjFromDomainLocked(struct vmware_driver *driver,\n                             const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (!(vm = virDomainObjListFindByUUID(driver->domains, uuid))) {\n        virUUIDFormat(uuid, uuidstr);\n\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching uuid '%s'\"), uuidstr);\n        return NULL;\n    }\n\n    return vm;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainObjPtr\nvmwareDomObjFromDomainLocked(struct vmware_driver *driver,\n                             const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (!(vm = virDomainObjListFindByUUID(driver->domains, uuid))) {\n        virUUIDFormat(uuid, uuidstr);\n\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching uuid '%s'\"), uuidstr);\n        return NULL;\n    }\n\n    return vm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverLock",
          "args": [
            "driver"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "50-54",
          "snippet": "static void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainUndefineFlags(virDomainPtr dom,\n                          unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    vmwareDriverLock(driver);\n    if (!(vm = vmwareDomObjFromDomainLocked(driver, dom->uuid)))\n        goto cleanup;\n\n    if (!vm->persistent) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"cannot undefine transient domain\"));\n        goto cleanup;\n    }\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    if (virDomainObjIsActive(vm))\n        vm->persistent = 0;\n    else\n        virDomainObjListRemove(driver->domains, vm);\n\n    ret = 0;\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    vmwareDriverUnlock(driver);\n    return ret;\n}"
  },
  {
    "function_name": "vmwareDomainCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "768-772",
    "snippet": "static int\nvmwareDomainCreate(virDomainPtr dom)\n{\n    return vmwareDomainCreateWithFlags(dom, 0);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareDomainCreateWithFlags",
          "args": [
            "dom",
            "0"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomainCreateWithFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "737-766",
          "snippet": "static int\nvmwareDomainCreateWithFlags(virDomainPtr dom,\n                            unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    vmwareDriverLock(driver);\n    if (!(vm = vmwareDomObjFromDomainLocked(driver, dom->uuid)))\n        goto cleanup;\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    if (virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"Domain is already running\"));\n        goto cleanup;\n    }\n\n    ret = vmwareStartVM(driver, vm);\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    vmwareDriverUnlock(driver);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainCreateWithFlags(virDomainPtr dom,\n                            unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    vmwareDriverLock(driver);\n    if (!(vm = vmwareDomObjFromDomainLocked(driver, dom->uuid)))\n        goto cleanup;\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    if (virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"Domain is already running\"));\n        goto cleanup;\n    }\n\n    ret = vmwareStartVM(driver, vm);\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    vmwareDriverUnlock(driver);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainCreate(virDomainPtr dom)\n{\n    return vmwareDomainCreateWithFlags(dom, 0);\n}"
  },
  {
    "function_name": "vmwareDomainCreateWithFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "737-766",
    "snippet": "static int\nvmwareDomainCreateWithFlags(virDomainPtr dom,\n                            unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    vmwareDriverLock(driver);\n    if (!(vm = vmwareDomObjFromDomainLocked(driver, dom->uuid)))\n        goto cleanup;\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    if (virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"Domain is already running\"));\n        goto cleanup;\n    }\n\n    ret = vmwareStartVM(driver, vm);\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    vmwareDriverUnlock(driver);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "56-60",
          "snippet": "static void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareStartVM",
          "args": [
            "driver",
            "vm"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareStartVM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "363-396",
          "snippet": "static int\nvmwareStartVM(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    const char *cmd[] = {\n        driver->vmrun, \"-T\", PROGRAM_SENTINEL, \"start\",\n        PROGRAM_SENTINEL, PROGRAM_SENTINEL, NULL\n    };\n    const char *vmxPath = ((vmwareDomainPtr) vm->privateData)->vmxPath;\n\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_SHUTOFF) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"domain is not in shutoff state\"));\n        return -1;\n    }\n\n    vmwareSetSentinal(cmd, vmwareDriverTypeToString(driver->type));\n    vmwareSetSentinal(cmd, vmxPath);\n    if (!((vmwareDomainPtr) vm->privateData)->gui)\n        vmwareSetSentinal(cmd, NOGUI);\n    else\n        vmwareSetSentinal(cmd, NULL);\n\n    if (virRun(cmd, NULL) < 0)\n        return -1;\n\n    if ((vm->def->id = vmwareExtractPid(vmxPath)) < 0) {\n        vmwareStopVM(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED);\n        return -1;\n    }\n\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, VIR_DOMAIN_RUNNING_BOOTED);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareStartVM(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    const char *cmd[] = {\n        driver->vmrun, \"-T\", PROGRAM_SENTINEL, \"start\",\n        PROGRAM_SENTINEL, PROGRAM_SENTINEL, NULL\n    };\n    const char *vmxPath = ((vmwareDomainPtr) vm->privateData)->vmxPath;\n\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_SHUTOFF) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"domain is not in shutoff state\"));\n        return -1;\n    }\n\n    vmwareSetSentinal(cmd, vmwareDriverTypeToString(driver->type));\n    vmwareSetSentinal(cmd, vmxPath);\n    if (!((vmwareDomainPtr) vm->privateData)->gui)\n        vmwareSetSentinal(cmd, NOGUI);\n    else\n        vmwareSetSentinal(cmd, NULL);\n\n    if (virRun(cmd, NULL) < 0)\n        return -1;\n\n    if ((vm->def->id = vmwareExtractPid(vmxPath)) < 0) {\n        vmwareStopVM(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED);\n        return -1;\n    }\n\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, VIR_DOMAIN_RUNNING_BOOTED);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Domain is already running\")"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Domain is already running\""
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjIsActive",
          "args": [
            "vm"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.h",
          "lines": "2845-2849",
          "snippet": "static inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virresctrl.h\"",
            "#include \"virsavecookie.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virperf.h\"",
            "#include \"virgic.h\"",
            "#include \"virprocess.h\"",
            "#include \"virseclabel.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virbitmap.h\"",
            "#include \"device_conf.h\"",
            "#include \"virobject.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"numa_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virthread.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"capabilities.h\"",
            "#include \"virconftypes.h\"",
            "#include \"internal.h\"",
            "#include <libxml/xpath.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parser.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void virDomainMemoryDefFree(virDomainMemoryDefPtr def);",
            "void virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);",
            "unsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);",
            "unsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);",
            "bool virDomainDefHasMemoryHotplug(const virDomainDef *def);",
            "int virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);",
            "bool virDomainDefHasUSB(const virDomainDef *def);",
            "int virDomainObjCheckActive(virDomainObjPtr dom);",
            "bool virDomainDefHasVcpusOffline(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpusMax(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpus(const virDomainDef *def);",
            "virBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);",
            "void virDomainDefVcpuOrderClear(virDomainDefPtr def);",
            "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);",
            "void virDomainInputDefFree(virDomainInputDefPtr def);",
            "void virDomainDiskDefFree(virDomainDiskDefPtr def);",
            "void virDomainLeaseDefFree(virDomainLeaseDefPtr def);",
            "int virDomainDiskGetType(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetSource(virDomainDiskDef const *def);",
            "void virDomainDiskEmptySource(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetDriver(const virDomainDiskDef *def);",
            "int virDomainDiskGetFormat(virDomainDiskDefPtr def);",
            "void virDomainControllerDefFree(virDomainControllerDefPtr def);",
            "void virDomainFSDefFree(virDomainFSDefPtr def);",
            "void virDomainActualNetDefFree(virDomainActualNetDefPtr def);",
            "void virDomainNetDefClear(virDomainNetDefPtr def);",
            "void virDomainNetDefFree(virDomainNetDefPtr def);",
            "void virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);",
            "void virDomainChrDefFree(virDomainChrDefPtr def);",
            "void virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);",
            "void virDomainSoundDefFree(virDomainSoundDefPtr def);",
            "void virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);",
            "void virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);",
            "void virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);",
            "void virDomainVideoDefFree(virDomainVideoDefPtr def);",
            "void virDomainVideoDefClear(virDomainVideoDefPtr def);",
            "void virDomainHostdevDefClear(virDomainHostdevDefPtr def);",
            "void virDomainHostdevDefFree(virDomainHostdevDefPtr def);",
            "void virDomainHubDefFree(virDomainHubDefPtr def);",
            "void virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);",
            "void virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);",
            "void virDomainShmemDefFree(virDomainShmemDefPtr def);",
            "void virDomainDeviceDefFree(virDomainDeviceDefPtr def);",
            "void virDomainTPMDefFree(virDomainTPMDefPtr def);",
            "void virDomainRNGDefFree(virDomainRNGDefPtr def);",
            "int virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);",
            "int virDomainVideoDefaultType(const virDomainDef *def);",
            "void virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);",
            "int virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);",
            "bool\nvirDomainDefHasManagedPR(const virDomainDef *def);",
            "bool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);",
            "bool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);",
            "bool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virresctrl.h\"\n#include \"virsavecookie.h\"\n#include \"virtypedparam.h\"\n#include \"virperf.h\"\n#include \"virgic.h\"\n#include \"virprocess.h\"\n#include \"virseclabel.h\"\n#include \"virstoragefile.h\"\n#include \"virbitmap.h\"\n#include \"device_conf.h\"\n#include \"virobject.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevvlan.h\"\n#include \"virnetdevbandwidth.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virsysinfo.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"numa_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"networkcommon_conf.h\"\n#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virthread.h\"\n#include \"cpu_conf.h\"\n#include \"virstorageencryption.h\"\n#include \"capabilities.h\"\n#include \"virconftypes.h\"\n#include \"internal.h\"\n#include <libxml/xpath.h>\n#include <libxml/tree.h>\n#include <libxml/parser.h>\n\nvoid virDomainMemoryDefFree(virDomainMemoryDefPtr def);\nvoid virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);\nunsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);\nunsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);\nbool virDomainDefHasMemoryHotplug(const virDomainDef *def);\nint virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);\nbool virDomainDefHasUSB(const virDomainDef *def);\nint virDomainObjCheckActive(virDomainObjPtr dom);\nbool virDomainDefHasVcpusOffline(const virDomainDef *def);\nunsigned int virDomainDefGetVcpusMax(const virDomainDef *def);\nunsigned int virDomainDefGetVcpus(const virDomainDef *def);\nvirBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);\nvoid virDomainDefVcpuOrderClear(virDomainDefPtr def);\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);\nvoid virDomainInputDefFree(virDomainInputDefPtr def);\nvoid virDomainDiskDefFree(virDomainDiskDefPtr def);\nvoid virDomainLeaseDefFree(virDomainLeaseDefPtr def);\nint virDomainDiskGetType(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetSource(virDomainDiskDef const *def);\nvoid virDomainDiskEmptySource(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetDriver(const virDomainDiskDef *def);\nint virDomainDiskGetFormat(virDomainDiskDefPtr def);\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def);\nvoid virDomainFSDefFree(virDomainFSDefPtr def);\nvoid virDomainActualNetDefFree(virDomainActualNetDefPtr def);\nvoid virDomainNetDefClear(virDomainNetDefPtr def);\nvoid virDomainNetDefFree(virDomainNetDefPtr def);\nvoid virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);\nvoid virDomainChrDefFree(virDomainChrDefPtr def);\nvoid virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);\nvoid virDomainSoundDefFree(virDomainSoundDefPtr def);\nvoid virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);\nvoid virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);\nvoid virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def);\nvoid virDomainVideoDefClear(virDomainVideoDefPtr def);\nvoid virDomainHostdevDefClear(virDomainHostdevDefPtr def);\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def);\nvoid virDomainHubDefFree(virDomainHubDefPtr def);\nvoid virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);\nvoid virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);\nvoid virDomainShmemDefFree(virDomainShmemDefPtr def);\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def);\nvoid virDomainTPMDefFree(virDomainTPMDefPtr def);\nvoid virDomainRNGDefFree(virDomainRNGDefPtr def);\nint virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);\nint virDomainVideoDefaultType(const virDomainDef *def);\nvoid virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);\nint virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);\nbool\nvirDomainDefHasManagedPR(const virDomainDef *def);\nbool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);\nbool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);\nbool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);\n\nstatic inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareUpdateVMStatus",
          "args": [
            "driver",
            "vm"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareUpdateVMStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "282-339",
          "snippet": "static int\nvmwareUpdateVMStatus(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    virCommandPtr cmd;\n    char *outbuf = NULL;\n    char *vmxAbsolutePath = NULL;\n    char *parsedVmxPath = NULL;\n    char *str;\n    char *saveptr = NULL;\n    bool found = false;\n    int oldState = virDomainObjGetState(vm, NULL);\n    int newState;\n    int ret = -1;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virFileResolveAllLinks(((vmwareDomainPtr) vm->privateData)->vmxPath,\n                               &vmxAbsolutePath) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (parsedVmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n         str = NULL) {\n\n        if (parsedVmxPath[0] != '/')\n            continue;\n\n        if (STREQ(parsedVmxPath, vmxAbsolutePath)) {\n            found = true;\n            /* If the vmx path is in the output, the domain is running or\n             * is paused but we have no way to detect if it is paused or not. */\n            if (oldState == VIR_DOMAIN_PAUSED)\n                newState = oldState;\n            else\n                newState = VIR_DOMAIN_RUNNING;\n            break;\n        }\n    }\n\n    if (!found) {\n        vm->def->id = -1;\n        newState = VIR_DOMAIN_SHUTOFF;\n    }\n\n    virDomainObjSetState(vm, newState, 0);\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(vmxAbsolutePath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareUpdateVMStatus(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    virCommandPtr cmd;\n    char *outbuf = NULL;\n    char *vmxAbsolutePath = NULL;\n    char *parsedVmxPath = NULL;\n    char *str;\n    char *saveptr = NULL;\n    bool found = false;\n    int oldState = virDomainObjGetState(vm, NULL);\n    int newState;\n    int ret = -1;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virFileResolveAllLinks(((vmwareDomainPtr) vm->privateData)->vmxPath,\n                               &vmxAbsolutePath) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (parsedVmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n         str = NULL) {\n\n        if (parsedVmxPath[0] != '/')\n            continue;\n\n        if (STREQ(parsedVmxPath, vmxAbsolutePath)) {\n            found = true;\n            /* If the vmx path is in the output, the domain is running or\n             * is paused but we have no way to detect if it is paused or not. */\n            if (oldState == VIR_DOMAIN_PAUSED)\n                newState = oldState;\n            else\n                newState = VIR_DOMAIN_RUNNING;\n            break;\n        }\n    }\n\n    if (!found) {\n        vm->def->id = -1;\n        newState = VIR_DOMAIN_SHUTOFF;\n    }\n\n    virDomainObjSetState(vm, newState, 0);\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(vmxAbsolutePath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomObjFromDomainLocked",
          "args": [
            "driver",
            "dom->uuid"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomObjFromDomainLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "63-79",
          "snippet": "static virDomainObjPtr\nvmwareDomObjFromDomainLocked(struct vmware_driver *driver,\n                             const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (!(vm = virDomainObjListFindByUUID(driver->domains, uuid))) {\n        virUUIDFormat(uuid, uuidstr);\n\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching uuid '%s'\"), uuidstr);\n        return NULL;\n    }\n\n    return vm;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainObjPtr\nvmwareDomObjFromDomainLocked(struct vmware_driver *driver,\n                             const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (!(vm = virDomainObjListFindByUUID(driver->domains, uuid))) {\n        virUUIDFormat(uuid, uuidstr);\n\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching uuid '%s'\"), uuidstr);\n        return NULL;\n    }\n\n    return vm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverLock",
          "args": [
            "driver"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "50-54",
          "snippet": "static void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainCreateWithFlags(virDomainPtr dom,\n                            unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    vmwareDriverLock(driver);\n    if (!(vm = vmwareDomObjFromDomainLocked(driver, dom->uuid)))\n        goto cleanup;\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    if (virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"Domain is already running\"));\n        goto cleanup;\n    }\n\n    ret = vmwareStartVM(driver, vm);\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    vmwareDriverUnlock(driver);\n    return ret;\n}"
  },
  {
    "function_name": "vmwareDomainCreateXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "660-735",
    "snippet": "static virDomainPtr\nvmwareDomainCreateXML(virConnectPtr conn, const char *xml,\n                      unsigned int flags)\n{\n    struct vmware_driver *driver = conn->privateData;\n    virDomainDefPtr vmdef = NULL;\n    virDomainObjPtr vm = NULL;\n    virDomainPtr dom = NULL;\n    char *vmx = NULL;\n    char *vmxPath = NULL;\n    vmwareDomainPtr pDomain = NULL;\n    virVMXContext ctx;\n    unsigned int parse_flags = VIR_DOMAIN_DEF_PARSE_INACTIVE;\n\n    virCheckFlags(VIR_DOMAIN_START_VALIDATE, NULL);\n\n    if (flags & VIR_DOMAIN_START_VALIDATE)\n        parse_flags |= VIR_DOMAIN_DEF_PARSE_VALIDATE_SCHEMA;\n\n    ctx.parseFileName = NULL;\n    ctx.formatFileName = vmwareCopyVMXFileName;\n    ctx.autodetectSCSIControllerModel = NULL;\n    ctx.datacenterPath = NULL;\n\n    vmwareDriverLock(driver);\n\n    if ((vmdef = virDomainDefParseString(xml, driver->xmlopt,\n                                         NULL, parse_flags)) == NULL)\n        goto cleanup;\n\n    /* generate vmx file */\n    vmx = virVMXFormatConfig(&ctx, driver->xmlopt, vmdef, 7);\n    if (vmx == NULL)\n        goto cleanup;\n\n    if (vmwareVmxPath(vmdef, &vmxPath) < 0)\n        goto cleanup;\n\n    /* create vmx file */\n    if (virFileWriteStr(vmxPath, vmx, S_IRUSR|S_IWUSR) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to write vmx file '%s'\"), vmxPath);\n        goto cleanup;\n    }\n\n    /* assign def */\n    if (!(vm = virDomainObjListAdd(driver->domains,\n                                   vmdef,\n                                   driver->xmlopt,\n                                   VIR_DOMAIN_OBJ_LIST_ADD_LIVE |\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE,\n                                   NULL)))\n        goto cleanup;\n\n    pDomain = vm->privateData;\n    pDomain->vmxPath = g_strdup(vmxPath);\n\n    vmwareDomainConfigDisplay(pDomain, vmdef);\n    vmdef = NULL;\n\n    if (vmwareStartVM(driver, vm) < 0) {\n        if (!vm->persistent)\n            virDomainObjListRemove(driver->domains, vm);\n        goto cleanup;\n    }\n\n    dom = virGetDomain(conn, vm->def->name, vm->def->uuid, vm->def->id);\n\n cleanup:\n    virDomainDefFree(vmdef);\n    VIR_FREE(vmx);\n    VIR_FREE(vmxPath);\n    virDomainObjEndAPI(&vm);\n    vmwareDriverUnlock(driver);\n    return dom;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "56-60",
          "snippet": "static void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vmxPath"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vmx"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "vmdef"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetDomain",
          "args": [
            "conn",
            "vm->def->name",
            "vm->def->uuid",
            "vm->def->id"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "275-304",
          "snippet": "virDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainClass;\n\nvirDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListRemove",
          "args": [
            "driver->domains",
            "vm"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "401-413",
          "snippet": "void\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareStartVM",
          "args": [
            "driver",
            "vm"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareStartVM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "363-396",
          "snippet": "static int\nvmwareStartVM(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    const char *cmd[] = {\n        driver->vmrun, \"-T\", PROGRAM_SENTINEL, \"start\",\n        PROGRAM_SENTINEL, PROGRAM_SENTINEL, NULL\n    };\n    const char *vmxPath = ((vmwareDomainPtr) vm->privateData)->vmxPath;\n\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_SHUTOFF) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"domain is not in shutoff state\"));\n        return -1;\n    }\n\n    vmwareSetSentinal(cmd, vmwareDriverTypeToString(driver->type));\n    vmwareSetSentinal(cmd, vmxPath);\n    if (!((vmwareDomainPtr) vm->privateData)->gui)\n        vmwareSetSentinal(cmd, NOGUI);\n    else\n        vmwareSetSentinal(cmd, NULL);\n\n    if (virRun(cmd, NULL) < 0)\n        return -1;\n\n    if ((vm->def->id = vmwareExtractPid(vmxPath)) < 0) {\n        vmwareStopVM(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED);\n        return -1;\n    }\n\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, VIR_DOMAIN_RUNNING_BOOTED);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareStartVM(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    const char *cmd[] = {\n        driver->vmrun, \"-T\", PROGRAM_SENTINEL, \"start\",\n        PROGRAM_SENTINEL, PROGRAM_SENTINEL, NULL\n    };\n    const char *vmxPath = ((vmwareDomainPtr) vm->privateData)->vmxPath;\n\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_SHUTOFF) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"domain is not in shutoff state\"));\n        return -1;\n    }\n\n    vmwareSetSentinal(cmd, vmwareDriverTypeToString(driver->type));\n    vmwareSetSentinal(cmd, vmxPath);\n    if (!((vmwareDomainPtr) vm->privateData)->gui)\n        vmwareSetSentinal(cmd, NOGUI);\n    else\n        vmwareSetSentinal(cmd, NULL);\n\n    if (virRun(cmd, NULL) < 0)\n        return -1;\n\n    if ((vm->def->id = vmwareExtractPid(vmxPath)) < 0) {\n        vmwareStopVM(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED);\n        return -1;\n    }\n\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, VIR_DOMAIN_RUNNING_BOOTED);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomainConfigDisplay",
          "args": [
            "pDomain",
            "vmdef"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomainConfigDisplay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "314-332",
          "snippet": "int\nvmwareDomainConfigDisplay(vmwareDomainPtr pDomain, virDomainDefPtr def)\n{\n    size_t i;\n\n    if (def->ngraphics == 0) {\n        pDomain->gui = true;\n        return 0;\n    } else {\n        pDomain->gui = false;\n        for (i = 0; i < def->ngraphics; i++) {\n            if (def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP) {\n                pDomain->gui = true;\n                return 0;\n            }\n        }\n        return 0;\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nint\nvmwareDomainConfigDisplay(vmwareDomainPtr pDomain, virDomainDefPtr def)\n{\n    size_t i;\n\n    if (def->ngraphics == 0) {\n        pDomain->gui = true;\n        return 0;\n    } else {\n        pDomain->gui = false;\n        for (i = 0; i < def->ngraphics; i++) {\n            if (def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP) {\n                pDomain->gui = true;\n                return 0;\n            }\n        }\n        return 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "vmxPath"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListAdd",
          "args": [
            "driver->domains",
            "vmdef",
            "driver->xmlopt",
            "VIR_DOMAIN_OBJ_LIST_ADD_LIVE |\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE",
            "NULL"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "354-366",
          "snippet": "virDomainObjPtr virDomainObjListAdd(virDomainObjListPtr doms,\n                                    virDomainDefPtr def,\n                                    virDomainXMLOptionPtr xmlopt,\n                                    unsigned int flags,\n                                    virDomainDefPtr *oldDef)\n{\n    virDomainObjPtr ret;\n\n    virObjectRWLockWrite(doms);\n    ret = virDomainObjListAddLocked(doms, def, xmlopt, flags, oldDef);\n    virObjectRWUnlock(doms);\n    return ret;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirDomainObjPtr virDomainObjListAdd(virDomainObjListPtr doms,\n                                    virDomainDefPtr def,\n                                    virDomainXMLOptionPtr xmlopt,\n                                    unsigned int flags,\n                                    virDomainDefPtr *oldDef)\n{\n    virDomainObjPtr ret;\n\n    virObjectRWLockWrite(doms);\n    ret = virDomainObjListAddLocked(doms, def, xmlopt, flags, oldDef);\n    virObjectRWUnlock(doms);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to write vmx file '%s'\")",
            "vmxPath"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileWriteStr",
          "args": [
            "vmxPath",
            "vmx",
            "S_IRUSR|S_IWUSR"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "virFileWriteStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1502-1524",
          "snippet": "int\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareVmxPath",
          "args": [
            "vmdef",
            "&vmxPath"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareVmxPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "369-434",
          "snippet": "int\nvmwareVmxPath(virDomainDefPtr vmdef, char **vmxPath)\n{\n    virDomainDiskDefPtr disk = NULL;\n    char *directoryName = NULL;\n    char *fileName = NULL;\n    int ret = -1;\n    size_t i;\n    const char *src;\n\n    /*\n     * Build VMX URL. Use the source of the first file-based harddisk\n     * to deduce the path for the VMX file. Don't just use the\n     * first disk, because it may be CDROM disk and ISO images are normally not\n     * located in the virtual machine's directory. This approach\n     * isn't perfect but should work in the majority of cases.\n     */\n    if (vmdef->ndisks < 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any disks, \"\n                         \"cannot deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < vmdef->ndisks; ++i) {\n        if (vmdef->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_DISK &&\n            virDomainDiskGetType(vmdef->disks[i]) == VIR_STORAGE_TYPE_FILE) {\n            disk = vmdef->disks[i];\n            break;\n        }\n    }\n\n    if (disk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any file-based harddisks, \"\n                         \"cannot deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    src = virDomainDiskGetSource(disk);\n    if (!src) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"First file-based harddisk has no source, cannot \"\n                         \"deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    if (vmwareParsePath(src, &directoryName, &fileName) < 0)\n        goto cleanup;\n\n    if (!virStringHasCaseSuffix(fileName, \".vmdk\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting source '%s' of first file-based harddisk \"\n                         \"to be a VMDK image\"), src);\n        goto cleanup;\n    }\n\n    vmwareConstructVmxPath(directoryName, vmdef->name, vmxPath);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(directoryName);\n    VIR_FREE(fileName);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nint\nvmwareVmxPath(virDomainDefPtr vmdef, char **vmxPath)\n{\n    virDomainDiskDefPtr disk = NULL;\n    char *directoryName = NULL;\n    char *fileName = NULL;\n    int ret = -1;\n    size_t i;\n    const char *src;\n\n    /*\n     * Build VMX URL. Use the source of the first file-based harddisk\n     * to deduce the path for the VMX file. Don't just use the\n     * first disk, because it may be CDROM disk and ISO images are normally not\n     * located in the virtual machine's directory. This approach\n     * isn't perfect but should work in the majority of cases.\n     */\n    if (vmdef->ndisks < 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any disks, \"\n                         \"cannot deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < vmdef->ndisks; ++i) {\n        if (vmdef->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_DISK &&\n            virDomainDiskGetType(vmdef->disks[i]) == VIR_STORAGE_TYPE_FILE) {\n            disk = vmdef->disks[i];\n            break;\n        }\n    }\n\n    if (disk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any file-based harddisks, \"\n                         \"cannot deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    src = virDomainDiskGetSource(disk);\n    if (!src) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"First file-based harddisk has no source, cannot \"\n                         \"deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    if (vmwareParsePath(src, &directoryName, &fileName) < 0)\n        goto cleanup;\n\n    if (!virStringHasCaseSuffix(fileName, \".vmdk\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting source '%s' of first file-based harddisk \"\n                         \"to be a VMDK image\"), src);\n        goto cleanup;\n    }\n\n    vmwareConstructVmxPath(directoryName, vmdef->name, vmxPath);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(directoryName);\n    VIR_FREE(fileName);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXFormatConfig",
          "args": [
            "&ctx",
            "driver->xmlopt",
            "vmdef",
            "7"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXFormatConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "3052-3453",
          "snippet": "char *\nvirVMXFormatConfig(virVMXContext *ctx, virDomainXMLOptionPtr xmlopt, virDomainDefPtr def,\n                   int virtualHW_version)\n{\n    char *vmx = NULL;\n    size_t i;\n    int sched_cpu_affinity_length;\n    unsigned char zero[VIR_UUID_BUFLEN];\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *preliminaryDisplayName = NULL;\n    char *displayName = NULL;\n    char *annotation = NULL;\n    unsigned long long max_balloon;\n    bool scsi_present[4] = { false, false, false, false };\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    bool floppy_present[2] = { false, false };\n    unsigned int maxvcpus;\n    bool hasSCSI = false;\n\n    if (ctx->formatFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no formatFileName function set\"));\n        return NULL;\n    }\n\n    memset(zero, 0, VIR_UUID_BUFLEN);\n\n    if (def->virtType != VIR_DOMAIN_VIRT_VMWARE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting virt type to be '%s' but found '%s'\"),\n                       virDomainVirtTypeToString(VIR_DOMAIN_VIRT_VMWARE),\n                       virDomainVirtTypeToString(def->virtType));\n        return NULL;\n    }\n\n    /* vmx:.encoding */\n    virBufferAddLit(&buffer, \".encoding = \\\"UTF-8\\\"\\n\");\n\n    /* vmx:config.version */\n    virBufferAddLit(&buffer, \"config.version = \\\"8\\\"\\n\");\n\n    /* vmx:virtualHW.version */\n    virBufferAsprintf(&buffer, \"virtualHW.version = \\\"%d\\\"\\n\",\n                      virtualHW_version);\n\n    /* def:os.arch -> vmx:guestOS */\n    if (def->os.arch == VIR_ARCH_I686) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other\\\"\\n\");\n    } else if (def->os.arch == VIR_ARCH_X86_64) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other-64\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting domain XML attribute 'arch' of entry 'os/type' \"\n                         \"to be 'i686' or 'x86_64' but found '%s'\"),\n                       virArchToString(def->os.arch));\n        goto cleanup;\n    }\n\n    /* def:os.smbios_mode -> vmx:smbios.reflecthost */\n    if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_NONE ||\n        def->os.smbios_mode == VIR_DOMAIN_SMBIOS_EMULATE) {\n        /* nothing */\n    } else if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_HOST) {\n        virBufferAddLit(&buffer, \"smbios.reflecthost = \\\"true\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported SMBIOS mode '%s'\"),\n                       virDomainSmbiosModeTypeToString(def->os.smbios_mode));\n        goto cleanup;\n    }\n\n    /* def:uuid -> vmx:uuid.action, vmx:uuid.bios */\n    if (memcmp(def->uuid, zero, VIR_UUID_BUFLEN) == 0) {\n        virBufferAddLit(&buffer, \"uuid.action = \\\"create\\\"\\n\");\n    } else {\n        virBufferAsprintf(&buffer, \"uuid.bios = \\\"%02x %02x %02x %02x %02x %02x \"\n                          \"%02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\\\"\\n\",\n                          def->uuid[0], def->uuid[1], def->uuid[2], def->uuid[3],\n                          def->uuid[4], def->uuid[5], def->uuid[6], def->uuid[7],\n                          def->uuid[8], def->uuid[9], def->uuid[10], def->uuid[11],\n                          def->uuid[12], def->uuid[13], def->uuid[14],\n                          def->uuid[15]);\n    }\n\n    /* def:name -> vmx:displayName */\n    preliminaryDisplayName = virVMXEscapeHexPipe(def->name);\n\n    if (preliminaryDisplayName == NULL)\n        goto cleanup;\n\n    displayName = virVMXEscapeHexPercent(preliminaryDisplayName);\n\n    if (displayName == NULL)\n        goto cleanup;\n\n    virBufferAsprintf(&buffer, \"displayName = \\\"%s\\\"\\n\", displayName);\n\n    /* def:description -> vmx:annotation */\n    if (def->description != NULL) {\n        if (!(annotation = virVMXEscapeHexPipe(def->description)))\n            goto cleanup;\n\n        virBufferAsprintf(&buffer, \"annotation = \\\"%s\\\"\\n\", annotation);\n    }\n\n    /* def:mem.max_balloon -> vmx:memsize */\n    /* max-memory must be a multiple of 4096 kilobyte */\n    max_balloon = VIR_DIV_UP(virDomainDefGetMemoryTotal(def), 4096) * 4096;\n\n    virBufferAsprintf(&buffer, \"memsize = \\\"%llu\\\"\\n\",\n                      max_balloon / 1024); /* Scale from kilobytes to megabytes */\n\n    /* def:mem.cur_balloon -> vmx:sched.mem.max */\n    if (def->mem.cur_balloon < max_balloon) {\n        virBufferAsprintf(&buffer, \"sched.mem.max = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.cur_balloon,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:mem.min_guarantee -> vmx:sched.mem.minsize */\n    if (def->mem.min_guarantee > 0) {\n        virBufferAsprintf(&buffer, \"sched.mem.minsize = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.min_guarantee,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:maxvcpus -> vmx:numvcpus */\n    if (virDomainDefHasVcpusOffline(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"No support for domain XML entry 'vcpu' attribute \"\n                         \"'current'\"));\n        goto cleanup;\n    }\n    maxvcpus = virDomainDefGetVcpusMax(def);\n    if (maxvcpus == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML entry 'vcpu' to be greater \"\n                         \"than 0\"));\n        goto cleanup;\n    }\n\n    virBufferAsprintf(&buffer, \"numvcpus = \\\"%d\\\"\\n\", maxvcpus);\n\n    if (def->cpu) {\n        unsigned int calculated_vcpus;\n\n        if (def->cpu->mode != VIR_CPU_MODE_CUSTOM) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU mode 'custom' but \"\n                             \"found '%s'\"),\n                           virCPUModeTypeToString(def->cpu->mode));\n            goto cleanup;\n        }\n\n        if (def->cpu->threads != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 thread per core is supported\"));\n            goto cleanup;\n        }\n\n        if (def->cpu->dies != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 die per socket is supported\"));\n            goto cleanup;\n        }\n\n        calculated_vcpus = def->cpu->sockets * def->cpu->cores;\n        if (calculated_vcpus != maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU sockets per core as %d \"\n                             \"but found %d\"),\n                           maxvcpus, calculated_vcpus);\n            goto cleanup;\n        }\n\n        virBufferAsprintf(&buffer, \"cpuid.coresPerSocket = \\\"%d\\\"\\n\", def->cpu->cores);\n    }\n\n    /* def:cpumask -> vmx:sched.cpu.affinity */\n    if (def->cpumask && virBitmapSize(def->cpumask) > 0) {\n        int bit;\n        virBufferAddLit(&buffer, \"sched.cpu.affinity = \\\"\");\n\n        sched_cpu_affinity_length = 0;\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0)\n            ++sched_cpu_affinity_length;\n\n        if (sched_cpu_affinity_length < maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML attribute 'cpuset' of entry \"\n                             \"'vcpu' to contain at least %d CPU(s)\"),\n                           maxvcpus);\n            goto cleanup;\n        }\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0) {\n            virBufferAsprintf(&buffer, \"%d\", bit);\n\n            if (sched_cpu_affinity_length > 1)\n                virBufferAddChar(&buffer, ',');\n\n            --sched_cpu_affinity_length;\n        }\n\n        virBufferAddLit(&buffer, \"\\\"\\n\");\n    }\n\n    /* def:cputune.shares -> vmx:sched.cpu.shares */\n    if (def->cputune.sharesSpecified) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (def->cputune.shares == vcpus * 500) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"low\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 1000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"normal\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 2000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"high\\\"\\n\");\n        } else {\n            virBufferAsprintf(&buffer, \"sched.cpu.shares = \\\"%llu\\\"\\n\",\n                              def->cputune.shares);\n        }\n    }\n\n    /* def:graphics */\n    for (i = 0; i < def->ngraphics; ++i) {\n        switch (def->graphics[i]->type) {\n          case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n            if (virVMXFormatVNC(def->graphics[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n          case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n          case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported graphics type '%s'\"),\n                           virDomainGraphicsTypeToString(def->graphics[i]->type));\n            goto cleanup;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n          default:\n              virReportEnumRangeError(virDomainGraphicsType, def->graphics[i]->type);\n              goto cleanup;\n        }\n    }\n\n    /* def:disks */\n    for (i = 0; i < def->ndisks; ++i) {\n        if (virVMXVerifyDiskAddress(xmlopt, def->disks[i], def) < 0 ||\n            virVMXHandleLegacySCSIDiskDriverName(def, def->disks[i]) < 0) {\n            goto cleanup;\n        }\n    }\n\n    if (virVMXGatherSCSIControllers(ctx, def, scsi_virtualDev,\n                                    scsi_present) < 0) {\n        goto cleanup;\n    }\n\n    for (i = 0; i < 4; ++i) {\n        if (scsi_present[i]) {\n            hasSCSI = true;\n\n            virBufferAsprintf(&buffer, \"scsi%zu.present = \\\"true\\\"\\n\", i);\n\n            if (scsi_virtualDev[i] != -1) {\n                virBufferAsprintf(&buffer, \"scsi%zu.virtualDev = \\\"%s\\\"\\n\", i,\n                                  virVMXControllerModelSCSITypeToString\n                                    (scsi_virtualDev[i]));\n            }\n        }\n    }\n\n    for (i = 0; i < def->ndisks; ++i) {\n        switch (def->disks[i]->device) {\n          case VIR_DOMAIN_DISK_DEVICE_DISK:\n          case VIR_DOMAIN_DISK_DEVICE_CDROM:\n          case VIR_DOMAIN_DISK_DEVICE_LUN:\n            if (virVMXFormatDisk(ctx, def->disks[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_DISK_DEVICE_FLOPPY:\n            if (virVMXFormatFloppy(ctx, def->disks[i], &buffer,\n                                   floppy_present) < 0) {\n                goto cleanup;\n            }\n\n            break;\n\n          default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported disk device type '%s'\"),\n                           virDomainDiskDeviceTypeToString(def->disks[i]->device));\n            goto cleanup;\n        }\n    }\n\n    for (i = 0; i < 2; ++i) {\n        /* floppy[0..1].present defaults to true, disable it explicitly */\n        if (! floppy_present[i])\n            virBufferAsprintf(&buffer, \"floppy%zu.present = \\\"false\\\"\\n\", i);\n    }\n\n    /* def:fss */\n    if (def->nfss > 0) {\n        virBufferAddLit(&buffer, \"isolation.tools.hgfs.disable = \\\"false\\\"\\n\");\n        virBufferAsprintf(&buffer, \"sharedFolder.maxNum = \\\"%zu\\\"\\n\", def->nfss);\n    }\n\n    for (i = 0; i < def->nfss; ++i) {\n        if (virVMXFormatFileSystem(def->fss[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:nets */\n    for (i = 0; i < def->nnets; ++i) {\n        if (virVMXFormatEthernet(def->nets[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:videos */\n    if (def->nvideos > 0) {\n        if (def->nvideos > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No support for multiple video devices\"));\n            goto cleanup;\n        }\n\n        if (virVMXFormatSVGA(def->videos[0], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    for (i = 0; i < def->nserials; ++i) {\n        if (virVMXFormatSerial(ctx, def->serials[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:parallels */\n    for (i = 0; i < def->nparallels; ++i) {\n        if (virVMXFormatParallel(ctx, def->parallels[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* vmx:firmware */\n    if (def->os.firmware == VIR_DOMAIN_OS_DEF_FIRMWARE_EFI)\n        virBufferAddLit(&buffer, \"firmware = \\\"efi\\\"\\n\");\n\n    if (virtualHW_version >= 7) {\n        if (hasSCSI) {\n            virBufferAddLit(&buffer, \"pciBridge0.present = \\\"true\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge4.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge5.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge6.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge7.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.functions = \\\"8\\\"\\n\");\n        }\n\n        virBufferAddLit(&buffer, \"vmci0.present = \\\"true\\\"\\n\");\n    }\n\n    /* Get final VMX output */\n    vmx = virBufferContentAndReset(&buffer);\n\n cleanup:\n    if (vmx == NULL)\n        virBufferFreeAndReset(&buffer);\n\n    VIR_FREE(preliminaryDisplayName);\n    VIR_FREE(displayName);\n    VIR_FREE(annotation);\n\n    return vmx;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirVMXFormatConfig(virVMXContext *ctx, virDomainXMLOptionPtr xmlopt, virDomainDefPtr def,\n                   int virtualHW_version)\n{\n    char *vmx = NULL;\n    size_t i;\n    int sched_cpu_affinity_length;\n    unsigned char zero[VIR_UUID_BUFLEN];\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *preliminaryDisplayName = NULL;\n    char *displayName = NULL;\n    char *annotation = NULL;\n    unsigned long long max_balloon;\n    bool scsi_present[4] = { false, false, false, false };\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    bool floppy_present[2] = { false, false };\n    unsigned int maxvcpus;\n    bool hasSCSI = false;\n\n    if (ctx->formatFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no formatFileName function set\"));\n        return NULL;\n    }\n\n    memset(zero, 0, VIR_UUID_BUFLEN);\n\n    if (def->virtType != VIR_DOMAIN_VIRT_VMWARE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting virt type to be '%s' but found '%s'\"),\n                       virDomainVirtTypeToString(VIR_DOMAIN_VIRT_VMWARE),\n                       virDomainVirtTypeToString(def->virtType));\n        return NULL;\n    }\n\n    /* vmx:.encoding */\n    virBufferAddLit(&buffer, \".encoding = \\\"UTF-8\\\"\\n\");\n\n    /* vmx:config.version */\n    virBufferAddLit(&buffer, \"config.version = \\\"8\\\"\\n\");\n\n    /* vmx:virtualHW.version */\n    virBufferAsprintf(&buffer, \"virtualHW.version = \\\"%d\\\"\\n\",\n                      virtualHW_version);\n\n    /* def:os.arch -> vmx:guestOS */\n    if (def->os.arch == VIR_ARCH_I686) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other\\\"\\n\");\n    } else if (def->os.arch == VIR_ARCH_X86_64) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other-64\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting domain XML attribute 'arch' of entry 'os/type' \"\n                         \"to be 'i686' or 'x86_64' but found '%s'\"),\n                       virArchToString(def->os.arch));\n        goto cleanup;\n    }\n\n    /* def:os.smbios_mode -> vmx:smbios.reflecthost */\n    if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_NONE ||\n        def->os.smbios_mode == VIR_DOMAIN_SMBIOS_EMULATE) {\n        /* nothing */\n    } else if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_HOST) {\n        virBufferAddLit(&buffer, \"smbios.reflecthost = \\\"true\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported SMBIOS mode '%s'\"),\n                       virDomainSmbiosModeTypeToString(def->os.smbios_mode));\n        goto cleanup;\n    }\n\n    /* def:uuid -> vmx:uuid.action, vmx:uuid.bios */\n    if (memcmp(def->uuid, zero, VIR_UUID_BUFLEN) == 0) {\n        virBufferAddLit(&buffer, \"uuid.action = \\\"create\\\"\\n\");\n    } else {\n        virBufferAsprintf(&buffer, \"uuid.bios = \\\"%02x %02x %02x %02x %02x %02x \"\n                          \"%02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\\\"\\n\",\n                          def->uuid[0], def->uuid[1], def->uuid[2], def->uuid[3],\n                          def->uuid[4], def->uuid[5], def->uuid[6], def->uuid[7],\n                          def->uuid[8], def->uuid[9], def->uuid[10], def->uuid[11],\n                          def->uuid[12], def->uuid[13], def->uuid[14],\n                          def->uuid[15]);\n    }\n\n    /* def:name -> vmx:displayName */\n    preliminaryDisplayName = virVMXEscapeHexPipe(def->name);\n\n    if (preliminaryDisplayName == NULL)\n        goto cleanup;\n\n    displayName = virVMXEscapeHexPercent(preliminaryDisplayName);\n\n    if (displayName == NULL)\n        goto cleanup;\n\n    virBufferAsprintf(&buffer, \"displayName = \\\"%s\\\"\\n\", displayName);\n\n    /* def:description -> vmx:annotation */\n    if (def->description != NULL) {\n        if (!(annotation = virVMXEscapeHexPipe(def->description)))\n            goto cleanup;\n\n        virBufferAsprintf(&buffer, \"annotation = \\\"%s\\\"\\n\", annotation);\n    }\n\n    /* def:mem.max_balloon -> vmx:memsize */\n    /* max-memory must be a multiple of 4096 kilobyte */\n    max_balloon = VIR_DIV_UP(virDomainDefGetMemoryTotal(def), 4096) * 4096;\n\n    virBufferAsprintf(&buffer, \"memsize = \\\"%llu\\\"\\n\",\n                      max_balloon / 1024); /* Scale from kilobytes to megabytes */\n\n    /* def:mem.cur_balloon -> vmx:sched.mem.max */\n    if (def->mem.cur_balloon < max_balloon) {\n        virBufferAsprintf(&buffer, \"sched.mem.max = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.cur_balloon,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:mem.min_guarantee -> vmx:sched.mem.minsize */\n    if (def->mem.min_guarantee > 0) {\n        virBufferAsprintf(&buffer, \"sched.mem.minsize = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.min_guarantee,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:maxvcpus -> vmx:numvcpus */\n    if (virDomainDefHasVcpusOffline(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"No support for domain XML entry 'vcpu' attribute \"\n                         \"'current'\"));\n        goto cleanup;\n    }\n    maxvcpus = virDomainDefGetVcpusMax(def);\n    if (maxvcpus == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML entry 'vcpu' to be greater \"\n                         \"than 0\"));\n        goto cleanup;\n    }\n\n    virBufferAsprintf(&buffer, \"numvcpus = \\\"%d\\\"\\n\", maxvcpus);\n\n    if (def->cpu) {\n        unsigned int calculated_vcpus;\n\n        if (def->cpu->mode != VIR_CPU_MODE_CUSTOM) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU mode 'custom' but \"\n                             \"found '%s'\"),\n                           virCPUModeTypeToString(def->cpu->mode));\n            goto cleanup;\n        }\n\n        if (def->cpu->threads != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 thread per core is supported\"));\n            goto cleanup;\n        }\n\n        if (def->cpu->dies != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 die per socket is supported\"));\n            goto cleanup;\n        }\n\n        calculated_vcpus = def->cpu->sockets * def->cpu->cores;\n        if (calculated_vcpus != maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU sockets per core as %d \"\n                             \"but found %d\"),\n                           maxvcpus, calculated_vcpus);\n            goto cleanup;\n        }\n\n        virBufferAsprintf(&buffer, \"cpuid.coresPerSocket = \\\"%d\\\"\\n\", def->cpu->cores);\n    }\n\n    /* def:cpumask -> vmx:sched.cpu.affinity */\n    if (def->cpumask && virBitmapSize(def->cpumask) > 0) {\n        int bit;\n        virBufferAddLit(&buffer, \"sched.cpu.affinity = \\\"\");\n\n        sched_cpu_affinity_length = 0;\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0)\n            ++sched_cpu_affinity_length;\n\n        if (sched_cpu_affinity_length < maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML attribute 'cpuset' of entry \"\n                             \"'vcpu' to contain at least %d CPU(s)\"),\n                           maxvcpus);\n            goto cleanup;\n        }\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0) {\n            virBufferAsprintf(&buffer, \"%d\", bit);\n\n            if (sched_cpu_affinity_length > 1)\n                virBufferAddChar(&buffer, ',');\n\n            --sched_cpu_affinity_length;\n        }\n\n        virBufferAddLit(&buffer, \"\\\"\\n\");\n    }\n\n    /* def:cputune.shares -> vmx:sched.cpu.shares */\n    if (def->cputune.sharesSpecified) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (def->cputune.shares == vcpus * 500) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"low\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 1000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"normal\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 2000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"high\\\"\\n\");\n        } else {\n            virBufferAsprintf(&buffer, \"sched.cpu.shares = \\\"%llu\\\"\\n\",\n                              def->cputune.shares);\n        }\n    }\n\n    /* def:graphics */\n    for (i = 0; i < def->ngraphics; ++i) {\n        switch (def->graphics[i]->type) {\n          case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n            if (virVMXFormatVNC(def->graphics[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n          case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n          case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported graphics type '%s'\"),\n                           virDomainGraphicsTypeToString(def->graphics[i]->type));\n            goto cleanup;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n          default:\n              virReportEnumRangeError(virDomainGraphicsType, def->graphics[i]->type);\n              goto cleanup;\n        }\n    }\n\n    /* def:disks */\n    for (i = 0; i < def->ndisks; ++i) {\n        if (virVMXVerifyDiskAddress(xmlopt, def->disks[i], def) < 0 ||\n            virVMXHandleLegacySCSIDiskDriverName(def, def->disks[i]) < 0) {\n            goto cleanup;\n        }\n    }\n\n    if (virVMXGatherSCSIControllers(ctx, def, scsi_virtualDev,\n                                    scsi_present) < 0) {\n        goto cleanup;\n    }\n\n    for (i = 0; i < 4; ++i) {\n        if (scsi_present[i]) {\n            hasSCSI = true;\n\n            virBufferAsprintf(&buffer, \"scsi%zu.present = \\\"true\\\"\\n\", i);\n\n            if (scsi_virtualDev[i] != -1) {\n                virBufferAsprintf(&buffer, \"scsi%zu.virtualDev = \\\"%s\\\"\\n\", i,\n                                  virVMXControllerModelSCSITypeToString\n                                    (scsi_virtualDev[i]));\n            }\n        }\n    }\n\n    for (i = 0; i < def->ndisks; ++i) {\n        switch (def->disks[i]->device) {\n          case VIR_DOMAIN_DISK_DEVICE_DISK:\n          case VIR_DOMAIN_DISK_DEVICE_CDROM:\n          case VIR_DOMAIN_DISK_DEVICE_LUN:\n            if (virVMXFormatDisk(ctx, def->disks[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_DISK_DEVICE_FLOPPY:\n            if (virVMXFormatFloppy(ctx, def->disks[i], &buffer,\n                                   floppy_present) < 0) {\n                goto cleanup;\n            }\n\n            break;\n\n          default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported disk device type '%s'\"),\n                           virDomainDiskDeviceTypeToString(def->disks[i]->device));\n            goto cleanup;\n        }\n    }\n\n    for (i = 0; i < 2; ++i) {\n        /* floppy[0..1].present defaults to true, disable it explicitly */\n        if (! floppy_present[i])\n            virBufferAsprintf(&buffer, \"floppy%zu.present = \\\"false\\\"\\n\", i);\n    }\n\n    /* def:fss */\n    if (def->nfss > 0) {\n        virBufferAddLit(&buffer, \"isolation.tools.hgfs.disable = \\\"false\\\"\\n\");\n        virBufferAsprintf(&buffer, \"sharedFolder.maxNum = \\\"%zu\\\"\\n\", def->nfss);\n    }\n\n    for (i = 0; i < def->nfss; ++i) {\n        if (virVMXFormatFileSystem(def->fss[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:nets */\n    for (i = 0; i < def->nnets; ++i) {\n        if (virVMXFormatEthernet(def->nets[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:videos */\n    if (def->nvideos > 0) {\n        if (def->nvideos > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No support for multiple video devices\"));\n            goto cleanup;\n        }\n\n        if (virVMXFormatSVGA(def->videos[0], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    for (i = 0; i < def->nserials; ++i) {\n        if (virVMXFormatSerial(ctx, def->serials[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:parallels */\n    for (i = 0; i < def->nparallels; ++i) {\n        if (virVMXFormatParallel(ctx, def->parallels[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* vmx:firmware */\n    if (def->os.firmware == VIR_DOMAIN_OS_DEF_FIRMWARE_EFI)\n        virBufferAddLit(&buffer, \"firmware = \\\"efi\\\"\\n\");\n\n    if (virtualHW_version >= 7) {\n        if (hasSCSI) {\n            virBufferAddLit(&buffer, \"pciBridge0.present = \\\"true\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge4.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge5.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge6.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge7.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.functions = \\\"8\\\"\\n\");\n        }\n\n        virBufferAddLit(&buffer, \"vmci0.present = \\\"true\\\"\\n\");\n    }\n\n    /* Get final VMX output */\n    vmx = virBufferContentAndReset(&buffer);\n\n cleanup:\n    if (vmx == NULL)\n        virBufferFreeAndReset(&buffer);\n\n    VIR_FREE(preliminaryDisplayName);\n    VIR_FREE(displayName);\n    VIR_FREE(annotation);\n\n    return vmx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefParseString",
          "args": [
            "xml",
            "driver->xmlopt",
            "NULL",
            "parse_flags"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "22134-22141",
          "snippet": "virDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverLock",
          "args": [
            "driver"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "50-54",
          "snippet": "static void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_START_VALIDATE",
            "NULL"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainPtr\nvmwareDomainCreateXML(virConnectPtr conn, const char *xml,\n                      unsigned int flags)\n{\n    struct vmware_driver *driver = conn->privateData;\n    virDomainDefPtr vmdef = NULL;\n    virDomainObjPtr vm = NULL;\n    virDomainPtr dom = NULL;\n    char *vmx = NULL;\n    char *vmxPath = NULL;\n    vmwareDomainPtr pDomain = NULL;\n    virVMXContext ctx;\n    unsigned int parse_flags = VIR_DOMAIN_DEF_PARSE_INACTIVE;\n\n    virCheckFlags(VIR_DOMAIN_START_VALIDATE, NULL);\n\n    if (flags & VIR_DOMAIN_START_VALIDATE)\n        parse_flags |= VIR_DOMAIN_DEF_PARSE_VALIDATE_SCHEMA;\n\n    ctx.parseFileName = NULL;\n    ctx.formatFileName = vmwareCopyVMXFileName;\n    ctx.autodetectSCSIControllerModel = NULL;\n    ctx.datacenterPath = NULL;\n\n    vmwareDriverLock(driver);\n\n    if ((vmdef = virDomainDefParseString(xml, driver->xmlopt,\n                                         NULL, parse_flags)) == NULL)\n        goto cleanup;\n\n    /* generate vmx file */\n    vmx = virVMXFormatConfig(&ctx, driver->xmlopt, vmdef, 7);\n    if (vmx == NULL)\n        goto cleanup;\n\n    if (vmwareVmxPath(vmdef, &vmxPath) < 0)\n        goto cleanup;\n\n    /* create vmx file */\n    if (virFileWriteStr(vmxPath, vmx, S_IRUSR|S_IWUSR) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to write vmx file '%s'\"), vmxPath);\n        goto cleanup;\n    }\n\n    /* assign def */\n    if (!(vm = virDomainObjListAdd(driver->domains,\n                                   vmdef,\n                                   driver->xmlopt,\n                                   VIR_DOMAIN_OBJ_LIST_ADD_LIVE |\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE,\n                                   NULL)))\n        goto cleanup;\n\n    pDomain = vm->privateData;\n    pDomain->vmxPath = g_strdup(vmxPath);\n\n    vmwareDomainConfigDisplay(pDomain, vmdef);\n    vmdef = NULL;\n\n    if (vmwareStartVM(driver, vm) < 0) {\n        if (!vm->persistent)\n            virDomainObjListRemove(driver->domains, vm);\n        goto cleanup;\n    }\n\n    dom = virGetDomain(conn, vm->def->name, vm->def->uuid, vm->def->id);\n\n cleanup:\n    virDomainDefFree(vmdef);\n    VIR_FREE(vmx);\n    VIR_FREE(vmxPath);\n    virDomainObjEndAPI(&vm);\n    vmwareDriverUnlock(driver);\n    return dom;\n}"
  },
  {
    "function_name": "vmwareDomainReboot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "620-658",
    "snippet": "static int\nvmwareDomainReboot(virDomainPtr dom, unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    const char * vmxPath = NULL;\n    virDomainObjPtr vm;\n    const char *cmd[] = {\n        driver->vmrun, \"-T\", PROGRAM_SENTINEL,\n        \"reset\", PROGRAM_SENTINEL, \"soft\", NULL\n    };\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    if (!(vm = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return -1;\n\n    vmxPath = ((vmwareDomainPtr) vm->privateData)->vmxPath;\n    vmwareSetSentinal(cmd, vmwareDriverTypeToString(driver->type));\n    vmwareSetSentinal(cmd, vmxPath);\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_RUNNING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domain is not in running state\"));\n        goto cleanup;\n    }\n\n    if (virRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "virRun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "890-900",
          "snippet": "int\nvirRun(const char *const *argv G_GNUC_UNUSED,\n       int *status)\n{\n    if (status)\n        *status = ENOTSUP;\n    else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virRun is not implemented for WIN32\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirRun(const char *const *argv G_GNUC_UNUSED,\n       int *status)\n{\n    if (status)\n        *status = ENOTSUP;\n    else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virRun is not implemented for WIN32\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"domain is not in running state\")"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"domain is not in running state\""
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "NULL"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareUpdateVMStatus",
          "args": [
            "driver",
            "vm"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareUpdateVMStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "282-339",
          "snippet": "static int\nvmwareUpdateVMStatus(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    virCommandPtr cmd;\n    char *outbuf = NULL;\n    char *vmxAbsolutePath = NULL;\n    char *parsedVmxPath = NULL;\n    char *str;\n    char *saveptr = NULL;\n    bool found = false;\n    int oldState = virDomainObjGetState(vm, NULL);\n    int newState;\n    int ret = -1;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virFileResolveAllLinks(((vmwareDomainPtr) vm->privateData)->vmxPath,\n                               &vmxAbsolutePath) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (parsedVmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n         str = NULL) {\n\n        if (parsedVmxPath[0] != '/')\n            continue;\n\n        if (STREQ(parsedVmxPath, vmxAbsolutePath)) {\n            found = true;\n            /* If the vmx path is in the output, the domain is running or\n             * is paused but we have no way to detect if it is paused or not. */\n            if (oldState == VIR_DOMAIN_PAUSED)\n                newState = oldState;\n            else\n                newState = VIR_DOMAIN_RUNNING;\n            break;\n        }\n    }\n\n    if (!found) {\n        vm->def->id = -1;\n        newState = VIR_DOMAIN_SHUTOFF;\n    }\n\n    virDomainObjSetState(vm, newState, 0);\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(vmxAbsolutePath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareUpdateVMStatus(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    virCommandPtr cmd;\n    char *outbuf = NULL;\n    char *vmxAbsolutePath = NULL;\n    char *parsedVmxPath = NULL;\n    char *str;\n    char *saveptr = NULL;\n    bool found = false;\n    int oldState = virDomainObjGetState(vm, NULL);\n    int newState;\n    int ret = -1;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virFileResolveAllLinks(((vmwareDomainPtr) vm->privateData)->vmxPath,\n                               &vmxAbsolutePath) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (parsedVmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n         str = NULL) {\n\n        if (parsedVmxPath[0] != '/')\n            continue;\n\n        if (STREQ(parsedVmxPath, vmxAbsolutePath)) {\n            found = true;\n            /* If the vmx path is in the output, the domain is running or\n             * is paused but we have no way to detect if it is paused or not. */\n            if (oldState == VIR_DOMAIN_PAUSED)\n                newState = oldState;\n            else\n                newState = VIR_DOMAIN_RUNNING;\n            break;\n        }\n    }\n\n    if (!found) {\n        vm->def->id = -1;\n        newState = VIR_DOMAIN_SHUTOFF;\n    }\n\n    virDomainObjSetState(vm, newState, 0);\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(vmxAbsolutePath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareSetSentinal",
          "args": [
            "cmd",
            "vmxPath"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareSetSentinal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "207-219",
          "snippet": "void\nvmwareSetSentinal(const char **prog, const char *key)\n{\n    const char **tmp = prog;\n\n    while (tmp && *tmp) {\n        if (*tmp == PROGRAM_SENTINEL) {\n            *tmp = key;\n            break;\n        }\n        tmp++;\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nvoid\nvmwareSetSentinal(const char **prog, const char *key)\n{\n    const char **tmp = prog;\n\n    while (tmp && *tmp) {\n        if (*tmp == PROGRAM_SENTINEL) {\n            *tmp = key;\n            break;\n        }\n        tmp++;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverTypeToString",
          "args": [
            "driver->type"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmwareDomObjFromDomain",
          "args": [
            "driver",
            "dom->uuid"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomObjFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "82-92",
          "snippet": "static virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainReboot(virDomainPtr dom, unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    const char * vmxPath = NULL;\n    virDomainObjPtr vm;\n    const char *cmd[] = {\n        driver->vmrun, \"-T\", PROGRAM_SENTINEL,\n        \"reset\", PROGRAM_SENTINEL, \"soft\", NULL\n    };\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    if (!(vm = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return -1;\n\n    vmxPath = ((vmwareDomainPtr) vm->privateData)->vmxPath;\n    vmwareSetSentinal(cmd, vmwareDriverTypeToString(driver->type));\n    vmwareSetSentinal(cmd, vmxPath);\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_RUNNING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domain is not in running state\"));\n        goto cleanup;\n    }\n\n    if (virRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return ret;\n}"
  },
  {
    "function_name": "vmwareDomainResume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "579-618",
    "snippet": "static int\nvmwareDomainResume(virDomainPtr dom)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n\n    virDomainObjPtr vm;\n    const char *cmd[] = {\n        driver->vmrun, \"-T\", PROGRAM_SENTINEL, \"unpause\", PROGRAM_SENTINEL,\n        NULL\n    };\n    int ret = -1;\n\n    if (driver->type == VMWARE_DRIVER_PLAYER) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"vmplayer does not support libvirt suspend/resume \"\n                         \"(vmware pause/unpause) operation \"));\n        return ret;\n    }\n\n    if (!(vm = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return -1;\n\n    vmwareSetSentinal(cmd, vmwareDriverTypeToString(driver->type));\n    vmwareSetSentinal(cmd, ((vmwareDomainPtr) vm->privateData)->vmxPath);\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_PAUSED) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domain is not in suspend state\"));\n        goto cleanup;\n    }\n\n    if (virRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, VIR_DOMAIN_RUNNING_UNPAUSED);\n    ret = 0;\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "VIR_DOMAIN_RUNNING",
            "VIR_DOMAIN_RUNNING_UNPAUSED"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "virRun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "890-900",
          "snippet": "int\nvirRun(const char *const *argv G_GNUC_UNUSED,\n       int *status)\n{\n    if (status)\n        *status = ENOTSUP;\n    else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virRun is not implemented for WIN32\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirRun(const char *const *argv G_GNUC_UNUSED,\n       int *status)\n{\n    if (status)\n        *status = ENOTSUP;\n    else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virRun is not implemented for WIN32\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"domain is not in suspend state\")"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"domain is not in suspend state\""
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "NULL"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareSetSentinal",
          "args": [
            "cmd",
            "((vmwareDomainPtr) vm->privateData)->vmxPath"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareSetSentinal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "207-219",
          "snippet": "void\nvmwareSetSentinal(const char **prog, const char *key)\n{\n    const char **tmp = prog;\n\n    while (tmp && *tmp) {\n        if (*tmp == PROGRAM_SENTINEL) {\n            *tmp = key;\n            break;\n        }\n        tmp++;\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nvoid\nvmwareSetSentinal(const char **prog, const char *key)\n{\n    const char **tmp = prog;\n\n    while (tmp && *tmp) {\n        if (*tmp == PROGRAM_SENTINEL) {\n            *tmp = key;\n            break;\n        }\n        tmp++;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverTypeToString",
          "args": [
            "driver->type"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmwareDomObjFromDomain",
          "args": [
            "driver",
            "dom->uuid"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomObjFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "82-92",
          "snippet": "static virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"vmplayer does not support libvirt suspend/resume \"\n                         \"(vmware pause/unpause) operation \")"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainResume(virDomainPtr dom)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n\n    virDomainObjPtr vm;\n    const char *cmd[] = {\n        driver->vmrun, \"-T\", PROGRAM_SENTINEL, \"unpause\", PROGRAM_SENTINEL,\n        NULL\n    };\n    int ret = -1;\n\n    if (driver->type == VMWARE_DRIVER_PLAYER) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"vmplayer does not support libvirt suspend/resume \"\n                         \"(vmware pause/unpause) operation \"));\n        return ret;\n    }\n\n    if (!(vm = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return -1;\n\n    vmwareSetSentinal(cmd, vmwareDriverTypeToString(driver->type));\n    vmwareSetSentinal(cmd, ((vmwareDomainPtr) vm->privateData)->vmxPath);\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_PAUSED) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domain is not in suspend state\"));\n        goto cleanup;\n    }\n\n    if (virRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, VIR_DOMAIN_RUNNING_UNPAUSED);\n    ret = 0;\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return ret;\n}"
  },
  {
    "function_name": "vmwareDomainSuspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "538-577",
    "snippet": "static int\nvmwareDomainSuspend(virDomainPtr dom)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n\n    virDomainObjPtr vm;\n    const char *cmd[] = {\n      driver->vmrun, \"-T\", PROGRAM_SENTINEL, \"pause\",\n      PROGRAM_SENTINEL, NULL\n    };\n    int ret = -1;\n\n    if (driver->type == VMWARE_DRIVER_PLAYER) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"vmplayer does not support libvirt suspend/resume\"\n                         \" (vmware pause/unpause) operation \"));\n        return ret;\n    }\n\n    if (!(vm = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return -1;\n\n    vmwareSetSentinal(cmd, vmwareDriverTypeToString(driver->type));\n    vmwareSetSentinal(cmd, ((vmwareDomainPtr) vm->privateData)->vmxPath);\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_RUNNING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domain is not in running state\"));\n        goto cleanup;\n    }\n\n    if (virRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_USER);\n    ret = 0;\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "VIR_DOMAIN_PAUSED",
            "VIR_DOMAIN_PAUSED_USER"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "virRun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "890-900",
          "snippet": "int\nvirRun(const char *const *argv G_GNUC_UNUSED,\n       int *status)\n{\n    if (status)\n        *status = ENOTSUP;\n    else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virRun is not implemented for WIN32\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirRun(const char *const *argv G_GNUC_UNUSED,\n       int *status)\n{\n    if (status)\n        *status = ENOTSUP;\n    else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virRun is not implemented for WIN32\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"domain is not in running state\")"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"domain is not in running state\""
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "NULL"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareSetSentinal",
          "args": [
            "cmd",
            "((vmwareDomainPtr) vm->privateData)->vmxPath"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareSetSentinal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "207-219",
          "snippet": "void\nvmwareSetSentinal(const char **prog, const char *key)\n{\n    const char **tmp = prog;\n\n    while (tmp && *tmp) {\n        if (*tmp == PROGRAM_SENTINEL) {\n            *tmp = key;\n            break;\n        }\n        tmp++;\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nvoid\nvmwareSetSentinal(const char **prog, const char *key)\n{\n    const char **tmp = prog;\n\n    while (tmp && *tmp) {\n        if (*tmp == PROGRAM_SENTINEL) {\n            *tmp = key;\n            break;\n        }\n        tmp++;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverTypeToString",
          "args": [
            "driver->type"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmwareDomObjFromDomain",
          "args": [
            "driver",
            "dom->uuid"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomObjFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "82-92",
          "snippet": "static virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"vmplayer does not support libvirt suspend/resume\"\n                         \" (vmware pause/unpause) operation \")"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainSuspend(virDomainPtr dom)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n\n    virDomainObjPtr vm;\n    const char *cmd[] = {\n      driver->vmrun, \"-T\", PROGRAM_SENTINEL, \"pause\",\n      PROGRAM_SENTINEL, NULL\n    };\n    int ret = -1;\n\n    if (driver->type == VMWARE_DRIVER_PLAYER) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"vmplayer does not support libvirt suspend/resume\"\n                         \" (vmware pause/unpause) operation \"));\n        return ret;\n    }\n\n    if (!(vm = vmwareDomObjFromDomain(driver, dom->uuid)))\n        return -1;\n\n    vmwareSetSentinal(cmd, vmwareDriverTypeToString(driver->type));\n    vmwareSetSentinal(cmd, ((vmwareDomainPtr) vm->privateData)->vmxPath);\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_RUNNING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domain is not in running state\"));\n        goto cleanup;\n    }\n\n    if (virRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_USER);\n    ret = 0;\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return ret;\n}"
  },
  {
    "function_name": "vmwareDomainDestroyFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "531-536",
    "snippet": "static int\nvmwareDomainDestroyFlags(virDomainPtr dom,\n                         unsigned int flags)\n{\n    return vmwareDomainShutdownFlags(dom, flags);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareDomainShutdownFlags",
          "args": [
            "dom",
            "flags"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomainShutdownFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "482-517",
          "snippet": "static int\nvmwareDomainShutdownFlags(virDomainPtr dom,\n                          unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    vmwareDriverLock(driver);\n\n    if (!(vm = vmwareDomObjFromDomainLocked(driver, dom->uuid)))\n        goto cleanup;\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_RUNNING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domain is not in running state\"));\n        goto cleanup;\n    }\n\n    if (vmwareStopVM(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN) < 0)\n        goto cleanup;\n\n    if (!vm->persistent)\n        virDomainObjListRemove(driver->domains, vm);\n\n    ret = 0;\n cleanup:\n    virDomainObjEndAPI(&vm);\n    vmwareDriverUnlock(driver);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainShutdownFlags(virDomainPtr dom,\n                          unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    vmwareDriverLock(driver);\n\n    if (!(vm = vmwareDomObjFromDomainLocked(driver, dom->uuid)))\n        goto cleanup;\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_RUNNING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domain is not in running state\"));\n        goto cleanup;\n    }\n\n    if (vmwareStopVM(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN) < 0)\n        goto cleanup;\n\n    if (!vm->persistent)\n        virDomainObjListRemove(driver->domains, vm);\n\n    ret = 0;\n cleanup:\n    virDomainObjEndAPI(&vm);\n    vmwareDriverUnlock(driver);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainDestroyFlags(virDomainPtr dom,\n                         unsigned int flags)\n{\n    return vmwareDomainShutdownFlags(dom, flags);\n}"
  },
  {
    "function_name": "vmwareDomainDestroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "525-529",
    "snippet": "static int\nvmwareDomainDestroy(virDomainPtr dom)\n{\n    return vmwareDomainShutdownFlags(dom, 0);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareDomainShutdownFlags",
          "args": [
            "dom",
            "0"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomainShutdownFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "482-517",
          "snippet": "static int\nvmwareDomainShutdownFlags(virDomainPtr dom,\n                          unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    vmwareDriverLock(driver);\n\n    if (!(vm = vmwareDomObjFromDomainLocked(driver, dom->uuid)))\n        goto cleanup;\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_RUNNING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domain is not in running state\"));\n        goto cleanup;\n    }\n\n    if (vmwareStopVM(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN) < 0)\n        goto cleanup;\n\n    if (!vm->persistent)\n        virDomainObjListRemove(driver->domains, vm);\n\n    ret = 0;\n cleanup:\n    virDomainObjEndAPI(&vm);\n    vmwareDriverUnlock(driver);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainShutdownFlags(virDomainPtr dom,\n                          unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    vmwareDriverLock(driver);\n\n    if (!(vm = vmwareDomObjFromDomainLocked(driver, dom->uuid)))\n        goto cleanup;\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_RUNNING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domain is not in running state\"));\n        goto cleanup;\n    }\n\n    if (vmwareStopVM(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN) < 0)\n        goto cleanup;\n\n    if (!vm->persistent)\n        virDomainObjListRemove(driver->domains, vm);\n\n    ret = 0;\n cleanup:\n    virDomainObjEndAPI(&vm);\n    vmwareDriverUnlock(driver);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainDestroy(virDomainPtr dom)\n{\n    return vmwareDomainShutdownFlags(dom, 0);\n}"
  },
  {
    "function_name": "vmwareDomainShutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "519-523",
    "snippet": "static int\nvmwareDomainShutdown(virDomainPtr dom)\n{\n    return vmwareDomainShutdownFlags(dom, 0);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareDomainShutdownFlags",
          "args": [
            "dom",
            "0"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomainShutdownFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "482-517",
          "snippet": "static int\nvmwareDomainShutdownFlags(virDomainPtr dom,\n                          unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    vmwareDriverLock(driver);\n\n    if (!(vm = vmwareDomObjFromDomainLocked(driver, dom->uuid)))\n        goto cleanup;\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_RUNNING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domain is not in running state\"));\n        goto cleanup;\n    }\n\n    if (vmwareStopVM(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN) < 0)\n        goto cleanup;\n\n    if (!vm->persistent)\n        virDomainObjListRemove(driver->domains, vm);\n\n    ret = 0;\n cleanup:\n    virDomainObjEndAPI(&vm);\n    vmwareDriverUnlock(driver);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainShutdownFlags(virDomainPtr dom,\n                          unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    vmwareDriverLock(driver);\n\n    if (!(vm = vmwareDomObjFromDomainLocked(driver, dom->uuid)))\n        goto cleanup;\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_RUNNING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domain is not in running state\"));\n        goto cleanup;\n    }\n\n    if (vmwareStopVM(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN) < 0)\n        goto cleanup;\n\n    if (!vm->persistent)\n        virDomainObjListRemove(driver->domains, vm);\n\n    ret = 0;\n cleanup:\n    virDomainObjEndAPI(&vm);\n    vmwareDriverUnlock(driver);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainShutdown(virDomainPtr dom)\n{\n    return vmwareDomainShutdownFlags(dom, 0);\n}"
  },
  {
    "function_name": "vmwareDomainShutdownFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "482-517",
    "snippet": "static int\nvmwareDomainShutdownFlags(virDomainPtr dom,\n                          unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    vmwareDriverLock(driver);\n\n    if (!(vm = vmwareDomObjFromDomainLocked(driver, dom->uuid)))\n        goto cleanup;\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_RUNNING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domain is not in running state\"));\n        goto cleanup;\n    }\n\n    if (vmwareStopVM(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN) < 0)\n        goto cleanup;\n\n    if (!vm->persistent)\n        virDomainObjListRemove(driver->domains, vm);\n\n    ret = 0;\n cleanup:\n    virDomainObjEndAPI(&vm);\n    vmwareDriverUnlock(driver);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "56-60",
          "snippet": "static void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListRemove",
          "args": [
            "driver->domains",
            "vm"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "401-413",
          "snippet": "void\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareStopVM",
          "args": [
            "driver",
            "vm",
            "VIR_DOMAIN_SHUTOFF_SHUTDOWN"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareStopVM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "341-361",
          "snippet": "static int\nvmwareStopVM(struct vmware_driver *driver,\n             virDomainObjPtr vm,\n             virDomainShutoffReason reason)\n{\n    const char *cmd[] = {\n        driver->vmrun, \"-T\", PROGRAM_SENTINEL, \"stop\",\n        PROGRAM_SENTINEL, \"soft\", NULL\n    };\n\n    vmwareSetSentinal(cmd, vmwareDriverTypeToString(driver->type));\n    vmwareSetSentinal(cmd, ((vmwareDomainPtr) vm->privateData)->vmxPath);\n\n    if (virRun(cmd, NULL) < 0)\n        return -1;\n\n    vm->def->id = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareStopVM(struct vmware_driver *driver,\n             virDomainObjPtr vm,\n             virDomainShutoffReason reason)\n{\n    const char *cmd[] = {\n        driver->vmrun, \"-T\", PROGRAM_SENTINEL, \"stop\",\n        PROGRAM_SENTINEL, \"soft\", NULL\n    };\n\n    vmwareSetSentinal(cmd, vmwareDriverTypeToString(driver->type));\n    vmwareSetSentinal(cmd, ((vmwareDomainPtr) vm->privateData)->vmxPath);\n\n    if (virRun(cmd, NULL) < 0)\n        return -1;\n\n    vm->def->id = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"domain is not in running state\")"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"domain is not in running state\""
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "NULL"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareUpdateVMStatus",
          "args": [
            "driver",
            "vm"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareUpdateVMStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "282-339",
          "snippet": "static int\nvmwareUpdateVMStatus(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    virCommandPtr cmd;\n    char *outbuf = NULL;\n    char *vmxAbsolutePath = NULL;\n    char *parsedVmxPath = NULL;\n    char *str;\n    char *saveptr = NULL;\n    bool found = false;\n    int oldState = virDomainObjGetState(vm, NULL);\n    int newState;\n    int ret = -1;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virFileResolveAllLinks(((vmwareDomainPtr) vm->privateData)->vmxPath,\n                               &vmxAbsolutePath) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (parsedVmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n         str = NULL) {\n\n        if (parsedVmxPath[0] != '/')\n            continue;\n\n        if (STREQ(parsedVmxPath, vmxAbsolutePath)) {\n            found = true;\n            /* If the vmx path is in the output, the domain is running or\n             * is paused but we have no way to detect if it is paused or not. */\n            if (oldState == VIR_DOMAIN_PAUSED)\n                newState = oldState;\n            else\n                newState = VIR_DOMAIN_RUNNING;\n            break;\n        }\n    }\n\n    if (!found) {\n        vm->def->id = -1;\n        newState = VIR_DOMAIN_SHUTOFF;\n    }\n\n    virDomainObjSetState(vm, newState, 0);\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(vmxAbsolutePath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareUpdateVMStatus(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    virCommandPtr cmd;\n    char *outbuf = NULL;\n    char *vmxAbsolutePath = NULL;\n    char *parsedVmxPath = NULL;\n    char *str;\n    char *saveptr = NULL;\n    bool found = false;\n    int oldState = virDomainObjGetState(vm, NULL);\n    int newState;\n    int ret = -1;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virFileResolveAllLinks(((vmwareDomainPtr) vm->privateData)->vmxPath,\n                               &vmxAbsolutePath) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (parsedVmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n         str = NULL) {\n\n        if (parsedVmxPath[0] != '/')\n            continue;\n\n        if (STREQ(parsedVmxPath, vmxAbsolutePath)) {\n            found = true;\n            /* If the vmx path is in the output, the domain is running or\n             * is paused but we have no way to detect if it is paused or not. */\n            if (oldState == VIR_DOMAIN_PAUSED)\n                newState = oldState;\n            else\n                newState = VIR_DOMAIN_RUNNING;\n            break;\n        }\n    }\n\n    if (!found) {\n        vm->def->id = -1;\n        newState = VIR_DOMAIN_SHUTOFF;\n    }\n\n    virDomainObjSetState(vm, newState, 0);\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(vmxAbsolutePath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomObjFromDomainLocked",
          "args": [
            "driver",
            "dom->uuid"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomObjFromDomainLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "63-79",
          "snippet": "static virDomainObjPtr\nvmwareDomObjFromDomainLocked(struct vmware_driver *driver,\n                             const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (!(vm = virDomainObjListFindByUUID(driver->domains, uuid))) {\n        virUUIDFormat(uuid, uuidstr);\n\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching uuid '%s'\"), uuidstr);\n        return NULL;\n    }\n\n    return vm;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainObjPtr\nvmwareDomObjFromDomainLocked(struct vmware_driver *driver,\n                             const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (!(vm = virDomainObjListFindByUUID(driver->domains, uuid))) {\n        virUUIDFormat(uuid, uuidstr);\n\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching uuid '%s'\"), uuidstr);\n        return NULL;\n    }\n\n    return vm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverLock",
          "args": [
            "driver"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "50-54",
          "snippet": "static void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainShutdownFlags(virDomainPtr dom,\n                          unsigned int flags)\n{\n    struct vmware_driver *driver = dom->conn->privateData;\n    virDomainObjPtr vm;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    vmwareDriverLock(driver);\n\n    if (!(vm = vmwareDomObjFromDomainLocked(driver, dom->uuid)))\n        goto cleanup;\n\n    if (vmwareUpdateVMStatus(driver, vm) < 0)\n        goto cleanup;\n\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_RUNNING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domain is not in running state\"));\n        goto cleanup;\n    }\n\n    if (vmwareStopVM(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN) < 0)\n        goto cleanup;\n\n    if (!vm->persistent)\n        virDomainObjListRemove(driver->domains, vm);\n\n    ret = 0;\n cleanup:\n    virDomainObjEndAPI(&vm);\n    vmwareDriverUnlock(driver);\n    return ret;\n}"
  },
  {
    "function_name": "vmwareDomainDefineXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "476-480",
    "snippet": "static virDomainPtr\nvmwareDomainDefineXML(virConnectPtr conn, const char *xml)\n{\n    return vmwareDomainDefineXMLFlags(conn, xml, 0);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareDomainDefineXMLFlags",
          "args": [
            "conn",
            "xml",
            "0"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomainDefineXMLFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "398-474",
          "snippet": "static virDomainPtr\nvmwareDomainDefineXMLFlags(virConnectPtr conn, const char *xml, unsigned int flags)\n{\n    struct vmware_driver *driver = conn->privateData;\n    virDomainDefPtr vmdef = NULL;\n    virDomainObjPtr vm = NULL;\n    virDomainPtr dom = NULL;\n    char *vmx = NULL;\n    char *directoryName = NULL;\n    char *fileName = NULL;\n    char *vmxPath = NULL;\n    vmwareDomainPtr pDomain = NULL;\n    virVMXContext ctx;\n    unsigned int parse_flags = VIR_DOMAIN_DEF_PARSE_INACTIVE;\n\n    virCheckFlags(VIR_DOMAIN_DEFINE_VALIDATE, NULL);\n\n    if (flags & VIR_DOMAIN_DEFINE_VALIDATE)\n        parse_flags |= VIR_DOMAIN_DEF_PARSE_VALIDATE_SCHEMA;\n\n    ctx.parseFileName = NULL;\n    ctx.formatFileName = vmwareCopyVMXFileName;\n    ctx.autodetectSCSIControllerModel = NULL;\n    ctx.datacenterPath = NULL;\n\n    vmwareDriverLock(driver);\n    if ((vmdef = virDomainDefParseString(xml, driver->xmlopt,\n                                         NULL, parse_flags)) == NULL)\n        goto cleanup;\n\n    if (virXMLCheckIllegalChars(\"name\", vmdef->name, \"\\n\") < 0)\n        goto cleanup;\n\n    /* generate vmx file */\n    vmx = virVMXFormatConfig(&ctx, driver->xmlopt, vmdef, 7);\n    if (vmx == NULL)\n        goto cleanup;\n\n    if (vmwareVmxPath(vmdef, &vmxPath) < 0)\n        goto cleanup;\n\n    /* create vmx file */\n    if (virFileWriteStr(vmxPath, vmx, S_IRUSR|S_IWUSR) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to write vmx file '%s'\"), vmxPath);\n        goto cleanup;\n    }\n\n    /* assign def */\n    if (!(vm = virDomainObjListAdd(driver->domains,\n                                   vmdef,\n                                   driver->xmlopt,\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE,\n                                   NULL)))\n        goto cleanup;\n\n    pDomain = vm->privateData;\n    pDomain->vmxPath = g_strdup(vmxPath);\n\n    vmwareDomainConfigDisplay(pDomain, vmdef);\n\n    vmdef = NULL;\n    vm->persistent = 1;\n\n    dom = virGetDomain(conn, vm->def->name, vm->def->uuid, -1);\n\n cleanup:\n    virDomainDefFree(vmdef);\n    VIR_FREE(vmx);\n    VIR_FREE(directoryName);\n    VIR_FREE(fileName);\n    VIR_FREE(vmxPath);\n    if (vm)\n        virObjectUnlock(vm);\n    vmwareDriverUnlock(driver);\n    return dom;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainPtr\nvmwareDomainDefineXMLFlags(virConnectPtr conn, const char *xml, unsigned int flags)\n{\n    struct vmware_driver *driver = conn->privateData;\n    virDomainDefPtr vmdef = NULL;\n    virDomainObjPtr vm = NULL;\n    virDomainPtr dom = NULL;\n    char *vmx = NULL;\n    char *directoryName = NULL;\n    char *fileName = NULL;\n    char *vmxPath = NULL;\n    vmwareDomainPtr pDomain = NULL;\n    virVMXContext ctx;\n    unsigned int parse_flags = VIR_DOMAIN_DEF_PARSE_INACTIVE;\n\n    virCheckFlags(VIR_DOMAIN_DEFINE_VALIDATE, NULL);\n\n    if (flags & VIR_DOMAIN_DEFINE_VALIDATE)\n        parse_flags |= VIR_DOMAIN_DEF_PARSE_VALIDATE_SCHEMA;\n\n    ctx.parseFileName = NULL;\n    ctx.formatFileName = vmwareCopyVMXFileName;\n    ctx.autodetectSCSIControllerModel = NULL;\n    ctx.datacenterPath = NULL;\n\n    vmwareDriverLock(driver);\n    if ((vmdef = virDomainDefParseString(xml, driver->xmlopt,\n                                         NULL, parse_flags)) == NULL)\n        goto cleanup;\n\n    if (virXMLCheckIllegalChars(\"name\", vmdef->name, \"\\n\") < 0)\n        goto cleanup;\n\n    /* generate vmx file */\n    vmx = virVMXFormatConfig(&ctx, driver->xmlopt, vmdef, 7);\n    if (vmx == NULL)\n        goto cleanup;\n\n    if (vmwareVmxPath(vmdef, &vmxPath) < 0)\n        goto cleanup;\n\n    /* create vmx file */\n    if (virFileWriteStr(vmxPath, vmx, S_IRUSR|S_IWUSR) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to write vmx file '%s'\"), vmxPath);\n        goto cleanup;\n    }\n\n    /* assign def */\n    if (!(vm = virDomainObjListAdd(driver->domains,\n                                   vmdef,\n                                   driver->xmlopt,\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE,\n                                   NULL)))\n        goto cleanup;\n\n    pDomain = vm->privateData;\n    pDomain->vmxPath = g_strdup(vmxPath);\n\n    vmwareDomainConfigDisplay(pDomain, vmdef);\n\n    vmdef = NULL;\n    vm->persistent = 1;\n\n    dom = virGetDomain(conn, vm->def->name, vm->def->uuid, -1);\n\n cleanup:\n    virDomainDefFree(vmdef);\n    VIR_FREE(vmx);\n    VIR_FREE(directoryName);\n    VIR_FREE(fileName);\n    VIR_FREE(vmxPath);\n    if (vm)\n        virObjectUnlock(vm);\n    vmwareDriverUnlock(driver);\n    return dom;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainPtr\nvmwareDomainDefineXML(virConnectPtr conn, const char *xml)\n{\n    return vmwareDomainDefineXMLFlags(conn, xml, 0);\n}"
  },
  {
    "function_name": "vmwareDomainDefineXMLFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "398-474",
    "snippet": "static virDomainPtr\nvmwareDomainDefineXMLFlags(virConnectPtr conn, const char *xml, unsigned int flags)\n{\n    struct vmware_driver *driver = conn->privateData;\n    virDomainDefPtr vmdef = NULL;\n    virDomainObjPtr vm = NULL;\n    virDomainPtr dom = NULL;\n    char *vmx = NULL;\n    char *directoryName = NULL;\n    char *fileName = NULL;\n    char *vmxPath = NULL;\n    vmwareDomainPtr pDomain = NULL;\n    virVMXContext ctx;\n    unsigned int parse_flags = VIR_DOMAIN_DEF_PARSE_INACTIVE;\n\n    virCheckFlags(VIR_DOMAIN_DEFINE_VALIDATE, NULL);\n\n    if (flags & VIR_DOMAIN_DEFINE_VALIDATE)\n        parse_flags |= VIR_DOMAIN_DEF_PARSE_VALIDATE_SCHEMA;\n\n    ctx.parseFileName = NULL;\n    ctx.formatFileName = vmwareCopyVMXFileName;\n    ctx.autodetectSCSIControllerModel = NULL;\n    ctx.datacenterPath = NULL;\n\n    vmwareDriverLock(driver);\n    if ((vmdef = virDomainDefParseString(xml, driver->xmlopt,\n                                         NULL, parse_flags)) == NULL)\n        goto cleanup;\n\n    if (virXMLCheckIllegalChars(\"name\", vmdef->name, \"\\n\") < 0)\n        goto cleanup;\n\n    /* generate vmx file */\n    vmx = virVMXFormatConfig(&ctx, driver->xmlopt, vmdef, 7);\n    if (vmx == NULL)\n        goto cleanup;\n\n    if (vmwareVmxPath(vmdef, &vmxPath) < 0)\n        goto cleanup;\n\n    /* create vmx file */\n    if (virFileWriteStr(vmxPath, vmx, S_IRUSR|S_IWUSR) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to write vmx file '%s'\"), vmxPath);\n        goto cleanup;\n    }\n\n    /* assign def */\n    if (!(vm = virDomainObjListAdd(driver->domains,\n                                   vmdef,\n                                   driver->xmlopt,\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE,\n                                   NULL)))\n        goto cleanup;\n\n    pDomain = vm->privateData;\n    pDomain->vmxPath = g_strdup(vmxPath);\n\n    vmwareDomainConfigDisplay(pDomain, vmdef);\n\n    vmdef = NULL;\n    vm->persistent = 1;\n\n    dom = virGetDomain(conn, vm->def->name, vm->def->uuid, -1);\n\n cleanup:\n    virDomainDefFree(vmdef);\n    VIR_FREE(vmx);\n    VIR_FREE(directoryName);\n    VIR_FREE(fileName);\n    VIR_FREE(vmxPath);\n    if (vm)\n        virObjectUnlock(vm);\n    vmwareDriverUnlock(driver);\n    return dom;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "56-60",
          "snippet": "static void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "vm"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vmxPath"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fileName"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "directoryName"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vmx"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "vmdef"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetDomain",
          "args": [
            "conn",
            "vm->def->name",
            "vm->def->uuid",
            "-1"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "275-304",
          "snippet": "virDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainClass;\n\nvirDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomainConfigDisplay",
          "args": [
            "pDomain",
            "vmdef"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomainConfigDisplay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "314-332",
          "snippet": "int\nvmwareDomainConfigDisplay(vmwareDomainPtr pDomain, virDomainDefPtr def)\n{\n    size_t i;\n\n    if (def->ngraphics == 0) {\n        pDomain->gui = true;\n        return 0;\n    } else {\n        pDomain->gui = false;\n        for (i = 0; i < def->ngraphics; i++) {\n            if (def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP) {\n                pDomain->gui = true;\n                return 0;\n            }\n        }\n        return 0;\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nint\nvmwareDomainConfigDisplay(vmwareDomainPtr pDomain, virDomainDefPtr def)\n{\n    size_t i;\n\n    if (def->ngraphics == 0) {\n        pDomain->gui = true;\n        return 0;\n    } else {\n        pDomain->gui = false;\n        for (i = 0; i < def->ngraphics; i++) {\n            if (def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP) {\n                pDomain->gui = true;\n                return 0;\n            }\n        }\n        return 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "vmxPath"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListAdd",
          "args": [
            "driver->domains",
            "vmdef",
            "driver->xmlopt",
            "VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE",
            "NULL"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "354-366",
          "snippet": "virDomainObjPtr virDomainObjListAdd(virDomainObjListPtr doms,\n                                    virDomainDefPtr def,\n                                    virDomainXMLOptionPtr xmlopt,\n                                    unsigned int flags,\n                                    virDomainDefPtr *oldDef)\n{\n    virDomainObjPtr ret;\n\n    virObjectRWLockWrite(doms);\n    ret = virDomainObjListAddLocked(doms, def, xmlopt, flags, oldDef);\n    virObjectRWUnlock(doms);\n    return ret;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirDomainObjPtr virDomainObjListAdd(virDomainObjListPtr doms,\n                                    virDomainDefPtr def,\n                                    virDomainXMLOptionPtr xmlopt,\n                                    unsigned int flags,\n                                    virDomainDefPtr *oldDef)\n{\n    virDomainObjPtr ret;\n\n    virObjectRWLockWrite(doms);\n    ret = virDomainObjListAddLocked(doms, def, xmlopt, flags, oldDef);\n    virObjectRWUnlock(doms);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to write vmx file '%s'\")",
            "vmxPath"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileWriteStr",
          "args": [
            "vmxPath",
            "vmx",
            "S_IRUSR|S_IWUSR"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "virFileWriteStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1502-1524",
          "snippet": "int\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareVmxPath",
          "args": [
            "vmdef",
            "&vmxPath"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareVmxPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "369-434",
          "snippet": "int\nvmwareVmxPath(virDomainDefPtr vmdef, char **vmxPath)\n{\n    virDomainDiskDefPtr disk = NULL;\n    char *directoryName = NULL;\n    char *fileName = NULL;\n    int ret = -1;\n    size_t i;\n    const char *src;\n\n    /*\n     * Build VMX URL. Use the source of the first file-based harddisk\n     * to deduce the path for the VMX file. Don't just use the\n     * first disk, because it may be CDROM disk and ISO images are normally not\n     * located in the virtual machine's directory. This approach\n     * isn't perfect but should work in the majority of cases.\n     */\n    if (vmdef->ndisks < 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any disks, \"\n                         \"cannot deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < vmdef->ndisks; ++i) {\n        if (vmdef->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_DISK &&\n            virDomainDiskGetType(vmdef->disks[i]) == VIR_STORAGE_TYPE_FILE) {\n            disk = vmdef->disks[i];\n            break;\n        }\n    }\n\n    if (disk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any file-based harddisks, \"\n                         \"cannot deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    src = virDomainDiskGetSource(disk);\n    if (!src) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"First file-based harddisk has no source, cannot \"\n                         \"deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    if (vmwareParsePath(src, &directoryName, &fileName) < 0)\n        goto cleanup;\n\n    if (!virStringHasCaseSuffix(fileName, \".vmdk\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting source '%s' of first file-based harddisk \"\n                         \"to be a VMDK image\"), src);\n        goto cleanup;\n    }\n\n    vmwareConstructVmxPath(directoryName, vmdef->name, vmxPath);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(directoryName);\n    VIR_FREE(fileName);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nint\nvmwareVmxPath(virDomainDefPtr vmdef, char **vmxPath)\n{\n    virDomainDiskDefPtr disk = NULL;\n    char *directoryName = NULL;\n    char *fileName = NULL;\n    int ret = -1;\n    size_t i;\n    const char *src;\n\n    /*\n     * Build VMX URL. Use the source of the first file-based harddisk\n     * to deduce the path for the VMX file. Don't just use the\n     * first disk, because it may be CDROM disk and ISO images are normally not\n     * located in the virtual machine's directory. This approach\n     * isn't perfect but should work in the majority of cases.\n     */\n    if (vmdef->ndisks < 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any disks, \"\n                         \"cannot deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < vmdef->ndisks; ++i) {\n        if (vmdef->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_DISK &&\n            virDomainDiskGetType(vmdef->disks[i]) == VIR_STORAGE_TYPE_FILE) {\n            disk = vmdef->disks[i];\n            break;\n        }\n    }\n\n    if (disk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any file-based harddisks, \"\n                         \"cannot deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    src = virDomainDiskGetSource(disk);\n    if (!src) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"First file-based harddisk has no source, cannot \"\n                         \"deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    if (vmwareParsePath(src, &directoryName, &fileName) < 0)\n        goto cleanup;\n\n    if (!virStringHasCaseSuffix(fileName, \".vmdk\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting source '%s' of first file-based harddisk \"\n                         \"to be a VMDK image\"), src);\n        goto cleanup;\n    }\n\n    vmwareConstructVmxPath(directoryName, vmdef->name, vmxPath);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(directoryName);\n    VIR_FREE(fileName);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXFormatConfig",
          "args": [
            "&ctx",
            "driver->xmlopt",
            "vmdef",
            "7"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXFormatConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "3052-3453",
          "snippet": "char *\nvirVMXFormatConfig(virVMXContext *ctx, virDomainXMLOptionPtr xmlopt, virDomainDefPtr def,\n                   int virtualHW_version)\n{\n    char *vmx = NULL;\n    size_t i;\n    int sched_cpu_affinity_length;\n    unsigned char zero[VIR_UUID_BUFLEN];\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *preliminaryDisplayName = NULL;\n    char *displayName = NULL;\n    char *annotation = NULL;\n    unsigned long long max_balloon;\n    bool scsi_present[4] = { false, false, false, false };\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    bool floppy_present[2] = { false, false };\n    unsigned int maxvcpus;\n    bool hasSCSI = false;\n\n    if (ctx->formatFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no formatFileName function set\"));\n        return NULL;\n    }\n\n    memset(zero, 0, VIR_UUID_BUFLEN);\n\n    if (def->virtType != VIR_DOMAIN_VIRT_VMWARE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting virt type to be '%s' but found '%s'\"),\n                       virDomainVirtTypeToString(VIR_DOMAIN_VIRT_VMWARE),\n                       virDomainVirtTypeToString(def->virtType));\n        return NULL;\n    }\n\n    /* vmx:.encoding */\n    virBufferAddLit(&buffer, \".encoding = \\\"UTF-8\\\"\\n\");\n\n    /* vmx:config.version */\n    virBufferAddLit(&buffer, \"config.version = \\\"8\\\"\\n\");\n\n    /* vmx:virtualHW.version */\n    virBufferAsprintf(&buffer, \"virtualHW.version = \\\"%d\\\"\\n\",\n                      virtualHW_version);\n\n    /* def:os.arch -> vmx:guestOS */\n    if (def->os.arch == VIR_ARCH_I686) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other\\\"\\n\");\n    } else if (def->os.arch == VIR_ARCH_X86_64) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other-64\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting domain XML attribute 'arch' of entry 'os/type' \"\n                         \"to be 'i686' or 'x86_64' but found '%s'\"),\n                       virArchToString(def->os.arch));\n        goto cleanup;\n    }\n\n    /* def:os.smbios_mode -> vmx:smbios.reflecthost */\n    if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_NONE ||\n        def->os.smbios_mode == VIR_DOMAIN_SMBIOS_EMULATE) {\n        /* nothing */\n    } else if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_HOST) {\n        virBufferAddLit(&buffer, \"smbios.reflecthost = \\\"true\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported SMBIOS mode '%s'\"),\n                       virDomainSmbiosModeTypeToString(def->os.smbios_mode));\n        goto cleanup;\n    }\n\n    /* def:uuid -> vmx:uuid.action, vmx:uuid.bios */\n    if (memcmp(def->uuid, zero, VIR_UUID_BUFLEN) == 0) {\n        virBufferAddLit(&buffer, \"uuid.action = \\\"create\\\"\\n\");\n    } else {\n        virBufferAsprintf(&buffer, \"uuid.bios = \\\"%02x %02x %02x %02x %02x %02x \"\n                          \"%02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\\\"\\n\",\n                          def->uuid[0], def->uuid[1], def->uuid[2], def->uuid[3],\n                          def->uuid[4], def->uuid[5], def->uuid[6], def->uuid[7],\n                          def->uuid[8], def->uuid[9], def->uuid[10], def->uuid[11],\n                          def->uuid[12], def->uuid[13], def->uuid[14],\n                          def->uuid[15]);\n    }\n\n    /* def:name -> vmx:displayName */\n    preliminaryDisplayName = virVMXEscapeHexPipe(def->name);\n\n    if (preliminaryDisplayName == NULL)\n        goto cleanup;\n\n    displayName = virVMXEscapeHexPercent(preliminaryDisplayName);\n\n    if (displayName == NULL)\n        goto cleanup;\n\n    virBufferAsprintf(&buffer, \"displayName = \\\"%s\\\"\\n\", displayName);\n\n    /* def:description -> vmx:annotation */\n    if (def->description != NULL) {\n        if (!(annotation = virVMXEscapeHexPipe(def->description)))\n            goto cleanup;\n\n        virBufferAsprintf(&buffer, \"annotation = \\\"%s\\\"\\n\", annotation);\n    }\n\n    /* def:mem.max_balloon -> vmx:memsize */\n    /* max-memory must be a multiple of 4096 kilobyte */\n    max_balloon = VIR_DIV_UP(virDomainDefGetMemoryTotal(def), 4096) * 4096;\n\n    virBufferAsprintf(&buffer, \"memsize = \\\"%llu\\\"\\n\",\n                      max_balloon / 1024); /* Scale from kilobytes to megabytes */\n\n    /* def:mem.cur_balloon -> vmx:sched.mem.max */\n    if (def->mem.cur_balloon < max_balloon) {\n        virBufferAsprintf(&buffer, \"sched.mem.max = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.cur_balloon,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:mem.min_guarantee -> vmx:sched.mem.minsize */\n    if (def->mem.min_guarantee > 0) {\n        virBufferAsprintf(&buffer, \"sched.mem.minsize = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.min_guarantee,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:maxvcpus -> vmx:numvcpus */\n    if (virDomainDefHasVcpusOffline(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"No support for domain XML entry 'vcpu' attribute \"\n                         \"'current'\"));\n        goto cleanup;\n    }\n    maxvcpus = virDomainDefGetVcpusMax(def);\n    if (maxvcpus == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML entry 'vcpu' to be greater \"\n                         \"than 0\"));\n        goto cleanup;\n    }\n\n    virBufferAsprintf(&buffer, \"numvcpus = \\\"%d\\\"\\n\", maxvcpus);\n\n    if (def->cpu) {\n        unsigned int calculated_vcpus;\n\n        if (def->cpu->mode != VIR_CPU_MODE_CUSTOM) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU mode 'custom' but \"\n                             \"found '%s'\"),\n                           virCPUModeTypeToString(def->cpu->mode));\n            goto cleanup;\n        }\n\n        if (def->cpu->threads != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 thread per core is supported\"));\n            goto cleanup;\n        }\n\n        if (def->cpu->dies != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 die per socket is supported\"));\n            goto cleanup;\n        }\n\n        calculated_vcpus = def->cpu->sockets * def->cpu->cores;\n        if (calculated_vcpus != maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU sockets per core as %d \"\n                             \"but found %d\"),\n                           maxvcpus, calculated_vcpus);\n            goto cleanup;\n        }\n\n        virBufferAsprintf(&buffer, \"cpuid.coresPerSocket = \\\"%d\\\"\\n\", def->cpu->cores);\n    }\n\n    /* def:cpumask -> vmx:sched.cpu.affinity */\n    if (def->cpumask && virBitmapSize(def->cpumask) > 0) {\n        int bit;\n        virBufferAddLit(&buffer, \"sched.cpu.affinity = \\\"\");\n\n        sched_cpu_affinity_length = 0;\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0)\n            ++sched_cpu_affinity_length;\n\n        if (sched_cpu_affinity_length < maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML attribute 'cpuset' of entry \"\n                             \"'vcpu' to contain at least %d CPU(s)\"),\n                           maxvcpus);\n            goto cleanup;\n        }\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0) {\n            virBufferAsprintf(&buffer, \"%d\", bit);\n\n            if (sched_cpu_affinity_length > 1)\n                virBufferAddChar(&buffer, ',');\n\n            --sched_cpu_affinity_length;\n        }\n\n        virBufferAddLit(&buffer, \"\\\"\\n\");\n    }\n\n    /* def:cputune.shares -> vmx:sched.cpu.shares */\n    if (def->cputune.sharesSpecified) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (def->cputune.shares == vcpus * 500) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"low\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 1000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"normal\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 2000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"high\\\"\\n\");\n        } else {\n            virBufferAsprintf(&buffer, \"sched.cpu.shares = \\\"%llu\\\"\\n\",\n                              def->cputune.shares);\n        }\n    }\n\n    /* def:graphics */\n    for (i = 0; i < def->ngraphics; ++i) {\n        switch (def->graphics[i]->type) {\n          case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n            if (virVMXFormatVNC(def->graphics[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n          case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n          case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported graphics type '%s'\"),\n                           virDomainGraphicsTypeToString(def->graphics[i]->type));\n            goto cleanup;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n          default:\n              virReportEnumRangeError(virDomainGraphicsType, def->graphics[i]->type);\n              goto cleanup;\n        }\n    }\n\n    /* def:disks */\n    for (i = 0; i < def->ndisks; ++i) {\n        if (virVMXVerifyDiskAddress(xmlopt, def->disks[i], def) < 0 ||\n            virVMXHandleLegacySCSIDiskDriverName(def, def->disks[i]) < 0) {\n            goto cleanup;\n        }\n    }\n\n    if (virVMXGatherSCSIControllers(ctx, def, scsi_virtualDev,\n                                    scsi_present) < 0) {\n        goto cleanup;\n    }\n\n    for (i = 0; i < 4; ++i) {\n        if (scsi_present[i]) {\n            hasSCSI = true;\n\n            virBufferAsprintf(&buffer, \"scsi%zu.present = \\\"true\\\"\\n\", i);\n\n            if (scsi_virtualDev[i] != -1) {\n                virBufferAsprintf(&buffer, \"scsi%zu.virtualDev = \\\"%s\\\"\\n\", i,\n                                  virVMXControllerModelSCSITypeToString\n                                    (scsi_virtualDev[i]));\n            }\n        }\n    }\n\n    for (i = 0; i < def->ndisks; ++i) {\n        switch (def->disks[i]->device) {\n          case VIR_DOMAIN_DISK_DEVICE_DISK:\n          case VIR_DOMAIN_DISK_DEVICE_CDROM:\n          case VIR_DOMAIN_DISK_DEVICE_LUN:\n            if (virVMXFormatDisk(ctx, def->disks[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_DISK_DEVICE_FLOPPY:\n            if (virVMXFormatFloppy(ctx, def->disks[i], &buffer,\n                                   floppy_present) < 0) {\n                goto cleanup;\n            }\n\n            break;\n\n          default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported disk device type '%s'\"),\n                           virDomainDiskDeviceTypeToString(def->disks[i]->device));\n            goto cleanup;\n        }\n    }\n\n    for (i = 0; i < 2; ++i) {\n        /* floppy[0..1].present defaults to true, disable it explicitly */\n        if (! floppy_present[i])\n            virBufferAsprintf(&buffer, \"floppy%zu.present = \\\"false\\\"\\n\", i);\n    }\n\n    /* def:fss */\n    if (def->nfss > 0) {\n        virBufferAddLit(&buffer, \"isolation.tools.hgfs.disable = \\\"false\\\"\\n\");\n        virBufferAsprintf(&buffer, \"sharedFolder.maxNum = \\\"%zu\\\"\\n\", def->nfss);\n    }\n\n    for (i = 0; i < def->nfss; ++i) {\n        if (virVMXFormatFileSystem(def->fss[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:nets */\n    for (i = 0; i < def->nnets; ++i) {\n        if (virVMXFormatEthernet(def->nets[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:videos */\n    if (def->nvideos > 0) {\n        if (def->nvideos > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No support for multiple video devices\"));\n            goto cleanup;\n        }\n\n        if (virVMXFormatSVGA(def->videos[0], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    for (i = 0; i < def->nserials; ++i) {\n        if (virVMXFormatSerial(ctx, def->serials[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:parallels */\n    for (i = 0; i < def->nparallels; ++i) {\n        if (virVMXFormatParallel(ctx, def->parallels[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* vmx:firmware */\n    if (def->os.firmware == VIR_DOMAIN_OS_DEF_FIRMWARE_EFI)\n        virBufferAddLit(&buffer, \"firmware = \\\"efi\\\"\\n\");\n\n    if (virtualHW_version >= 7) {\n        if (hasSCSI) {\n            virBufferAddLit(&buffer, \"pciBridge0.present = \\\"true\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge4.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge5.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge6.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge7.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.functions = \\\"8\\\"\\n\");\n        }\n\n        virBufferAddLit(&buffer, \"vmci0.present = \\\"true\\\"\\n\");\n    }\n\n    /* Get final VMX output */\n    vmx = virBufferContentAndReset(&buffer);\n\n cleanup:\n    if (vmx == NULL)\n        virBufferFreeAndReset(&buffer);\n\n    VIR_FREE(preliminaryDisplayName);\n    VIR_FREE(displayName);\n    VIR_FREE(annotation);\n\n    return vmx;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirVMXFormatConfig(virVMXContext *ctx, virDomainXMLOptionPtr xmlopt, virDomainDefPtr def,\n                   int virtualHW_version)\n{\n    char *vmx = NULL;\n    size_t i;\n    int sched_cpu_affinity_length;\n    unsigned char zero[VIR_UUID_BUFLEN];\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *preliminaryDisplayName = NULL;\n    char *displayName = NULL;\n    char *annotation = NULL;\n    unsigned long long max_balloon;\n    bool scsi_present[4] = { false, false, false, false };\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    bool floppy_present[2] = { false, false };\n    unsigned int maxvcpus;\n    bool hasSCSI = false;\n\n    if (ctx->formatFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no formatFileName function set\"));\n        return NULL;\n    }\n\n    memset(zero, 0, VIR_UUID_BUFLEN);\n\n    if (def->virtType != VIR_DOMAIN_VIRT_VMWARE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting virt type to be '%s' but found '%s'\"),\n                       virDomainVirtTypeToString(VIR_DOMAIN_VIRT_VMWARE),\n                       virDomainVirtTypeToString(def->virtType));\n        return NULL;\n    }\n\n    /* vmx:.encoding */\n    virBufferAddLit(&buffer, \".encoding = \\\"UTF-8\\\"\\n\");\n\n    /* vmx:config.version */\n    virBufferAddLit(&buffer, \"config.version = \\\"8\\\"\\n\");\n\n    /* vmx:virtualHW.version */\n    virBufferAsprintf(&buffer, \"virtualHW.version = \\\"%d\\\"\\n\",\n                      virtualHW_version);\n\n    /* def:os.arch -> vmx:guestOS */\n    if (def->os.arch == VIR_ARCH_I686) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other\\\"\\n\");\n    } else if (def->os.arch == VIR_ARCH_X86_64) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other-64\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting domain XML attribute 'arch' of entry 'os/type' \"\n                         \"to be 'i686' or 'x86_64' but found '%s'\"),\n                       virArchToString(def->os.arch));\n        goto cleanup;\n    }\n\n    /* def:os.smbios_mode -> vmx:smbios.reflecthost */\n    if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_NONE ||\n        def->os.smbios_mode == VIR_DOMAIN_SMBIOS_EMULATE) {\n        /* nothing */\n    } else if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_HOST) {\n        virBufferAddLit(&buffer, \"smbios.reflecthost = \\\"true\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported SMBIOS mode '%s'\"),\n                       virDomainSmbiosModeTypeToString(def->os.smbios_mode));\n        goto cleanup;\n    }\n\n    /* def:uuid -> vmx:uuid.action, vmx:uuid.bios */\n    if (memcmp(def->uuid, zero, VIR_UUID_BUFLEN) == 0) {\n        virBufferAddLit(&buffer, \"uuid.action = \\\"create\\\"\\n\");\n    } else {\n        virBufferAsprintf(&buffer, \"uuid.bios = \\\"%02x %02x %02x %02x %02x %02x \"\n                          \"%02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\\\"\\n\",\n                          def->uuid[0], def->uuid[1], def->uuid[2], def->uuid[3],\n                          def->uuid[4], def->uuid[5], def->uuid[6], def->uuid[7],\n                          def->uuid[8], def->uuid[9], def->uuid[10], def->uuid[11],\n                          def->uuid[12], def->uuid[13], def->uuid[14],\n                          def->uuid[15]);\n    }\n\n    /* def:name -> vmx:displayName */\n    preliminaryDisplayName = virVMXEscapeHexPipe(def->name);\n\n    if (preliminaryDisplayName == NULL)\n        goto cleanup;\n\n    displayName = virVMXEscapeHexPercent(preliminaryDisplayName);\n\n    if (displayName == NULL)\n        goto cleanup;\n\n    virBufferAsprintf(&buffer, \"displayName = \\\"%s\\\"\\n\", displayName);\n\n    /* def:description -> vmx:annotation */\n    if (def->description != NULL) {\n        if (!(annotation = virVMXEscapeHexPipe(def->description)))\n            goto cleanup;\n\n        virBufferAsprintf(&buffer, \"annotation = \\\"%s\\\"\\n\", annotation);\n    }\n\n    /* def:mem.max_balloon -> vmx:memsize */\n    /* max-memory must be a multiple of 4096 kilobyte */\n    max_balloon = VIR_DIV_UP(virDomainDefGetMemoryTotal(def), 4096) * 4096;\n\n    virBufferAsprintf(&buffer, \"memsize = \\\"%llu\\\"\\n\",\n                      max_balloon / 1024); /* Scale from kilobytes to megabytes */\n\n    /* def:mem.cur_balloon -> vmx:sched.mem.max */\n    if (def->mem.cur_balloon < max_balloon) {\n        virBufferAsprintf(&buffer, \"sched.mem.max = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.cur_balloon,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:mem.min_guarantee -> vmx:sched.mem.minsize */\n    if (def->mem.min_guarantee > 0) {\n        virBufferAsprintf(&buffer, \"sched.mem.minsize = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.min_guarantee,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:maxvcpus -> vmx:numvcpus */\n    if (virDomainDefHasVcpusOffline(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"No support for domain XML entry 'vcpu' attribute \"\n                         \"'current'\"));\n        goto cleanup;\n    }\n    maxvcpus = virDomainDefGetVcpusMax(def);\n    if (maxvcpus == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML entry 'vcpu' to be greater \"\n                         \"than 0\"));\n        goto cleanup;\n    }\n\n    virBufferAsprintf(&buffer, \"numvcpus = \\\"%d\\\"\\n\", maxvcpus);\n\n    if (def->cpu) {\n        unsigned int calculated_vcpus;\n\n        if (def->cpu->mode != VIR_CPU_MODE_CUSTOM) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU mode 'custom' but \"\n                             \"found '%s'\"),\n                           virCPUModeTypeToString(def->cpu->mode));\n            goto cleanup;\n        }\n\n        if (def->cpu->threads != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 thread per core is supported\"));\n            goto cleanup;\n        }\n\n        if (def->cpu->dies != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 die per socket is supported\"));\n            goto cleanup;\n        }\n\n        calculated_vcpus = def->cpu->sockets * def->cpu->cores;\n        if (calculated_vcpus != maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU sockets per core as %d \"\n                             \"but found %d\"),\n                           maxvcpus, calculated_vcpus);\n            goto cleanup;\n        }\n\n        virBufferAsprintf(&buffer, \"cpuid.coresPerSocket = \\\"%d\\\"\\n\", def->cpu->cores);\n    }\n\n    /* def:cpumask -> vmx:sched.cpu.affinity */\n    if (def->cpumask && virBitmapSize(def->cpumask) > 0) {\n        int bit;\n        virBufferAddLit(&buffer, \"sched.cpu.affinity = \\\"\");\n\n        sched_cpu_affinity_length = 0;\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0)\n            ++sched_cpu_affinity_length;\n\n        if (sched_cpu_affinity_length < maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML attribute 'cpuset' of entry \"\n                             \"'vcpu' to contain at least %d CPU(s)\"),\n                           maxvcpus);\n            goto cleanup;\n        }\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0) {\n            virBufferAsprintf(&buffer, \"%d\", bit);\n\n            if (sched_cpu_affinity_length > 1)\n                virBufferAddChar(&buffer, ',');\n\n            --sched_cpu_affinity_length;\n        }\n\n        virBufferAddLit(&buffer, \"\\\"\\n\");\n    }\n\n    /* def:cputune.shares -> vmx:sched.cpu.shares */\n    if (def->cputune.sharesSpecified) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (def->cputune.shares == vcpus * 500) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"low\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 1000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"normal\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 2000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"high\\\"\\n\");\n        } else {\n            virBufferAsprintf(&buffer, \"sched.cpu.shares = \\\"%llu\\\"\\n\",\n                              def->cputune.shares);\n        }\n    }\n\n    /* def:graphics */\n    for (i = 0; i < def->ngraphics; ++i) {\n        switch (def->graphics[i]->type) {\n          case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n            if (virVMXFormatVNC(def->graphics[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n          case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n          case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported graphics type '%s'\"),\n                           virDomainGraphicsTypeToString(def->graphics[i]->type));\n            goto cleanup;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n          default:\n              virReportEnumRangeError(virDomainGraphicsType, def->graphics[i]->type);\n              goto cleanup;\n        }\n    }\n\n    /* def:disks */\n    for (i = 0; i < def->ndisks; ++i) {\n        if (virVMXVerifyDiskAddress(xmlopt, def->disks[i], def) < 0 ||\n            virVMXHandleLegacySCSIDiskDriverName(def, def->disks[i]) < 0) {\n            goto cleanup;\n        }\n    }\n\n    if (virVMXGatherSCSIControllers(ctx, def, scsi_virtualDev,\n                                    scsi_present) < 0) {\n        goto cleanup;\n    }\n\n    for (i = 0; i < 4; ++i) {\n        if (scsi_present[i]) {\n            hasSCSI = true;\n\n            virBufferAsprintf(&buffer, \"scsi%zu.present = \\\"true\\\"\\n\", i);\n\n            if (scsi_virtualDev[i] != -1) {\n                virBufferAsprintf(&buffer, \"scsi%zu.virtualDev = \\\"%s\\\"\\n\", i,\n                                  virVMXControllerModelSCSITypeToString\n                                    (scsi_virtualDev[i]));\n            }\n        }\n    }\n\n    for (i = 0; i < def->ndisks; ++i) {\n        switch (def->disks[i]->device) {\n          case VIR_DOMAIN_DISK_DEVICE_DISK:\n          case VIR_DOMAIN_DISK_DEVICE_CDROM:\n          case VIR_DOMAIN_DISK_DEVICE_LUN:\n            if (virVMXFormatDisk(ctx, def->disks[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_DISK_DEVICE_FLOPPY:\n            if (virVMXFormatFloppy(ctx, def->disks[i], &buffer,\n                                   floppy_present) < 0) {\n                goto cleanup;\n            }\n\n            break;\n\n          default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported disk device type '%s'\"),\n                           virDomainDiskDeviceTypeToString(def->disks[i]->device));\n            goto cleanup;\n        }\n    }\n\n    for (i = 0; i < 2; ++i) {\n        /* floppy[0..1].present defaults to true, disable it explicitly */\n        if (! floppy_present[i])\n            virBufferAsprintf(&buffer, \"floppy%zu.present = \\\"false\\\"\\n\", i);\n    }\n\n    /* def:fss */\n    if (def->nfss > 0) {\n        virBufferAddLit(&buffer, \"isolation.tools.hgfs.disable = \\\"false\\\"\\n\");\n        virBufferAsprintf(&buffer, \"sharedFolder.maxNum = \\\"%zu\\\"\\n\", def->nfss);\n    }\n\n    for (i = 0; i < def->nfss; ++i) {\n        if (virVMXFormatFileSystem(def->fss[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:nets */\n    for (i = 0; i < def->nnets; ++i) {\n        if (virVMXFormatEthernet(def->nets[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:videos */\n    if (def->nvideos > 0) {\n        if (def->nvideos > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No support for multiple video devices\"));\n            goto cleanup;\n        }\n\n        if (virVMXFormatSVGA(def->videos[0], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    for (i = 0; i < def->nserials; ++i) {\n        if (virVMXFormatSerial(ctx, def->serials[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:parallels */\n    for (i = 0; i < def->nparallels; ++i) {\n        if (virVMXFormatParallel(ctx, def->parallels[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* vmx:firmware */\n    if (def->os.firmware == VIR_DOMAIN_OS_DEF_FIRMWARE_EFI)\n        virBufferAddLit(&buffer, \"firmware = \\\"efi\\\"\\n\");\n\n    if (virtualHW_version >= 7) {\n        if (hasSCSI) {\n            virBufferAddLit(&buffer, \"pciBridge0.present = \\\"true\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge4.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge5.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge6.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge7.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.functions = \\\"8\\\"\\n\");\n        }\n\n        virBufferAddLit(&buffer, \"vmci0.present = \\\"true\\\"\\n\");\n    }\n\n    /* Get final VMX output */\n    vmx = virBufferContentAndReset(&buffer);\n\n cleanup:\n    if (vmx == NULL)\n        virBufferFreeAndReset(&buffer);\n\n    VIR_FREE(preliminaryDisplayName);\n    VIR_FREE(displayName);\n    VIR_FREE(annotation);\n\n    return vmx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLCheckIllegalChars",
          "args": [
            "\"name\"",
            "vmdef->name",
            "\"\\n\""
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLCheckIllegalChars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "490-502",
          "snippet": "int\nvirXMLCheckIllegalChars(const char *nodeName,\n                        const char *str,\n                        const char *illegal)\n{\n    char *c;\n    if ((c = strpbrk(str, illegal))) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"invalid char in %s: %c\"), nodeName, *c);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXMLCheckIllegalChars(const char *nodeName,\n                        const char *str,\n                        const char *illegal)\n{\n    char *c;\n    if ((c = strpbrk(str, illegal))) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"invalid char in %s: %c\"), nodeName, *c);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefParseString",
          "args": [
            "xml",
            "driver->xmlopt",
            "NULL",
            "parse_flags"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "22134-22141",
          "snippet": "virDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverLock",
          "args": [
            "driver"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "50-54",
          "snippet": "static void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_DEFINE_VALIDATE",
            "NULL"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainPtr\nvmwareDomainDefineXMLFlags(virConnectPtr conn, const char *xml, unsigned int flags)\n{\n    struct vmware_driver *driver = conn->privateData;\n    virDomainDefPtr vmdef = NULL;\n    virDomainObjPtr vm = NULL;\n    virDomainPtr dom = NULL;\n    char *vmx = NULL;\n    char *directoryName = NULL;\n    char *fileName = NULL;\n    char *vmxPath = NULL;\n    vmwareDomainPtr pDomain = NULL;\n    virVMXContext ctx;\n    unsigned int parse_flags = VIR_DOMAIN_DEF_PARSE_INACTIVE;\n\n    virCheckFlags(VIR_DOMAIN_DEFINE_VALIDATE, NULL);\n\n    if (flags & VIR_DOMAIN_DEFINE_VALIDATE)\n        parse_flags |= VIR_DOMAIN_DEF_PARSE_VALIDATE_SCHEMA;\n\n    ctx.parseFileName = NULL;\n    ctx.formatFileName = vmwareCopyVMXFileName;\n    ctx.autodetectSCSIControllerModel = NULL;\n    ctx.datacenterPath = NULL;\n\n    vmwareDriverLock(driver);\n    if ((vmdef = virDomainDefParseString(xml, driver->xmlopt,\n                                         NULL, parse_flags)) == NULL)\n        goto cleanup;\n\n    if (virXMLCheckIllegalChars(\"name\", vmdef->name, \"\\n\") < 0)\n        goto cleanup;\n\n    /* generate vmx file */\n    vmx = virVMXFormatConfig(&ctx, driver->xmlopt, vmdef, 7);\n    if (vmx == NULL)\n        goto cleanup;\n\n    if (vmwareVmxPath(vmdef, &vmxPath) < 0)\n        goto cleanup;\n\n    /* create vmx file */\n    if (virFileWriteStr(vmxPath, vmx, S_IRUSR|S_IWUSR) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to write vmx file '%s'\"), vmxPath);\n        goto cleanup;\n    }\n\n    /* assign def */\n    if (!(vm = virDomainObjListAdd(driver->domains,\n                                   vmdef,\n                                   driver->xmlopt,\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE,\n                                   NULL)))\n        goto cleanup;\n\n    pDomain = vm->privateData;\n    pDomain->vmxPath = g_strdup(vmxPath);\n\n    vmwareDomainConfigDisplay(pDomain, vmdef);\n\n    vmdef = NULL;\n    vm->persistent = 1;\n\n    dom = virGetDomain(conn, vm->def->name, vm->def->uuid, -1);\n\n cleanup:\n    virDomainDefFree(vmdef);\n    VIR_FREE(vmx);\n    VIR_FREE(directoryName);\n    VIR_FREE(fileName);\n    VIR_FREE(vmxPath);\n    if (vm)\n        virObjectUnlock(vm);\n    vmwareDriverUnlock(driver);\n    return dom;\n}"
  },
  {
    "function_name": "vmwareStartVM",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "363-396",
    "snippet": "static int\nvmwareStartVM(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    const char *cmd[] = {\n        driver->vmrun, \"-T\", PROGRAM_SENTINEL, \"start\",\n        PROGRAM_SENTINEL, PROGRAM_SENTINEL, NULL\n    };\n    const char *vmxPath = ((vmwareDomainPtr) vm->privateData)->vmxPath;\n\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_SHUTOFF) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"domain is not in shutoff state\"));\n        return -1;\n    }\n\n    vmwareSetSentinal(cmd, vmwareDriverTypeToString(driver->type));\n    vmwareSetSentinal(cmd, vmxPath);\n    if (!((vmwareDomainPtr) vm->privateData)->gui)\n        vmwareSetSentinal(cmd, NOGUI);\n    else\n        vmwareSetSentinal(cmd, NULL);\n\n    if (virRun(cmd, NULL) < 0)\n        return -1;\n\n    if ((vm->def->id = vmwareExtractPid(vmxPath)) < 0) {\n        vmwareStopVM(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED);\n        return -1;\n    }\n\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, VIR_DOMAIN_RUNNING_BOOTED);\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "VIR_DOMAIN_RUNNING",
            "VIR_DOMAIN_RUNNING_BOOTED"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareStopVM",
          "args": [
            "driver",
            "vm",
            "VIR_DOMAIN_SHUTOFF_FAILED"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareStopVM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "341-361",
          "snippet": "static int\nvmwareStopVM(struct vmware_driver *driver,\n             virDomainObjPtr vm,\n             virDomainShutoffReason reason)\n{\n    const char *cmd[] = {\n        driver->vmrun, \"-T\", PROGRAM_SENTINEL, \"stop\",\n        PROGRAM_SENTINEL, \"soft\", NULL\n    };\n\n    vmwareSetSentinal(cmd, vmwareDriverTypeToString(driver->type));\n    vmwareSetSentinal(cmd, ((vmwareDomainPtr) vm->privateData)->vmxPath);\n\n    if (virRun(cmd, NULL) < 0)\n        return -1;\n\n    vm->def->id = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareStopVM(struct vmware_driver *driver,\n             virDomainObjPtr vm,\n             virDomainShutoffReason reason)\n{\n    const char *cmd[] = {\n        driver->vmrun, \"-T\", PROGRAM_SENTINEL, \"stop\",\n        PROGRAM_SENTINEL, \"soft\", NULL\n    };\n\n    vmwareSetSentinal(cmd, vmwareDriverTypeToString(driver->type));\n    vmwareSetSentinal(cmd, ((vmwareDomainPtr) vm->privateData)->vmxPath);\n\n    if (virRun(cmd, NULL) < 0)\n        return -1;\n\n    vm->def->id = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareExtractPid",
          "args": [
            "vmxPath"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareExtractPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "469-513",
          "snippet": "int\nvmwareExtractPid(const char * vmxPath)\n{\n    char *vmxDir = NULL;\n    char *logFilePath = NULL;\n    FILE *logFile = NULL;\n    char line[1024];\n    char *tmp = NULL;\n    int pid_value = -1;\n\n    vmxDir = g_path_get_dirname(vmxPath);\n\n    logFilePath = g_strdup_printf(\"%s/vmware.log\", vmxDir);\n\n    if ((logFile = fopen(logFilePath, \"r\")) == NULL)\n        goto cleanup;\n\n    if (!fgets(line, sizeof(line), logFile)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to read vmware log file\"));\n        goto cleanup;\n    }\n\n    if ((tmp = strstr(line, \" pid=\")) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot find pid in vmware log file\"));\n        goto cleanup;\n    }\n\n    tmp += strlen(\" pid=\");\n\n    /* Although 64-bit windows allows 64-bit pid_t, a domain id has to be\n     * 32 bits.  For now, we just reject pid values that overflow int.  */\n    if (virStrToLong_i(tmp, &tmp, 10, &pid_value) < 0 || *tmp != ' ') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot parse pid in vmware log file\"));\n        goto cleanup;\n    }\n\n cleanup:\n    VIR_FREE(vmxDir);\n    VIR_FREE(logFilePath);\n    VIR_FORCE_FCLOSE(logFile);\n    return pid_value;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nint\nvmwareExtractPid(const char * vmxPath)\n{\n    char *vmxDir = NULL;\n    char *logFilePath = NULL;\n    FILE *logFile = NULL;\n    char line[1024];\n    char *tmp = NULL;\n    int pid_value = -1;\n\n    vmxDir = g_path_get_dirname(vmxPath);\n\n    logFilePath = g_strdup_printf(\"%s/vmware.log\", vmxDir);\n\n    if ((logFile = fopen(logFilePath, \"r\")) == NULL)\n        goto cleanup;\n\n    if (!fgets(line, sizeof(line), logFile)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to read vmware log file\"));\n        goto cleanup;\n    }\n\n    if ((tmp = strstr(line, \" pid=\")) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot find pid in vmware log file\"));\n        goto cleanup;\n    }\n\n    tmp += strlen(\" pid=\");\n\n    /* Although 64-bit windows allows 64-bit pid_t, a domain id has to be\n     * 32 bits.  For now, we just reject pid values that overflow int.  */\n    if (virStrToLong_i(tmp, &tmp, 10, &pid_value) < 0 || *tmp != ' ') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot parse pid in vmware log file\"));\n        goto cleanup;\n    }\n\n cleanup:\n    VIR_FREE(vmxDir);\n    VIR_FREE(logFilePath);\n    VIR_FORCE_FCLOSE(logFile);\n    return pid_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "virRun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "890-900",
          "snippet": "int\nvirRun(const char *const *argv G_GNUC_UNUSED,\n       int *status)\n{\n    if (status)\n        *status = ENOTSUP;\n    else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virRun is not implemented for WIN32\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirRun(const char *const *argv G_GNUC_UNUSED,\n       int *status)\n{\n    if (status)\n        *status = ENOTSUP;\n    else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virRun is not implemented for WIN32\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareSetSentinal",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareSetSentinal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "207-219",
          "snippet": "void\nvmwareSetSentinal(const char **prog, const char *key)\n{\n    const char **tmp = prog;\n\n    while (tmp && *tmp) {\n        if (*tmp == PROGRAM_SENTINEL) {\n            *tmp = key;\n            break;\n        }\n        tmp++;\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nvoid\nvmwareSetSentinal(const char **prog, const char *key)\n{\n    const char **tmp = prog;\n\n    while (tmp && *tmp) {\n        if (*tmp == PROGRAM_SENTINEL) {\n            *tmp = key;\n            break;\n        }\n        tmp++;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverTypeToString",
          "args": [
            "driver->type"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"domain is not in shutoff state\")"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"domain is not in shutoff state\""
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "NULL"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareStartVM(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    const char *cmd[] = {\n        driver->vmrun, \"-T\", PROGRAM_SENTINEL, \"start\",\n        PROGRAM_SENTINEL, PROGRAM_SENTINEL, NULL\n    };\n    const char *vmxPath = ((vmwareDomainPtr) vm->privateData)->vmxPath;\n\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_SHUTOFF) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"domain is not in shutoff state\"));\n        return -1;\n    }\n\n    vmwareSetSentinal(cmd, vmwareDriverTypeToString(driver->type));\n    vmwareSetSentinal(cmd, vmxPath);\n    if (!((vmwareDomainPtr) vm->privateData)->gui)\n        vmwareSetSentinal(cmd, NOGUI);\n    else\n        vmwareSetSentinal(cmd, NULL);\n\n    if (virRun(cmd, NULL) < 0)\n        return -1;\n\n    if ((vm->def->id = vmwareExtractPid(vmxPath)) < 0) {\n        vmwareStopVM(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED);\n        return -1;\n    }\n\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, VIR_DOMAIN_RUNNING_BOOTED);\n\n    return 0;\n}"
  },
  {
    "function_name": "vmwareStopVM",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "341-361",
    "snippet": "static int\nvmwareStopVM(struct vmware_driver *driver,\n             virDomainObjPtr vm,\n             virDomainShutoffReason reason)\n{\n    const char *cmd[] = {\n        driver->vmrun, \"-T\", PROGRAM_SENTINEL, \"stop\",\n        PROGRAM_SENTINEL, \"soft\", NULL\n    };\n\n    vmwareSetSentinal(cmd, vmwareDriverTypeToString(driver->type));\n    vmwareSetSentinal(cmd, ((vmwareDomainPtr) vm->privateData)->vmxPath);\n\n    if (virRun(cmd, NULL) < 0)\n        return -1;\n\n    vm->def->id = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "VIR_DOMAIN_SHUTOFF",
            "reason"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "virRun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "890-900",
          "snippet": "int\nvirRun(const char *const *argv G_GNUC_UNUSED,\n       int *status)\n{\n    if (status)\n        *status = ENOTSUP;\n    else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virRun is not implemented for WIN32\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirRun(const char *const *argv G_GNUC_UNUSED,\n       int *status)\n{\n    if (status)\n        *status = ENOTSUP;\n    else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virRun is not implemented for WIN32\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareSetSentinal",
          "args": [
            "cmd",
            "((vmwareDomainPtr) vm->privateData)->vmxPath"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareSetSentinal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "207-219",
          "snippet": "void\nvmwareSetSentinal(const char **prog, const char *key)\n{\n    const char **tmp = prog;\n\n    while (tmp && *tmp) {\n        if (*tmp == PROGRAM_SENTINEL) {\n            *tmp = key;\n            break;\n        }\n        tmp++;\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nvoid\nvmwareSetSentinal(const char **prog, const char *key)\n{\n    const char **tmp = prog;\n\n    while (tmp && *tmp) {\n        if (*tmp == PROGRAM_SENTINEL) {\n            *tmp = key;\n            break;\n        }\n        tmp++;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverTypeToString",
          "args": [
            "driver->type"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareStopVM(struct vmware_driver *driver,\n             virDomainObjPtr vm,\n             virDomainShutoffReason reason)\n{\n    const char *cmd[] = {\n        driver->vmrun, \"-T\", PROGRAM_SENTINEL, \"stop\",\n        PROGRAM_SENTINEL, \"soft\", NULL\n    };\n\n    vmwareSetSentinal(cmd, vmwareDriverTypeToString(driver->type));\n    vmwareSetSentinal(cmd, ((vmwareDomainPtr) vm->privateData)->vmxPath);\n\n    if (virRun(cmd, NULL) < 0)\n        return -1;\n\n    vm->def->id = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n\n    return 0;\n}"
  },
  {
    "function_name": "vmwareUpdateVMStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "282-339",
    "snippet": "static int\nvmwareUpdateVMStatus(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    virCommandPtr cmd;\n    char *outbuf = NULL;\n    char *vmxAbsolutePath = NULL;\n    char *parsedVmxPath = NULL;\n    char *str;\n    char *saveptr = NULL;\n    bool found = false;\n    int oldState = virDomainObjGetState(vm, NULL);\n    int newState;\n    int ret = -1;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virFileResolveAllLinks(((vmwareDomainPtr) vm->privateData)->vmxPath,\n                               &vmxAbsolutePath) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (parsedVmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n         str = NULL) {\n\n        if (parsedVmxPath[0] != '/')\n            continue;\n\n        if (STREQ(parsedVmxPath, vmxAbsolutePath)) {\n            found = true;\n            /* If the vmx path is in the output, the domain is running or\n             * is paused but we have no way to detect if it is paused or not. */\n            if (oldState == VIR_DOMAIN_PAUSED)\n                newState = oldState;\n            else\n                newState = VIR_DOMAIN_RUNNING;\n            break;\n        }\n    }\n\n    if (!found) {\n        vm->def->id = -1;\n        newState = VIR_DOMAIN_SHUTOFF;\n    }\n\n    virDomainObjSetState(vm, newState, 0);\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(vmxAbsolutePath);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vmxAbsolutePath"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "outbuf"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "newState",
            "0"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "parsedVmxPath",
            "vmxAbsolutePath"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "str",
            "\"\\n\"",
            "&saveptr"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileResolveAllLinks",
          "args": [
            "((vmwareDomainPtr) vm->privateData)->vmxPath",
            "&vmxAbsolutePath"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "virFileResolveAllLinks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1622-1626",
          "snippet": "int\nvirFileResolveAllLinks(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, true, resultpath);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileResolveAllLinks(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, true, resultpath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputBuffer",
          "args": [
            "cmd",
            "&outbuf"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1869-1884",
          "snippet": "void\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "driver->vmrun",
            "\"-T\"",
            "vmwareDriverTypeToString(driver->type)",
            "\"list\"",
            "NULL"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverTypeToString",
          "args": [
            "driver->type"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "NULL"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareUpdateVMStatus(struct vmware_driver *driver, virDomainObjPtr vm)\n{\n    virCommandPtr cmd;\n    char *outbuf = NULL;\n    char *vmxAbsolutePath = NULL;\n    char *parsedVmxPath = NULL;\n    char *str;\n    char *saveptr = NULL;\n    bool found = false;\n    int oldState = virDomainObjGetState(vm, NULL);\n    int newState;\n    int ret = -1;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virFileResolveAllLinks(((vmwareDomainPtr) vm->privateData)->vmxPath,\n                               &vmxAbsolutePath) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (parsedVmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n         str = NULL) {\n\n        if (parsedVmxPath[0] != '/')\n            continue;\n\n        if (STREQ(parsedVmxPath, vmxAbsolutePath)) {\n            found = true;\n            /* If the vmx path is in the output, the domain is running or\n             * is paused but we have no way to detect if it is paused or not. */\n            if (oldState == VIR_DOMAIN_PAUSED)\n                newState = oldState;\n            else\n                newState = VIR_DOMAIN_RUNNING;\n            break;\n        }\n    }\n\n    if (!found) {\n        vm->def->id = -1;\n        newState = VIR_DOMAIN_SHUTOFF;\n    }\n\n    virDomainObjSetState(vm, newState, 0);\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(vmxAbsolutePath);\n    return ret;\n}"
  },
  {
    "function_name": "vmwareConnectGetVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "271-280",
    "snippet": "static int\nvmwareConnectGetVersion(virConnectPtr conn, unsigned long *version)\n{\n    struct vmware_driver *driver = conn->privateData;\n\n    vmwareDriverLock(driver);\n    *version = driver->version;\n    vmwareDriverUnlock(driver);\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "56-60",
          "snippet": "static void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverLock",
          "args": [
            "driver"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "50-54",
          "snippet": "static void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareConnectGetVersion(virConnectPtr conn, unsigned long *version)\n{\n    struct vmware_driver *driver = conn->privateData;\n\n    vmwareDriverLock(driver);\n    *version = driver->version;\n    vmwareDriverUnlock(driver);\n    return 0;\n}"
  },
  {
    "function_name": "vmwareConnectGetType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "265-269",
    "snippet": "static const char *\nvmwareConnectGetType(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return \"VMware\";\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic const char *\nvmwareConnectGetType(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return \"VMware\";\n}"
  },
  {
    "function_name": "vmwareConnectClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "253-263",
    "snippet": "static int\nvmwareConnectClose(virConnectPtr conn)\n{\n    struct vmware_driver *driver = conn->privateData;\n\n    vmwareFreeDriver(driver);\n\n    conn->privateData = NULL;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareFreeDriver",
          "args": [
            "driver"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareFreeDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "49-61",
          "snippet": "void\nvmwareFreeDriver(struct vmware_driver *driver)\n{\n    if (!driver)\n        return;\n\n    virMutexDestroy(&driver->lock);\n    virObjectUnref(driver->domains);\n    virObjectUnref(driver->caps);\n    virObjectUnref(driver->xmlopt);\n    VIR_FREE(driver->vmrun);\n    VIR_FREE(driver);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nvoid\nvmwareFreeDriver(struct vmware_driver *driver)\n{\n    if (!driver)\n        return;\n\n    virMutexDestroy(&driver->lock);\n    virObjectUnref(driver->domains);\n    virObjectUnref(driver->caps);\n    virObjectUnref(driver->xmlopt);\n    VIR_FREE(driver->vmrun);\n    VIR_FREE(driver);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareConnectClose(virConnectPtr conn)\n{\n    struct vmware_driver *driver = conn->privateData;\n\n    vmwareFreeDriver(driver);\n\n    conn->privateData = NULL;\n\n    return 0;\n}"
  },
  {
    "function_name": "vmwareConnectOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "159-251",
    "snippet": "static virDrvOpenStatus\nvmwareConnectOpen(virConnectPtr conn,\n                  virConnectAuthPtr auth G_GNUC_UNUSED,\n                  virConfPtr conf G_GNUC_UNUSED,\n                  unsigned int flags)\n{\n    struct vmware_driver *driver;\n    size_t i;\n    char *tmp;\n    char *vmrun = NULL;\n\n    virCheckFlags(VIR_CONNECT_RO, VIR_DRV_OPEN_ERROR);\n\n    /* If path isn't /session, then they typoed, so tell them correct path */\n    if (STRNEQ(conn->uri->path, \"/session\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected VMware URI path '%s', try vmwareplayer:///session, vmwarews:///session or vmwarefusion:///session\"),\n                       NULLSTR(conn->uri->path));\n        return VIR_DRV_OPEN_ERROR;\n    }\n\n    /* We now know the URI is definitely for this driver, so beyond\n     * here, don't return DECLINED, always use ERROR */\n\n    if (VIR_ALLOC(driver) < 0)\n        return VIR_DRV_OPEN_ERROR;\n\n    /* Find vmrun, which is what this driver uses to communicate to\n     * the VMware hypervisor. We look this up first since we use it\n     * for auto detection of the backend\n     */\n    for (i = 0; i < G_N_ELEMENTS(vmrun_candidates); i++) {\n        vmrun = virFindFileInPath(vmrun_candidates[i]);\n        if (vmrun == NULL)\n            continue;\n        if (virFileResolveLink(vmrun, &driver->vmrun) < 0) {\n            virReportSystemError(errno, _(\"unable to resolve symlink '%s'\"), vmrun);\n            goto cleanup;\n        }\n        VIR_FREE(vmrun);\n        /* If we found one, we can stop looking */\n        if (driver->vmrun)\n            break;\n    }\n\n    if (driver->vmrun == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"vmrun utility is missing\"));\n        goto cleanup;\n    }\n\n    if (virMutexInit(&driver->lock) < 0)\n        goto cleanup;\n\n    if ((tmp = STRSKIP(conn->uri->scheme, \"vmware\")) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"unable to parse URI \"\n                       \"scheme '%s'\"), conn->uri->scheme);\n        goto cleanup;\n    }\n\n    /* Match the non-'vmware' part of the scheme as the driver backend */\n    driver->type = vmwareDriverTypeFromString(tmp);\n\n    if (driver->type == -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"unable to find valid \"\n                       \"requested VMware backend '%s'\"), tmp);\n        goto cleanup;\n    }\n\n    if (vmwareExtractVersion(driver) < 0)\n        goto cleanup;\n\n    if (!(driver->domains = virDomainObjListNew()))\n        goto cleanup;\n\n    if (!(driver->caps = vmwareCapsInit()))\n        goto cleanup;\n\n    if (!(driver->xmlopt = vmwareDomainXMLConfigInit(driver)))\n        goto cleanup;\n\n    if (vmwareLoadDomains(driver) < 0)\n        goto cleanup;\n\n    conn->privateData = driver;\n\n    return VIR_DRV_OPEN_SUCCESS;\n\n cleanup:\n    vmwareFreeDriver(driver);\n    VIR_FREE(vmrun);\n    return VIR_DRV_OPEN_ERROR;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const vmrun_candidates[] = {\n    \"vmrun\",\n#ifdef __APPLE__\n    \"/Applications/VMware Fusion.app/Contents/Library/vmrun\",\n    \"/Library/Application Support/VMware Fusion/vmrun\",\n#endif /* __APPLE__ */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vmrun"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmwareFreeDriver",
          "args": [
            "driver"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareFreeDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "49-61",
          "snippet": "void\nvmwareFreeDriver(struct vmware_driver *driver)\n{\n    if (!driver)\n        return;\n\n    virMutexDestroy(&driver->lock);\n    virObjectUnref(driver->domains);\n    virObjectUnref(driver->caps);\n    virObjectUnref(driver->xmlopt);\n    VIR_FREE(driver->vmrun);\n    VIR_FREE(driver);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nvoid\nvmwareFreeDriver(struct vmware_driver *driver)\n{\n    if (!driver)\n        return;\n\n    virMutexDestroy(&driver->lock);\n    virObjectUnref(driver->domains);\n    virObjectUnref(driver->caps);\n    virObjectUnref(driver->xmlopt);\n    VIR_FREE(driver->vmrun);\n    VIR_FREE(driver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareLoadDomains",
          "args": [
            "driver"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareLoadDomains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "127-205",
          "snippet": "int\nvmwareLoadDomains(struct vmware_driver *driver)\n{\n    virDomainDefPtr vmdef = NULL;\n    virDomainObjPtr vm = NULL;\n    char *vmxPath = NULL;\n    char *vmx = NULL;\n    vmwareDomainPtr pDomain;\n    char *directoryName = NULL;\n    char *fileName = NULL;\n    int ret = -1;\n    virVMXContext ctx;\n    char *outbuf = NULL;\n    char *str;\n    char *saveptr = NULL;\n    virCommandPtr cmd;\n\n    ctx.parseFileName = vmwareCopyVMXFileName;\n    ctx.formatFileName = NULL;\n    ctx.autodetectSCSIControllerModel = NULL;\n    ctx.datacenterPath = NULL;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (vmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n        str = NULL) {\n\n        if (vmxPath[0] != '/')\n            continue;\n\n        if (virFileReadAll(vmxPath, 10000, &vmx) < 0)\n            goto cleanup;\n\n        if ((vmdef =\n             virVMXParseConfig(&ctx, driver->xmlopt,\n                               driver->caps, vmx)) == NULL) {\n            goto cleanup;\n        }\n\n        if (!(vm = virDomainObjListAdd(driver->domains, vmdef,\n                                       driver->xmlopt,\n                                       0, NULL)))\n            goto cleanup;\n\n        pDomain = vm->privateData;\n\n        pDomain->vmxPath = g_strdup(vmxPath);\n\n        vmwareDomainConfigDisplay(pDomain, vmdef);\n\n        if ((vm->def->id = vmwareExtractPid(vmxPath)) < 0)\n            goto cleanup;\n        /* vmrun list only reports running vms */\n        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_UNKNOWN);\n        vm->persistent = 1;\n\n        virDomainObjEndAPI(&vm);\n\n        vmdef = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    virDomainDefFree(vmdef);\n    VIR_FREE(directoryName);\n    VIR_FREE(fileName);\n    VIR_FREE(vmx);\n    virObjectUnref(vm);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nint\nvmwareLoadDomains(struct vmware_driver *driver)\n{\n    virDomainDefPtr vmdef = NULL;\n    virDomainObjPtr vm = NULL;\n    char *vmxPath = NULL;\n    char *vmx = NULL;\n    vmwareDomainPtr pDomain;\n    char *directoryName = NULL;\n    char *fileName = NULL;\n    int ret = -1;\n    virVMXContext ctx;\n    char *outbuf = NULL;\n    char *str;\n    char *saveptr = NULL;\n    virCommandPtr cmd;\n\n    ctx.parseFileName = vmwareCopyVMXFileName;\n    ctx.formatFileName = NULL;\n    ctx.autodetectSCSIControllerModel = NULL;\n    ctx.datacenterPath = NULL;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (vmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n        str = NULL) {\n\n        if (vmxPath[0] != '/')\n            continue;\n\n        if (virFileReadAll(vmxPath, 10000, &vmx) < 0)\n            goto cleanup;\n\n        if ((vmdef =\n             virVMXParseConfig(&ctx, driver->xmlopt,\n                               driver->caps, vmx)) == NULL) {\n            goto cleanup;\n        }\n\n        if (!(vm = virDomainObjListAdd(driver->domains, vmdef,\n                                       driver->xmlopt,\n                                       0, NULL)))\n            goto cleanup;\n\n        pDomain = vm->privateData;\n\n        pDomain->vmxPath = g_strdup(vmxPath);\n\n        vmwareDomainConfigDisplay(pDomain, vmdef);\n\n        if ((vm->def->id = vmwareExtractPid(vmxPath)) < 0)\n            goto cleanup;\n        /* vmrun list only reports running vms */\n        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_UNKNOWN);\n        vm->persistent = 1;\n\n        virDomainObjEndAPI(&vm);\n\n        vmdef = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    virDomainDefFree(vmdef);\n    VIR_FREE(directoryName);\n    VIR_FREE(fileName);\n    VIR_FREE(vmx);\n    virObjectUnref(vm);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomainXMLConfigInit",
          "args": [
            "driver"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomainXMLConfigInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "149-157",
          "snippet": "static virDomainXMLOptionPtr\nvmwareDomainXMLConfigInit(struct vmware_driver *driver)\n{\n    virDomainXMLPrivateDataCallbacks priv = { .alloc = vmwareDataAllocFunc,\n                                              .free = vmwareDataFreeFunc };\n    vmwareDomainDefParserConfig.priv = driver;\n    return virDomainXMLOptionNew(&vmwareDomainDefParserConfig, &priv,\n                                 NULL, NULL, NULL);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virDomainDefParserConfig vmwareDomainDefParserConfig = {\n    .devicesPostParseCallback = vmwareDomainDeviceDefPostParse,\n    .domainPostParseCallback = vmwareDomainDefPostParse,\n    .defArch = VIR_ARCH_I686,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefParserConfig vmwareDomainDefParserConfig = {\n    .devicesPostParseCallback = vmwareDomainDeviceDefPostParse,\n    .domainPostParseCallback = vmwareDomainDefPostParse,\n    .defArch = VIR_ARCH_I686,\n};\n\nstatic virDomainXMLOptionPtr\nvmwareDomainXMLConfigInit(struct vmware_driver *driver)\n{\n    virDomainXMLPrivateDataCallbacks priv = { .alloc = vmwareDataAllocFunc,\n                                              .free = vmwareDataFreeFunc };\n    vmwareDomainDefParserConfig.priv = driver;\n    return virDomainXMLOptionNew(&vmwareDomainDefParserConfig, &priv,\n                                 NULL, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareCapsInit",
          "args": [],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareCapsInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "64-125",
          "snippet": "virCapsPtr\nvmwareCapsInit(void)\n{\n    virCapsPtr caps = NULL;\n    virCapsGuestPtr guest = NULL;\n\n    if ((caps = virCapabilitiesNew(virArchFromHost(),\n                                   false, false)) == NULL)\n        goto error;\n\n    if (!(caps->host.numa = virCapabilitiesHostNUMANewHost()))\n        goto error;\n\n    if (virCapabilitiesInitCaches(caps) < 0)\n        VIR_WARN(\"Failed to get host CPU cache info\");\n\n    /* i686 guests are always supported */\n    if ((guest = virCapabilitiesAddGuest(caps,\n                                         VIR_DOMAIN_OSTYPE_HVM,\n                                         VIR_ARCH_I686,\n                                         NULL, NULL, 0, NULL)) == NULL)\n        goto error;\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      VIR_DOMAIN_VIRT_VMWARE,\n                                      NULL, NULL, 0, NULL) == NULL)\n        goto error;\n    guest = NULL;\n\n    if (!(caps->host.cpu = virCPUProbeHost(caps->host.arch)))\n        goto error;\n\n    /* x86_64 guests are supported if\n     *  - Host arch is x86_64\n     * Or\n     *  - Host CPU is x86_64 with virtualization extensions\n     */\n    if (caps->host.arch == VIR_ARCH_X86_64 ||\n        (virCPUCheckFeature(caps->host.cpu->arch, caps->host.cpu, \"lm\") &&\n         (virCPUCheckFeature(caps->host.cpu->arch, caps->host.cpu, \"vmx\") ||\n          virCPUCheckFeature(caps->host.cpu->arch, caps->host.cpu, \"svm\")))) {\n\n        if ((guest = virCapabilitiesAddGuest(caps,\n                                             VIR_DOMAIN_OSTYPE_HVM,\n                                             VIR_ARCH_X86_64,\n                                             NULL, NULL, 0, NULL)) == NULL)\n            goto error;\n\n        if (virCapabilitiesAddGuestDomain(guest,\n                                          VIR_DOMAIN_VIRT_VMWARE,\n                                          NULL, NULL, 0, NULL) == NULL)\n            goto error;\n        guest = NULL;\n    }\n\n    return caps;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    virObjectUnref(caps);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nvirCapsPtr\nvmwareCapsInit(void)\n{\n    virCapsPtr caps = NULL;\n    virCapsGuestPtr guest = NULL;\n\n    if ((caps = virCapabilitiesNew(virArchFromHost(),\n                                   false, false)) == NULL)\n        goto error;\n\n    if (!(caps->host.numa = virCapabilitiesHostNUMANewHost()))\n        goto error;\n\n    if (virCapabilitiesInitCaches(caps) < 0)\n        VIR_WARN(\"Failed to get host CPU cache info\");\n\n    /* i686 guests are always supported */\n    if ((guest = virCapabilitiesAddGuest(caps,\n                                         VIR_DOMAIN_OSTYPE_HVM,\n                                         VIR_ARCH_I686,\n                                         NULL, NULL, 0, NULL)) == NULL)\n        goto error;\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      VIR_DOMAIN_VIRT_VMWARE,\n                                      NULL, NULL, 0, NULL) == NULL)\n        goto error;\n    guest = NULL;\n\n    if (!(caps->host.cpu = virCPUProbeHost(caps->host.arch)))\n        goto error;\n\n    /* x86_64 guests are supported if\n     *  - Host arch is x86_64\n     * Or\n     *  - Host CPU is x86_64 with virtualization extensions\n     */\n    if (caps->host.arch == VIR_ARCH_X86_64 ||\n        (virCPUCheckFeature(caps->host.cpu->arch, caps->host.cpu, \"lm\") &&\n         (virCPUCheckFeature(caps->host.cpu->arch, caps->host.cpu, \"vmx\") ||\n          virCPUCheckFeature(caps->host.cpu->arch, caps->host.cpu, \"svm\")))) {\n\n        if ((guest = virCapabilitiesAddGuest(caps,\n                                             VIR_DOMAIN_OSTYPE_HVM,\n                                             VIR_ARCH_X86_64,\n                                             NULL, NULL, 0, NULL)) == NULL)\n            goto error;\n\n        if (virCapabilitiesAddGuestDomain(guest,\n                                          VIR_DOMAIN_VIRT_VMWARE,\n                                          NULL, NULL, 0, NULL) == NULL)\n            goto error;\n        guest = NULL;\n    }\n\n    return caps;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    virObjectUnref(caps);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListNew",
          "args": [],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "68-85",
          "snippet": "virDomainObjListPtr virDomainObjListNew(void)\n{\n    virDomainObjListPtr doms;\n\n    if (virDomainObjListInitialize() < 0)\n        return NULL;\n\n    if (!(doms = virObjectRWLockableNew(virDomainObjListClass)))\n        return NULL;\n\n    if (!(doms->objs = virHashCreate(50, virObjectFreeHashData)) ||\n        !(doms->objsName = virHashCreate(50, virObjectFreeHashData))) {\n        virObjectUnref(doms);\n        return NULL;\n    }\n\n    return doms;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virDomainObjListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virClassPtr virDomainObjListClass;\n\nvirDomainObjListPtr virDomainObjListNew(void)\n{\n    virDomainObjListPtr doms;\n\n    if (virDomainObjListInitialize() < 0)\n        return NULL;\n\n    if (!(doms = virObjectRWLockableNew(virDomainObjListClass)))\n        return NULL;\n\n    if (!(doms->objs = virHashCreate(50, virObjectFreeHashData)) ||\n        !(doms->objsName = virHashCreate(50, virObjectFreeHashData))) {\n        virObjectUnref(doms);\n        return NULL;\n    }\n\n    return doms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareExtractVersion",
          "args": [
            "driver"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareExtractVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "264-312",
          "snippet": "int\nvmwareExtractVersion(struct vmware_driver *driver)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    char * outbuf = NULL;\n    char *bin = NULL;\n    char *vmwarePath = NULL;\n\n    vmwarePath = g_path_get_dirname(driver->vmrun);\n\n    switch (driver->type) {\n        case VMWARE_DRIVER_PLAYER:\n            bin = g_strdup_printf(\"%s/%s\", vmwarePath, \"vmplayer\");\n            break;\n\n        case VMWARE_DRIVER_WORKSTATION:\n            bin = g_strdup_printf(\"%s/%s\", vmwarePath, \"vmware\");\n            break;\n\n        case VMWARE_DRIVER_FUSION:\n            bin = g_strdup_printf(\"%s/%s\", vmwarePath, \"vmware-vmx\");\n            break;\n\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid driver type for version detection\"));\n            goto cleanup;\n    }\n\n    cmd = virCommandNewArgList(bin, \"-v\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    virCommandSetErrorBuffer(cmd, &outbuf);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (vmwareParseVersionStr(driver->type, outbuf, &driver->version) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(bin);\n    VIR_FREE(vmwarePath);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nint\nvmwareExtractVersion(struct vmware_driver *driver)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    char * outbuf = NULL;\n    char *bin = NULL;\n    char *vmwarePath = NULL;\n\n    vmwarePath = g_path_get_dirname(driver->vmrun);\n\n    switch (driver->type) {\n        case VMWARE_DRIVER_PLAYER:\n            bin = g_strdup_printf(\"%s/%s\", vmwarePath, \"vmplayer\");\n            break;\n\n        case VMWARE_DRIVER_WORKSTATION:\n            bin = g_strdup_printf(\"%s/%s\", vmwarePath, \"vmware\");\n            break;\n\n        case VMWARE_DRIVER_FUSION:\n            bin = g_strdup_printf(\"%s/%s\", vmwarePath, \"vmware-vmx\");\n            break;\n\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid driver type for version detection\"));\n            goto cleanup;\n    }\n\n    cmd = virCommandNewArgList(bin, \"-v\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    virCommandSetErrorBuffer(cmd, &outbuf);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (vmwareParseVersionStr(driver->type, outbuf, &driver->version) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(bin);\n    VIR_FREE(vmwarePath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unable to find valid \"\n                       \"requested VMware backend '%s'\")",
            "tmp"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to find valid \"\n                       \"requested VMware backend '%s'\""
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverTypeFromString",
          "args": [
            "tmp"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unable to parse URI \"\n                       \"scheme '%s'\")",
            "conn->uri->scheme"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRSKIP",
          "args": [
            "conn->uri->scheme",
            "\"vmware\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexInit",
          "args": [
            "&driver->lock"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexInitRecursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "61-74",
          "snippet": "int virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"vmrun utility is missing\")"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vmrun"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to resolve symlink '%s'\")",
            "vmrun"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileResolveLink",
          "args": [
            "vmrun",
            "&driver->vmrun"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "virFileResolveLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1608-1612",
          "snippet": "int\nvirFileResolveLink(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, false, resultpath);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileResolveLink(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, false, resultpath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFindFileInPath",
          "args": [
            "vmrun_candidates[i]"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "virFindFileInPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1657-1709",
          "snippet": "char *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "vmrun_candidates"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "driver"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected VMware URI path '%s', try vmwareplayer:///session, vmwarews:///session or vmwarefusion:///session\")",
            "NULLSTR(conn->uri->path)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "conn->uri->path"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "conn->uri->path",
            "\"/session\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_CONNECT_RO",
            "VIR_DRV_OPEN_ERROR"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic const char * const vmrun_candidates[] = {\n    \"vmrun\",\n#ifdef __APPLE__\n    \"/Applications/VMware Fusion.app/Contents/Library/vmrun\",\n    \"/Library/Application Support/VMware Fusion/vmrun\",\n#endif /* __APPLE__ */\n};\n\nstatic virDrvOpenStatus\nvmwareConnectOpen(virConnectPtr conn,\n                  virConnectAuthPtr auth G_GNUC_UNUSED,\n                  virConfPtr conf G_GNUC_UNUSED,\n                  unsigned int flags)\n{\n    struct vmware_driver *driver;\n    size_t i;\n    char *tmp;\n    char *vmrun = NULL;\n\n    virCheckFlags(VIR_CONNECT_RO, VIR_DRV_OPEN_ERROR);\n\n    /* If path isn't /session, then they typoed, so tell them correct path */\n    if (STRNEQ(conn->uri->path, \"/session\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected VMware URI path '%s', try vmwareplayer:///session, vmwarews:///session or vmwarefusion:///session\"),\n                       NULLSTR(conn->uri->path));\n        return VIR_DRV_OPEN_ERROR;\n    }\n\n    /* We now know the URI is definitely for this driver, so beyond\n     * here, don't return DECLINED, always use ERROR */\n\n    if (VIR_ALLOC(driver) < 0)\n        return VIR_DRV_OPEN_ERROR;\n\n    /* Find vmrun, which is what this driver uses to communicate to\n     * the VMware hypervisor. We look this up first since we use it\n     * for auto detection of the backend\n     */\n    for (i = 0; i < G_N_ELEMENTS(vmrun_candidates); i++) {\n        vmrun = virFindFileInPath(vmrun_candidates[i]);\n        if (vmrun == NULL)\n            continue;\n        if (virFileResolveLink(vmrun, &driver->vmrun) < 0) {\n            virReportSystemError(errno, _(\"unable to resolve symlink '%s'\"), vmrun);\n            goto cleanup;\n        }\n        VIR_FREE(vmrun);\n        /* If we found one, we can stop looking */\n        if (driver->vmrun)\n            break;\n    }\n\n    if (driver->vmrun == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"vmrun utility is missing\"));\n        goto cleanup;\n    }\n\n    if (virMutexInit(&driver->lock) < 0)\n        goto cleanup;\n\n    if ((tmp = STRSKIP(conn->uri->scheme, \"vmware\")) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"unable to parse URI \"\n                       \"scheme '%s'\"), conn->uri->scheme);\n        goto cleanup;\n    }\n\n    /* Match the non-'vmware' part of the scheme as the driver backend */\n    driver->type = vmwareDriverTypeFromString(tmp);\n\n    if (driver->type == -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"unable to find valid \"\n                       \"requested VMware backend '%s'\"), tmp);\n        goto cleanup;\n    }\n\n    if (vmwareExtractVersion(driver) < 0)\n        goto cleanup;\n\n    if (!(driver->domains = virDomainObjListNew()))\n        goto cleanup;\n\n    if (!(driver->caps = vmwareCapsInit()))\n        goto cleanup;\n\n    if (!(driver->xmlopt = vmwareDomainXMLConfigInit(driver)))\n        goto cleanup;\n\n    if (vmwareLoadDomains(driver) < 0)\n        goto cleanup;\n\n    conn->privateData = driver;\n\n    return VIR_DRV_OPEN_SUCCESS;\n\n cleanup:\n    vmwareFreeDriver(driver);\n    VIR_FREE(vmrun);\n    return VIR_DRV_OPEN_ERROR;\n}"
  },
  {
    "function_name": "vmwareDomainXMLConfigInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "149-157",
    "snippet": "static virDomainXMLOptionPtr\nvmwareDomainXMLConfigInit(struct vmware_driver *driver)\n{\n    virDomainXMLPrivateDataCallbacks priv = { .alloc = vmwareDataAllocFunc,\n                                              .free = vmwareDataFreeFunc };\n    vmwareDomainDefParserConfig.priv = driver;\n    return virDomainXMLOptionNew(&vmwareDomainDefParserConfig, &priv,\n                                 NULL, NULL, NULL);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virDomainDefParserConfig vmwareDomainDefParserConfig = {\n    .devicesPostParseCallback = vmwareDomainDeviceDefPostParse,\n    .domainPostParseCallback = vmwareDomainDefPostParse,\n    .defArch = VIR_ARCH_I686,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainXMLOptionNew",
          "args": [
            "&vmwareDomainDefParserConfig",
            "&priv",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainXMLOptionNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1415-1458",
          "snippet": "virDomainXMLOptionPtr\nvirDomainXMLOptionNew(virDomainDefParserConfigPtr config,\n                      virDomainXMLPrivateDataCallbacksPtr priv,\n                      virXMLNamespacePtr xmlns,\n                      virDomainABIStabilityPtr abi,\n                      virSaveCookieCallbacksPtr saveCookie)\n{\n    virDomainXMLOptionPtr xmlopt;\n\n    if (virDomainObjInitialize() < 0)\n        return NULL;\n\n    if (!(xmlopt = virObjectNew(virDomainXMLOptionClass)))\n        return NULL;\n\n    if (priv)\n        xmlopt->privateData = *priv;\n\n    if (config)\n        xmlopt->config = *config;\n\n    if (xmlns)\n        xmlopt->ns = *xmlns;\n\n    if (abi)\n        xmlopt->abi = *abi;\n\n    if (saveCookie)\n        xmlopt->saveCookie = *saveCookie;\n\n    /* Technically this forbids to use one of Xerox's MAC address prefixes in\n     * our hypervisor drivers. This shouldn't ever be a problem.\n     *\n     * Use the KVM prefix as default as it's in the privately administered\n     * range */\n    if (xmlopt->config.macPrefix[0] == 0 &&\n        xmlopt->config.macPrefix[1] == 0 &&\n        xmlopt->config.macPrefix[2] == 0) {\n        xmlopt->config.macPrefix[0] = 0x52;\n        xmlopt->config.macPrefix[1] = 0x54;\n    }\n\n    return xmlopt;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virDomainXMLOptionClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virClassPtr virDomainXMLOptionClass;\n\nvirDomainXMLOptionPtr\nvirDomainXMLOptionNew(virDomainDefParserConfigPtr config,\n                      virDomainXMLPrivateDataCallbacksPtr priv,\n                      virXMLNamespacePtr xmlns,\n                      virDomainABIStabilityPtr abi,\n                      virSaveCookieCallbacksPtr saveCookie)\n{\n    virDomainXMLOptionPtr xmlopt;\n\n    if (virDomainObjInitialize() < 0)\n        return NULL;\n\n    if (!(xmlopt = virObjectNew(virDomainXMLOptionClass)))\n        return NULL;\n\n    if (priv)\n        xmlopt->privateData = *priv;\n\n    if (config)\n        xmlopt->config = *config;\n\n    if (xmlns)\n        xmlopt->ns = *xmlns;\n\n    if (abi)\n        xmlopt->abi = *abi;\n\n    if (saveCookie)\n        xmlopt->saveCookie = *saveCookie;\n\n    /* Technically this forbids to use one of Xerox's MAC address prefixes in\n     * our hypervisor drivers. This shouldn't ever be a problem.\n     *\n     * Use the KVM prefix as default as it's in the privately administered\n     * range */\n    if (xmlopt->config.macPrefix[0] == 0 &&\n        xmlopt->config.macPrefix[1] == 0 &&\n        xmlopt->config.macPrefix[2] == 0) {\n        xmlopt->config.macPrefix[0] = 0x52;\n        xmlopt->config.macPrefix[1] = 0x54;\n    }\n\n    return xmlopt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefParserConfig vmwareDomainDefParserConfig = {\n    .devicesPostParseCallback = vmwareDomainDeviceDefPostParse,\n    .domainPostParseCallback = vmwareDomainDefPostParse,\n    .defArch = VIR_ARCH_I686,\n};\n\nstatic virDomainXMLOptionPtr\nvmwareDomainXMLConfigInit(struct vmware_driver *driver)\n{\n    virDomainXMLPrivateDataCallbacks priv = { .alloc = vmwareDataAllocFunc,\n                                              .free = vmwareDataFreeFunc };\n    vmwareDomainDefParserConfig.priv = driver;\n    return virDomainXMLOptionNew(&vmwareDomainDefParserConfig, &priv,\n                                 NULL, NULL, NULL);\n}"
  },
  {
    "function_name": "vmwareDomainDeviceDefPostParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "133-141",
    "snippet": "static int\nvmwareDomainDeviceDefPostParse(virDomainDeviceDefPtr dev G_GNUC_UNUSED,\n                               const virDomainDef *def G_GNUC_UNUSED,\n                               unsigned int parseFlags G_GNUC_UNUSED,\n                               void *opaque G_GNUC_UNUSED,\n                               void *parseOpaque G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainDeviceDefPostParse(virDomainDeviceDefPtr dev G_GNUC_UNUSED,\n                               const virDomainDef *def G_GNUC_UNUSED,\n                               unsigned int parseFlags G_GNUC_UNUSED,\n                               void *opaque G_GNUC_UNUSED,\n                               void *parseOpaque G_GNUC_UNUSED)\n{\n    return 0;\n}"
  },
  {
    "function_name": "vmwareDomainDefPostParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "118-131",
    "snippet": "static int\nvmwareDomainDefPostParse(virDomainDefPtr def,\n                         unsigned int parseFlags G_GNUC_UNUSED,\n                         void *opaque G_GNUC_UNUSED,\n                         void *parseOpaque G_GNUC_UNUSED)\n{\n    struct vmware_driver *driver = opaque;\n    if (!virCapabilitiesDomainSupported(driver->caps, def->os.type,\n                                        def->os.arch,\n                                        def->virtType))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCapabilitiesDomainSupported",
          "args": [
            "driver->caps",
            "def->os.type",
            "def->os.arch",
            "def->virtType"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesDomainSupported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "787-801",
          "snippet": "bool\nvirCapabilitiesDomainSupported(virCapsPtr caps,\n                               int ostype,\n                               virArch arch,\n                               int virttype)\n{\n    g_autofree virCapsDomainDataPtr capsdata = NULL;\n\n    capsdata = virCapabilitiesDomainDataLookup(caps, ostype,\n                                               arch,\n                                               virttype,\n                                               NULL, NULL);\n\n    return capsdata != NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirCapabilitiesDomainSupported(virCapsPtr caps,\n                               int ostype,\n                               virArch arch,\n                               int virttype)\n{\n    g_autofree virCapsDomainDataPtr capsdata = NULL;\n\n    capsdata = virCapabilitiesDomainDataLookup(caps, ostype,\n                                               arch,\n                                               virttype,\n                                               NULL, NULL);\n\n    return capsdata != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvmwareDomainDefPostParse(virDomainDefPtr def,\n                         unsigned int parseFlags G_GNUC_UNUSED,\n                         void *opaque G_GNUC_UNUSED,\n                         void *parseOpaque G_GNUC_UNUSED)\n{\n    struct vmware_driver *driver = opaque;\n    if (!virCapabilitiesDomainSupported(driver->caps, def->os.type,\n                                        def->os.arch,\n                                        def->virtType))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "vmwareDataFreeFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "109-116",
    "snippet": "static void\nvmwareDataFreeFunc(void *data)\n{\n    vmwareDomainPtr dom = data;\n\n    VIR_FREE(dom->vmxPath);\n    VIR_FREE(dom);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dom"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dom->vmxPath"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDataFreeFunc(void *data)\n{\n    vmwareDomainPtr dom = data;\n\n    VIR_FREE(dom->vmxPath);\n    VIR_FREE(dom);\n}"
  },
  {
    "function_name": "vmwareDataAllocFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "95-107",
    "snippet": "static void *\nvmwareDataAllocFunc(void *opaque G_GNUC_UNUSED)\n{\n    vmwareDomainPtr dom;\n\n    if (VIR_ALLOC(dom) < 0)\n        return NULL;\n\n    dom->vmxPath = NULL;\n    dom->gui = true;\n\n    return dom;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "dom"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void *\nvmwareDataAllocFunc(void *opaque G_GNUC_UNUSED)\n{\n    vmwareDomainPtr dom;\n\n    if (VIR_ALLOC(dom) < 0)\n        return NULL;\n\n    dom->vmxPath = NULL;\n    dom->gui = true;\n\n    return dom;\n}"
  },
  {
    "function_name": "vmwareDomObjFromDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "82-92",
    "snippet": "static virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmwareDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "56-60",
          "snippet": "static void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomObjFromDomainLocked",
          "args": [
            "driver",
            "uuid"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomObjFromDomainLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "63-79",
          "snippet": "static virDomainObjPtr\nvmwareDomObjFromDomainLocked(struct vmware_driver *driver,\n                             const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (!(vm = virDomainObjListFindByUUID(driver->domains, uuid))) {\n        virUUIDFormat(uuid, uuidstr);\n\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching uuid '%s'\"), uuidstr);\n        return NULL;\n    }\n\n    return vm;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainObjPtr\nvmwareDomObjFromDomainLocked(struct vmware_driver *driver,\n                             const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (!(vm = virDomainObjListFindByUUID(driver->domains, uuid))) {\n        virUUIDFormat(uuid, uuidstr);\n\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching uuid '%s'\"), uuidstr);\n        return NULL;\n    }\n\n    return vm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverLock",
          "args": [
            "driver"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
          "lines": "50-54",
          "snippet": "static void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vmware_driver.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainObjPtr\nvmwareDomObjFromDomain(struct vmware_driver *driver,\n                       const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n\n    vmwareDriverLock(driver);\n    vm = vmwareDomObjFromDomainLocked(driver, uuid);\n    vmwareDriverUnlock(driver);\n    return vm;\n}"
  },
  {
    "function_name": "vmwareDomObjFromDomainLocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "63-79",
    "snippet": "static virDomainObjPtr\nvmwareDomObjFromDomainLocked(struct vmware_driver *driver,\n                             const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (!(vm = virDomainObjListFindByUUID(driver->domains, uuid))) {\n        virUUIDFormat(uuid, uuidstr);\n\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching uuid '%s'\"), uuidstr);\n        return NULL;\n    }\n\n    return vm;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "_(\"no domain with matching uuid '%s'\")",
            "uuidstr"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no domain with matching uuid '%s'\""
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "uuid",
            "uuidstr"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListFindByUUID",
          "args": [
            "driver->domains",
            "uuid"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListFindByUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "162-179",
          "snippet": "virDomainObjPtr\nvirDomainObjListFindByUUID(virDomainObjListPtr doms,\n                           const unsigned char *uuid)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByUUIDLocked(doms, uuid);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virDomainObjListDispose(void *obj);\n\nvirDomainObjPtr\nvirDomainObjListFindByUUID(virDomainObjListPtr doms,\n                           const unsigned char *uuid)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByUUIDLocked(doms, uuid);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainObjPtr\nvmwareDomObjFromDomainLocked(struct vmware_driver *driver,\n                             const unsigned char *uuid)\n{\n    virDomainObjPtr vm;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (!(vm = virDomainObjListFindByUUID(driver->domains, uuid))) {\n        virUUIDFormat(uuid, uuidstr);\n\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching uuid '%s'\"), uuidstr);\n        return NULL;\n    }\n\n    return vm;\n}"
  },
  {
    "function_name": "vmwareDriverUnlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "56-60",
    "snippet": "static void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&driver->lock"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverUnlock(struct vmware_driver *driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
  },
  {
    "function_name": "vmwareDriverLock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_driver.c",
    "lines": "50-54",
    "snippet": "static void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vmware_driver.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&driver->lock"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vmware_driver.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvmwareDriverLock(struct vmware_driver *driver)\n{\n    virMutexLock(&driver->lock);\n}"
  }
]