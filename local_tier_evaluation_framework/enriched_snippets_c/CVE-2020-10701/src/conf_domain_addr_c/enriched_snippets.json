[
  {
    "function_name": "virDomainUSBAddressRelease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "2453-2475",
    "snippet": "int\nvirDomainUSBAddressRelease(virDomainUSBAddressSetPtr addrs,\n                           virDomainDeviceInfoPtr info)\n{\n    virDomainUSBAddressHubPtr targetHub = NULL;\n    g_autofree char *portStr = NULL;\n    int targetPort;\n\n    if (!addrs || info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB ||\n        !virDomainUSBAddressPortIsValid(info->addr.usb.port))\n        return 0;\n\n    portStr = virDomainUSBAddressPortFormat(info->addr.usb.port);\n    VIR_DEBUG(\"Releasing USB addr bus=%u port=%s\", info->addr.usb.bus, portStr);\n\n    if (!(targetHub = virDomainUSBAddressFindPort(addrs, info, &targetPort,\n                                                  portStr)))\n        return -1;\n\n    ignore_value(virBitmapClearBit(targetHub->portmap, targetPort));\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapClearBit(targetHub->portmap, targetPort)"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapClearBit",
          "args": [
            "targetHub->portmap",
            "targetPort"
          ],
          "line": 2472
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapClearBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "265-277",
          "snippet": "int\nvirBitmapClearBitExpand(virBitmapPtr bitmap,\n                        size_t b)\n{\n    if (bitmap->nbits <= b) {\n        if (virBitmapExpand(bitmap, b) < 0)\n            return -1;\n    } else {\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] &= ~VIR_BITMAP_BIT(b);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapClearBitExpand(virBitmapPtr bitmap,\n                        size_t b)\n{\n    if (bitmap->nbits <= b) {\n        if (virBitmapExpand(bitmap, b) < 0)\n            return -1;\n    } else {\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] &= ~VIR_BITMAP_BIT(b);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressFindPort",
          "args": [
            "addrs",
            "info",
            "&targetPort",
            "portStr"
          ],
          "line": 2468
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressFindPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2124-2176",
          "snippet": "static virDomainUSBAddressHubPtr\nvirDomainUSBAddressFindPort(virDomainUSBAddressSetPtr addrs,\n                            virDomainDeviceInfoPtr info,\n                            int *targetIdx,\n                            const char *portStr)\n{\n    virDomainUSBAddressHubPtr hub = NULL;\n    ssize_t i, lastIdx, targetPort;\n\n    if (info->addr.usb.bus >= addrs->nbuses ||\n        !addrs->buses[info->addr.usb.bus]) {\n        virReportError(VIR_ERR_XML_ERROR, _(\"Missing USB bus %u\"),\n                       info->addr.usb.bus);\n        return NULL;\n    }\n    hub = addrs->buses[info->addr.usb.bus];\n\n    lastIdx = virDomainUSBAddressGetLastIdx(info);\n\n    for (i = 0; i < lastIdx; i++) {\n        /* ports are numbered from 1 */\n        int portIdx = info->addr.usb.port[i] - 1;\n\n        if (hub->nports <= portIdx) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"port %u out of range in USB address bus: %u port: %s\"),\n                           info->addr.usb.port[i],\n                           info->addr.usb.bus,\n                           portStr);\n            return NULL;\n        }\n        hub = hub->ports[portIdx];\n        if (!hub) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"there is no hub at port %u in USB address bus: %u port: %s\"),\n                           info->addr.usb.port[i],\n                           info->addr.usb.bus,\n                           portStr);\n            return NULL;\n        }\n    }\n\n    targetPort = info->addr.usb.port[lastIdx] - 1;\n    if (targetPort >= virBitmapSize(hub->portmap)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"requested USB port %s not present on USB bus %u\"),\n                       portStr, info->addr.usb.bus);\n        return NULL;\n    }\n\n    *targetIdx = targetPort;\n    return hub;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic virDomainUSBAddressHubPtr\nvirDomainUSBAddressFindPort(virDomainUSBAddressSetPtr addrs,\n                            virDomainDeviceInfoPtr info,\n                            int *targetIdx,\n                            const char *portStr)\n{\n    virDomainUSBAddressHubPtr hub = NULL;\n    ssize_t i, lastIdx, targetPort;\n\n    if (info->addr.usb.bus >= addrs->nbuses ||\n        !addrs->buses[info->addr.usb.bus]) {\n        virReportError(VIR_ERR_XML_ERROR, _(\"Missing USB bus %u\"),\n                       info->addr.usb.bus);\n        return NULL;\n    }\n    hub = addrs->buses[info->addr.usb.bus];\n\n    lastIdx = virDomainUSBAddressGetLastIdx(info);\n\n    for (i = 0; i < lastIdx; i++) {\n        /* ports are numbered from 1 */\n        int portIdx = info->addr.usb.port[i] - 1;\n\n        if (hub->nports <= portIdx) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"port %u out of range in USB address bus: %u port: %s\"),\n                           info->addr.usb.port[i],\n                           info->addr.usb.bus,\n                           portStr);\n            return NULL;\n        }\n        hub = hub->ports[portIdx];\n        if (!hub) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"there is no hub at port %u in USB address bus: %u port: %s\"),\n                           info->addr.usb.port[i],\n                           info->addr.usb.bus,\n                           portStr);\n            return NULL;\n        }\n    }\n\n    targetPort = info->addr.usb.port[lastIdx] - 1;\n    if (targetPort >= virBitmapSize(hub->portmap)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"requested USB port %s not present on USB bus %u\"),\n                       portStr, info->addr.usb.bus);\n        return NULL;\n    }\n\n    *targetIdx = targetPort;\n    return hub;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Releasing USB addr bus=%u port=%s\"",
            "info->addr.usb.bus",
            "portStr"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressPortFormat",
          "args": [
            "info->addr.usb.port"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressPortIsValid",
          "args": [
            "info->addr.usb.port"
          ],
          "line": 2462
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressPortIsValid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1928-1932",
          "snippet": "bool\nvirDomainUSBAddressPortIsValid(unsigned int *port)\n{\n    return port[0] != 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainUSBAddressPortIsValid(unsigned int *port)\n{\n    return port[0] != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainUSBAddressRelease(virDomainUSBAddressSetPtr addrs,\n                           virDomainDeviceInfoPtr info)\n{\n    virDomainUSBAddressHubPtr targetHub = NULL;\n    g_autofree char *portStr = NULL;\n    int targetPort;\n\n    if (!addrs || info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB ||\n        !virDomainUSBAddressPortIsValid(info->addr.usb.port))\n        return 0;\n\n    portStr = virDomainUSBAddressPortFormat(info->addr.usb.port);\n    VIR_DEBUG(\"Releasing USB addr bus=%u port=%s\", info->addr.usb.bus, portStr);\n\n    if (!(targetHub = virDomainUSBAddressFindPort(addrs, info, &targetPort,\n                                                  portStr)))\n        return -1;\n\n    ignore_value(virBitmapClearBit(targetHub->portmap, targetPort));\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainUSBAddressEnsure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "2432-2450",
    "snippet": "int\nvirDomainUSBAddressEnsure(virDomainUSBAddressSetPtr addrs,\n                          virDomainDeviceInfoPtr info)\n{\n    if (!addrs)\n        return 0;\n\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE ||\n        (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB &&\n         !virDomainUSBAddressPortIsValid(info->addr.usb.port))) {\n        if (virDomainUSBAddressAssign(addrs, info) < 0)\n            return -1;\n    } else if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB) {\n        if (virDomainUSBAddressReserve(info, addrs) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainUSBAddressReserve",
          "args": [
            "info",
            "addrs"
          ],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressReserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2395-2429",
          "snippet": "int\nvirDomainUSBAddressReserve(virDomainDeviceInfoPtr info,\n                           void *data)\n{\n    virDomainUSBAddressSetPtr addrs = data;\n    virDomainUSBAddressHubPtr targetHub = NULL;\n    g_autofree char *portStr = NULL;\n    int targetPort;\n\n    if (info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB)\n        return 0;\n\n    if (!virDomainUSBAddressPortIsValid(info->addr.usb.port))\n        return 0;\n\n    portStr = virDomainUSBAddressPortFormat(info->addr.usb.port);\n    if (!portStr)\n        return -1;\n    VIR_DEBUG(\"Reserving USB address bus=%u port=%s\", info->addr.usb.bus, portStr);\n\n    if (!(targetHub = virDomainUSBAddressFindPort(addrs, info, &targetPort,\n                                                  portStr)))\n        return -1;\n\n    if (virBitmapIsBitSet(targetHub->portmap, targetPort)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Duplicate USB address bus %u port %s\"),\n                       info->addr.usb.bus, portStr);\n        return -1;\n    }\n\n    ignore_value(virBitmapSetBit(targetHub->portmap, targetPort));\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainUSBAddressReserve(virDomainDeviceInfoPtr info,\n                           void *data)\n{\n    virDomainUSBAddressSetPtr addrs = data;\n    virDomainUSBAddressHubPtr targetHub = NULL;\n    g_autofree char *portStr = NULL;\n    int targetPort;\n\n    if (info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB)\n        return 0;\n\n    if (!virDomainUSBAddressPortIsValid(info->addr.usb.port))\n        return 0;\n\n    portStr = virDomainUSBAddressPortFormat(info->addr.usb.port);\n    if (!portStr)\n        return -1;\n    VIR_DEBUG(\"Reserving USB address bus=%u port=%s\", info->addr.usb.bus, portStr);\n\n    if (!(targetHub = virDomainUSBAddressFindPort(addrs, info, &targetPort,\n                                                  portStr)))\n        return -1;\n\n    if (virBitmapIsBitSet(targetHub->portmap, targetPort)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Duplicate USB address bus %u port %s\"),\n                       info->addr.usb.bus, portStr);\n        return -1;\n    }\n\n    ignore_value(virBitmapSetBit(targetHub->portmap, targetPort));\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressAssign",
          "args": [
            "addrs",
            "info"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressAssign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2350-2380",
          "snippet": "int\nvirDomainUSBAddressAssign(virDomainUSBAddressSetPtr addrs,\n                          virDomainDeviceInfoPtr info)\n{\n    size_t i;\n    int rc;\n\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB) {\n        VIR_DEBUG(\"A USB port on bus %u was requested\", info->addr.usb.bus);\n        if (info->addr.usb.bus >= addrs->nbuses ||\n            !addrs->buses[info->addr.usb.bus]) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"USB bus %u requested but no controller \"\n                             \"with that index is present\"), info->addr.usb.bus);\n            return -1;\n        }\n        rc = virDomainUSBAddressAssignFromBus(addrs, info, info->addr.usb.bus);\n        if (rc >= -1)\n            return rc;\n    } else {\n        VIR_DEBUG(\"Looking for a free USB port on all the buses\");\n        for (i = 0; i < addrs->nbuses; i++) {\n            rc = virDomainUSBAddressAssignFromBus(addrs, info, i);\n            if (rc >= -1)\n                return rc;\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"No free USB ports\"));\n    return -1;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainUSBAddressAssign(virDomainUSBAddressSetPtr addrs,\n                          virDomainDeviceInfoPtr info)\n{\n    size_t i;\n    int rc;\n\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB) {\n        VIR_DEBUG(\"A USB port on bus %u was requested\", info->addr.usb.bus);\n        if (info->addr.usb.bus >= addrs->nbuses ||\n            !addrs->buses[info->addr.usb.bus]) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"USB bus %u requested but no controller \"\n                             \"with that index is present\"), info->addr.usb.bus);\n            return -1;\n        }\n        rc = virDomainUSBAddressAssignFromBus(addrs, info, info->addr.usb.bus);\n        if (rc >= -1)\n            return rc;\n    } else {\n        VIR_DEBUG(\"Looking for a free USB port on all the buses\");\n        for (i = 0; i < addrs->nbuses; i++) {\n            rc = virDomainUSBAddressAssignFromBus(addrs, info, i);\n            if (rc >= -1)\n                return rc;\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"No free USB ports\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressPortIsValid",
          "args": [
            "info->addr.usb.port"
          ],
          "line": 2441
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressPortIsValid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1928-1932",
          "snippet": "bool\nvirDomainUSBAddressPortIsValid(unsigned int *port)\n{\n    return port[0] != 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainUSBAddressPortIsValid(unsigned int *port)\n{\n    return port[0] != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainUSBAddressEnsure(virDomainUSBAddressSetPtr addrs,\n                          virDomainDeviceInfoPtr info)\n{\n    if (!addrs)\n        return 0;\n\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE ||\n        (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB &&\n         !virDomainUSBAddressPortIsValid(info->addr.usb.port))) {\n        if (virDomainUSBAddressAssign(addrs, info) < 0)\n            return -1;\n    } else if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB) {\n        if (virDomainUSBAddressReserve(info, addrs) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainUSBAddressReserve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "2395-2429",
    "snippet": "int\nvirDomainUSBAddressReserve(virDomainDeviceInfoPtr info,\n                           void *data)\n{\n    virDomainUSBAddressSetPtr addrs = data;\n    virDomainUSBAddressHubPtr targetHub = NULL;\n    g_autofree char *portStr = NULL;\n    int targetPort;\n\n    if (info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB)\n        return 0;\n\n    if (!virDomainUSBAddressPortIsValid(info->addr.usb.port))\n        return 0;\n\n    portStr = virDomainUSBAddressPortFormat(info->addr.usb.port);\n    if (!portStr)\n        return -1;\n    VIR_DEBUG(\"Reserving USB address bus=%u port=%s\", info->addr.usb.bus, portStr);\n\n    if (!(targetHub = virDomainUSBAddressFindPort(addrs, info, &targetPort,\n                                                  portStr)))\n        return -1;\n\n    if (virBitmapIsBitSet(targetHub->portmap, targetPort)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Duplicate USB address bus %u port %s\"),\n                       info->addr.usb.bus, portStr);\n        return -1;\n    }\n\n    ignore_value(virBitmapSetBit(targetHub->portmap, targetPort));\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(targetHub->portmap, targetPort)"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "targetHub->portmap",
            "targetPort"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Duplicate USB address bus %u port %s\")",
            "info->addr.usb.bus",
            "portStr"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Duplicate USB address bus %u port %s\""
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapIsBitSet",
          "args": [
            "targetHub->portmap",
            "targetPort"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapIsBitSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "298-306",
          "snippet": "bool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressFindPort",
          "args": [
            "addrs",
            "info",
            "&targetPort",
            "portStr"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressFindPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2124-2176",
          "snippet": "static virDomainUSBAddressHubPtr\nvirDomainUSBAddressFindPort(virDomainUSBAddressSetPtr addrs,\n                            virDomainDeviceInfoPtr info,\n                            int *targetIdx,\n                            const char *portStr)\n{\n    virDomainUSBAddressHubPtr hub = NULL;\n    ssize_t i, lastIdx, targetPort;\n\n    if (info->addr.usb.bus >= addrs->nbuses ||\n        !addrs->buses[info->addr.usb.bus]) {\n        virReportError(VIR_ERR_XML_ERROR, _(\"Missing USB bus %u\"),\n                       info->addr.usb.bus);\n        return NULL;\n    }\n    hub = addrs->buses[info->addr.usb.bus];\n\n    lastIdx = virDomainUSBAddressGetLastIdx(info);\n\n    for (i = 0; i < lastIdx; i++) {\n        /* ports are numbered from 1 */\n        int portIdx = info->addr.usb.port[i] - 1;\n\n        if (hub->nports <= portIdx) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"port %u out of range in USB address bus: %u port: %s\"),\n                           info->addr.usb.port[i],\n                           info->addr.usb.bus,\n                           portStr);\n            return NULL;\n        }\n        hub = hub->ports[portIdx];\n        if (!hub) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"there is no hub at port %u in USB address bus: %u port: %s\"),\n                           info->addr.usb.port[i],\n                           info->addr.usb.bus,\n                           portStr);\n            return NULL;\n        }\n    }\n\n    targetPort = info->addr.usb.port[lastIdx] - 1;\n    if (targetPort >= virBitmapSize(hub->portmap)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"requested USB port %s not present on USB bus %u\"),\n                       portStr, info->addr.usb.bus);\n        return NULL;\n    }\n\n    *targetIdx = targetPort;\n    return hub;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic virDomainUSBAddressHubPtr\nvirDomainUSBAddressFindPort(virDomainUSBAddressSetPtr addrs,\n                            virDomainDeviceInfoPtr info,\n                            int *targetIdx,\n                            const char *portStr)\n{\n    virDomainUSBAddressHubPtr hub = NULL;\n    ssize_t i, lastIdx, targetPort;\n\n    if (info->addr.usb.bus >= addrs->nbuses ||\n        !addrs->buses[info->addr.usb.bus]) {\n        virReportError(VIR_ERR_XML_ERROR, _(\"Missing USB bus %u\"),\n                       info->addr.usb.bus);\n        return NULL;\n    }\n    hub = addrs->buses[info->addr.usb.bus];\n\n    lastIdx = virDomainUSBAddressGetLastIdx(info);\n\n    for (i = 0; i < lastIdx; i++) {\n        /* ports are numbered from 1 */\n        int portIdx = info->addr.usb.port[i] - 1;\n\n        if (hub->nports <= portIdx) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"port %u out of range in USB address bus: %u port: %s\"),\n                           info->addr.usb.port[i],\n                           info->addr.usb.bus,\n                           portStr);\n            return NULL;\n        }\n        hub = hub->ports[portIdx];\n        if (!hub) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"there is no hub at port %u in USB address bus: %u port: %s\"),\n                           info->addr.usb.port[i],\n                           info->addr.usb.bus,\n                           portStr);\n            return NULL;\n        }\n    }\n\n    targetPort = info->addr.usb.port[lastIdx] - 1;\n    if (targetPort >= virBitmapSize(hub->portmap)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"requested USB port %s not present on USB bus %u\"),\n                       portStr, info->addr.usb.bus);\n        return NULL;\n    }\n\n    *targetIdx = targetPort;\n    return hub;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Reserving USB address bus=%u port=%s\"",
            "info->addr.usb.bus",
            "portStr"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressPortFormat",
          "args": [
            "info->addr.usb.port"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressPortIsValid",
          "args": [
            "info->addr.usb.port"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressPortIsValid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1928-1932",
          "snippet": "bool\nvirDomainUSBAddressPortIsValid(unsigned int *port)\n{\n    return port[0] != 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainUSBAddressPortIsValid(unsigned int *port)\n{\n    return port[0] != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainUSBAddressReserve(virDomainDeviceInfoPtr info,\n                           void *data)\n{\n    virDomainUSBAddressSetPtr addrs = data;\n    virDomainUSBAddressHubPtr targetHub = NULL;\n    g_autofree char *portStr = NULL;\n    int targetPort;\n\n    if (info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB)\n        return 0;\n\n    if (!virDomainUSBAddressPortIsValid(info->addr.usb.port))\n        return 0;\n\n    portStr = virDomainUSBAddressPortFormat(info->addr.usb.port);\n    if (!portStr)\n        return -1;\n    VIR_DEBUG(\"Reserving USB address bus=%u port=%s\", info->addr.usb.bus, portStr);\n\n    if (!(targetHub = virDomainUSBAddressFindPort(addrs, info, &targetPort,\n                                                  portStr)))\n        return -1;\n\n    if (virBitmapIsBitSet(targetHub->portmap, targetPort)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Duplicate USB address bus %u port %s\"),\n                       info->addr.usb.bus, portStr);\n        return -1;\n    }\n\n    ignore_value(virBitmapSetBit(targetHub->portmap, targetPort));\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainUSBAddressPresent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "2383-2392",
    "snippet": "int\nvirDomainUSBAddressPresent(virDomainDeviceInfoPtr info,\n                           void *data G_GNUC_UNUSED)\n{\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB &&\n        virDomainUSBAddressPortIsValid(info->addr.usb.port))\n        return 0;\n\n    return -1;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainUSBAddressPortIsValid",
          "args": [
            "info->addr.usb.port"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressPortIsValid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1928-1932",
          "snippet": "bool\nvirDomainUSBAddressPortIsValid(unsigned int *port)\n{\n    return port[0] != 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainUSBAddressPortIsValid(unsigned int *port)\n{\n    return port[0] != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainUSBAddressPresent(virDomainDeviceInfoPtr info,\n                           void *data G_GNUC_UNUSED)\n{\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB &&\n        virDomainUSBAddressPortIsValid(info->addr.usb.port))\n        return 0;\n\n    return -1;\n}"
  },
  {
    "function_name": "virDomainUSBAddressAssign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "2350-2380",
    "snippet": "int\nvirDomainUSBAddressAssign(virDomainUSBAddressSetPtr addrs,\n                          virDomainDeviceInfoPtr info)\n{\n    size_t i;\n    int rc;\n\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB) {\n        VIR_DEBUG(\"A USB port on bus %u was requested\", info->addr.usb.bus);\n        if (info->addr.usb.bus >= addrs->nbuses ||\n            !addrs->buses[info->addr.usb.bus]) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"USB bus %u requested but no controller \"\n                             \"with that index is present\"), info->addr.usb.bus);\n            return -1;\n        }\n        rc = virDomainUSBAddressAssignFromBus(addrs, info, info->addr.usb.bus);\n        if (rc >= -1)\n            return rc;\n    } else {\n        VIR_DEBUG(\"Looking for a free USB port on all the buses\");\n        for (i = 0; i < addrs->nbuses; i++) {\n            rc = virDomainUSBAddressAssignFromBus(addrs, info, i);\n            if (rc >= -1)\n                return rc;\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"No free USB ports\"));\n    return -1;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"No free USB ports\")"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No free USB ports\""
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressAssignFromBus",
          "args": [
            "addrs",
            "info",
            "i"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressAssignFromBus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2319-2347",
          "snippet": "static int\nvirDomainUSBAddressAssignFromBus(virDomainUSBAddressSetPtr addrs,\n                                 virDomainDeviceInfoPtr info,\n                                 size_t bus)\n{\n    unsigned int portpath[VIR_DOMAIN_DEVICE_USB_MAX_PORT_DEPTH] = { 0 };\n    virDomainUSBAddressHubPtr hub = addrs->buses[bus];\n    g_autofree char *portStr = NULL;\n\n    if (!hub)\n        return -2;\n\n    if (virDomainUSBAddressFindFreePort(hub, portpath, 0) < 0)\n        return -2;\n\n    /* we found a free port */\n    if (!(portStr = virDomainUSBAddressPortFormat(portpath)))\n        return -1;\n\n    info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB;\n    info->addr.usb.bus = bus;\n    memcpy(info->addr.usb.port, portpath, sizeof(portpath));\n    VIR_DEBUG(\"Assigning USB addr bus=%u port=%s\",\n              info->addr.usb.bus, portStr);\n    if (virDomainUSBAddressReserve(info, addrs) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainUSBAddressAssignFromBus(virDomainUSBAddressSetPtr addrs,\n                                 virDomainDeviceInfoPtr info,\n                                 size_t bus)\n{\n    unsigned int portpath[VIR_DOMAIN_DEVICE_USB_MAX_PORT_DEPTH] = { 0 };\n    virDomainUSBAddressHubPtr hub = addrs->buses[bus];\n    g_autofree char *portStr = NULL;\n\n    if (!hub)\n        return -2;\n\n    if (virDomainUSBAddressFindFreePort(hub, portpath, 0) < 0)\n        return -2;\n\n    /* we found a free port */\n    if (!(portStr = virDomainUSBAddressPortFormat(portpath)))\n        return -1;\n\n    info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB;\n    info->addr.usb.bus = bus;\n    memcpy(info->addr.usb.port, portpath, sizeof(portpath));\n    VIR_DEBUG(\"Assigning USB addr bus=%u port=%s\",\n              info->addr.usb.bus, portStr);\n    if (virDomainUSBAddressReserve(info, addrs) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Looking for a free USB port on all the buses\""
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"USB bus %u requested but no controller \"\n                             \"with that index is present\")",
            "info->addr.usb.bus"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"A USB port on bus %u was requested\"",
            "info->addr.usb.bus"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainUSBAddressAssign(virDomainUSBAddressSetPtr addrs,\n                          virDomainDeviceInfoPtr info)\n{\n    size_t i;\n    int rc;\n\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB) {\n        VIR_DEBUG(\"A USB port on bus %u was requested\", info->addr.usb.bus);\n        if (info->addr.usb.bus >= addrs->nbuses ||\n            !addrs->buses[info->addr.usb.bus]) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"USB bus %u requested but no controller \"\n                             \"with that index is present\"), info->addr.usb.bus);\n            return -1;\n        }\n        rc = virDomainUSBAddressAssignFromBus(addrs, info, info->addr.usb.bus);\n        if (rc >= -1)\n            return rc;\n    } else {\n        VIR_DEBUG(\"Looking for a free USB port on all the buses\");\n        for (i = 0; i < addrs->nbuses; i++) {\n            rc = virDomainUSBAddressAssignFromBus(addrs, info, i);\n            if (rc >= -1)\n                return rc;\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"No free USB ports\"));\n    return -1;\n}"
  },
  {
    "function_name": "virDomainUSBAddressAssignFromBus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "2319-2347",
    "snippet": "static int\nvirDomainUSBAddressAssignFromBus(virDomainUSBAddressSetPtr addrs,\n                                 virDomainDeviceInfoPtr info,\n                                 size_t bus)\n{\n    unsigned int portpath[VIR_DOMAIN_DEVICE_USB_MAX_PORT_DEPTH] = { 0 };\n    virDomainUSBAddressHubPtr hub = addrs->buses[bus];\n    g_autofree char *portStr = NULL;\n\n    if (!hub)\n        return -2;\n\n    if (virDomainUSBAddressFindFreePort(hub, portpath, 0) < 0)\n        return -2;\n\n    /* we found a free port */\n    if (!(portStr = virDomainUSBAddressPortFormat(portpath)))\n        return -1;\n\n    info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB;\n    info->addr.usb.bus = bus;\n    memcpy(info->addr.usb.port, portpath, sizeof(portpath));\n    VIR_DEBUG(\"Assigning USB addr bus=%u port=%s\",\n              info->addr.usb.bus, portStr);\n    if (virDomainUSBAddressReserve(info, addrs) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainUSBAddressReserve",
          "args": [
            "info",
            "addrs"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressReserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2395-2429",
          "snippet": "int\nvirDomainUSBAddressReserve(virDomainDeviceInfoPtr info,\n                           void *data)\n{\n    virDomainUSBAddressSetPtr addrs = data;\n    virDomainUSBAddressHubPtr targetHub = NULL;\n    g_autofree char *portStr = NULL;\n    int targetPort;\n\n    if (info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB)\n        return 0;\n\n    if (!virDomainUSBAddressPortIsValid(info->addr.usb.port))\n        return 0;\n\n    portStr = virDomainUSBAddressPortFormat(info->addr.usb.port);\n    if (!portStr)\n        return -1;\n    VIR_DEBUG(\"Reserving USB address bus=%u port=%s\", info->addr.usb.bus, portStr);\n\n    if (!(targetHub = virDomainUSBAddressFindPort(addrs, info, &targetPort,\n                                                  portStr)))\n        return -1;\n\n    if (virBitmapIsBitSet(targetHub->portmap, targetPort)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Duplicate USB address bus %u port %s\"),\n                       info->addr.usb.bus, portStr);\n        return -1;\n    }\n\n    ignore_value(virBitmapSetBit(targetHub->portmap, targetPort));\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainUSBAddressReserve(virDomainDeviceInfoPtr info,\n                           void *data)\n{\n    virDomainUSBAddressSetPtr addrs = data;\n    virDomainUSBAddressHubPtr targetHub = NULL;\n    g_autofree char *portStr = NULL;\n    int targetPort;\n\n    if (info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB)\n        return 0;\n\n    if (!virDomainUSBAddressPortIsValid(info->addr.usb.port))\n        return 0;\n\n    portStr = virDomainUSBAddressPortFormat(info->addr.usb.port);\n    if (!portStr)\n        return -1;\n    VIR_DEBUG(\"Reserving USB address bus=%u port=%s\", info->addr.usb.bus, portStr);\n\n    if (!(targetHub = virDomainUSBAddressFindPort(addrs, info, &targetPort,\n                                                  portStr)))\n        return -1;\n\n    if (virBitmapIsBitSet(targetHub->portmap, targetPort)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Duplicate USB address bus %u port %s\"),\n                       info->addr.usb.bus, portStr);\n        return -1;\n    }\n\n    ignore_value(virBitmapSetBit(targetHub->portmap, targetPort));\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Assigning USB addr bus=%u port=%s\"",
            "info->addr.usb.bus",
            "portStr"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "info->addr.usb.port",
            "portpath",
            "sizeof(portpath)"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressPortFormat",
          "args": [
            "portpath"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressFindFreePort",
          "args": [
            "hub",
            "portpath",
            "0"
          ],
          "line": 2331
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressFindFreePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2253-2290",
          "snippet": "static int\nvirDomainUSBAddressFindFreePort(virDomainUSBAddressHubPtr hub,\n                                unsigned int *portpath,\n                                unsigned int level)\n{\n    unsigned int port;\n    ssize_t portIdx;\n    size_t i;\n\n    /* Look for free ports on the current hub */\n    if ((portIdx = virBitmapNextClearBit(hub->portmap, -1)) >= 0) {\n        port = portIdx + 1;\n        VIR_DEBUG(\"Found a free port %u at level %u\", port, level);\n        portpath[level] = port;\n        return 0;\n    }\n\n    VIR_DEBUG(\"No ports found on hub %p, trying the hubs on it\", hub);\n\n    if (level >= VIR_DOMAIN_DEVICE_USB_MAX_PORT_DEPTH - 1)\n        return -1;\n\n    /* Recursively search through the ports that contain another hub */\n    for (i = 0; i < hub->nports; i++) {\n        if (!hub->ports[i])\n            continue;\n\n        port = i + 1;\n        VIR_DEBUG(\"Looking at USB hub at level: %u port: %u\", level, port);\n        if (virDomainUSBAddressFindFreePort(hub->ports[i], portpath,\n                                            level + 1) < 0)\n            continue;\n\n        portpath[level] = port;\n        return 0;\n    }\n    return -1;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainUSBAddressFindFreePort(virDomainUSBAddressHubPtr hub,\n                                unsigned int *portpath,\n                                unsigned int level)\n{\n    unsigned int port;\n    ssize_t portIdx;\n    size_t i;\n\n    /* Look for free ports on the current hub */\n    if ((portIdx = virBitmapNextClearBit(hub->portmap, -1)) >= 0) {\n        port = portIdx + 1;\n        VIR_DEBUG(\"Found a free port %u at level %u\", port, level);\n        portpath[level] = port;\n        return 0;\n    }\n\n    VIR_DEBUG(\"No ports found on hub %p, trying the hubs on it\", hub);\n\n    if (level >= VIR_DOMAIN_DEVICE_USB_MAX_PORT_DEPTH - 1)\n        return -1;\n\n    /* Recursively search through the ports that contain another hub */\n    for (i = 0; i < hub->nports; i++) {\n        if (!hub->ports[i])\n            continue;\n\n        port = i + 1;\n        VIR_DEBUG(\"Looking at USB hub at level: %u port: %u\", level, port);\n        if (virDomainUSBAddressFindFreePort(hub->ports[i], portpath,\n                                            level + 1) < 0)\n            continue;\n\n        portpath[level] = port;\n        return 0;\n    }\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainUSBAddressAssignFromBus(virDomainUSBAddressSetPtr addrs,\n                                 virDomainDeviceInfoPtr info,\n                                 size_t bus)\n{\n    unsigned int portpath[VIR_DOMAIN_DEVICE_USB_MAX_PORT_DEPTH] = { 0 };\n    virDomainUSBAddressHubPtr hub = addrs->buses[bus];\n    g_autofree char *portStr = NULL;\n\n    if (!hub)\n        return -2;\n\n    if (virDomainUSBAddressFindFreePort(hub, portpath, 0) < 0)\n        return -2;\n\n    /* we found a free port */\n    if (!(portStr = virDomainUSBAddressPortFormat(portpath)))\n        return -1;\n\n    info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB;\n    info->addr.usb.bus = bus;\n    memcpy(info->addr.usb.port, portpath, sizeof(portpath));\n    VIR_DEBUG(\"Assigning USB addr bus=%u port=%s\",\n              info->addr.usb.bus, portStr);\n    if (virDomainUSBAddressReserve(info, addrs) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainUSBAddressCountAllPorts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "2293-2310",
    "snippet": "size_t\nvirDomainUSBAddressCountAllPorts(virDomainDefPtr def)\n{\n    size_t i, ret = 0;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB)\n            ret += virDomainUSBAddressControllerModelToPorts(cont);\n    }\n\n    for (i = 0; i < def->nhubs; i++) {\n        virDomainHubDefPtr hub = def->hubs[i];\n        if (hub->type == VIR_DOMAIN_HUB_TYPE_USB)\n            ret += VIR_DOMAIN_USB_HUB_PORTS;\n    }\n    return ret;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainUSBAddressControllerModelToPorts",
          "args": [
            "cont"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressControllerModelToPorts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2002-2044",
          "snippet": "static size_t\nvirDomainUSBAddressControllerModelToPorts(virDomainControllerDefPtr cont)\n{\n    switch ((virDomainControllerModelUSB) cont->model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX4_UHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_VT82C686B_UHCI:\n        return 2;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_EHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_EHCI1:\n        return 6;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI2:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI3:\n        /* These have two ports each and are used to provide USB1.1\n         * ports while ICH9_EHCI1 provides 6 USB2.0 ports.\n         * Ignore these since we will add the EHCI1 too. */\n        return 0;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_PCI_OHCI:\n        return 3;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_NEC_XHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_QEMU_XHCI:\n        if (cont->opts.usbopts.ports != -1)\n            return cont->opts.usbopts.ports;\n        return 4;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2:\n        if (cont->opts.usbopts.ports != -1)\n            return cont->opts.usbopts.ports;\n        return 8;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_LAST:\n        break;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic size_t\nvirDomainUSBAddressControllerModelToPorts(virDomainControllerDefPtr cont)\n{\n    switch ((virDomainControllerModelUSB) cont->model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX4_UHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_VT82C686B_UHCI:\n        return 2;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_EHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_EHCI1:\n        return 6;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI2:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI3:\n        /* These have two ports each and are used to provide USB1.1\n         * ports while ICH9_EHCI1 provides 6 USB2.0 ports.\n         * Ignore these since we will add the EHCI1 too. */\n        return 0;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_PCI_OHCI:\n        return 3;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_NEC_XHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_QEMU_XHCI:\n        if (cont->opts.usbopts.ports != -1)\n            return cont->opts.usbopts.ports;\n        return 4;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2:\n        if (cont->opts.usbopts.ports != -1)\n            return cont->opts.usbopts.ports;\n        return 8;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_LAST:\n        break;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nsize_t\nvirDomainUSBAddressCountAllPorts(virDomainDefPtr def)\n{\n    size_t i, ret = 0;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB)\n            ret += virDomainUSBAddressControllerModelToPorts(cont);\n    }\n\n    for (i = 0; i < def->nhubs; i++) {\n        virDomainHubDefPtr hub = def->hubs[i];\n        if (hub->type == VIR_DOMAIN_HUB_TYPE_USB)\n            ret += VIR_DOMAIN_USB_HUB_PORTS;\n    }\n    return ret;\n}"
  },
  {
    "function_name": "virDomainUSBAddressFindFreePort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "2253-2290",
    "snippet": "static int\nvirDomainUSBAddressFindFreePort(virDomainUSBAddressHubPtr hub,\n                                unsigned int *portpath,\n                                unsigned int level)\n{\n    unsigned int port;\n    ssize_t portIdx;\n    size_t i;\n\n    /* Look for free ports on the current hub */\n    if ((portIdx = virBitmapNextClearBit(hub->portmap, -1)) >= 0) {\n        port = portIdx + 1;\n        VIR_DEBUG(\"Found a free port %u at level %u\", port, level);\n        portpath[level] = port;\n        return 0;\n    }\n\n    VIR_DEBUG(\"No ports found on hub %p, trying the hubs on it\", hub);\n\n    if (level >= VIR_DOMAIN_DEVICE_USB_MAX_PORT_DEPTH - 1)\n        return -1;\n\n    /* Recursively search through the ports that contain another hub */\n    for (i = 0; i < hub->nports; i++) {\n        if (!hub->ports[i])\n            continue;\n\n        port = i + 1;\n        VIR_DEBUG(\"Looking at USB hub at level: %u port: %u\", level, port);\n        if (virDomainUSBAddressFindFreePort(hub->ports[i], portpath,\n                                            level + 1) < 0)\n            continue;\n\n        portpath[level] = port;\n        return 0;\n    }\n    return -1;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainUSBAddressFindFreePort",
          "args": [
            "hub->ports[i]",
            "portpath",
            "level + 1"
          ],
          "line": 2282
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressFindFreePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2253-2290",
          "snippet": "static int\nvirDomainUSBAddressFindFreePort(virDomainUSBAddressHubPtr hub,\n                                unsigned int *portpath,\n                                unsigned int level)\n{\n    unsigned int port;\n    ssize_t portIdx;\n    size_t i;\n\n    /* Look for free ports on the current hub */\n    if ((portIdx = virBitmapNextClearBit(hub->portmap, -1)) >= 0) {\n        port = portIdx + 1;\n        VIR_DEBUG(\"Found a free port %u at level %u\", port, level);\n        portpath[level] = port;\n        return 0;\n    }\n\n    VIR_DEBUG(\"No ports found on hub %p, trying the hubs on it\", hub);\n\n    if (level >= VIR_DOMAIN_DEVICE_USB_MAX_PORT_DEPTH - 1)\n        return -1;\n\n    /* Recursively search through the ports that contain another hub */\n    for (i = 0; i < hub->nports; i++) {\n        if (!hub->ports[i])\n            continue;\n\n        port = i + 1;\n        VIR_DEBUG(\"Looking at USB hub at level: %u port: %u\", level, port);\n        if (virDomainUSBAddressFindFreePort(hub->ports[i], portpath,\n                                            level + 1) < 0)\n            continue;\n\n        portpath[level] = port;\n        return 0;\n    }\n    return -1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Looking at USB hub at level: %u port: %u\"",
            "level",
            "port"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"No ports found on hub %p, trying the hubs on it\"",
            "hub"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Found a free port %u at level %u\"",
            "port",
            "level"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapNextClearBit",
          "args": [
            "hub->portmap",
            "-1"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNextClearBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1078-1113",
          "snippet": "ssize_t\nvirBitmapNextClearBit(virBitmapPtr bitmap,\n                      ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = ~bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = ~bitmap->map[nl];\n\n    if (nl == bitmap->map_len - 1) {\n        /* Ensure tail bits are ignored.  */\n        int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n        if (tail)\n            bits &= -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n    }\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapNextClearBit(virBitmapPtr bitmap,\n                      ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = ~bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = ~bitmap->map[nl];\n\n    if (nl == bitmap->map_len - 1) {\n        /* Ensure tail bits are ignored.  */\n        int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n        if (tail)\n            bits &= -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n    }\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainUSBAddressFindFreePort(virDomainUSBAddressHubPtr hub,\n                                unsigned int *portpath,\n                                unsigned int level)\n{\n    unsigned int port;\n    ssize_t portIdx;\n    size_t i;\n\n    /* Look for free ports on the current hub */\n    if ((portIdx = virBitmapNextClearBit(hub->portmap, -1)) >= 0) {\n        port = portIdx + 1;\n        VIR_DEBUG(\"Found a free port %u at level %u\", port, level);\n        portpath[level] = port;\n        return 0;\n    }\n\n    VIR_DEBUG(\"No ports found on hub %p, trying the hubs on it\", hub);\n\n    if (level >= VIR_DOMAIN_DEVICE_USB_MAX_PORT_DEPTH - 1)\n        return -1;\n\n    /* Recursively search through the ports that contain another hub */\n    for (i = 0; i < hub->nports; i++) {\n        if (!hub->ports[i])\n            continue;\n\n        port = i + 1;\n        VIR_DEBUG(\"Looking at USB hub at level: %u port: %u\", level, port);\n        if (virDomainUSBAddressFindFreePort(hub->ports[i], portpath,\n                                            level + 1) < 0)\n            continue;\n\n        portpath[level] = port;\n        return 0;\n    }\n    return -1;\n}"
  },
  {
    "function_name": "virDomainUSBAddressSetAddControllers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "2224-2250",
    "snippet": "int\nvirDomainUSBAddressSetAddControllers(virDomainUSBAddressSetPtr addrs,\n                                     virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB) {\n            if (virDomainUSBAddressSetAddController(addrs, cont) < 0)\n                return -1;\n        }\n    }\n\n    for (i = 0; i < def->nhubs; i++) {\n        virDomainHubDefPtr hub = def->hubs[i];\n        if (hub->type == VIR_DOMAIN_HUB_TYPE_USB &&\n            hub->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB &&\n            virDomainUSBAddressPortIsValid(hub->info.addr.usb.port)) {\n            /* USB hubs that do not yet have an USB address have to be\n             * dealt with later */\n            if (virDomainUSBAddressSetAddHub(addrs, hub) < 0)\n                return -1;\n        }\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainUSBAddressSetAddHub",
          "args": [
            "addrs",
            "hub"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressSetAddHub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2179-2221",
          "snippet": "int\nvirDomainUSBAddressSetAddHub(virDomainUSBAddressSetPtr addrs,\n                             virDomainHubDefPtr hub)\n{\n    virDomainUSBAddressHubPtr targetHub = NULL, newHub = NULL;\n    int ret = -1;\n    int targetPort;\n    g_autofree char *portStr = NULL;\n\n    if (hub->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Wrong address type for USB hub\"));\n        goto cleanup;\n    }\n\n    if (!(portStr = virDomainUSBAddressPortFormat(hub->info.addr.usb.port)))\n        goto cleanup;\n\n    VIR_DEBUG(\"Adding a USB hub with 8 ports on bus=%u port=%s\",\n              hub->info.addr.usb.bus, portStr);\n\n    if (!(newHub = virDomainUSBAddressHubNew(VIR_DOMAIN_USB_HUB_PORTS)))\n        goto cleanup;\n\n    if (!(targetHub = virDomainUSBAddressFindPort(addrs, &(hub->info), &targetPort,\n                                                  portStr)))\n        goto cleanup;\n\n    if (targetHub->ports[targetPort]) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Duplicate USB hub on bus %u port %s\"),\n                       hub->info.addr.usb.bus, portStr);\n        goto cleanup;\n    }\n    ignore_value(virBitmapSetBit(targetHub->portmap, targetPort));\n    targetHub->ports[targetPort] = newHub;\n    newHub = NULL;\n\n    ret = 0;\n cleanup:\n    virDomainUSBAddressHubFree(newHub);\n    return ret;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainUSBAddressSetAddHub(virDomainUSBAddressSetPtr addrs,\n                             virDomainHubDefPtr hub)\n{\n    virDomainUSBAddressHubPtr targetHub = NULL, newHub = NULL;\n    int ret = -1;\n    int targetPort;\n    g_autofree char *portStr = NULL;\n\n    if (hub->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Wrong address type for USB hub\"));\n        goto cleanup;\n    }\n\n    if (!(portStr = virDomainUSBAddressPortFormat(hub->info.addr.usb.port)))\n        goto cleanup;\n\n    VIR_DEBUG(\"Adding a USB hub with 8 ports on bus=%u port=%s\",\n              hub->info.addr.usb.bus, portStr);\n\n    if (!(newHub = virDomainUSBAddressHubNew(VIR_DOMAIN_USB_HUB_PORTS)))\n        goto cleanup;\n\n    if (!(targetHub = virDomainUSBAddressFindPort(addrs, &(hub->info), &targetPort,\n                                                  portStr)))\n        goto cleanup;\n\n    if (targetHub->ports[targetPort]) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Duplicate USB hub on bus %u port %s\"),\n                       hub->info.addr.usb.bus, portStr);\n        goto cleanup;\n    }\n    ignore_value(virBitmapSetBit(targetHub->portmap, targetPort));\n    targetHub->ports[targetPort] = newHub;\n    newHub = NULL;\n\n    ret = 0;\n cleanup:\n    virDomainUSBAddressHubFree(newHub);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressPortIsValid",
          "args": [
            "hub->info.addr.usb.port"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressPortIsValid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1928-1932",
          "snippet": "bool\nvirDomainUSBAddressPortIsValid(unsigned int *port)\n{\n    return port[0] != 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainUSBAddressPortIsValid(unsigned int *port)\n{\n    return port[0] != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressSetAddController",
          "args": [
            "addrs",
            "cont"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressSetAddControllers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2224-2250",
          "snippet": "int\nvirDomainUSBAddressSetAddControllers(virDomainUSBAddressSetPtr addrs,\n                                     virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB) {\n            if (virDomainUSBAddressSetAddController(addrs, cont) < 0)\n                return -1;\n        }\n    }\n\n    for (i = 0; i < def->nhubs; i++) {\n        virDomainHubDefPtr hub = def->hubs[i];\n        if (hub->type == VIR_DOMAIN_HUB_TYPE_USB &&\n            hub->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB &&\n            virDomainUSBAddressPortIsValid(hub->info.addr.usb.port)) {\n            /* USB hubs that do not yet have an USB address have to be\n             * dealt with later */\n            if (virDomainUSBAddressSetAddHub(addrs, hub) < 0)\n                return -1;\n        }\n    }\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainUSBAddressSetAddControllers(virDomainUSBAddressSetPtr addrs,\n                                     virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB) {\n            if (virDomainUSBAddressSetAddController(addrs, cont) < 0)\n                return -1;\n        }\n    }\n\n    for (i = 0; i < def->nhubs; i++) {\n        virDomainHubDefPtr hub = def->hubs[i];\n        if (hub->type == VIR_DOMAIN_HUB_TYPE_USB &&\n            hub->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB &&\n            virDomainUSBAddressPortIsValid(hub->info.addr.usb.port)) {\n            /* USB hubs that do not yet have an USB address have to be\n             * dealt with later */\n            if (virDomainUSBAddressSetAddHub(addrs, hub) < 0)\n                return -1;\n        }\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virDomainUSBAddressSetAddHub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "2179-2221",
    "snippet": "int\nvirDomainUSBAddressSetAddHub(virDomainUSBAddressSetPtr addrs,\n                             virDomainHubDefPtr hub)\n{\n    virDomainUSBAddressHubPtr targetHub = NULL, newHub = NULL;\n    int ret = -1;\n    int targetPort;\n    g_autofree char *portStr = NULL;\n\n    if (hub->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Wrong address type for USB hub\"));\n        goto cleanup;\n    }\n\n    if (!(portStr = virDomainUSBAddressPortFormat(hub->info.addr.usb.port)))\n        goto cleanup;\n\n    VIR_DEBUG(\"Adding a USB hub with 8 ports on bus=%u port=%s\",\n              hub->info.addr.usb.bus, portStr);\n\n    if (!(newHub = virDomainUSBAddressHubNew(VIR_DOMAIN_USB_HUB_PORTS)))\n        goto cleanup;\n\n    if (!(targetHub = virDomainUSBAddressFindPort(addrs, &(hub->info), &targetPort,\n                                                  portStr)))\n        goto cleanup;\n\n    if (targetHub->ports[targetPort]) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Duplicate USB hub on bus %u port %s\"),\n                       hub->info.addr.usb.bus, portStr);\n        goto cleanup;\n    }\n    ignore_value(virBitmapSetBit(targetHub->portmap, targetPort));\n    targetHub->ports[targetPort] = newHub;\n    newHub = NULL;\n\n    ret = 0;\n cleanup:\n    virDomainUSBAddressHubFree(newHub);\n    return ret;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainUSBAddressHubFree",
          "args": [
            "newHub"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressHubFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1971-1984",
          "snippet": "static void\nvirDomainUSBAddressHubFree(virDomainUSBAddressHubPtr hub)\n{\n    size_t i;\n\n    if (!hub)\n        return;\n\n    for (i = 0; i < hub->nports; i++)\n        virDomainUSBAddressHubFree(hub->ports[i]);\n    VIR_FREE(hub->ports);\n    virBitmapFree(hub->portmap);\n    VIR_FREE(hub);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainUSBAddressHubFree(virDomainUSBAddressHubPtr hub)\n{\n    size_t i;\n\n    if (!hub)\n        return;\n\n    for (i = 0; i < hub->nports; i++)\n        virDomainUSBAddressHubFree(hub->ports[i]);\n    VIR_FREE(hub->ports);\n    virBitmapFree(hub->portmap);\n    VIR_FREE(hub);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(targetHub->portmap, targetPort)"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "targetHub->portmap",
            "targetPort"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Duplicate USB hub on bus %u port %s\")",
            "hub->info.addr.usb.bus",
            "portStr"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Duplicate USB hub on bus %u port %s\""
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressFindPort",
          "args": [
            "addrs",
            "&(hub->info)",
            "&targetPort",
            "portStr"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressFindPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2124-2176",
          "snippet": "static virDomainUSBAddressHubPtr\nvirDomainUSBAddressFindPort(virDomainUSBAddressSetPtr addrs,\n                            virDomainDeviceInfoPtr info,\n                            int *targetIdx,\n                            const char *portStr)\n{\n    virDomainUSBAddressHubPtr hub = NULL;\n    ssize_t i, lastIdx, targetPort;\n\n    if (info->addr.usb.bus >= addrs->nbuses ||\n        !addrs->buses[info->addr.usb.bus]) {\n        virReportError(VIR_ERR_XML_ERROR, _(\"Missing USB bus %u\"),\n                       info->addr.usb.bus);\n        return NULL;\n    }\n    hub = addrs->buses[info->addr.usb.bus];\n\n    lastIdx = virDomainUSBAddressGetLastIdx(info);\n\n    for (i = 0; i < lastIdx; i++) {\n        /* ports are numbered from 1 */\n        int portIdx = info->addr.usb.port[i] - 1;\n\n        if (hub->nports <= portIdx) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"port %u out of range in USB address bus: %u port: %s\"),\n                           info->addr.usb.port[i],\n                           info->addr.usb.bus,\n                           portStr);\n            return NULL;\n        }\n        hub = hub->ports[portIdx];\n        if (!hub) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"there is no hub at port %u in USB address bus: %u port: %s\"),\n                           info->addr.usb.port[i],\n                           info->addr.usb.bus,\n                           portStr);\n            return NULL;\n        }\n    }\n\n    targetPort = info->addr.usb.port[lastIdx] - 1;\n    if (targetPort >= virBitmapSize(hub->portmap)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"requested USB port %s not present on USB bus %u\"),\n                       portStr, info->addr.usb.bus);\n        return NULL;\n    }\n\n    *targetIdx = targetPort;\n    return hub;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic virDomainUSBAddressHubPtr\nvirDomainUSBAddressFindPort(virDomainUSBAddressSetPtr addrs,\n                            virDomainDeviceInfoPtr info,\n                            int *targetIdx,\n                            const char *portStr)\n{\n    virDomainUSBAddressHubPtr hub = NULL;\n    ssize_t i, lastIdx, targetPort;\n\n    if (info->addr.usb.bus >= addrs->nbuses ||\n        !addrs->buses[info->addr.usb.bus]) {\n        virReportError(VIR_ERR_XML_ERROR, _(\"Missing USB bus %u\"),\n                       info->addr.usb.bus);\n        return NULL;\n    }\n    hub = addrs->buses[info->addr.usb.bus];\n\n    lastIdx = virDomainUSBAddressGetLastIdx(info);\n\n    for (i = 0; i < lastIdx; i++) {\n        /* ports are numbered from 1 */\n        int portIdx = info->addr.usb.port[i] - 1;\n\n        if (hub->nports <= portIdx) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"port %u out of range in USB address bus: %u port: %s\"),\n                           info->addr.usb.port[i],\n                           info->addr.usb.bus,\n                           portStr);\n            return NULL;\n        }\n        hub = hub->ports[portIdx];\n        if (!hub) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"there is no hub at port %u in USB address bus: %u port: %s\"),\n                           info->addr.usb.port[i],\n                           info->addr.usb.bus,\n                           portStr);\n            return NULL;\n        }\n    }\n\n    targetPort = info->addr.usb.port[lastIdx] - 1;\n    if (targetPort >= virBitmapSize(hub->portmap)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"requested USB port %s not present on USB bus %u\"),\n                       portStr, info->addr.usb.bus);\n        return NULL;\n    }\n\n    *targetIdx = targetPort;\n    return hub;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressHubNew",
          "args": [
            "VIR_DOMAIN_USB_HUB_PORTS"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressHubNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2047-2066",
          "snippet": "static virDomainUSBAddressHubPtr\nvirDomainUSBAddressHubNew(size_t nports)\n{\n    virDomainUSBAddressHubPtr hub = NULL, ret = NULL;\n\n    if (VIR_ALLOC(hub) < 0)\n        goto cleanup;\n\n    if (!(hub->portmap = virBitmapNew(nports)))\n        goto cleanup;\n\n    if (VIR_ALLOC_N(hub->ports, nports) < 0)\n        goto cleanup;\n    hub->nports = nports;\n\n    ret = g_steal_pointer(&hub);\n cleanup:\n    virDomainUSBAddressHubFree(hub);\n    return ret;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic virDomainUSBAddressHubPtr\nvirDomainUSBAddressHubNew(size_t nports)\n{\n    virDomainUSBAddressHubPtr hub = NULL, ret = NULL;\n\n    if (VIR_ALLOC(hub) < 0)\n        goto cleanup;\n\n    if (!(hub->portmap = virBitmapNew(nports)))\n        goto cleanup;\n\n    if (VIR_ALLOC_N(hub->ports, nports) < 0)\n        goto cleanup;\n    hub->nports = nports;\n\n    ret = g_steal_pointer(&hub);\n cleanup:\n    virDomainUSBAddressHubFree(hub);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Adding a USB hub with 8 ports on bus=%u port=%s\"",
            "hub->info.addr.usb.bus",
            "portStr"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressPortFormat",
          "args": [
            "hub->info.addr.usb.port"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Wrong address type for USB hub\")"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainUSBAddressSetAddHub(virDomainUSBAddressSetPtr addrs,\n                             virDomainHubDefPtr hub)\n{\n    virDomainUSBAddressHubPtr targetHub = NULL, newHub = NULL;\n    int ret = -1;\n    int targetPort;\n    g_autofree char *portStr = NULL;\n\n    if (hub->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Wrong address type for USB hub\"));\n        goto cleanup;\n    }\n\n    if (!(portStr = virDomainUSBAddressPortFormat(hub->info.addr.usb.port)))\n        goto cleanup;\n\n    VIR_DEBUG(\"Adding a USB hub with 8 ports on bus=%u port=%s\",\n              hub->info.addr.usb.bus, portStr);\n\n    if (!(newHub = virDomainUSBAddressHubNew(VIR_DOMAIN_USB_HUB_PORTS)))\n        goto cleanup;\n\n    if (!(targetHub = virDomainUSBAddressFindPort(addrs, &(hub->info), &targetPort,\n                                                  portStr)))\n        goto cleanup;\n\n    if (targetHub->ports[targetPort]) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Duplicate USB hub on bus %u port %s\"),\n                       hub->info.addr.usb.bus, portStr);\n        goto cleanup;\n    }\n    ignore_value(virBitmapSetBit(targetHub->portmap, targetPort));\n    targetHub->ports[targetPort] = newHub;\n    newHub = NULL;\n\n    ret = 0;\n cleanup:\n    virDomainUSBAddressHubFree(newHub);\n    return ret;\n}"
  },
  {
    "function_name": "virDomainUSBAddressFindPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "2124-2176",
    "snippet": "static virDomainUSBAddressHubPtr\nvirDomainUSBAddressFindPort(virDomainUSBAddressSetPtr addrs,\n                            virDomainDeviceInfoPtr info,\n                            int *targetIdx,\n                            const char *portStr)\n{\n    virDomainUSBAddressHubPtr hub = NULL;\n    ssize_t i, lastIdx, targetPort;\n\n    if (info->addr.usb.bus >= addrs->nbuses ||\n        !addrs->buses[info->addr.usb.bus]) {\n        virReportError(VIR_ERR_XML_ERROR, _(\"Missing USB bus %u\"),\n                       info->addr.usb.bus);\n        return NULL;\n    }\n    hub = addrs->buses[info->addr.usb.bus];\n\n    lastIdx = virDomainUSBAddressGetLastIdx(info);\n\n    for (i = 0; i < lastIdx; i++) {\n        /* ports are numbered from 1 */\n        int portIdx = info->addr.usb.port[i] - 1;\n\n        if (hub->nports <= portIdx) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"port %u out of range in USB address bus: %u port: %s\"),\n                           info->addr.usb.port[i],\n                           info->addr.usb.bus,\n                           portStr);\n            return NULL;\n        }\n        hub = hub->ports[portIdx];\n        if (!hub) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"there is no hub at port %u in USB address bus: %u port: %s\"),\n                           info->addr.usb.port[i],\n                           info->addr.usb.bus,\n                           portStr);\n            return NULL;\n        }\n    }\n\n    targetPort = info->addr.usb.port[lastIdx] - 1;\n    if (targetPort >= virBitmapSize(hub->portmap)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"requested USB port %s not present on USB bus %u\"),\n                       portStr, info->addr.usb.bus);\n        return NULL;\n    }\n\n    *targetIdx = targetPort;\n    return hub;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"requested USB port %s not present on USB bus %u\")",
            "portStr",
            "info->addr.usb.bus"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"requested USB port %s not present on USB bus %u\""
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapSize",
          "args": [
            "hub->portmap"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "882-886",
          "snippet": "size_t\nvirBitmapSize(virBitmapPtr bitmap)\n{\n    return bitmap->nbits;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nsize_t\nvirBitmapSize(virBitmapPtr bitmap)\n{\n    return bitmap->nbits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"there is no hub at port %u in USB address bus: %u port: %s\")",
            "info->addr.usb.port[i]",
            "info->addr.usb.bus",
            "portStr"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"port %u out of range in USB address bus: %u port: %s\")",
            "info->addr.usb.port[i]",
            "info->addr.usb.bus",
            "portStr"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressGetLastIdx",
          "args": [
            "info"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressGetLastIdx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2108-2117",
          "snippet": "static ssize_t\nvirDomainUSBAddressGetLastIdx(virDomainDeviceInfoPtr info)\n{\n    ssize_t i;\n    for (i = VIR_DOMAIN_DEVICE_USB_MAX_PORT_DEPTH - 1; i > 0; i--) {\n        if (info->addr.usb.port[i] != 0)\n            break;\n    }\n    return i;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic ssize_t\nvirDomainUSBAddressGetLastIdx(virDomainDeviceInfoPtr info)\n{\n    ssize_t i;\n    for (i = VIR_DOMAIN_DEVICE_USB_MAX_PORT_DEPTH - 1; i > 0; i--) {\n        if (info->addr.usb.port[i] != 0)\n            break;\n    }\n    return i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Missing USB bus %u\")",
            "info->addr.usb.bus"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic virDomainUSBAddressHubPtr\nvirDomainUSBAddressFindPort(virDomainUSBAddressSetPtr addrs,\n                            virDomainDeviceInfoPtr info,\n                            int *targetIdx,\n                            const char *portStr)\n{\n    virDomainUSBAddressHubPtr hub = NULL;\n    ssize_t i, lastIdx, targetPort;\n\n    if (info->addr.usb.bus >= addrs->nbuses ||\n        !addrs->buses[info->addr.usb.bus]) {\n        virReportError(VIR_ERR_XML_ERROR, _(\"Missing USB bus %u\"),\n                       info->addr.usb.bus);\n        return NULL;\n    }\n    hub = addrs->buses[info->addr.usb.bus];\n\n    lastIdx = virDomainUSBAddressGetLastIdx(info);\n\n    for (i = 0; i < lastIdx; i++) {\n        /* ports are numbered from 1 */\n        int portIdx = info->addr.usb.port[i] - 1;\n\n        if (hub->nports <= portIdx) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"port %u out of range in USB address bus: %u port: %s\"),\n                           info->addr.usb.port[i],\n                           info->addr.usb.bus,\n                           portStr);\n            return NULL;\n        }\n        hub = hub->ports[portIdx];\n        if (!hub) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"there is no hub at port %u in USB address bus: %u port: %s\"),\n                           info->addr.usb.port[i],\n                           info->addr.usb.bus,\n                           portStr);\n            return NULL;\n        }\n    }\n\n    targetPort = info->addr.usb.port[lastIdx] - 1;\n    if (targetPort >= virBitmapSize(hub->portmap)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"requested USB port %s not present on USB bus %u\"),\n                       portStr, info->addr.usb.bus);\n        return NULL;\n    }\n\n    *targetIdx = targetPort;\n    return hub;\n}"
  },
  {
    "function_name": "virDomainUSBAddressGetLastIdx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "2108-2117",
    "snippet": "static ssize_t\nvirDomainUSBAddressGetLastIdx(virDomainDeviceInfoPtr info)\n{\n    ssize_t i;\n    for (i = VIR_DOMAIN_DEVICE_USB_MAX_PORT_DEPTH - 1; i > 0; i--) {\n        if (info->addr.usb.port[i] != 0)\n            break;\n    }\n    return i;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic ssize_t\nvirDomainUSBAddressGetLastIdx(virDomainDeviceInfoPtr info)\n{\n    ssize_t i;\n    for (i = VIR_DOMAIN_DEVICE_USB_MAX_PORT_DEPTH - 1; i > 0; i--) {\n        if (info->addr.usb.port[i] != 0)\n            break;\n    }\n    return i;\n}"
  },
  {
    "function_name": "virDomainUSBAddressSetAddController",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "2069-2105",
    "snippet": "static int\nvirDomainUSBAddressSetAddController(virDomainUSBAddressSetPtr addrs,\n                                    virDomainControllerDefPtr cont)\n{\n    size_t nports = virDomainUSBAddressControllerModelToPorts(cont);\n    virDomainUSBAddressHubPtr hub = NULL;\n    int ret = -1;\n\n    VIR_DEBUG(\"Adding a USB controller model=%s with %zu ports\",\n              virDomainControllerModelUSBTypeToString(cont->model),\n              nports);\n\n    /* Skip UHCI{1,2,3} companions; only add the EHCI1 */\n    if (nports == 0)\n        return 0;\n\n    if (addrs->nbuses <= cont->idx) {\n        if (VIR_EXPAND_N(addrs->buses, addrs->nbuses, cont->idx - addrs->nbuses + 1) < 0)\n            goto cleanup;\n    } else if (addrs->buses[cont->idx]) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Duplicate USB controllers with index %u\"),\n                       cont->idx);\n        goto cleanup;\n    }\n\n    if (!(hub = virDomainUSBAddressHubNew(nports)))\n        goto cleanup;\n\n    addrs->buses[cont->idx] = hub;\n    hub = NULL;\n\n    ret = 0;\n cleanup:\n    virDomainUSBAddressHubFree(hub);\n    return ret;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainUSBAddressHubFree",
          "args": [
            "hub"
          ],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressHubFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1971-1984",
          "snippet": "static void\nvirDomainUSBAddressHubFree(virDomainUSBAddressHubPtr hub)\n{\n    size_t i;\n\n    if (!hub)\n        return;\n\n    for (i = 0; i < hub->nports; i++)\n        virDomainUSBAddressHubFree(hub->ports[i]);\n    VIR_FREE(hub->ports);\n    virBitmapFree(hub->portmap);\n    VIR_FREE(hub);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainUSBAddressHubFree(virDomainUSBAddressHubPtr hub)\n{\n    size_t i;\n\n    if (!hub)\n        return;\n\n    for (i = 0; i < hub->nports; i++)\n        virDomainUSBAddressHubFree(hub->ports[i]);\n    VIR_FREE(hub->ports);\n    virBitmapFree(hub->portmap);\n    VIR_FREE(hub);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressHubNew",
          "args": [
            "nports"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressHubNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2047-2066",
          "snippet": "static virDomainUSBAddressHubPtr\nvirDomainUSBAddressHubNew(size_t nports)\n{\n    virDomainUSBAddressHubPtr hub = NULL, ret = NULL;\n\n    if (VIR_ALLOC(hub) < 0)\n        goto cleanup;\n\n    if (!(hub->portmap = virBitmapNew(nports)))\n        goto cleanup;\n\n    if (VIR_ALLOC_N(hub->ports, nports) < 0)\n        goto cleanup;\n    hub->nports = nports;\n\n    ret = g_steal_pointer(&hub);\n cleanup:\n    virDomainUSBAddressHubFree(hub);\n    return ret;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic virDomainUSBAddressHubPtr\nvirDomainUSBAddressHubNew(size_t nports)\n{\n    virDomainUSBAddressHubPtr hub = NULL, ret = NULL;\n\n    if (VIR_ALLOC(hub) < 0)\n        goto cleanup;\n\n    if (!(hub->portmap = virBitmapNew(nports)))\n        goto cleanup;\n\n    if (VIR_ALLOC_N(hub->ports, nports) < 0)\n        goto cleanup;\n    hub->nports = nports;\n\n    ret = g_steal_pointer(&hub);\n cleanup:\n    virDomainUSBAddressHubFree(hub);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Duplicate USB controllers with index %u\")",
            "cont->idx"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Duplicate USB controllers with index %u\""
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "addrs->buses",
            "addrs->nbuses",
            "cont->idx - addrs->nbuses + 1"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Adding a USB controller model=%s with %zu ports\"",
            "virDomainControllerModelUSBTypeToString(cont->model)",
            "nports"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainControllerModelUSBTypeToString",
          "args": [
            "cont->model"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressControllerModelToPorts",
          "args": [
            "cont"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressControllerModelToPorts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2002-2044",
          "snippet": "static size_t\nvirDomainUSBAddressControllerModelToPorts(virDomainControllerDefPtr cont)\n{\n    switch ((virDomainControllerModelUSB) cont->model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX4_UHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_VT82C686B_UHCI:\n        return 2;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_EHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_EHCI1:\n        return 6;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI2:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI3:\n        /* These have two ports each and are used to provide USB1.1\n         * ports while ICH9_EHCI1 provides 6 USB2.0 ports.\n         * Ignore these since we will add the EHCI1 too. */\n        return 0;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_PCI_OHCI:\n        return 3;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_NEC_XHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_QEMU_XHCI:\n        if (cont->opts.usbopts.ports != -1)\n            return cont->opts.usbopts.ports;\n        return 4;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2:\n        if (cont->opts.usbopts.ports != -1)\n            return cont->opts.usbopts.ports;\n        return 8;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_LAST:\n        break;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic size_t\nvirDomainUSBAddressControllerModelToPorts(virDomainControllerDefPtr cont)\n{\n    switch ((virDomainControllerModelUSB) cont->model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX4_UHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_VT82C686B_UHCI:\n        return 2;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_EHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_EHCI1:\n        return 6;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI2:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI3:\n        /* These have two ports each and are used to provide USB1.1\n         * ports while ICH9_EHCI1 provides 6 USB2.0 ports.\n         * Ignore these since we will add the EHCI1 too. */\n        return 0;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_PCI_OHCI:\n        return 3;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_NEC_XHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_QEMU_XHCI:\n        if (cont->opts.usbopts.ports != -1)\n            return cont->opts.usbopts.ports;\n        return 4;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2:\n        if (cont->opts.usbopts.ports != -1)\n            return cont->opts.usbopts.ports;\n        return 8;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_LAST:\n        break;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainUSBAddressSetAddController(virDomainUSBAddressSetPtr addrs,\n                                    virDomainControllerDefPtr cont)\n{\n    size_t nports = virDomainUSBAddressControllerModelToPorts(cont);\n    virDomainUSBAddressHubPtr hub = NULL;\n    int ret = -1;\n\n    VIR_DEBUG(\"Adding a USB controller model=%s with %zu ports\",\n              virDomainControllerModelUSBTypeToString(cont->model),\n              nports);\n\n    /* Skip UHCI{1,2,3} companions; only add the EHCI1 */\n    if (nports == 0)\n        return 0;\n\n    if (addrs->nbuses <= cont->idx) {\n        if (VIR_EXPAND_N(addrs->buses, addrs->nbuses, cont->idx - addrs->nbuses + 1) < 0)\n            goto cleanup;\n    } else if (addrs->buses[cont->idx]) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Duplicate USB controllers with index %u\"),\n                       cont->idx);\n        goto cleanup;\n    }\n\n    if (!(hub = virDomainUSBAddressHubNew(nports)))\n        goto cleanup;\n\n    addrs->buses[cont->idx] = hub;\n    hub = NULL;\n\n    ret = 0;\n cleanup:\n    virDomainUSBAddressHubFree(hub);\n    return ret;\n}"
  },
  {
    "function_name": "virDomainUSBAddressHubNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "2047-2066",
    "snippet": "static virDomainUSBAddressHubPtr\nvirDomainUSBAddressHubNew(size_t nports)\n{\n    virDomainUSBAddressHubPtr hub = NULL, ret = NULL;\n\n    if (VIR_ALLOC(hub) < 0)\n        goto cleanup;\n\n    if (!(hub->portmap = virBitmapNew(nports)))\n        goto cleanup;\n\n    if (VIR_ALLOC_N(hub->ports, nports) < 0)\n        goto cleanup;\n    hub->nports = nports;\n\n    ret = g_steal_pointer(&hub);\n cleanup:\n    virDomainUSBAddressHubFree(hub);\n    return ret;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainUSBAddressHubFree",
          "args": [
            "hub"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressHubFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1971-1984",
          "snippet": "static void\nvirDomainUSBAddressHubFree(virDomainUSBAddressHubPtr hub)\n{\n    size_t i;\n\n    if (!hub)\n        return;\n\n    for (i = 0; i < hub->nports; i++)\n        virDomainUSBAddressHubFree(hub->ports[i]);\n    VIR_FREE(hub->ports);\n    virBitmapFree(hub->portmap);\n    VIR_FREE(hub);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainUSBAddressHubFree(virDomainUSBAddressHubPtr hub)\n{\n    size_t i;\n\n    if (!hub)\n        return;\n\n    for (i = 0; i < hub->nports; i++)\n        virDomainUSBAddressHubFree(hub->ports[i]);\n    VIR_FREE(hub->ports);\n    virBitmapFree(hub->portmap);\n    VIR_FREE(hub);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&hub"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "hub->ports",
            "nports"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "nports"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "hub"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic virDomainUSBAddressHubPtr\nvirDomainUSBAddressHubNew(size_t nports)\n{\n    virDomainUSBAddressHubPtr hub = NULL, ret = NULL;\n\n    if (VIR_ALLOC(hub) < 0)\n        goto cleanup;\n\n    if (!(hub->portmap = virBitmapNew(nports)))\n        goto cleanup;\n\n    if (VIR_ALLOC_N(hub->ports, nports) < 0)\n        goto cleanup;\n    hub->nports = nports;\n\n    ret = g_steal_pointer(&hub);\n cleanup:\n    virDomainUSBAddressHubFree(hub);\n    return ret;\n}"
  },
  {
    "function_name": "virDomainUSBAddressControllerModelToPorts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "2002-2044",
    "snippet": "static size_t\nvirDomainUSBAddressControllerModelToPorts(virDomainControllerDefPtr cont)\n{\n    switch ((virDomainControllerModelUSB) cont->model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX4_UHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_VT82C686B_UHCI:\n        return 2;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_EHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_EHCI1:\n        return 6;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI2:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI3:\n        /* These have two ports each and are used to provide USB1.1\n         * ports while ICH9_EHCI1 provides 6 USB2.0 ports.\n         * Ignore these since we will add the EHCI1 too. */\n        return 0;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_PCI_OHCI:\n        return 3;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_NEC_XHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_QEMU_XHCI:\n        if (cont->opts.usbopts.ports != -1)\n            return cont->opts.usbopts.ports;\n        return 4;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2:\n        if (cont->opts.usbopts.ports != -1)\n            return cont->opts.usbopts.ports;\n        return 8;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_LAST:\n        break;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic size_t\nvirDomainUSBAddressControllerModelToPorts(virDomainControllerDefPtr cont)\n{\n    switch ((virDomainControllerModelUSB) cont->model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX4_UHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_VT82C686B_UHCI:\n        return 2;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_EHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_EHCI1:\n        return 6;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI2:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI3:\n        /* These have two ports each and are used to provide USB1.1\n         * ports while ICH9_EHCI1 provides 6 USB2.0 ports.\n         * Ignore these since we will add the EHCI1 too. */\n        return 0;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_PCI_OHCI:\n        return 3;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_NEC_XHCI:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_QEMU_XHCI:\n        if (cont->opts.usbopts.ports != -1)\n            return cont->opts.usbopts.ports;\n        return 4;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2:\n        if (cont->opts.usbopts.ports != -1)\n            return cont->opts.usbopts.ports;\n        return 8;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE:\n    case VIR_DOMAIN_CONTROLLER_MODEL_USB_LAST:\n        break;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virDomainUSBAddressSetFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1987-1999",
    "snippet": "void\nvirDomainUSBAddressSetFree(virDomainUSBAddressSetPtr addrs)\n{\n    size_t i;\n\n    if (!addrs)\n        return;\n\n    for (i = 0; i < addrs->nbuses; i++)\n        virDomainUSBAddressHubFree(addrs->buses[i]);\n    VIR_FREE(addrs->buses);\n    VIR_FREE(addrs);\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addrs"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addrs->buses"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressHubFree",
          "args": [
            "addrs->buses[i]"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressHubFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1971-1984",
          "snippet": "static void\nvirDomainUSBAddressHubFree(virDomainUSBAddressHubPtr hub)\n{\n    size_t i;\n\n    if (!hub)\n        return;\n\n    for (i = 0; i < hub->nports; i++)\n        virDomainUSBAddressHubFree(hub->ports[i]);\n    VIR_FREE(hub->ports);\n    virBitmapFree(hub->portmap);\n    VIR_FREE(hub);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainUSBAddressHubFree(virDomainUSBAddressHubPtr hub)\n{\n    size_t i;\n\n    if (!hub)\n        return;\n\n    for (i = 0; i < hub->nports; i++)\n        virDomainUSBAddressHubFree(hub->ports[i]);\n    VIR_FREE(hub->ports);\n    virBitmapFree(hub->portmap);\n    VIR_FREE(hub);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainUSBAddressSetFree(virDomainUSBAddressSetPtr addrs)\n{\n    size_t i;\n\n    if (!addrs)\n        return;\n\n    for (i = 0; i < addrs->nbuses; i++)\n        virDomainUSBAddressHubFree(addrs->buses[i]);\n    VIR_FREE(addrs->buses);\n    VIR_FREE(addrs);\n}"
  },
  {
    "function_name": "virDomainUSBAddressHubFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1971-1984",
    "snippet": "static void\nvirDomainUSBAddressHubFree(virDomainUSBAddressHubPtr hub)\n{\n    size_t i;\n\n    if (!hub)\n        return;\n\n    for (i = 0; i < hub->nports; i++)\n        virDomainUSBAddressHubFree(hub->ports[i]);\n    VIR_FREE(hub->ports);\n    virBitmapFree(hub->portmap);\n    VIR_FREE(hub);\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "hub"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "hub->portmap"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "hub->ports"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressHubFree",
          "args": [
            "hub->ports[i]"
          ],
          "line": 1980
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressHubFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1971-1984",
          "snippet": "static void\nvirDomainUSBAddressHubFree(virDomainUSBAddressHubPtr hub)\n{\n    size_t i;\n\n    if (!hub)\n        return;\n\n    for (i = 0; i < hub->nports; i++)\n        virDomainUSBAddressHubFree(hub->ports[i]);\n    VIR_FREE(hub->ports);\n    virBitmapFree(hub->portmap);\n    VIR_FREE(hub);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainUSBAddressHubFree(virDomainUSBAddressHubPtr hub)\n{\n    size_t i;\n\n    if (!hub)\n        return;\n\n    for (i = 0; i < hub->nports; i++)\n        virDomainUSBAddressHubFree(hub->ports[i]);\n    VIR_FREE(hub->ports);\n    virBitmapFree(hub->portmap);\n    VIR_FREE(hub);\n}"
  },
  {
    "function_name": "virDomainUSBAddressSetCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1959-1968",
    "snippet": "virDomainUSBAddressSetPtr\nvirDomainUSBAddressSetCreate(void)\n{\n    virDomainUSBAddressSetPtr addrs;\n\n    if (VIR_ALLOC(addrs) < 0)\n        return NULL;\n\n    return addrs;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "addrs"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvirDomainUSBAddressSetPtr\nvirDomainUSBAddressSetCreate(void)\n{\n    virDomainUSBAddressSetPtr addrs;\n\n    if (VIR_ALLOC(addrs) < 0)\n        return NULL;\n\n    return addrs;\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1950-1956",
    "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressPortFormatBuf",
          "args": [
            "&buf",
            "port"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressPortFormatBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1935-1947",
          "snippet": "void\nvirDomainUSBAddressPortFormatBuf(virBufferPtr buf,\n                                 unsigned int *port)\n{\n    size_t i;\n\n    for (i = 0; i < VIR_DOMAIN_DEVICE_USB_MAX_PORT_DEPTH; i++) {\n        if (port[i] == 0)\n            break;\n        virBufferAsprintf(buf, \"%u.\", port[i]);\n    }\n    virBufferTrim(buf, \".\");\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainUSBAddressPortFormatBuf(virBufferPtr buf,\n                                 unsigned int *port)\n{\n    size_t i;\n\n    for (i = 0; i < VIR_DOMAIN_DEVICE_USB_MAX_PORT_DEPTH; i++) {\n        if (port[i] == 0)\n            break;\n        virBufferAsprintf(buf, \"%u.\", port[i]);\n    }\n    virBufferTrim(buf, \".\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressPortFormat",
          "args": [
            "unsigned int *port"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}"
  },
  {
    "function_name": "virDomainUSBAddressPortFormatBuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1935-1947",
    "snippet": "void\nvirDomainUSBAddressPortFormatBuf(virBufferPtr buf,\n                                 unsigned int *port)\n{\n    size_t i;\n\n    for (i = 0; i < VIR_DOMAIN_DEVICE_USB_MAX_PORT_DEPTH; i++) {\n        if (port[i] == 0)\n            break;\n        virBufferAsprintf(buf, \"%u.\", port[i]);\n    }\n    virBufferTrim(buf, \".\");\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferTrim",
          "args": [
            "buf",
            "\".\""
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferTrimLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "698-708",
          "snippet": "void\nvirBufferTrimLen(virBufferPtr buf, int len)\n{\n    if (!buf || !buf->str)\n        return;\n\n    if (len > buf->str->len)\n        return;\n\n    g_string_truncate(buf->str, buf->str->len - len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferTrimLen(virBufferPtr buf, int len)\n{\n    if (!buf || !buf->str)\n        return;\n\n    if (len > buf->str->len)\n        return;\n\n    g_string_truncate(buf->str, buf->str->len - len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"%u.\"",
            "port[i]"
          ],
          "line": 1944
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainUSBAddressPortFormatBuf(virBufferPtr buf,\n                                 unsigned int *port)\n{\n    size_t i;\n\n    for (i = 0; i < VIR_DOMAIN_DEVICE_USB_MAX_PORT_DEPTH; i++) {\n        if (port[i] == 0)\n            break;\n        virBufferAsprintf(buf, \"%u.\", port[i]);\n    }\n    virBufferTrim(buf, \".\");\n}"
  },
  {
    "function_name": "virDomainUSBAddressPortIsValid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1928-1932",
    "snippet": "bool\nvirDomainUSBAddressPortIsValid(unsigned int *port)\n{\n    return port[0] != 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainUSBAddressPortIsValid(unsigned int *port)\n{\n    return port[0] != 0;\n}"
  },
  {
    "function_name": "virDomainVirtioSerialAddrIsComplete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1920-1925",
    "snippet": "bool\nvirDomainVirtioSerialAddrIsComplete(virDomainDeviceInfoPtr info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL &&\n        info->addr.vioserial.port != 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainVirtioSerialAddrIsComplete(virDomainDeviceInfoPtr info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL &&\n        info->addr.vioserial.port != 0;\n}"
  },
  {
    "function_name": "virDomainVirtioSerialAddrAutoAssign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1894-1913",
    "snippet": "int\nvirDomainVirtioSerialAddrAutoAssign(virDomainDefPtr def,\n                                    virDomainDeviceInfoPtr info,\n                                    bool allowZero)\n{\n    virDomainVirtioSerialAddrSetPtr addrs = NULL;\n    int ret = -1;\n\n    if (!(addrs = virDomainVirtioSerialAddrSetCreateFromDomain(def)))\n        goto cleanup;\n\n    if (virDomainVirtioSerialAddrAutoAssignFromCache(def, addrs, info, allowZero) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virDomainVirtioSerialAddrSetFree(addrs);\n    return ret;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrSetFree",
          "args": [
            "addrs"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialAddrSetFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1645-1655",
          "snippet": "void\nvirDomainVirtioSerialAddrSetFree(virDomainVirtioSerialAddrSetPtr addrs)\n{\n    size_t i;\n    if (addrs) {\n        for (i = 0; i < addrs->ncontrollers; i++)\n            virDomainVirtioSerialControllerFree(addrs->controllers[i]);\n        VIR_FREE(addrs->controllers);\n        VIR_FREE(addrs);\n    }\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainVirtioSerialAddrSetFree(virDomainVirtioSerialAddrSetPtr addrs)\n{\n    size_t i;\n    if (addrs) {\n        for (i = 0; i < addrs->ncontrollers; i++)\n            virDomainVirtioSerialControllerFree(addrs->controllers[i]);\n        VIR_FREE(addrs->controllers);\n        VIR_FREE(addrs);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrAutoAssignFromCache",
          "args": [
            "def",
            "addrs",
            "info",
            "allowZero"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialAddrAutoAssignFromCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1880-1892",
          "snippet": "int\nvirDomainVirtioSerialAddrAutoAssignFromCache(virDomainDefPtr def,\n                                             virDomainVirtioSerialAddrSetPtr addrs,\n                                             virDomainDeviceInfoPtr info,\n                                             bool allowZero)\n{\n    bool portOnly = info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL;\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL &&\n        info->addr.vioserial.port)\n        return virDomainVirtioSerialAddrReserve(NULL, NULL, info, addrs);\n    else\n        return virDomainVirtioSerialAddrAssign(def, addrs, info, allowZero, portOnly);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainVirtioSerialAddrAutoAssignFromCache(virDomainDefPtr def,\n                                             virDomainVirtioSerialAddrSetPtr addrs,\n                                             virDomainDeviceInfoPtr info,\n                                             bool allowZero)\n{\n    bool portOnly = info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL;\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL &&\n        info->addr.vioserial.port)\n        return virDomainVirtioSerialAddrReserve(NULL, NULL, info, addrs);\n    else\n        return virDomainVirtioSerialAddrAssign(def, addrs, info, allowZero, portOnly);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrSetCreateFromDomain",
          "args": [
            "def"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialAddrSetCreateFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1718-1738",
          "snippet": "virDomainVirtioSerialAddrSetPtr\nvirDomainVirtioSerialAddrSetCreateFromDomain(virDomainDefPtr def)\n{\n    virDomainVirtioSerialAddrSetPtr addrs = NULL;\n    virDomainVirtioSerialAddrSetPtr ret = NULL;\n\n    if (!(addrs = virDomainVirtioSerialAddrSetCreate()))\n        goto cleanup;\n\n    if (virDomainVirtioSerialAddrSetAddControllers(addrs, def) < 0)\n        goto cleanup;\n\n    if (virDomainDeviceInfoIterate(def, virDomainVirtioSerialAddrReserve,\n                                   addrs) < 0)\n        goto cleanup;\n\n    ret = g_steal_pointer(&addrs);\n cleanup:\n    virDomainVirtioSerialAddrSetFree(addrs);\n    return ret;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvirDomainVirtioSerialAddrSetPtr\nvirDomainVirtioSerialAddrSetCreateFromDomain(virDomainDefPtr def)\n{\n    virDomainVirtioSerialAddrSetPtr addrs = NULL;\n    virDomainVirtioSerialAddrSetPtr ret = NULL;\n\n    if (!(addrs = virDomainVirtioSerialAddrSetCreate()))\n        goto cleanup;\n\n    if (virDomainVirtioSerialAddrSetAddControllers(addrs, def) < 0)\n        goto cleanup;\n\n    if (virDomainDeviceInfoIterate(def, virDomainVirtioSerialAddrReserve,\n                                   addrs) < 0)\n        goto cleanup;\n\n    ret = g_steal_pointer(&addrs);\n cleanup:\n    virDomainVirtioSerialAddrSetFree(addrs);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainVirtioSerialAddrAutoAssign(virDomainDefPtr def,\n                                    virDomainDeviceInfoPtr info,\n                                    bool allowZero)\n{\n    virDomainVirtioSerialAddrSetPtr addrs = NULL;\n    int ret = -1;\n\n    if (!(addrs = virDomainVirtioSerialAddrSetCreateFromDomain(def)))\n        goto cleanup;\n\n    if (virDomainVirtioSerialAddrAutoAssignFromCache(def, addrs, info, allowZero) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virDomainVirtioSerialAddrSetFree(addrs);\n    return ret;\n}"
  },
  {
    "function_name": "virDomainVirtioSerialAddrAutoAssignFromCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1880-1892",
    "snippet": "int\nvirDomainVirtioSerialAddrAutoAssignFromCache(virDomainDefPtr def,\n                                             virDomainVirtioSerialAddrSetPtr addrs,\n                                             virDomainDeviceInfoPtr info,\n                                             bool allowZero)\n{\n    bool portOnly = info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL;\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL &&\n        info->addr.vioserial.port)\n        return virDomainVirtioSerialAddrReserve(NULL, NULL, info, addrs);\n    else\n        return virDomainVirtioSerialAddrAssign(def, addrs, info, allowZero, portOnly);\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrAssign",
          "args": [
            "def",
            "addrs",
            "info",
            "allowZero",
            "portOnly"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrReserve",
          "args": [
            "NULL",
            "NULL",
            "info",
            "addrs"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainVirtioSerialAddrAutoAssignFromCache(virDomainDefPtr def,\n                                             virDomainVirtioSerialAddrSetPtr addrs,\n                                             virDomainDeviceInfoPtr info,\n                                             bool allowZero)\n{\n    bool portOnly = info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL;\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL &&\n        info->addr.vioserial.port)\n        return virDomainVirtioSerialAddrReserve(NULL, NULL, info, addrs);\n    else\n        return virDomainVirtioSerialAddrAssign(def, addrs, info, allowZero, portOnly);\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1847-1873",
    "snippet": "static int ATTRIBUTE_NONNULL(2) ATTRIBUTE_NONNULL(3)\nvirDomainVirtioSerialAddrAssign(virDomainDefPtr def,\n                                virDomainVirtioSerialAddrSetPtr addrs,\n                                virDomainDeviceInfoPtr info,\n                                bool allowZero,\n                                bool portOnly)\n{\n    virDomainDeviceInfo nfo = { 0 };\n    virDomainDeviceInfoPtr ptr = allowZero ? &nfo : info;\n\n    ptr->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL;\n\n    if (portOnly) {\n        if (virDomainVirtioSerialAddrNextFromController(addrs,\n                                                        &ptr->addr.vioserial) < 0)\n            return -1;\n    } else {\n        if (virDomainVirtioSerialAddrNext(def, addrs, &ptr->addr.vioserial,\n                                          allowZero) < 0)\n            return -1;\n    }\n\n    if (virDomainVirtioSerialAddrReserve(NULL, NULL, ptr, addrs) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrReserve",
          "args": [
            "NULL",
            "NULL",
            "ptr",
            "addrs"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrNext",
          "args": [
            "def",
            "addrs",
            "&ptr->addr.vioserial",
            "allowZero"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialAddrNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1760-1814",
          "snippet": "static int\nvirDomainVirtioSerialAddrNext(virDomainDefPtr def,\n                              virDomainVirtioSerialAddrSetPtr addrs,\n                              virDomainDeviceVirtioSerialAddress *addr,\n                              bool allowZero)\n{\n    ssize_t port, startPort = 0;\n    ssize_t i;\n    unsigned int controller;\n\n    /* port number 0 is reserved for virtconsoles */\n    if (allowZero)\n        startPort = -1;\n\n    if (addrs->ncontrollers == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no virtio-serial controllers are available\"));\n        return -1;\n    }\n\n    for (i = 0; i < addrs->ncontrollers; i++) {\n        virBitmapPtr map = addrs->controllers[i]->ports;\n        if ((port = virBitmapNextClearBit(map, startPort)) >= 0) {\n            controller = addrs->controllers[i]->idx;\n            goto success;\n        }\n    }\n\n    if (def) {\n        for (i = 0; i < INT_MAX; i++) {\n            int idx = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL, i);\n\n            if (idx == -1) {\n                if (virDomainVirtioSerialAddrSetAutoaddController(def, addrs, i) < 0)\n                    return -1;\n                controller = i;\n                port = startPort + 1;\n                goto success;\n            }\n        }\n    }\n\n    virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                   _(\"Unable to find a free virtio-serial port\"));\n\n    return -1;\n\n success:\n    addr->bus = 0;\n    addr->port = port;\n    addr->controller = controller;\n    VIR_DEBUG(\"Found free virtio serial controller %u port %u\", addr->controller,\n              addr->port);\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainVirtioSerialAddrNext(virDomainDefPtr def,\n                              virDomainVirtioSerialAddrSetPtr addrs,\n                              virDomainDeviceVirtioSerialAddress *addr,\n                              bool allowZero)\n{\n    ssize_t port, startPort = 0;\n    ssize_t i;\n    unsigned int controller;\n\n    /* port number 0 is reserved for virtconsoles */\n    if (allowZero)\n        startPort = -1;\n\n    if (addrs->ncontrollers == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no virtio-serial controllers are available\"));\n        return -1;\n    }\n\n    for (i = 0; i < addrs->ncontrollers; i++) {\n        virBitmapPtr map = addrs->controllers[i]->ports;\n        if ((port = virBitmapNextClearBit(map, startPort)) >= 0) {\n            controller = addrs->controllers[i]->idx;\n            goto success;\n        }\n    }\n\n    if (def) {\n        for (i = 0; i < INT_MAX; i++) {\n            int idx = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL, i);\n\n            if (idx == -1) {\n                if (virDomainVirtioSerialAddrSetAutoaddController(def, addrs, i) < 0)\n                    return -1;\n                controller = i;\n                port = startPort + 1;\n                goto success;\n            }\n        }\n    }\n\n    virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                   _(\"Unable to find a free virtio-serial port\"));\n\n    return -1;\n\n success:\n    addr->bus = 0;\n    addr->port = port;\n    addr->controller = controller;\n    VIR_DEBUG(\"Found free virtio serial controller %u port %u\", addr->controller,\n              addr->port);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrNextFromController",
          "args": [
            "addrs",
            "&ptr->addr.vioserial"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialAddrNextFromController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1816-1845",
          "snippet": "static int\nvirDomainVirtioSerialAddrNextFromController(virDomainVirtioSerialAddrSetPtr addrs,\n                                            virDomainDeviceVirtioSerialAddress *addr)\n{\n    ssize_t port;\n    ssize_t i;\n    virBitmapPtr map;\n\n    i = virDomainVirtioSerialAddrFindController(addrs, addr->controller);\n    if (i < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"virtio-serial controller %u not available\"),\n                       addr->controller);\n        return -1;\n    }\n\n    map = addrs->controllers[i]->ports;\n    if ((port = virBitmapNextClearBit(map, 0)) <= 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Unable to find a free port on virtio-serial controller %u\"),\n                       addr->controller);\n        return -1;\n    }\n\n    addr->bus = 0;\n    addr->port = port;\n    VIR_DEBUG(\"Found free virtio serial controller %u port %u\", addr->controller,\n              addr->port);\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainVirtioSerialAddrNextFromController(virDomainVirtioSerialAddrSetPtr addrs,\n                                            virDomainDeviceVirtioSerialAddress *addr)\n{\n    ssize_t port;\n    ssize_t i;\n    virBitmapPtr map;\n\n    i = virDomainVirtioSerialAddrFindController(addrs, addr->controller);\n    if (i < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"virtio-serial controller %u not available\"),\n                       addr->controller);\n        return -1;\n    }\n\n    map = addrs->controllers[i]->ports;\n    if ((port = virBitmapNextClearBit(map, 0)) <= 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Unable to find a free port on virtio-serial controller %u\"),\n                       addr->controller);\n        return -1;\n    }\n\n    addr->bus = 0;\n    addr->port = port;\n    VIR_DEBUG(\"Found free virtio serial controller %u port %u\", addr->controller,\n              addr->port);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrAssign",
          "args": [
            "virDomainDefPtrdef",
            "virDomainVirtioSerialAddrSetPtraddrs",
            "virDomainDeviceInfoPtrinfo",
            "boolallowZero",
            "boolportOnly"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATTRIBUTE_NONNULL",
          "args": [
            "3"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(2) ATTRIBUTE_NONNULL(3)\nvirDomainVirtioSerialAddrAssign(virDomainDefPtr def,\n                                virDomainVirtioSerialAddrSetPtr addrs,\n                                virDomainDeviceInfoPtr info,\n                                bool allowZero,\n                                bool portOnly)\n{\n    virDomainDeviceInfo nfo = { 0 };\n    virDomainDeviceInfoPtr ptr = allowZero ? &nfo : info;\n\n    ptr->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL;\n\n    if (portOnly) {\n        if (virDomainVirtioSerialAddrNextFromController(addrs,\n                                                        &ptr->addr.vioserial) < 0)\n            return -1;\n    } else {\n        if (virDomainVirtioSerialAddrNext(def, addrs, &ptr->addr.vioserial,\n                                          allowZero) < 0)\n            return -1;\n    }\n\n    if (virDomainVirtioSerialAddrReserve(NULL, NULL, ptr, addrs) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainVirtioSerialAddrNextFromController",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1816-1845",
    "snippet": "static int\nvirDomainVirtioSerialAddrNextFromController(virDomainVirtioSerialAddrSetPtr addrs,\n                                            virDomainDeviceVirtioSerialAddress *addr)\n{\n    ssize_t port;\n    ssize_t i;\n    virBitmapPtr map;\n\n    i = virDomainVirtioSerialAddrFindController(addrs, addr->controller);\n    if (i < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"virtio-serial controller %u not available\"),\n                       addr->controller);\n        return -1;\n    }\n\n    map = addrs->controllers[i]->ports;\n    if ((port = virBitmapNextClearBit(map, 0)) <= 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Unable to find a free port on virtio-serial controller %u\"),\n                       addr->controller);\n        return -1;\n    }\n\n    addr->bus = 0;\n    addr->port = port;\n    VIR_DEBUG(\"Found free virtio serial controller %u port %u\", addr->controller,\n              addr->port);\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Found free virtio serial controller %u port %u\"",
            "addr->controller",
            "addr->port"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Unable to find a free port on virtio-serial controller %u\")",
            "addr->controller"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to find a free port on virtio-serial controller %u\""
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNextClearBit",
          "args": [
            "map",
            "0"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNextClearBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1078-1113",
          "snippet": "ssize_t\nvirBitmapNextClearBit(virBitmapPtr bitmap,\n                      ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = ~bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = ~bitmap->map[nl];\n\n    if (nl == bitmap->map_len - 1) {\n        /* Ensure tail bits are ignored.  */\n        int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n        if (tail)\n            bits &= -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n    }\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapNextClearBit(virBitmapPtr bitmap,\n                      ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = ~bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = ~bitmap->map[nl];\n\n    if (nl == bitmap->map_len - 1) {\n        /* Ensure tail bits are ignored.  */\n        int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n        if (tail)\n            bits &= -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n    }\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"virtio-serial controller %u not available\")",
            "addr->controller"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrFindController",
          "args": [
            "addrs",
            "addr->controller"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialAddrFindController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1567-1578",
          "snippet": "static ssize_t\nvirDomainVirtioSerialAddrFindController(virDomainVirtioSerialAddrSetPtr addrs,\n                                        unsigned int idx)\n{\n    size_t i;\n\n    for (i = 0; i < addrs->ncontrollers; i++) {\n        if (addrs->controllers[i]->idx == idx)\n            return i;\n    }\n    return -1;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic ssize_t\nvirDomainVirtioSerialAddrFindController(virDomainVirtioSerialAddrSetPtr addrs,\n                                        unsigned int idx)\n{\n    size_t i;\n\n    for (i = 0; i < addrs->ncontrollers; i++) {\n        if (addrs->controllers[i]->idx == idx)\n            return i;\n    }\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainVirtioSerialAddrNextFromController(virDomainVirtioSerialAddrSetPtr addrs,\n                                            virDomainDeviceVirtioSerialAddress *addr)\n{\n    ssize_t port;\n    ssize_t i;\n    virBitmapPtr map;\n\n    i = virDomainVirtioSerialAddrFindController(addrs, addr->controller);\n    if (i < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"virtio-serial controller %u not available\"),\n                       addr->controller);\n        return -1;\n    }\n\n    map = addrs->controllers[i]->ports;\n    if ((port = virBitmapNextClearBit(map, 0)) <= 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Unable to find a free port on virtio-serial controller %u\"),\n                       addr->controller);\n        return -1;\n    }\n\n    addr->bus = 0;\n    addr->port = port;\n    VIR_DEBUG(\"Found free virtio serial controller %u port %u\", addr->controller,\n              addr->port);\n    return 0;\n}"
  },
  {
    "function_name": "virDomainVirtioSerialAddrNext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1760-1814",
    "snippet": "static int\nvirDomainVirtioSerialAddrNext(virDomainDefPtr def,\n                              virDomainVirtioSerialAddrSetPtr addrs,\n                              virDomainDeviceVirtioSerialAddress *addr,\n                              bool allowZero)\n{\n    ssize_t port, startPort = 0;\n    ssize_t i;\n    unsigned int controller;\n\n    /* port number 0 is reserved for virtconsoles */\n    if (allowZero)\n        startPort = -1;\n\n    if (addrs->ncontrollers == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no virtio-serial controllers are available\"));\n        return -1;\n    }\n\n    for (i = 0; i < addrs->ncontrollers; i++) {\n        virBitmapPtr map = addrs->controllers[i]->ports;\n        if ((port = virBitmapNextClearBit(map, startPort)) >= 0) {\n            controller = addrs->controllers[i]->idx;\n            goto success;\n        }\n    }\n\n    if (def) {\n        for (i = 0; i < INT_MAX; i++) {\n            int idx = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL, i);\n\n            if (idx == -1) {\n                if (virDomainVirtioSerialAddrSetAutoaddController(def, addrs, i) < 0)\n                    return -1;\n                controller = i;\n                port = startPort + 1;\n                goto success;\n            }\n        }\n    }\n\n    virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                   _(\"Unable to find a free virtio-serial port\"));\n\n    return -1;\n\n success:\n    addr->bus = 0;\n    addr->port = port;\n    addr->controller = controller;\n    VIR_DEBUG(\"Found free virtio serial controller %u port %u\", addr->controller,\n              addr->port);\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Found free virtio serial controller %u port %u\"",
            "addr->controller",
            "addr->port"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Unable to find a free virtio-serial port\")"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to find a free virtio-serial port\""
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrSetAutoaddController",
          "args": [
            "def",
            "addrs",
            "i"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialAddrSetAutoaddController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1740-1758",
          "snippet": "static int\nvirDomainVirtioSerialAddrSetAutoaddController(virDomainDefPtr def,\n                                              virDomainVirtioSerialAddrSetPtr addrs,\n                                              unsigned int idx)\n{\n    int contidx;\n\n    if (virDomainDefMaybeAddController(def,\n                                       VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL,\n                                       idx, -1) < 0)\n        return -1;\n\n    contidx = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL, idx);\n\n    if (virDomainVirtioSerialAddrSetAddController(addrs, def->controllers[contidx]) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainVirtioSerialAddrSetAutoaddController(virDomainDefPtr def,\n                                              virDomainVirtioSerialAddrSetPtr addrs,\n                                              unsigned int idx)\n{\n    int contidx;\n\n    if (virDomainDefMaybeAddController(def,\n                                       VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL,\n                                       idx, -1) < 0)\n        return -1;\n\n    contidx = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL, idx);\n\n    if (virDomainVirtioSerialAddrSetAddController(addrs, def->controllers[contidx]) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainControllerFind",
          "args": [
            "def",
            "VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL",
            "i"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainControllerFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17803-17818",
          "snippet": "int\nvirDomainControllerFind(const virDomainDef *def,\n                        int type,\n                        int idx)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if ((def->controllers[i]->type == type) &&\n            (def->controllers[i]->idx == idx)) {\n            return i;\n        }\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainControllerFind(const virDomainDef *def,\n                        int type,\n                        int idx)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if ((def->controllers[i]->type == type) &&\n            (def->controllers[i]->idx == idx)) {\n            return i;\n        }\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNextClearBit",
          "args": [
            "map",
            "startPort"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNextClearBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1078-1113",
          "snippet": "ssize_t\nvirBitmapNextClearBit(virBitmapPtr bitmap,\n                      ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = ~bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = ~bitmap->map[nl];\n\n    if (nl == bitmap->map_len - 1) {\n        /* Ensure tail bits are ignored.  */\n        int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n        if (tail)\n            bits &= -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n    }\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapNextClearBit(virBitmapPtr bitmap,\n                      ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = ~bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = ~bitmap->map[nl];\n\n    if (nl == bitmap->map_len - 1) {\n        /* Ensure tail bits are ignored.  */\n        int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n        if (tail)\n            bits &= -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n    }\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no virtio-serial controllers are available\")"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainVirtioSerialAddrNext(virDomainDefPtr def,\n                              virDomainVirtioSerialAddrSetPtr addrs,\n                              virDomainDeviceVirtioSerialAddress *addr,\n                              bool allowZero)\n{\n    ssize_t port, startPort = 0;\n    ssize_t i;\n    unsigned int controller;\n\n    /* port number 0 is reserved for virtconsoles */\n    if (allowZero)\n        startPort = -1;\n\n    if (addrs->ncontrollers == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no virtio-serial controllers are available\"));\n        return -1;\n    }\n\n    for (i = 0; i < addrs->ncontrollers; i++) {\n        virBitmapPtr map = addrs->controllers[i]->ports;\n        if ((port = virBitmapNextClearBit(map, startPort)) >= 0) {\n            controller = addrs->controllers[i]->idx;\n            goto success;\n        }\n    }\n\n    if (def) {\n        for (i = 0; i < INT_MAX; i++) {\n            int idx = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL, i);\n\n            if (idx == -1) {\n                if (virDomainVirtioSerialAddrSetAutoaddController(def, addrs, i) < 0)\n                    return -1;\n                controller = i;\n                port = startPort + 1;\n                goto success;\n            }\n        }\n    }\n\n    virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                   _(\"Unable to find a free virtio-serial port\"));\n\n    return -1;\n\n success:\n    addr->bus = 0;\n    addr->port = port;\n    addr->controller = controller;\n    VIR_DEBUG(\"Found free virtio serial controller %u port %u\", addr->controller,\n              addr->port);\n    return 0;\n}"
  },
  {
    "function_name": "virDomainVirtioSerialAddrSetAutoaddController",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1740-1758",
    "snippet": "static int\nvirDomainVirtioSerialAddrSetAutoaddController(virDomainDefPtr def,\n                                              virDomainVirtioSerialAddrSetPtr addrs,\n                                              unsigned int idx)\n{\n    int contidx;\n\n    if (virDomainDefMaybeAddController(def,\n                                       VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL,\n                                       idx, -1) < 0)\n        return -1;\n\n    contidx = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL, idx);\n\n    if (virDomainVirtioSerialAddrSetAddController(addrs, def->controllers[contidx]) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrSetAddController",
          "args": [
            "addrs",
            "def->controllers[contidx]"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialAddrSetAddController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1585-1622",
          "snippet": "static int\nvirDomainVirtioSerialAddrSetAddController(virDomainVirtioSerialAddrSetPtr addrs,\n                                          virDomainControllerDefPtr cont)\n{\n    int ret = -1;\n    int ports;\n    virDomainVirtioSerialControllerPtr cnt = NULL;\n    ssize_t insertAt;\n\n    if (cont->type != VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL)\n        return 0;\n\n    ports = cont->opts.vioserial.ports;\n    if (ports == -1)\n        ports = VIR_DOMAIN_DEFAULT_VIRTIO_SERIAL_PORTS;\n\n    VIR_DEBUG(\"Adding virtio serial controller index %u with %d\"\n              \" ports to the address set\", cont->idx, ports);\n\n    if (VIR_ALLOC(cnt) < 0)\n        goto cleanup;\n\n    if (!(cnt->ports = virBitmapNew(ports)))\n        goto cleanup;\n    cnt->idx = cont->idx;\n\n    if ((insertAt = virDomainVirtioSerialAddrPlaceController(addrs, cnt)) < -1)\n        goto cleanup;\n    if (VIR_INSERT_ELEMENT(addrs->controllers, insertAt,\n                           addrs->ncontrollers, cnt) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virDomainVirtioSerialControllerFree(cnt);\n    return ret;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_DEFAULT_VIRTIO_SERIAL_PORTS 31"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\n#define VIR_DOMAIN_DEFAULT_VIRTIO_SERIAL_PORTS 31\n\nstatic int\nvirDomainVirtioSerialAddrSetAddController(virDomainVirtioSerialAddrSetPtr addrs,\n                                          virDomainControllerDefPtr cont)\n{\n    int ret = -1;\n    int ports;\n    virDomainVirtioSerialControllerPtr cnt = NULL;\n    ssize_t insertAt;\n\n    if (cont->type != VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL)\n        return 0;\n\n    ports = cont->opts.vioserial.ports;\n    if (ports == -1)\n        ports = VIR_DOMAIN_DEFAULT_VIRTIO_SERIAL_PORTS;\n\n    VIR_DEBUG(\"Adding virtio serial controller index %u with %d\"\n              \" ports to the address set\", cont->idx, ports);\n\n    if (VIR_ALLOC(cnt) < 0)\n        goto cleanup;\n\n    if (!(cnt->ports = virBitmapNew(ports)))\n        goto cleanup;\n    cnt->idx = cont->idx;\n\n    if ((insertAt = virDomainVirtioSerialAddrPlaceController(addrs, cnt)) < -1)\n        goto cleanup;\n    if (VIR_INSERT_ELEMENT(addrs->controllers, insertAt,\n                           addrs->ncontrollers, cnt) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virDomainVirtioSerialControllerFree(cnt);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainControllerFind",
          "args": [
            "def",
            "VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL",
            "idx"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainControllerFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17803-17818",
          "snippet": "int\nvirDomainControllerFind(const virDomainDef *def,\n                        int type,\n                        int idx)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if ((def->controllers[i]->type == type) &&\n            (def->controllers[i]->idx == idx)) {\n            return i;\n        }\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainControllerFind(const virDomainDef *def,\n                        int type,\n                        int idx)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if ((def->controllers[i]->type == type) &&\n            (def->controllers[i]->idx == idx)) {\n            return i;\n        }\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefMaybeAddController",
          "args": [
            "def",
            "VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL",
            "idx",
            "-1"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefMaybeAddController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "19009-19024",
          "snippet": "int\nvirDomainDefMaybeAddController(virDomainDefPtr def,\n                               int type,\n                               int idx,\n                               int model)\n{\n    /* skip if a specific index was given and it is already\n     * in use for that type of controller\n     */\n    if (idx >= 0 && virDomainControllerFind(def, type, idx) >= 0)\n        return 0;\n\n    if (virDomainDefAddController(def, type, idx, model))\n        return 1;\n    return -1;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefMaybeAddController(virDomainDefPtr def,\n                               int type,\n                               int idx,\n                               int model)\n{\n    /* skip if a specific index was given and it is already\n     * in use for that type of controller\n     */\n    if (idx >= 0 && virDomainControllerFind(def, type, idx) >= 0)\n        return 0;\n\n    if (virDomainDefAddController(def, type, idx, model))\n        return 1;\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainVirtioSerialAddrSetAutoaddController(virDomainDefPtr def,\n                                              virDomainVirtioSerialAddrSetPtr addrs,\n                                              unsigned int idx)\n{\n    int contidx;\n\n    if (virDomainDefMaybeAddController(def,\n                                       VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL,\n                                       idx, -1) < 0)\n        return -1;\n\n    contidx = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL, idx);\n\n    if (virDomainVirtioSerialAddrSetAddController(addrs, def->controllers[contidx]) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainVirtioSerialAddrSetCreateFromDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1718-1738",
    "snippet": "virDomainVirtioSerialAddrSetPtr\nvirDomainVirtioSerialAddrSetCreateFromDomain(virDomainDefPtr def)\n{\n    virDomainVirtioSerialAddrSetPtr addrs = NULL;\n    virDomainVirtioSerialAddrSetPtr ret = NULL;\n\n    if (!(addrs = virDomainVirtioSerialAddrSetCreate()))\n        goto cleanup;\n\n    if (virDomainVirtioSerialAddrSetAddControllers(addrs, def) < 0)\n        goto cleanup;\n\n    if (virDomainDeviceInfoIterate(def, virDomainVirtioSerialAddrReserve,\n                                   addrs) < 0)\n        goto cleanup;\n\n    ret = g_steal_pointer(&addrs);\n cleanup:\n    virDomainVirtioSerialAddrSetFree(addrs);\n    return ret;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrSetFree",
          "args": [
            "addrs"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialAddrSetFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1645-1655",
          "snippet": "void\nvirDomainVirtioSerialAddrSetFree(virDomainVirtioSerialAddrSetPtr addrs)\n{\n    size_t i;\n    if (addrs) {\n        for (i = 0; i < addrs->ncontrollers; i++)\n            virDomainVirtioSerialControllerFree(addrs->controllers[i]);\n        VIR_FREE(addrs->controllers);\n        VIR_FREE(addrs);\n    }\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainVirtioSerialAddrSetFree(virDomainVirtioSerialAddrSetPtr addrs)\n{\n    size_t i;\n    if (addrs) {\n        for (i = 0; i < addrs->ncontrollers; i++)\n            virDomainVirtioSerialControllerFree(addrs->controllers[i]);\n        VIR_FREE(addrs->controllers);\n        VIR_FREE(addrs);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&addrs"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDeviceInfoIterate",
          "args": [
            "def",
            "virDomainVirtioSerialAddrReserve",
            "addrs"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceInfoIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "4352-4358",
          "snippet": "int\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrSetAddControllers",
          "args": [
            "addrs",
            "def"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrSetCreate",
          "args": [],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialAddrSetCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1527-1536",
          "snippet": "static virDomainVirtioSerialAddrSetPtr\nvirDomainVirtioSerialAddrSetCreate(void)\n{\n    virDomainVirtioSerialAddrSetPtr ret = NULL;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    return ret;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic virDomainVirtioSerialAddrSetPtr\nvirDomainVirtioSerialAddrSetCreate(void)\n{\n    virDomainVirtioSerialAddrSetPtr ret = NULL;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvirDomainVirtioSerialAddrSetPtr\nvirDomainVirtioSerialAddrSetCreateFromDomain(virDomainDefPtr def)\n{\n    virDomainVirtioSerialAddrSetPtr addrs = NULL;\n    virDomainVirtioSerialAddrSetPtr ret = NULL;\n\n    if (!(addrs = virDomainVirtioSerialAddrSetCreate()))\n        goto cleanup;\n\n    if (virDomainVirtioSerialAddrSetAddControllers(addrs, def) < 0)\n        goto cleanup;\n\n    if (virDomainDeviceInfoIterate(def, virDomainVirtioSerialAddrReserve,\n                                   addrs) < 0)\n        goto cleanup;\n\n    ret = g_steal_pointer(&addrs);\n cleanup:\n    virDomainVirtioSerialAddrSetFree(addrs);\n    return ret;\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1664-1709",
    "snippet": "static int ATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirDomainVirtioSerialAddrReserve(virDomainDefPtr def G_GNUC_UNUSED,\n                                 virDomainDeviceDefPtr dev G_GNUC_UNUSED,\n                                 virDomainDeviceInfoPtr info,\n                                 void *data)\n{\n    virDomainVirtioSerialAddrSetPtr addrs = data;\n    virBitmapPtr map = NULL;\n    bool b;\n    ssize_t i;\n\n    if (!virDomainVirtioSerialAddrIsComplete(info))\n        return 0;\n\n    VIR_DEBUG(\"Reserving virtio serial %u %u\", info->addr.vioserial.controller,\n              info->addr.vioserial.port);\n\n    i = virDomainVirtioSerialAddrFindController(addrs, info->addr.vioserial.controller);\n    if (i < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"virtio serial controller %u is missing\"),\n                       info->addr.vioserial.controller);\n        return -1;\n    }\n\n    map = addrs->controllers[i]->ports;\n    if (virBitmapGetBit(map, info->addr.vioserial.port, &b) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"virtio serial controller %u does not have port %u\"),\n                       info->addr.vioserial.controller,\n                       info->addr.vioserial.port);\n        return -1;\n    }\n\n    if (b) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"virtio serial port %u on controller %u is already occupied\"),\n                       info->addr.vioserial.port,\n                       info->addr.vioserial.controller);\n        return -1;\n    }\n\n    ignore_value(virBitmapSetBit(map, info->addr.vioserial.port));\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(map, info->addr.vioserial.port)"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "map",
            "info->addr.vioserial.port"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"virtio serial port %u on controller %u is already occupied\")",
            "info->addr.vioserial.port",
            "info->addr.vioserial.controller"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"virtio serial port %u on controller %u is already occupied\""
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"virtio serial controller %u does not have port %u\")",
            "info->addr.vioserial.controller",
            "info->addr.vioserial.port"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapGetBit",
          "args": [
            "map",
            "info->addr.vioserial.port",
            "&b"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapGetBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "320-330",
          "snippet": "int\nvirBitmapGetBit(virBitmapPtr bitmap,\n                size_t b,\n                bool *result)\n{\n    if (bitmap->nbits <= b)\n        return -1;\n\n    *result = virBitmapIsSet(bitmap, b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapGetBit(virBitmapPtr bitmap,\n                size_t b,\n                bool *result)\n{\n    if (bitmap->nbits <= b)\n        return -1;\n\n    *result = virBitmapIsSet(bitmap, b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"virtio serial controller %u is missing\")",
            "info->addr.vioserial.controller"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrFindController",
          "args": [
            "addrs",
            "info->addr.vioserial.controller"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialAddrFindController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1567-1578",
          "snippet": "static ssize_t\nvirDomainVirtioSerialAddrFindController(virDomainVirtioSerialAddrSetPtr addrs,\n                                        unsigned int idx)\n{\n    size_t i;\n\n    for (i = 0; i < addrs->ncontrollers; i++) {\n        if (addrs->controllers[i]->idx == idx)\n            return i;\n    }\n    return -1;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic ssize_t\nvirDomainVirtioSerialAddrFindController(virDomainVirtioSerialAddrSetPtr addrs,\n                                        unsigned int idx)\n{\n    size_t i;\n\n    for (i = 0; i < addrs->ncontrollers; i++) {\n        if (addrs->controllers[i]->idx == idx)\n            return i;\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Reserving virtio serial %u %u\"",
            "info->addr.vioserial.controller",
            "info->addr.vioserial.port"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrIsComplete",
          "args": [
            "info"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialAddrIsComplete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1920-1925",
          "snippet": "bool\nvirDomainVirtioSerialAddrIsComplete(virDomainDeviceInfoPtr info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL &&\n        info->addr.vioserial.port != 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainVirtioSerialAddrIsComplete(virDomainDeviceInfoPtr info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL &&\n        info->addr.vioserial.port != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrReserve",
          "args": [
            "virDomainDefPtr defG_GNUC_UNUSED",
            "virDomainDeviceDefPtr devG_GNUC_UNUSED",
            "virDomainDeviceInfoPtrinfo",
            "void *data"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirDomainVirtioSerialAddrReserve(virDomainDefPtr def G_GNUC_UNUSED,\n                                 virDomainDeviceDefPtr dev G_GNUC_UNUSED,\n                                 virDomainDeviceInfoPtr info,\n                                 void *data)\n{\n    virDomainVirtioSerialAddrSetPtr addrs = data;\n    virBitmapPtr map = NULL;\n    bool b;\n    ssize_t i;\n\n    if (!virDomainVirtioSerialAddrIsComplete(info))\n        return 0;\n\n    VIR_DEBUG(\"Reserving virtio serial %u %u\", info->addr.vioserial.controller,\n              info->addr.vioserial.port);\n\n    i = virDomainVirtioSerialAddrFindController(addrs, info->addr.vioserial.controller);\n    if (i < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"virtio serial controller %u is missing\"),\n                       info->addr.vioserial.controller);\n        return -1;\n    }\n\n    map = addrs->controllers[i]->ports;\n    if (virBitmapGetBit(map, info->addr.vioserial.port, &b) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"virtio serial controller %u does not have port %u\"),\n                       info->addr.vioserial.controller,\n                       info->addr.vioserial.port);\n        return -1;\n    }\n\n    if (b) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"virtio serial port %u on controller %u is already occupied\"),\n                       info->addr.vioserial.port,\n                       info->addr.vioserial.controller);\n        return -1;\n    }\n\n    ignore_value(virBitmapSetBit(map, info->addr.vioserial.port));\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainVirtioSerialAddrSetFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1645-1655",
    "snippet": "void\nvirDomainVirtioSerialAddrSetFree(virDomainVirtioSerialAddrSetPtr addrs)\n{\n    size_t i;\n    if (addrs) {\n        for (i = 0; i < addrs->ncontrollers; i++)\n            virDomainVirtioSerialControllerFree(addrs->controllers[i]);\n        VIR_FREE(addrs->controllers);\n        VIR_FREE(addrs);\n    }\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addrs"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addrs->controllers"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialControllerFree",
          "args": [
            "addrs->controllers[i]"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialControllerFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1538-1545",
          "snippet": "static void\nvirDomainVirtioSerialControllerFree(virDomainVirtioSerialControllerPtr cont)\n{\n    if (cont) {\n        virBitmapFree(cont->ports);\n        VIR_FREE(cont);\n    }\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainVirtioSerialControllerFree(virDomainVirtioSerialControllerPtr cont)\n{\n    if (cont) {\n        virBitmapFree(cont->ports);\n        VIR_FREE(cont);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainVirtioSerialAddrSetFree(virDomainVirtioSerialAddrSetPtr addrs)\n{\n    size_t i;\n    if (addrs) {\n        for (i = 0; i < addrs->ncontrollers; i++)\n            virDomainVirtioSerialControllerFree(addrs->controllers[i]);\n        VIR_FREE(addrs->controllers);\n        VIR_FREE(addrs);\n    }\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1629-1642",
    "snippet": "static int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirDomainVirtioSerialAddrSetAddControllers(virDomainVirtioSerialAddrSetPtr addrs,\n                                           virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (virDomainVirtioSerialAddrSetAddController(addrs,\n                                                      def->controllers[i]) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrSetAddController",
          "args": [
            "addrs",
            "def->controllers[i]"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialAddrSetAddController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1585-1622",
          "snippet": "static int\nvirDomainVirtioSerialAddrSetAddController(virDomainVirtioSerialAddrSetPtr addrs,\n                                          virDomainControllerDefPtr cont)\n{\n    int ret = -1;\n    int ports;\n    virDomainVirtioSerialControllerPtr cnt = NULL;\n    ssize_t insertAt;\n\n    if (cont->type != VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL)\n        return 0;\n\n    ports = cont->opts.vioserial.ports;\n    if (ports == -1)\n        ports = VIR_DOMAIN_DEFAULT_VIRTIO_SERIAL_PORTS;\n\n    VIR_DEBUG(\"Adding virtio serial controller index %u with %d\"\n              \" ports to the address set\", cont->idx, ports);\n\n    if (VIR_ALLOC(cnt) < 0)\n        goto cleanup;\n\n    if (!(cnt->ports = virBitmapNew(ports)))\n        goto cleanup;\n    cnt->idx = cont->idx;\n\n    if ((insertAt = virDomainVirtioSerialAddrPlaceController(addrs, cnt)) < -1)\n        goto cleanup;\n    if (VIR_INSERT_ELEMENT(addrs->controllers, insertAt,\n                           addrs->ncontrollers, cnt) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virDomainVirtioSerialControllerFree(cnt);\n    return ret;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_DEFAULT_VIRTIO_SERIAL_PORTS 31"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\n#define VIR_DOMAIN_DEFAULT_VIRTIO_SERIAL_PORTS 31\n\nstatic int\nvirDomainVirtioSerialAddrSetAddController(virDomainVirtioSerialAddrSetPtr addrs,\n                                          virDomainControllerDefPtr cont)\n{\n    int ret = -1;\n    int ports;\n    virDomainVirtioSerialControllerPtr cnt = NULL;\n    ssize_t insertAt;\n\n    if (cont->type != VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL)\n        return 0;\n\n    ports = cont->opts.vioserial.ports;\n    if (ports == -1)\n        ports = VIR_DOMAIN_DEFAULT_VIRTIO_SERIAL_PORTS;\n\n    VIR_DEBUG(\"Adding virtio serial controller index %u with %d\"\n              \" ports to the address set\", cont->idx, ports);\n\n    if (VIR_ALLOC(cnt) < 0)\n        goto cleanup;\n\n    if (!(cnt->ports = virBitmapNew(ports)))\n        goto cleanup;\n    cnt->idx = cont->idx;\n\n    if ((insertAt = virDomainVirtioSerialAddrPlaceController(addrs, cnt)) < -1)\n        goto cleanup;\n    if (VIR_INSERT_ELEMENT(addrs->controllers, insertAt,\n                           addrs->ncontrollers, cnt) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virDomainVirtioSerialControllerFree(cnt);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrSetAddControllers",
          "args": [
            "virDomainVirtioSerialAddrSetPtraddrs",
            "virDomainDefPtrdef"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATTRIBUTE_NONNULL",
          "args": [
            "2"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirDomainVirtioSerialAddrSetAddControllers(virDomainVirtioSerialAddrSetPtr addrs,\n                                           virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (virDomainVirtioSerialAddrSetAddController(addrs,\n                                                      def->controllers[i]) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainVirtioSerialAddrSetAddController",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1585-1622",
    "snippet": "static int\nvirDomainVirtioSerialAddrSetAddController(virDomainVirtioSerialAddrSetPtr addrs,\n                                          virDomainControllerDefPtr cont)\n{\n    int ret = -1;\n    int ports;\n    virDomainVirtioSerialControllerPtr cnt = NULL;\n    ssize_t insertAt;\n\n    if (cont->type != VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL)\n        return 0;\n\n    ports = cont->opts.vioserial.ports;\n    if (ports == -1)\n        ports = VIR_DOMAIN_DEFAULT_VIRTIO_SERIAL_PORTS;\n\n    VIR_DEBUG(\"Adding virtio serial controller index %u with %d\"\n              \" ports to the address set\", cont->idx, ports);\n\n    if (VIR_ALLOC(cnt) < 0)\n        goto cleanup;\n\n    if (!(cnt->ports = virBitmapNew(ports)))\n        goto cleanup;\n    cnt->idx = cont->idx;\n\n    if ((insertAt = virDomainVirtioSerialAddrPlaceController(addrs, cnt)) < -1)\n        goto cleanup;\n    if (VIR_INSERT_ELEMENT(addrs->controllers, insertAt,\n                           addrs->ncontrollers, cnt) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virDomainVirtioSerialControllerFree(cnt);\n    return ret;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define VIR_DOMAIN_DEFAULT_VIRTIO_SERIAL_PORTS 31"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainVirtioSerialControllerFree",
          "args": [
            "cnt"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialControllerFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1538-1545",
          "snippet": "static void\nvirDomainVirtioSerialControllerFree(virDomainVirtioSerialControllerPtr cont)\n{\n    if (cont) {\n        virBitmapFree(cont->ports);\n        VIR_FREE(cont);\n    }\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainVirtioSerialControllerFree(virDomainVirtioSerialControllerPtr cont)\n{\n    if (cont) {\n        virBitmapFree(cont->ports);\n        VIR_FREE(cont);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INSERT_ELEMENT",
          "args": [
            "addrs->controllers",
            "insertAt",
            "addrs->ncontrollers",
            "cnt"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrPlaceController",
          "args": [
            "addrs",
            "cnt"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialAddrPlaceController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1547-1565",
          "snippet": "static ssize_t\nvirDomainVirtioSerialAddrPlaceController(virDomainVirtioSerialAddrSetPtr addrs,\n                                         virDomainVirtioSerialControllerPtr cont)\n{\n    size_t i;\n\n    for (i = 0; i < addrs->ncontrollers; i++) {\n        if (addrs->controllers[i]->idx == cont->idx) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"virtio serial controller with index %u already exists\"\n                             \" in the address set\"),\n                           cont->idx);\n            return -2;\n        }\n        if (addrs->controllers[i]->idx > cont->idx)\n            return i;\n    }\n    return -1;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic ssize_t\nvirDomainVirtioSerialAddrPlaceController(virDomainVirtioSerialAddrSetPtr addrs,\n                                         virDomainVirtioSerialControllerPtr cont)\n{\n    size_t i;\n\n    for (i = 0; i < addrs->ncontrollers; i++) {\n        if (addrs->controllers[i]->idx == cont->idx) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"virtio serial controller with index %u already exists\"\n                             \" in the address set\"),\n                           cont->idx);\n            return -2;\n        }\n        if (addrs->controllers[i]->idx > cont->idx)\n            return i;\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "ports"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "cnt"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Adding virtio serial controller index %u with %d\"\n              \" ports to the address set\"",
            "cont->idx",
            "ports"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\n#define VIR_DOMAIN_DEFAULT_VIRTIO_SERIAL_PORTS 31\n\nstatic int\nvirDomainVirtioSerialAddrSetAddController(virDomainVirtioSerialAddrSetPtr addrs,\n                                          virDomainControllerDefPtr cont)\n{\n    int ret = -1;\n    int ports;\n    virDomainVirtioSerialControllerPtr cnt = NULL;\n    ssize_t insertAt;\n\n    if (cont->type != VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL)\n        return 0;\n\n    ports = cont->opts.vioserial.ports;\n    if (ports == -1)\n        ports = VIR_DOMAIN_DEFAULT_VIRTIO_SERIAL_PORTS;\n\n    VIR_DEBUG(\"Adding virtio serial controller index %u with %d\"\n              \" ports to the address set\", cont->idx, ports);\n\n    if (VIR_ALLOC(cnt) < 0)\n        goto cleanup;\n\n    if (!(cnt->ports = virBitmapNew(ports)))\n        goto cleanup;\n    cnt->idx = cont->idx;\n\n    if ((insertAt = virDomainVirtioSerialAddrPlaceController(addrs, cnt)) < -1)\n        goto cleanup;\n    if (VIR_INSERT_ELEMENT(addrs->controllers, insertAt,\n                           addrs->ncontrollers, cnt) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virDomainVirtioSerialControllerFree(cnt);\n    return ret;\n}"
  },
  {
    "function_name": "virDomainVirtioSerialAddrFindController",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1567-1578",
    "snippet": "static ssize_t\nvirDomainVirtioSerialAddrFindController(virDomainVirtioSerialAddrSetPtr addrs,\n                                        unsigned int idx)\n{\n    size_t i;\n\n    for (i = 0; i < addrs->ncontrollers; i++) {\n        if (addrs->controllers[i]->idx == idx)\n            return i;\n    }\n    return -1;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic ssize_t\nvirDomainVirtioSerialAddrFindController(virDomainVirtioSerialAddrSetPtr addrs,\n                                        unsigned int idx)\n{\n    size_t i;\n\n    for (i = 0; i < addrs->ncontrollers; i++) {\n        if (addrs->controllers[i]->idx == idx)\n            return i;\n    }\n    return -1;\n}"
  },
  {
    "function_name": "virDomainVirtioSerialAddrPlaceController",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1547-1565",
    "snippet": "static ssize_t\nvirDomainVirtioSerialAddrPlaceController(virDomainVirtioSerialAddrSetPtr addrs,\n                                         virDomainVirtioSerialControllerPtr cont)\n{\n    size_t i;\n\n    for (i = 0; i < addrs->ncontrollers; i++) {\n        if (addrs->controllers[i]->idx == cont->idx) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"virtio serial controller with index %u already exists\"\n                             \" in the address set\"),\n                           cont->idx);\n            return -2;\n        }\n        if (addrs->controllers[i]->idx > cont->idx)\n            return i;\n    }\n    return -1;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"virtio serial controller with index %u already exists\"\n                             \" in the address set\")",
            "cont->idx"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"virtio serial controller with index %u already exists\"\n                             \" in the address set\""
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic ssize_t\nvirDomainVirtioSerialAddrPlaceController(virDomainVirtioSerialAddrSetPtr addrs,\n                                         virDomainVirtioSerialControllerPtr cont)\n{\n    size_t i;\n\n    for (i = 0; i < addrs->ncontrollers; i++) {\n        if (addrs->controllers[i]->idx == cont->idx) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"virtio serial controller with index %u already exists\"\n                             \" in the address set\"),\n                           cont->idx);\n            return -2;\n        }\n        if (addrs->controllers[i]->idx > cont->idx)\n            return i;\n    }\n    return -1;\n}"
  },
  {
    "function_name": "virDomainVirtioSerialControllerFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1538-1545",
    "snippet": "static void\nvirDomainVirtioSerialControllerFree(virDomainVirtioSerialControllerPtr cont)\n{\n    if (cont) {\n        virBitmapFree(cont->ports);\n        VIR_FREE(cont);\n    }\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cont"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "cont->ports"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainVirtioSerialControllerFree(virDomainVirtioSerialControllerPtr cont)\n{\n    if (cont) {\n        virBitmapFree(cont->ports);\n        VIR_FREE(cont);\n    }\n}"
  },
  {
    "function_name": "virDomainVirtioSerialAddrSetCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1527-1536",
    "snippet": "static virDomainVirtioSerialAddrSetPtr\nvirDomainVirtioSerialAddrSetCreate(void)\n{\n    virDomainVirtioSerialAddrSetPtr ret = NULL;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    return ret;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ret"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic virDomainVirtioSerialAddrSetPtr\nvirDomainVirtioSerialAddrSetCreate(void)\n{\n    virDomainVirtioSerialAddrSetPtr ret = NULL;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    return ret;\n}"
  },
  {
    "function_name": "virDomainCCWAddressSetCreateFromDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1496-1517",
    "snippet": "virDomainCCWAddressSetPtr\nvirDomainCCWAddressSetCreateFromDomain(virDomainDefPtr def)\n{\n    virDomainCCWAddressSetPtr addrs = NULL;\n\n    if (!(addrs = virDomainCCWAddressSetCreate()))\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def, virDomainCCWAddressValidate,\n                                   addrs) < 0)\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def, virDomainCCWAddressAllocate,\n                                   addrs) < 0)\n        goto error;\n\n    return addrs;\n\n error:\n    virDomainCCWAddressSetFree(addrs);\n    return NULL;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainCCWAddressSetFree",
          "args": [
            "addrs"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCCWAddressSetFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1463-1470",
          "snippet": "void virDomainCCWAddressSetFree(virDomainCCWAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virHashFree(addrs->defined);\n    VIR_FREE(addrs);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid virDomainCCWAddressSetFree(virDomainCCWAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virHashFree(addrs->defined);\n    VIR_FREE(addrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDeviceInfoIterate",
          "args": [
            "def",
            "virDomainCCWAddressAllocate",
            "addrs"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceInfoIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "4352-4358",
          "snippet": "int\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainCCWAddressSetCreate",
          "args": [],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCCWAddressSetCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1472-1493",
          "snippet": "static virDomainCCWAddressSetPtr\nvirDomainCCWAddressSetCreate(void)\n{\n    virDomainCCWAddressSetPtr addrs = NULL;\n\n    if (VIR_ALLOC(addrs) < 0)\n        goto error;\n\n    if (!(addrs->defined = virHashCreate(10, virHashValueFree)))\n        goto error;\n\n    /* must use cssid = 0xfe (254) for virtio-ccw devices */\n    addrs->next.cssid = 254;\n    addrs->next.ssid = 0;\n    addrs->next.devno = 0;\n    addrs->next.assigned = 0;\n    return addrs;\n\n error:\n    virDomainCCWAddressSetFree(addrs);\n    return NULL;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic virDomainCCWAddressSetPtr\nvirDomainCCWAddressSetCreate(void)\n{\n    virDomainCCWAddressSetPtr addrs = NULL;\n\n    if (VIR_ALLOC(addrs) < 0)\n        goto error;\n\n    if (!(addrs->defined = virHashCreate(10, virHashValueFree)))\n        goto error;\n\n    /* must use cssid = 0xfe (254) for virtio-ccw devices */\n    addrs->next.cssid = 254;\n    addrs->next.ssid = 0;\n    addrs->next.devno = 0;\n    addrs->next.assigned = 0;\n    return addrs;\n\n error:\n    virDomainCCWAddressSetFree(addrs);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvirDomainCCWAddressSetPtr\nvirDomainCCWAddressSetCreateFromDomain(virDomainDefPtr def)\n{\n    virDomainCCWAddressSetPtr addrs = NULL;\n\n    if (!(addrs = virDomainCCWAddressSetCreate()))\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def, virDomainCCWAddressValidate,\n                                   addrs) < 0)\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def, virDomainCCWAddressAllocate,\n                                   addrs) < 0)\n        goto error;\n\n    return addrs;\n\n error:\n    virDomainCCWAddressSetFree(addrs);\n    return NULL;\n}"
  },
  {
    "function_name": "virDomainCCWAddressSetCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1472-1493",
    "snippet": "static virDomainCCWAddressSetPtr\nvirDomainCCWAddressSetCreate(void)\n{\n    virDomainCCWAddressSetPtr addrs = NULL;\n\n    if (VIR_ALLOC(addrs) < 0)\n        goto error;\n\n    if (!(addrs->defined = virHashCreate(10, virHashValueFree)))\n        goto error;\n\n    /* must use cssid = 0xfe (254) for virtio-ccw devices */\n    addrs->next.cssid = 254;\n    addrs->next.ssid = 0;\n    addrs->next.devno = 0;\n    addrs->next.assigned = 0;\n    return addrs;\n\n error:\n    virDomainCCWAddressSetFree(addrs);\n    return NULL;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainCCWAddressSetFree",
          "args": [
            "addrs"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCCWAddressSetFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1463-1470",
          "snippet": "void virDomainCCWAddressSetFree(virDomainCCWAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virHashFree(addrs->defined);\n    VIR_FREE(addrs);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid virDomainCCWAddressSetFree(virDomainCCWAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virHashFree(addrs->defined);\n    VIR_FREE(addrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "10",
            "virHashValueFree"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "addrs"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic virDomainCCWAddressSetPtr\nvirDomainCCWAddressSetCreate(void)\n{\n    virDomainCCWAddressSetPtr addrs = NULL;\n\n    if (VIR_ALLOC(addrs) < 0)\n        goto error;\n\n    if (!(addrs->defined = virHashCreate(10, virHashValueFree)))\n        goto error;\n\n    /* must use cssid = 0xfe (254) for virtio-ccw devices */\n    addrs->next.cssid = 254;\n    addrs->next.ssid = 0;\n    addrs->next.devno = 0;\n    addrs->next.assigned = 0;\n    return addrs;\n\n error:\n    virDomainCCWAddressSetFree(addrs);\n    return NULL;\n}"
  },
  {
    "function_name": "virDomainCCWAddressSetFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1463-1470",
    "snippet": "void virDomainCCWAddressSetFree(virDomainCCWAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virHashFree(addrs->defined);\n    VIR_FREE(addrs);\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addrs"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "addrs->defined"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid virDomainCCWAddressSetFree(virDomainCCWAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virHashFree(addrs->defined);\n    VIR_FREE(addrs);\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1454-1461",
    "snippet": "static int ATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirDomainCCWAddressValidate(virDomainDefPtr def G_GNUC_UNUSED,\n                            virDomainDeviceDefPtr dev G_GNUC_UNUSED,\n                            virDomainDeviceInfoPtr info,\n                            void *data)\n{\n    return virDomainCCWAddressAssign(info, data, false);\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainCCWAddressAssign",
          "args": [
            "info",
            "data",
            "false"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCCWAddressAssign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1397-1443",
          "snippet": "int\nvirDomainCCWAddressAssign(virDomainDeviceInfoPtr dev,\n                          virDomainCCWAddressSetPtr addrs,\n                          bool autoassign)\n{\n    g_autofree char *addr = NULL;\n\n    if (dev->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW)\n        return 0;\n\n    if (!autoassign && dev->addr.ccw.assigned) {\n        if (!(addr = virDomainCCWAddressAsString(&dev->addr.ccw)))\n            return -1;\n\n        if (virHashLookup(addrs->defined, addr)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"The CCW devno '%s' is in use already \"),\n                           addr);\n            return -1;\n        }\n    } else if (autoassign && !dev->addr.ccw.assigned) {\n        if (!(addr = virDomainCCWAddressAsString(&addrs->next)))\n            return -1;\n\n        while (virHashLookup(addrs->defined, addr)) {\n            if (virDomainCCWAddressIncrement(&addrs->next) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"There are no more free CCW devnos.\"));\n                return -1;\n            }\n            VIR_FREE(addr);\n            if (!(addr = virDomainCCWAddressAsString(&addrs->next)))\n                return -1;\n        }\n        dev->addr.ccw = addrs->next;\n        dev->addr.ccw.assigned = true;\n    } else {\n        return 0;\n    }\n\n    if (virHashAddEntry(addrs->defined, addr, addr) < 0)\n        return -1;\n    else\n        addr = NULL; /* memory will be freed by hash table */\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainCCWAddressAssign(virDomainDeviceInfoPtr dev,\n                          virDomainCCWAddressSetPtr addrs,\n                          bool autoassign)\n{\n    g_autofree char *addr = NULL;\n\n    if (dev->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW)\n        return 0;\n\n    if (!autoassign && dev->addr.ccw.assigned) {\n        if (!(addr = virDomainCCWAddressAsString(&dev->addr.ccw)))\n            return -1;\n\n        if (virHashLookup(addrs->defined, addr)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"The CCW devno '%s' is in use already \"),\n                           addr);\n            return -1;\n        }\n    } else if (autoassign && !dev->addr.ccw.assigned) {\n        if (!(addr = virDomainCCWAddressAsString(&addrs->next)))\n            return -1;\n\n        while (virHashLookup(addrs->defined, addr)) {\n            if (virDomainCCWAddressIncrement(&addrs->next) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"There are no more free CCW devnos.\"));\n                return -1;\n            }\n            VIR_FREE(addr);\n            if (!(addr = virDomainCCWAddressAsString(&addrs->next)))\n                return -1;\n        }\n        dev->addr.ccw = addrs->next;\n        dev->addr.ccw.assigned = true;\n    } else {\n        return 0;\n    }\n\n    if (virHashAddEntry(addrs->defined, addr, addr) < 0)\n        return -1;\n    else\n        addr = NULL; /* memory will be freed by hash table */\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainCCWAddressValidate",
          "args": [
            "virDomainDefPtr defG_GNUC_UNUSED",
            "virDomainDeviceDefPtr devG_GNUC_UNUSED",
            "virDomainDeviceInfoPtrinfo",
            "void *data"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATTRIBUTE_NONNULL",
          "args": [
            "4"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirDomainCCWAddressValidate(virDomainDefPtr def G_GNUC_UNUSED,\n                            virDomainDeviceDefPtr dev G_GNUC_UNUSED,\n                            virDomainDeviceInfoPtr info,\n                            void *data)\n{\n    return virDomainCCWAddressAssign(info, data, false);\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1445-1452",
    "snippet": "static int ATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirDomainCCWAddressAllocate(virDomainDefPtr def G_GNUC_UNUSED,\n                            virDomainDeviceDefPtr dev G_GNUC_UNUSED,\n                            virDomainDeviceInfoPtr info,\n                            void *data)\n{\n    return virDomainCCWAddressAssign(info, data, true);\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainCCWAddressAssign",
          "args": [
            "info",
            "data",
            "true"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCCWAddressAssign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1397-1443",
          "snippet": "int\nvirDomainCCWAddressAssign(virDomainDeviceInfoPtr dev,\n                          virDomainCCWAddressSetPtr addrs,\n                          bool autoassign)\n{\n    g_autofree char *addr = NULL;\n\n    if (dev->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW)\n        return 0;\n\n    if (!autoassign && dev->addr.ccw.assigned) {\n        if (!(addr = virDomainCCWAddressAsString(&dev->addr.ccw)))\n            return -1;\n\n        if (virHashLookup(addrs->defined, addr)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"The CCW devno '%s' is in use already \"),\n                           addr);\n            return -1;\n        }\n    } else if (autoassign && !dev->addr.ccw.assigned) {\n        if (!(addr = virDomainCCWAddressAsString(&addrs->next)))\n            return -1;\n\n        while (virHashLookup(addrs->defined, addr)) {\n            if (virDomainCCWAddressIncrement(&addrs->next) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"There are no more free CCW devnos.\"));\n                return -1;\n            }\n            VIR_FREE(addr);\n            if (!(addr = virDomainCCWAddressAsString(&addrs->next)))\n                return -1;\n        }\n        dev->addr.ccw = addrs->next;\n        dev->addr.ccw.assigned = true;\n    } else {\n        return 0;\n    }\n\n    if (virHashAddEntry(addrs->defined, addr, addr) < 0)\n        return -1;\n    else\n        addr = NULL; /* memory will be freed by hash table */\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainCCWAddressAssign(virDomainDeviceInfoPtr dev,\n                          virDomainCCWAddressSetPtr addrs,\n                          bool autoassign)\n{\n    g_autofree char *addr = NULL;\n\n    if (dev->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW)\n        return 0;\n\n    if (!autoassign && dev->addr.ccw.assigned) {\n        if (!(addr = virDomainCCWAddressAsString(&dev->addr.ccw)))\n            return -1;\n\n        if (virHashLookup(addrs->defined, addr)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"The CCW devno '%s' is in use already \"),\n                           addr);\n            return -1;\n        }\n    } else if (autoassign && !dev->addr.ccw.assigned) {\n        if (!(addr = virDomainCCWAddressAsString(&addrs->next)))\n            return -1;\n\n        while (virHashLookup(addrs->defined, addr)) {\n            if (virDomainCCWAddressIncrement(&addrs->next) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"There are no more free CCW devnos.\"));\n                return -1;\n            }\n            VIR_FREE(addr);\n            if (!(addr = virDomainCCWAddressAsString(&addrs->next)))\n                return -1;\n        }\n        dev->addr.ccw = addrs->next;\n        dev->addr.ccw.assigned = true;\n    } else {\n        return 0;\n    }\n\n    if (virHashAddEntry(addrs->defined, addr, addr) < 0)\n        return -1;\n    else\n        addr = NULL; /* memory will be freed by hash table */\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainCCWAddressAllocate",
          "args": [
            "virDomainDefPtr defG_GNUC_UNUSED",
            "virDomainDeviceDefPtr devG_GNUC_UNUSED",
            "virDomainDeviceInfoPtrinfo",
            "void *data"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATTRIBUTE_NONNULL",
          "args": [
            "4"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirDomainCCWAddressAllocate(virDomainDefPtr def G_GNUC_UNUSED,\n                            virDomainDeviceDefPtr dev G_GNUC_UNUSED,\n                            virDomainDeviceInfoPtr info,\n                            void *data)\n{\n    return virDomainCCWAddressAssign(info, data, true);\n}"
  },
  {
    "function_name": "virDomainCCWAddressAssign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1397-1443",
    "snippet": "int\nvirDomainCCWAddressAssign(virDomainDeviceInfoPtr dev,\n                          virDomainCCWAddressSetPtr addrs,\n                          bool autoassign)\n{\n    g_autofree char *addr = NULL;\n\n    if (dev->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW)\n        return 0;\n\n    if (!autoassign && dev->addr.ccw.assigned) {\n        if (!(addr = virDomainCCWAddressAsString(&dev->addr.ccw)))\n            return -1;\n\n        if (virHashLookup(addrs->defined, addr)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"The CCW devno '%s' is in use already \"),\n                           addr);\n            return -1;\n        }\n    } else if (autoassign && !dev->addr.ccw.assigned) {\n        if (!(addr = virDomainCCWAddressAsString(&addrs->next)))\n            return -1;\n\n        while (virHashLookup(addrs->defined, addr)) {\n            if (virDomainCCWAddressIncrement(&addrs->next) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"There are no more free CCW devnos.\"));\n                return -1;\n            }\n            VIR_FREE(addr);\n            if (!(addr = virDomainCCWAddressAsString(&addrs->next)))\n                return -1;\n        }\n        dev->addr.ccw = addrs->next;\n        dev->addr.ccw.assigned = true;\n    } else {\n        return 0;\n    }\n\n    if (virHashAddEntry(addrs->defined, addr, addr) < 0)\n        return -1;\n    else\n        addr = NULL; /* memory will be freed by hash table */\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashAddEntry",
          "args": [
            "addrs->defined",
            "addr",
            "addr"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAddEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "404-408",
          "snippet": "int\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainCCWAddressAsString",
          "args": [
            "&addrs->next"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCCWAddressAsString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1371-1381",
          "snippet": "static char*\nvirDomainCCWAddressAsString(virDomainDeviceCCWAddressPtr addr)\n{\n    char *addrstr = NULL;\n\n    addrstr = g_strdup_printf(\"%x.%x.%04x\",\n                              addr->cssid,\n                              addr->ssid,\n                              addr->devno);\n    return addrstr;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char*\nvirDomainCCWAddressAsString(virDomainDeviceCCWAddressPtr addr)\n{\n    char *addrstr = NULL;\n\n    addrstr = g_strdup_printf(\"%x.%x.%04x\",\n                              addr->cssid,\n                              addr->ssid,\n                              addr->devno);\n    return addrstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addr"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"There are no more free CCW devnos.\")"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"There are no more free CCW devnos.\""
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainCCWAddressIncrement",
          "args": [
            "&addrs->next"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCCWAddressIncrement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1383-1394",
          "snippet": "static int\nvirDomainCCWAddressIncrement(virDomainDeviceCCWAddressPtr addr)\n{\n    virDomainDeviceCCWAddress ccwaddr = *addr;\n\n    /* We are not touching subchannel sets and channel subsystems */\n    if (++ccwaddr.devno > VIR_DOMAIN_DEVICE_CCW_MAX_DEVNO)\n        return -1;\n\n    *addr = ccwaddr;\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainCCWAddressIncrement(virDomainDeviceCCWAddressPtr addr)\n{\n    virDomainDeviceCCWAddress ccwaddr = *addr;\n\n    /* We are not touching subchannel sets and channel subsystems */\n    if (++ccwaddr.devno > VIR_DOMAIN_DEVICE_CCW_MAX_DEVNO)\n        return -1;\n\n    *addr = ccwaddr;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "addrs->defined",
            "addr"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"The CCW devno '%s' is in use already \")",
            "addr"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainCCWAddressAssign(virDomainDeviceInfoPtr dev,\n                          virDomainCCWAddressSetPtr addrs,\n                          bool autoassign)\n{\n    g_autofree char *addr = NULL;\n\n    if (dev->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW)\n        return 0;\n\n    if (!autoassign && dev->addr.ccw.assigned) {\n        if (!(addr = virDomainCCWAddressAsString(&dev->addr.ccw)))\n            return -1;\n\n        if (virHashLookup(addrs->defined, addr)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"The CCW devno '%s' is in use already \"),\n                           addr);\n            return -1;\n        }\n    } else if (autoassign && !dev->addr.ccw.assigned) {\n        if (!(addr = virDomainCCWAddressAsString(&addrs->next)))\n            return -1;\n\n        while (virHashLookup(addrs->defined, addr)) {\n            if (virDomainCCWAddressIncrement(&addrs->next) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"There are no more free CCW devnos.\"));\n                return -1;\n            }\n            VIR_FREE(addr);\n            if (!(addr = virDomainCCWAddressAsString(&addrs->next)))\n                return -1;\n        }\n        dev->addr.ccw = addrs->next;\n        dev->addr.ccw.assigned = true;\n    } else {\n        return 0;\n    }\n\n    if (virHashAddEntry(addrs->defined, addr, addr) < 0)\n        return -1;\n    else\n        addr = NULL; /* memory will be freed by hash table */\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainCCWAddressIncrement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1383-1394",
    "snippet": "static int\nvirDomainCCWAddressIncrement(virDomainDeviceCCWAddressPtr addr)\n{\n    virDomainDeviceCCWAddress ccwaddr = *addr;\n\n    /* We are not touching subchannel sets and channel subsystems */\n    if (++ccwaddr.devno > VIR_DOMAIN_DEVICE_CCW_MAX_DEVNO)\n        return -1;\n\n    *addr = ccwaddr;\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainCCWAddressIncrement(virDomainDeviceCCWAddressPtr addr)\n{\n    virDomainDeviceCCWAddress ccwaddr = *addr;\n\n    /* We are not touching subchannel sets and channel subsystems */\n    if (++ccwaddr.devno > VIR_DOMAIN_DEVICE_CCW_MAX_DEVNO)\n        return -1;\n\n    *addr = ccwaddr;\n    return 0;\n}"
  },
  {
    "function_name": "virDomainCCWAddressAsString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1371-1381",
    "snippet": "static char*\nvirDomainCCWAddressAsString(virDomainDeviceCCWAddressPtr addr)\n{\n    char *addrstr = NULL;\n\n    addrstr = g_strdup_printf(\"%x.%x.%04x\",\n                              addr->cssid,\n                              addr->ssid,\n                              addr->devno);\n    return addrstr;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%x.%x.%04x\"",
            "addr->cssid",
            "addr->ssid",
            "addr->devno"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char*\nvirDomainCCWAddressAsString(virDomainDeviceCCWAddressPtr addr)\n{\n    char *addrstr = NULL;\n\n    addrstr = g_strdup_printf(\"%x.%x.%04x\",\n                              addr->cssid,\n                              addr->ssid,\n                              addr->devno);\n    return addrstr;\n}"
  },
  {
    "function_name": "virDomainPCIAddressSetAllMulti",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1356-1368",
    "snippet": "void\nvirDomainPCIAddressSetAllMulti(virDomainDefPtr def)\n{\n    /* Use nested iterators over all the devices - the outer iterator\n     * scans through all the devices looking for those whose address\n     * has a non-0 function; when one is found, the inner iterator looks\n     * for the device that uses function 0 on the same slot and marks\n     * it as multi = ON\n     */\n    ignore_value(virDomainDeviceInfoIterate(def,\n                                            virDomainPCIAddressSetAllMultiIter,\n                                            NULL));\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virDomainDeviceInfoIterate(def,\n                                            virDomainPCIAddressSetAllMultiIter,\n                                            NULL)"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDeviceInfoIterate",
          "args": [
            "def",
            "virDomainPCIAddressSetAllMultiIter",
            "NULL"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceInfoIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "4352-4358",
          "snippet": "int\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainPCIAddressSetAllMulti(virDomainDefPtr def)\n{\n    /* Use nested iterators over all the devices - the outer iterator\n     * scans through all the devices looking for those whose address\n     * has a non-0 function; when one is found, the inner iterator looks\n     * for the device that uses function 0 on the same slot and marks\n     * it as multi = ON\n     */\n    ignore_value(virDomainDeviceInfoIterate(def,\n                                            virDomainPCIAddressSetAllMultiIter,\n                                            NULL));\n}"
  },
  {
    "function_name": "virDomainPCIAddressSetAllMultiIter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1321-1341",
    "snippet": "static int\nvirDomainPCIAddressSetAllMultiIter(virDomainDefPtr def,\n                                   virDomainDeviceDefPtr dev G_GNUC_UNUSED,\n                                   virDomainDeviceInfoPtr info,\n                                   void *data G_GNUC_UNUSED)\n{\n    virPCIDeviceAddressPtr testAddr;\n\n    if (!info || info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI)\n       return 0;\n\n    testAddr = &info->addr.pci;\n\n    if (testAddr->function != 0) {\n        ignore_value(virDomainDeviceInfoIterate(def,\n                                                virDomainPCIAddressSetMultiIter,\n                                                testAddr));\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virDomainDeviceInfoIterate(def,\n                                                virDomainPCIAddressSetMultiIter,\n                                                testAddr)"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDeviceInfoIterate",
          "args": [
            "def",
            "virDomainPCIAddressSetMultiIter",
            "testAddr"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceInfoIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "4352-4358",
          "snippet": "int\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainPCIAddressSetAllMultiIter(virDomainDefPtr def,\n                                   virDomainDeviceDefPtr dev G_GNUC_UNUSED,\n                                   virDomainDeviceInfoPtr info,\n                                   void *data G_GNUC_UNUSED)\n{\n    virPCIDeviceAddressPtr testAddr;\n\n    if (!info || info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI)\n       return 0;\n\n    testAddr = &info->addr.pci;\n\n    if (testAddr->function != 0) {\n        ignore_value(virDomainDeviceInfoIterate(def,\n                                                virDomainPCIAddressSetMultiIter,\n                                                testAddr));\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainPCIAddressSetMultiIter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1288-1318",
    "snippet": "static int\nvirDomainPCIAddressSetMultiIter(virDomainDefPtr def G_GNUC_UNUSED,\n                                virDomainDeviceDefPtr dev G_GNUC_UNUSED,\n                                virDomainDeviceInfoPtr info,\n                                void *data)\n{\n    virPCIDeviceAddressPtr testAddr = data;\n    virPCIDeviceAddressPtr thisAddr;\n\n    if (!info || info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI)\n       return 0;\n\n    thisAddr = &info->addr.pci;\n\n    if (thisAddr->domain == testAddr->domain &&\n        thisAddr->bus == testAddr->bus &&\n        thisAddr->slot == testAddr->slot &&\n        thisAddr->function == 0) {\n\n        /* only set to ON if it wasn't previously set\n         * (assuming that the user must have better information\n         * than us if they explicitly set it OFF)\n         */\n        if (thisAddr->multi == VIR_TRISTATE_SWITCH_ABSENT)\n            thisAddr->multi = VIR_TRISTATE_SWITCH_ON;\n\n        return -1; /* finish early, *NOT* an error */\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainPCIAddressSetMultiIter(virDomainDefPtr def G_GNUC_UNUSED,\n                                virDomainDeviceDefPtr dev G_GNUC_UNUSED,\n                                virDomainDeviceInfoPtr info,\n                                void *data)\n{\n    virPCIDeviceAddressPtr testAddr = data;\n    virPCIDeviceAddressPtr thisAddr;\n\n    if (!info || info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI)\n       return 0;\n\n    thisAddr = &info->addr.pci;\n\n    if (thisAddr->domain == testAddr->domain &&\n        thisAddr->bus == testAddr->bus &&\n        thisAddr->slot == testAddr->slot &&\n        thisAddr->function == 0) {\n\n        /* only set to ON if it wasn't previously set\n         * (assuming that the user must have better information\n         * than us if they explicitly set it OFF)\n         */\n        if (thisAddr->multi == VIR_TRISTATE_SWITCH_ABSENT)\n            thisAddr->multi = VIR_TRISTATE_SWITCH_ON;\n\n        return -1; /* finish early, *NOT* an error */\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainPCIAddressReserveNextAddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1260-1285",
    "snippet": "int\nvirDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                   virDomainDeviceInfoPtr dev,\n                                   virDomainPCIConnectFlags flags,\n                                   int function)\n{\n    virPCIDeviceAddress addr;\n\n    if (virDomainPCIAddressGetNextAddr(addrs, &addr, flags,\n                                       dev->isolationGroup, function) < 0)\n        return -1;\n\n    if (virDomainPCIAddressReserveAddrInternal(addrs, &addr, flags,\n                                               dev->isolationGroup, false) < 0)\n        return -1;\n\n    addr.extFlags = dev->addr.pci.extFlags;\n    addr.zpci = dev->addr.pci.zpci;\n\n    if (!addrs->dryRun) {\n        dev->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n        dev->addr.pci = addr;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainPCIAddressReserveAddrInternal",
          "args": [
            "addrs",
            "&addr",
            "flags",
            "dev->isolationGroup",
            "false"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressGetNextAddr",
          "args": [
            "addrs",
            "&addr",
            "flags",
            "dev->isolationGroup",
            "function"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                   virDomainDeviceInfoPtr dev,\n                                   virDomainPCIConnectFlags flags,\n                                   int function)\n{\n    virPCIDeviceAddress addr;\n\n    if (virDomainPCIAddressGetNextAddr(addrs, &addr, flags,\n                                       dev->isolationGroup, function) < 0)\n        return -1;\n\n    if (virDomainPCIAddressReserveAddrInternal(addrs, &addr, flags,\n                                               dev->isolationGroup, false) < 0)\n        return -1;\n\n    addr.extFlags = dev->addr.pci.extFlags;\n    addr.zpci = dev->addr.pci.zpci;\n\n    if (!addrs->dryRun) {\n        dev->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n        dev->addr.pci = addr;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1153-1240",
    "snippet": "static int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirDomainPCIAddressGetNextAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr next_addr,\n                               virDomainPCIConnectFlags flags,\n                               unsigned int isolationGroup,\n                               int function)\n{\n    virPCIDeviceAddress a = { 0 };\n\n    if (addrs->nbuses == 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\", _(\"No PCI buses available\"));\n        return -1;\n    }\n\n    /* if the caller asks for \"any function\", give them function 0 */\n    if (function == -1)\n        a.function = 0;\n    else\n        a.function = function;\n\n    /* When looking for a suitable bus for the device, start by being\n     * very strict and ignoring all those where the isolation groups\n     * don't match. This ensures all devices sharing the same isolation\n     * group will end up on the same bus */\n    for (a.bus = 0; a.bus < addrs->nbuses; a.bus++) {\n        virDomainPCIAddressBusPtr bus = &addrs->buses[a.bus];\n        bool found = false;\n\n        if (bus->isolationGroup != isolationGroup)\n            continue;\n\n        a.slot = bus->minSlot;\n\n        if (virDomainPCIAddressFindUnusedFunctionOnBus(bus, &a, function,\n                                                       flags, &found) < 0) {\n            return -1;\n        }\n\n        if (found)\n            goto success;\n    }\n\n    /* We haven't been able to find a perfectly matching bus, but we\n     * might still be able to make this work by altering the isolation\n     * group for a bus that's currently empty. So let's try that */\n    for (a.bus = 0; a.bus < addrs->nbuses; a.bus++) {\n        virDomainPCIAddressBusPtr bus = &addrs->buses[a.bus];\n        bool found = false;\n\n        /* We can only change the isolation group for a bus when\n         * plugging in the first device; moreover, some buses are\n         * prevented from ever changing it */\n        if (!virDomainPCIAddressBusIsEmpty(bus) || bus->isolationGroupLocked)\n            continue;\n\n        a.slot = bus->minSlot;\n\n        if (virDomainPCIAddressFindUnusedFunctionOnBus(bus, &a, function,\n                                                       flags, &found) < 0) {\n            return -1;\n        }\n\n        /* The isolation group for the bus will actually be changed\n         * later, in virDomainPCIAddressReserveAddrInternal() */\n        if (found)\n            goto success;\n    }\n\n    /* There were no free slots after the last used one */\n    if (addrs->dryRun) {\n        /* a is already set to the first new bus */\n        if (virDomainPCIAddressSetGrow(addrs, &a, flags) < 0)\n            return -1;\n        /* this device will use the first slot of the new bus */\n        a.slot = addrs->buses[a.bus].minSlot;\n        goto success;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"No more available PCI slots\"));\n    return -1;\n\n success:\n    VIR_DEBUG(\"Found free PCI slot %04x:%02x:%02x\",\n              a.domain, a.bus, a.slot);\n    *next_addr = a;\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Found free PCI slot %04x:%02x:%02x\"",
            "a.domain",
            "a.bus",
            "a.slot"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"No more available PCI slots\")"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No more available PCI slots\""
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressSetGrow",
          "args": [
            "addrs",
            "&a",
            "flags"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressSetGrow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "641-804",
          "snippet": "static int\nvirDomainPCIAddressSetGrow(virDomainPCIAddressSetPtr addrs,\n                           virPCIDeviceAddressPtr addr,\n                           virDomainPCIConnectFlags flags)\n{\n    int add;\n    size_t i;\n    int model;\n    bool needDMIToPCIBridge = false;\n    bool needPCIeToPCIBridge = false;\n\n    add = addr->bus - addrs->nbuses + 1;\n    if (add <= 0)\n        return 0;\n\n    /* remember that the flags aren't for the type of controller that\n     * we want to add, they are the type of *device* that we want to\n     * plug in, and this function must decide on the appropriate\n     * controller to add in order to give us a slot for that device.\n     */\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCI_DEVICE) {\n        if (addrs->areMultipleRootsSupported) {\n            /* Use a pci-root controller to expand the guest's PCI\n             * topology if it supports having more than one */\n            model = VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT;\n        } else {\n            model = VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE;\n\n            /* if there aren't yet any buses that will accept a\n             * pci-bridge, but we need one for the device's PCI address\n             * to make sense, it means the guest only has a PCIe topology\n             * configured so far, and we need to create a traditional PCI\n             * topology to accommodate the new device.\n             */\n            needDMIToPCIBridge = true;\n            needPCIeToPCIBridge = true;\n            for (i = 0; i < addrs->nbuses; i++) {\n                if (addrs->buses[i].flags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE) {\n                    needDMIToPCIBridge = false;\n                    needPCIeToPCIBridge = false;\n                    break;\n                }\n            }\n\n            /* Prefer pcie-to-pci-bridge, fall back to dmi-to-pci-bridge */\n            if (addrs->isPCIeToPCIBridgeSupported)\n                needDMIToPCIBridge = false;\n            else\n                needPCIeToPCIBridge = false;\n\n            if ((needDMIToPCIBridge || needPCIeToPCIBridge) && add == 1) {\n                /* We need to add a single pci-bridge to provide the bus\n                 * our legacy PCI device will be plugged into; however, we\n                 * have also determined that there isn't yet any proper\n                 * place to connect that pci-bridge we're about to add,\n                 * which means we're dealing with a pure PCIe guest. We\n                 * need to create a traditional PCI topology, and for that\n                 * we have two options: dmi-to-pci-bridge + pci-bridge or\n                 * pcie-root-port + pcie-to-pci-bridge (the latter of which\n                 * is pretty much a pci-bridge as far as devices attached\n                 * to it are concerned and as such makes the pci-bridge\n                 * unnecessary). Either way, there's going to be one more\n                 * controller than initially expected, and the 'bus' part\n                 * of the device's address will need to be bumped.\n                 */\n                add++;\n                addr->bus++;\n            }\n        }\n    } else if (flags & (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                        VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT)) {\n        model = VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT;\n    } else {\n        /* The types of devices that we can't auto-add a controller for:\n         *\n         * VIR_CONNECT_TYPE_DMI_TO_PCI_BRIDGE &\n         * VIR_PCI_CONNECT_TYPE_ROOT_PORT - these can only plug into\n         *  pcie-root or pcie-expander-bus. By definition there is\n         *  only 1 pcie-root, and we don't support auto-adding\n         *  pcie-expander-bus (because it is intended for NUMA usage,\n         *  and we can't automatically decide which numa node to\n         *  associate it with)\n         *\n         * VIR_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT - we ndon't\n         *  support this, because it can only plug into an\n         *  upstream-port, and the upstream port might need a\n         *  root-port; supporting this extra layer needlessly\n         *  complicates the code, and upstream/downstream ports are\n         *  outside the scope of our \"automatic-bus-expansion\" model\n         *  anyway.\n         *\n         * VIR_CONNECT_TYPE_PCI[E]_EXPANDER_BUS - these were created\n         *  to support guest awareness of the NUMA node placement of\n         *  devices on the host, and are also outside the scope of our\n         *  \"automatic-bus-expansion\".\n         *\n         * VIR_PCI_CONNECT_TYPE_PCI_BRIDGE (when the root bus is\n         *  pci-root) - see the comment above in the case that handles\n         *  adding a slot for pci-bridge to a guest with pcie-root.\n         *\n         */\n        int existingContModel = virDomainPCIControllerConnectTypeToModel(flags);\n\n        if (existingContModel >= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"a PCI slot is needed to connect a PCI controller \"\n                             \"model='%s', but none is available, and it \"\n                             \"cannot be automatically added\"),\n                           virDomainControllerModelPCITypeToString(existingContModel));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cannot automatically add a new PCI bus for a \"\n                             \"device with connect flags %.2x\"), flags);\n        }\n        return -1;\n    }\n\n    i = addrs->nbuses;\n\n    if (VIR_EXPAND_N(addrs->buses, addrs->nbuses, add) < 0)\n        return -1;\n\n    if (needDMIToPCIBridge) {\n        /* first of the new buses is dmi-to-pci-bridge, the\n         * rest are of the requested type\n         */\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i++],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE) < 0) {\n            return -1;\n        }\n    }\n\n    if (needPCIeToPCIBridge) {\n        /* We need a pcie-root-port to plug pcie-to-pci-bridge into; however,\n         * qemuDomainAssignPCIAddresses() will, in some cases, create a dummy\n         * PCIe device and reserve an address for it in order to leave the\n         * user with an empty pcie-root-port ready for hotplugging, and if\n         * we didn't do anything other than adding the pcie-root-port here\n         * it would be used for that, which we don't want. So we change the\n         * connect flags to make sure only the pcie-to-pci-bridge will be\n         * connected to the pcie-root-port we just added, and another one\n         * will be allocated for the dummy PCIe device later on.\n         */\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT) < 0) {\n            return -1;\n        }\n        addrs->buses[i].flags = VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE;\n        i++;\n\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i++],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE) < 0) {\n            return -1;\n        }\n    }\n\n    for (; i < addrs->nbuses; i++) {\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i], model) < 0)\n            return -1;\n    }\n\n    return add;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainPCIAddressSetGrow(virDomainPCIAddressSetPtr addrs,\n                           virPCIDeviceAddressPtr addr,\n                           virDomainPCIConnectFlags flags)\n{\n    int add;\n    size_t i;\n    int model;\n    bool needDMIToPCIBridge = false;\n    bool needPCIeToPCIBridge = false;\n\n    add = addr->bus - addrs->nbuses + 1;\n    if (add <= 0)\n        return 0;\n\n    /* remember that the flags aren't for the type of controller that\n     * we want to add, they are the type of *device* that we want to\n     * plug in, and this function must decide on the appropriate\n     * controller to add in order to give us a slot for that device.\n     */\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCI_DEVICE) {\n        if (addrs->areMultipleRootsSupported) {\n            /* Use a pci-root controller to expand the guest's PCI\n             * topology if it supports having more than one */\n            model = VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT;\n        } else {\n            model = VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE;\n\n            /* if there aren't yet any buses that will accept a\n             * pci-bridge, but we need one for the device's PCI address\n             * to make sense, it means the guest only has a PCIe topology\n             * configured so far, and we need to create a traditional PCI\n             * topology to accommodate the new device.\n             */\n            needDMIToPCIBridge = true;\n            needPCIeToPCIBridge = true;\n            for (i = 0; i < addrs->nbuses; i++) {\n                if (addrs->buses[i].flags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE) {\n                    needDMIToPCIBridge = false;\n                    needPCIeToPCIBridge = false;\n                    break;\n                }\n            }\n\n            /* Prefer pcie-to-pci-bridge, fall back to dmi-to-pci-bridge */\n            if (addrs->isPCIeToPCIBridgeSupported)\n                needDMIToPCIBridge = false;\n            else\n                needPCIeToPCIBridge = false;\n\n            if ((needDMIToPCIBridge || needPCIeToPCIBridge) && add == 1) {\n                /* We need to add a single pci-bridge to provide the bus\n                 * our legacy PCI device will be plugged into; however, we\n                 * have also determined that there isn't yet any proper\n                 * place to connect that pci-bridge we're about to add,\n                 * which means we're dealing with a pure PCIe guest. We\n                 * need to create a traditional PCI topology, and for that\n                 * we have two options: dmi-to-pci-bridge + pci-bridge or\n                 * pcie-root-port + pcie-to-pci-bridge (the latter of which\n                 * is pretty much a pci-bridge as far as devices attached\n                 * to it are concerned and as such makes the pci-bridge\n                 * unnecessary). Either way, there's going to be one more\n                 * controller than initially expected, and the 'bus' part\n                 * of the device's address will need to be bumped.\n                 */\n                add++;\n                addr->bus++;\n            }\n        }\n    } else if (flags & (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                        VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT)) {\n        model = VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT;\n    } else {\n        /* The types of devices that we can't auto-add a controller for:\n         *\n         * VIR_CONNECT_TYPE_DMI_TO_PCI_BRIDGE &\n         * VIR_PCI_CONNECT_TYPE_ROOT_PORT - these can only plug into\n         *  pcie-root or pcie-expander-bus. By definition there is\n         *  only 1 pcie-root, and we don't support auto-adding\n         *  pcie-expander-bus (because it is intended for NUMA usage,\n         *  and we can't automatically decide which numa node to\n         *  associate it with)\n         *\n         * VIR_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT - we ndon't\n         *  support this, because it can only plug into an\n         *  upstream-port, and the upstream port might need a\n         *  root-port; supporting this extra layer needlessly\n         *  complicates the code, and upstream/downstream ports are\n         *  outside the scope of our \"automatic-bus-expansion\" model\n         *  anyway.\n         *\n         * VIR_CONNECT_TYPE_PCI[E]_EXPANDER_BUS - these were created\n         *  to support guest awareness of the NUMA node placement of\n         *  devices on the host, and are also outside the scope of our\n         *  \"automatic-bus-expansion\".\n         *\n         * VIR_PCI_CONNECT_TYPE_PCI_BRIDGE (when the root bus is\n         *  pci-root) - see the comment above in the case that handles\n         *  adding a slot for pci-bridge to a guest with pcie-root.\n         *\n         */\n        int existingContModel = virDomainPCIControllerConnectTypeToModel(flags);\n\n        if (existingContModel >= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"a PCI slot is needed to connect a PCI controller \"\n                             \"model='%s', but none is available, and it \"\n                             \"cannot be automatically added\"),\n                           virDomainControllerModelPCITypeToString(existingContModel));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cannot automatically add a new PCI bus for a \"\n                             \"device with connect flags %.2x\"), flags);\n        }\n        return -1;\n    }\n\n    i = addrs->nbuses;\n\n    if (VIR_EXPAND_N(addrs->buses, addrs->nbuses, add) < 0)\n        return -1;\n\n    if (needDMIToPCIBridge) {\n        /* first of the new buses is dmi-to-pci-bridge, the\n         * rest are of the requested type\n         */\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i++],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE) < 0) {\n            return -1;\n        }\n    }\n\n    if (needPCIeToPCIBridge) {\n        /* We need a pcie-root-port to plug pcie-to-pci-bridge into; however,\n         * qemuDomainAssignPCIAddresses() will, in some cases, create a dummy\n         * PCIe device and reserve an address for it in order to leave the\n         * user with an empty pcie-root-port ready for hotplugging, and if\n         * we didn't do anything other than adding the pcie-root-port here\n         * it would be used for that, which we don't want. So we change the\n         * connect flags to make sure only the pcie-to-pci-bridge will be\n         * connected to the pcie-root-port we just added, and another one\n         * will be allocated for the dummy PCIe device later on.\n         */\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT) < 0) {\n            return -1;\n        }\n        addrs->buses[i].flags = VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE;\n        i++;\n\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i++],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE) < 0) {\n            return -1;\n        }\n    }\n\n    for (; i < addrs->nbuses; i++) {\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i], model) < 0)\n            return -1;\n    }\n\n    return add;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressFindUnusedFunctionOnBus",
          "args": [
            "bus",
            "&a",
            "function",
            "flags",
            "&found"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressFindUnusedFunctionOnBus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1091-1150",
          "snippet": "static int\nvirDomainPCIAddressFindUnusedFunctionOnBus(virDomainPCIAddressBusPtr bus,\n                                           virPCIDeviceAddressPtr searchAddr,\n                                           int function,\n                                           virDomainPCIConnectFlags flags,\n                                           bool *found)\n{\n    g_autofree char *addrStr = NULL;\n\n    *found = false;\n\n    if (!(addrStr = virPCIDeviceAddressAsString(searchAddr)))\n        return -1;\n\n    if (!virDomainPCIAddressFlagsCompatible(searchAddr, addrStr, bus->flags,\n                                            flags, false, false)) {\n        VIR_DEBUG(\"PCI bus %04x:%02x is not compatible with the device\",\n                  searchAddr->domain, searchAddr->bus);\n    } else {\n        while (searchAddr->slot <= bus->maxSlot) {\n            if (bus->slot[searchAddr->slot].functions == 0) {\n                *found = true;\n                break;\n            }\n\n            if (flags & VIR_PCI_CONNECT_AGGREGATE_SLOT &&\n                bus->slot[searchAddr->slot].aggregate) {\n                /* slot and device are okay with aggregating devices */\n                if ((bus->slot[searchAddr->slot].functions &\n                     (1 << searchAddr->function)) == 0) {\n                    *found = true;\n                    break;\n                }\n\n                /* also check for *any* unused function if caller\n                 * sent function = -1\n                 */\n                if (function == -1) {\n                    while (searchAddr->function < 8) {\n                        if ((bus->slot[searchAddr->slot].functions &\n                             (1 << searchAddr->function)) == 0) {\n                            *found = true;\n                            break; /* out of inner while */\n                        }\n                        searchAddr->function++;\n                    }\n                    if (*found)\n                       break; /* out of outer while */\n                    searchAddr->function = 0; /* reset for next try */\n                }\n            }\n\n            VIR_DEBUG(\"PCI slot %04x:%02x:%02x already in use\",\n                      searchAddr->domain, searchAddr->bus, searchAddr->slot);\n            searchAddr->slot++;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainPCIAddressFindUnusedFunctionOnBus(virDomainPCIAddressBusPtr bus,\n                                           virPCIDeviceAddressPtr searchAddr,\n                                           int function,\n                                           virDomainPCIConnectFlags flags,\n                                           bool *found)\n{\n    g_autofree char *addrStr = NULL;\n\n    *found = false;\n\n    if (!(addrStr = virPCIDeviceAddressAsString(searchAddr)))\n        return -1;\n\n    if (!virDomainPCIAddressFlagsCompatible(searchAddr, addrStr, bus->flags,\n                                            flags, false, false)) {\n        VIR_DEBUG(\"PCI bus %04x:%02x is not compatible with the device\",\n                  searchAddr->domain, searchAddr->bus);\n    } else {\n        while (searchAddr->slot <= bus->maxSlot) {\n            if (bus->slot[searchAddr->slot].functions == 0) {\n                *found = true;\n                break;\n            }\n\n            if (flags & VIR_PCI_CONNECT_AGGREGATE_SLOT &&\n                bus->slot[searchAddr->slot].aggregate) {\n                /* slot and device are okay with aggregating devices */\n                if ((bus->slot[searchAddr->slot].functions &\n                     (1 << searchAddr->function)) == 0) {\n                    *found = true;\n                    break;\n                }\n\n                /* also check for *any* unused function if caller\n                 * sent function = -1\n                 */\n                if (function == -1) {\n                    while (searchAddr->function < 8) {\n                        if ((bus->slot[searchAddr->slot].functions &\n                             (1 << searchAddr->function)) == 0) {\n                            *found = true;\n                            break; /* out of inner while */\n                        }\n                        searchAddr->function++;\n                    }\n                    if (*found)\n                       break; /* out of outer while */\n                    searchAddr->function = 0; /* reset for next try */\n                }\n            }\n\n            VIR_DEBUG(\"PCI slot %04x:%02x:%02x already in use\",\n                      searchAddr->domain, searchAddr->bus, searchAddr->slot);\n            searchAddr->slot++;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressBusIsEmpty",
          "args": [
            "bus"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"No PCI buses available\")"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressGetNextAddr",
          "args": [
            "virDomainPCIAddressSetPtraddrs",
            "virPCIDeviceAddressPtrnext_addr",
            "virDomainPCIConnectFlagsflags",
            "unsigned intisolationGroup",
            "intfunction"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirDomainPCIAddressGetNextAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr next_addr,\n                               virDomainPCIConnectFlags flags,\n                               unsigned int isolationGroup,\n                               int function)\n{\n    virPCIDeviceAddress a = { 0 };\n\n    if (addrs->nbuses == 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\", _(\"No PCI buses available\"));\n        return -1;\n    }\n\n    /* if the caller asks for \"any function\", give them function 0 */\n    if (function == -1)\n        a.function = 0;\n    else\n        a.function = function;\n\n    /* When looking for a suitable bus for the device, start by being\n     * very strict and ignoring all those where the isolation groups\n     * don't match. This ensures all devices sharing the same isolation\n     * group will end up on the same bus */\n    for (a.bus = 0; a.bus < addrs->nbuses; a.bus++) {\n        virDomainPCIAddressBusPtr bus = &addrs->buses[a.bus];\n        bool found = false;\n\n        if (bus->isolationGroup != isolationGroup)\n            continue;\n\n        a.slot = bus->minSlot;\n\n        if (virDomainPCIAddressFindUnusedFunctionOnBus(bus, &a, function,\n                                                       flags, &found) < 0) {\n            return -1;\n        }\n\n        if (found)\n            goto success;\n    }\n\n    /* We haven't been able to find a perfectly matching bus, but we\n     * might still be able to make this work by altering the isolation\n     * group for a bus that's currently empty. So let's try that */\n    for (a.bus = 0; a.bus < addrs->nbuses; a.bus++) {\n        virDomainPCIAddressBusPtr bus = &addrs->buses[a.bus];\n        bool found = false;\n\n        /* We can only change the isolation group for a bus when\n         * plugging in the first device; moreover, some buses are\n         * prevented from ever changing it */\n        if (!virDomainPCIAddressBusIsEmpty(bus) || bus->isolationGroupLocked)\n            continue;\n\n        a.slot = bus->minSlot;\n\n        if (virDomainPCIAddressFindUnusedFunctionOnBus(bus, &a, function,\n                                                       flags, &found) < 0) {\n            return -1;\n        }\n\n        /* The isolation group for the bus will actually be changed\n         * later, in virDomainPCIAddressReserveAddrInternal() */\n        if (found)\n            goto success;\n    }\n\n    /* There were no free slots after the last used one */\n    if (addrs->dryRun) {\n        /* a is already set to the first new bus */\n        if (virDomainPCIAddressSetGrow(addrs, &a, flags) < 0)\n            return -1;\n        /* this device will use the first slot of the new bus */\n        a.slot = addrs->buses[a.bus].minSlot;\n        goto success;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"No more available PCI slots\"));\n    return -1;\n\n success:\n    VIR_DEBUG(\"Found free PCI slot %04x:%02x:%02x\",\n              a.domain, a.bus, a.slot);\n    *next_addr = a;\n    return 0;\n}"
  },
  {
    "function_name": "virDomainPCIAddressFindUnusedFunctionOnBus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1091-1150",
    "snippet": "static int\nvirDomainPCIAddressFindUnusedFunctionOnBus(virDomainPCIAddressBusPtr bus,\n                                           virPCIDeviceAddressPtr searchAddr,\n                                           int function,\n                                           virDomainPCIConnectFlags flags,\n                                           bool *found)\n{\n    g_autofree char *addrStr = NULL;\n\n    *found = false;\n\n    if (!(addrStr = virPCIDeviceAddressAsString(searchAddr)))\n        return -1;\n\n    if (!virDomainPCIAddressFlagsCompatible(searchAddr, addrStr, bus->flags,\n                                            flags, false, false)) {\n        VIR_DEBUG(\"PCI bus %04x:%02x is not compatible with the device\",\n                  searchAddr->domain, searchAddr->bus);\n    } else {\n        while (searchAddr->slot <= bus->maxSlot) {\n            if (bus->slot[searchAddr->slot].functions == 0) {\n                *found = true;\n                break;\n            }\n\n            if (flags & VIR_PCI_CONNECT_AGGREGATE_SLOT &&\n                bus->slot[searchAddr->slot].aggregate) {\n                /* slot and device are okay with aggregating devices */\n                if ((bus->slot[searchAddr->slot].functions &\n                     (1 << searchAddr->function)) == 0) {\n                    *found = true;\n                    break;\n                }\n\n                /* also check for *any* unused function if caller\n                 * sent function = -1\n                 */\n                if (function == -1) {\n                    while (searchAddr->function < 8) {\n                        if ((bus->slot[searchAddr->slot].functions &\n                             (1 << searchAddr->function)) == 0) {\n                            *found = true;\n                            break; /* out of inner while */\n                        }\n                        searchAddr->function++;\n                    }\n                    if (*found)\n                       break; /* out of outer while */\n                    searchAddr->function = 0; /* reset for next try */\n                }\n            }\n\n            VIR_DEBUG(\"PCI slot %04x:%02x:%02x already in use\",\n                      searchAddr->domain, searchAddr->bus, searchAddr->slot);\n            searchAddr->slot++;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"PCI slot %04x:%02x:%02x already in use\"",
            "searchAddr->domain",
            "searchAddr->bus",
            "searchAddr->slot"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"PCI bus %04x:%02x is not compatible with the device\"",
            "searchAddr->domain",
            "searchAddr->bus"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressFlagsCompatible",
          "args": [
            "searchAddr",
            "addrStr",
            "bus->flags",
            "flags",
            "false",
            "false"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressFlagsCompatible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "341-434",
          "snippet": "static bool\nvirDomainPCIAddressFlagsCompatible(virPCIDeviceAddressPtr addr,\n                                   const char *addrStr,\n                                   virDomainPCIConnectFlags busFlags,\n                                   virDomainPCIConnectFlags devFlags,\n                                   bool reportError,\n                                   bool fromConfig)\n{\n    virErrorNumber errType = (fromConfig\n                              ? VIR_ERR_XML_ERROR : VIR_ERR_INTERNAL_ERROR);\n\n    if (fromConfig) {\n        /* If the requested connection was manually specified in\n         * config, allow a PCI device to connect to a PCIe slot, or\n         * vice versa. In order to do so, we add *both* the PCI_DEVICE\n         * and the PCIE_DEVICE flags to the bus if it already has either\n         * of them, using the ENDPOINT mask.\n         */\n        if (busFlags & VIR_PCI_CONNECT_TYPES_ENDPOINT)\n            busFlags |= VIR_PCI_CONNECT_TYPES_ENDPOINT;\n        /* Also allow manual specification of bus to override\n         * libvirt's assumptions about whether or not hotplug\n         * capability will be required.\n         */\n        if (devFlags & VIR_PCI_CONNECT_HOTPLUGGABLE)\n            busFlags |= VIR_PCI_CONNECT_HOTPLUGGABLE;\n        /* if the device is a pci-bridge, allow manually\n         * assigning to any bus that would also accept a\n         * standard PCI device.\n         */\n        if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE)\n            devFlags |= VIR_PCI_CONNECT_TYPE_PCI_DEVICE;\n    }\n\n    /* If this bus doesn't allow the type of connection (PCI\n     * vs. PCIe) required by the device, or if the device requires\n     * hot-plug and this bus doesn't have it, return false.\n     */\n    if (!(devFlags & busFlags & VIR_PCI_CONNECT_TYPES_MASK)) {\n        const char *connectStr;\n\n        if (!reportError)\n            return false;\n\n        if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_DEVICE) {\n            connectStr = \"standard PCI device\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_DEVICE) {\n            connectStr = \"PCI Express device\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT) {\n            connectStr = \"pcie-root-port\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT) {\n            connectStr = \"pcie-switch-upstream-port\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT) {\n            connectStr = \"pcie-switch-downstream-port\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE) {\n            connectStr = \"dmi-to-pci-bridge\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE) {\n            connectStr = \"pcie-to-pci-bridge\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS) {\n            connectStr = \"pci-expander-bus\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS) {\n            connectStr = \"pcie-expander-bus\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE) {\n            connectStr = \"pci-bridge\";\n        } else {\n            /* this should never happen. If it does, there is a\n             * bug in the code that sets the flag bits for devices.\n             */\n            virReportError(errType,\n                           _(\"The device at PCI address %s has \"\n                             \"unrecognized connection type flags 0x%.2x\"),\n                           addrStr, devFlags & VIR_PCI_CONNECT_TYPES_MASK);\n            return false;\n        }\n        virReportError(errType,\n                       _(\"The device at PCI address %s cannot be \"\n                         \"plugged into the PCI controller with index='%d'. \"\n                         \"It requires a controller that accepts a %s.\"),\n                       addrStr, addr->bus, connectStr);\n        return false;\n    }\n    if ((devFlags & VIR_PCI_CONNECT_HOTPLUGGABLE) &&\n        !(busFlags & VIR_PCI_CONNECT_HOTPLUGGABLE)) {\n        if (reportError) {\n            virReportError(errType,\n                           _(\"The device at PCI address %s requires \"\n                             \"hotplug capability, but the PCI controller \"\n                             \"with index='%d' doesn't support hotplug\"),\n                           addrStr, addr->bus);\n        }\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic bool\nvirDomainPCIAddressFlagsCompatible(virPCIDeviceAddressPtr addr,\n                                   const char *addrStr,\n                                   virDomainPCIConnectFlags busFlags,\n                                   virDomainPCIConnectFlags devFlags,\n                                   bool reportError,\n                                   bool fromConfig)\n{\n    virErrorNumber errType = (fromConfig\n                              ? VIR_ERR_XML_ERROR : VIR_ERR_INTERNAL_ERROR);\n\n    if (fromConfig) {\n        /* If the requested connection was manually specified in\n         * config, allow a PCI device to connect to a PCIe slot, or\n         * vice versa. In order to do so, we add *both* the PCI_DEVICE\n         * and the PCIE_DEVICE flags to the bus if it already has either\n         * of them, using the ENDPOINT mask.\n         */\n        if (busFlags & VIR_PCI_CONNECT_TYPES_ENDPOINT)\n            busFlags |= VIR_PCI_CONNECT_TYPES_ENDPOINT;\n        /* Also allow manual specification of bus to override\n         * libvirt's assumptions about whether or not hotplug\n         * capability will be required.\n         */\n        if (devFlags & VIR_PCI_CONNECT_HOTPLUGGABLE)\n            busFlags |= VIR_PCI_CONNECT_HOTPLUGGABLE;\n        /* if the device is a pci-bridge, allow manually\n         * assigning to any bus that would also accept a\n         * standard PCI device.\n         */\n        if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE)\n            devFlags |= VIR_PCI_CONNECT_TYPE_PCI_DEVICE;\n    }\n\n    /* If this bus doesn't allow the type of connection (PCI\n     * vs. PCIe) required by the device, or if the device requires\n     * hot-plug and this bus doesn't have it, return false.\n     */\n    if (!(devFlags & busFlags & VIR_PCI_CONNECT_TYPES_MASK)) {\n        const char *connectStr;\n\n        if (!reportError)\n            return false;\n\n        if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_DEVICE) {\n            connectStr = \"standard PCI device\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_DEVICE) {\n            connectStr = \"PCI Express device\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT) {\n            connectStr = \"pcie-root-port\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT) {\n            connectStr = \"pcie-switch-upstream-port\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT) {\n            connectStr = \"pcie-switch-downstream-port\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE) {\n            connectStr = \"dmi-to-pci-bridge\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE) {\n            connectStr = \"pcie-to-pci-bridge\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS) {\n            connectStr = \"pci-expander-bus\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS) {\n            connectStr = \"pcie-expander-bus\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE) {\n            connectStr = \"pci-bridge\";\n        } else {\n            /* this should never happen. If it does, there is a\n             * bug in the code that sets the flag bits for devices.\n             */\n            virReportError(errType,\n                           _(\"The device at PCI address %s has \"\n                             \"unrecognized connection type flags 0x%.2x\"),\n                           addrStr, devFlags & VIR_PCI_CONNECT_TYPES_MASK);\n            return false;\n        }\n        virReportError(errType,\n                       _(\"The device at PCI address %s cannot be \"\n                         \"plugged into the PCI controller with index='%d'. \"\n                         \"It requires a controller that accepts a %s.\"),\n                       addrStr, addr->bus, connectStr);\n        return false;\n    }\n    if ((devFlags & VIR_PCI_CONNECT_HOTPLUGGABLE) &&\n        !(busFlags & VIR_PCI_CONNECT_HOTPLUGGABLE)) {\n        if (reportError) {\n            virReportError(errType,\n                           _(\"The device at PCI address %s requires \"\n                             \"hotplug capability, but the PCI controller \"\n                             \"with index='%d' doesn't support hotplug\"),\n                           addrStr, addr->bus);\n        }\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressAsString",
          "args": [
            "searchAddr"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressAsString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1351-1362",
          "snippet": "char *\nvirPCIDeviceAddressAsString(const virPCIDeviceAddress *addr)\n{\n    char *str;\n\n    str = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT,\n                          addr->domain,\n                          addr->bus,\n                          addr->slot,\n                          addr->function);\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceAddressAsString(const virPCIDeviceAddress *addr)\n{\n    char *str;\n\n    str = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT,\n                          addr->domain,\n                          addr->bus,\n                          addr->slot,\n                          addr->function);\n    return str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainPCIAddressFindUnusedFunctionOnBus(virDomainPCIAddressBusPtr bus,\n                                           virPCIDeviceAddressPtr searchAddr,\n                                           int function,\n                                           virDomainPCIConnectFlags flags,\n                                           bool *found)\n{\n    g_autofree char *addrStr = NULL;\n\n    *found = false;\n\n    if (!(addrStr = virPCIDeviceAddressAsString(searchAddr)))\n        return -1;\n\n    if (!virDomainPCIAddressFlagsCompatible(searchAddr, addrStr, bus->flags,\n                                            flags, false, false)) {\n        VIR_DEBUG(\"PCI bus %04x:%02x is not compatible with the device\",\n                  searchAddr->domain, searchAddr->bus);\n    } else {\n        while (searchAddr->slot <= bus->maxSlot) {\n            if (bus->slot[searchAddr->slot].functions == 0) {\n                *found = true;\n                break;\n            }\n\n            if (flags & VIR_PCI_CONNECT_AGGREGATE_SLOT &&\n                bus->slot[searchAddr->slot].aggregate) {\n                /* slot and device are okay with aggregating devices */\n                if ((bus->slot[searchAddr->slot].functions &\n                     (1 << searchAddr->function)) == 0) {\n                    *found = true;\n                    break;\n                }\n\n                /* also check for *any* unused function if caller\n                 * sent function = -1\n                 */\n                if (function == -1) {\n                    while (searchAddr->function < 8) {\n                        if ((bus->slot[searchAddr->slot].functions &\n                             (1 << searchAddr->function)) == 0) {\n                            *found = true;\n                            break; /* out of inner while */\n                        }\n                        searchAddr->function++;\n                    }\n                    if (*found)\n                       break; /* out of outer while */\n                    searchAddr->function = 0; /* reset for next try */\n                }\n            }\n\n            VIR_DEBUG(\"PCI slot %04x:%02x:%02x already in use\",\n                      searchAddr->domain, searchAddr->bus, searchAddr->slot);\n            searchAddr->slot++;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainPCIAddressSetFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1079-1088",
    "snippet": "void\nvirDomainPCIAddressSetFree(virDomainPCIAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virDomainPCIAddressSetExtensionFree(addrs);\n    VIR_FREE(addrs->buses);\n    VIR_FREE(addrs);\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addrs"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addrs->buses"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressSetExtensionFree",
          "args": [
            "addrs"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressSetExtensionFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1012-1021",
          "snippet": "static void\nvirDomainPCIAddressSetExtensionFree(virDomainPCIAddressSetPtr addrs)\n{\n    if (!addrs || !addrs->zpciIds)\n        return;\n\n    virHashFree(addrs->zpciIds->uids);\n    virHashFree(addrs->zpciIds->fids);\n    VIR_FREE(addrs->zpciIds);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainPCIAddressSetExtensionFree(virDomainPCIAddressSetPtr addrs)\n{\n    if (!addrs || !addrs->zpciIds)\n        return;\n\n    virHashFree(addrs->zpciIds->uids);\n    virHashFree(addrs->zpciIds->fids);\n    VIR_FREE(addrs->zpciIds);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainPCIAddressSetFree(virDomainPCIAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virDomainPCIAddressSetExtensionFree(addrs);\n    VIR_FREE(addrs->buses);\n    VIR_FREE(addrs);\n}"
  },
  {
    "function_name": "virDomainPCIAddressSetAlloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1054-1076",
    "snippet": "virDomainPCIAddressSetPtr\nvirDomainPCIAddressSetAlloc(unsigned int nbuses,\n                            virPCIDeviceAddressExtensionFlags extFlags)\n{\n    virDomainPCIAddressSetPtr addrs;\n\n    if (VIR_ALLOC(addrs) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(addrs->buses, nbuses) < 0)\n        goto error;\n\n    addrs->nbuses = nbuses;\n\n    if (virDomainPCIAddressSetExtensionAlloc(addrs, extFlags) < 0)\n        goto error;\n\n    return addrs;\n\n error:\n    virDomainPCIAddressSetFree(addrs);\n    return NULL;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainPCIAddressSetFree",
          "args": [
            "addrs"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressSetFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1079-1088",
          "snippet": "void\nvirDomainPCIAddressSetFree(virDomainPCIAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virDomainPCIAddressSetExtensionFree(addrs);\n    VIR_FREE(addrs->buses);\n    VIR_FREE(addrs);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainPCIAddressSetFree(virDomainPCIAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virDomainPCIAddressSetExtensionFree(addrs);\n    VIR_FREE(addrs->buses);\n    VIR_FREE(addrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressSetExtensionAlloc",
          "args": [
            "addrs",
            "extFlags"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressSetExtensionAlloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1024-1051",
          "snippet": "static int\nvirDomainPCIAddressSetExtensionAlloc(virDomainPCIAddressSetPtr addrs,\n                                     virPCIDeviceAddressExtensionFlags extFlags)\n{\n    if (extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) {\n        if (addrs->zpciIds)\n            return 0;\n\n        if (VIR_ALLOC(addrs->zpciIds) < 0)\n            return -1;\n\n        addrs->zpciIds->uids = virHashCreateFull(10, NULL,\n                                                 virZPCIAddrKeyCode,\n                                                 virZPCIAddrKeyEqual,\n                                                 virZPCIAddrKeyCopy,\n                                                 virZPCIAddrKeyPrintHuman,\n                                                 virZPCIAddrKeyFree);\n\n        addrs->zpciIds->fids = virHashCreateFull(10, NULL,\n                                                 virZPCIAddrKeyCode,\n                                                 virZPCIAddrKeyEqual,\n                                                 virZPCIAddrKeyCopy,\n                                                 virZPCIAddrKeyPrintHuman,\n                                                 virZPCIAddrKeyFree);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainPCIAddressSetExtensionAlloc(virDomainPCIAddressSetPtr addrs,\n                                     virPCIDeviceAddressExtensionFlags extFlags)\n{\n    if (extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) {\n        if (addrs->zpciIds)\n            return 0;\n\n        if (VIR_ALLOC(addrs->zpciIds) < 0)\n            return -1;\n\n        addrs->zpciIds->uids = virHashCreateFull(10, NULL,\n                                                 virZPCIAddrKeyCode,\n                                                 virZPCIAddrKeyEqual,\n                                                 virZPCIAddrKeyCopy,\n                                                 virZPCIAddrKeyPrintHuman,\n                                                 virZPCIAddrKeyFree);\n\n        addrs->zpciIds->fids = virHashCreateFull(10, NULL,\n                                                 virZPCIAddrKeyCode,\n                                                 virZPCIAddrKeyEqual,\n                                                 virZPCIAddrKeyCopy,\n                                                 virZPCIAddrKeyPrintHuman,\n                                                 virZPCIAddrKeyFree);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "addrs->buses",
            "nbuses"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "addrs"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvirDomainPCIAddressSetPtr\nvirDomainPCIAddressSetAlloc(unsigned int nbuses,\n                            virPCIDeviceAddressExtensionFlags extFlags)\n{\n    virDomainPCIAddressSetPtr addrs;\n\n    if (VIR_ALLOC(addrs) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(addrs->buses, nbuses) < 0)\n        goto error;\n\n    addrs->nbuses = nbuses;\n\n    if (virDomainPCIAddressSetExtensionAlloc(addrs, extFlags) < 0)\n        goto error;\n\n    return addrs;\n\n error:\n    virDomainPCIAddressSetFree(addrs);\n    return NULL;\n}"
  },
  {
    "function_name": "virDomainPCIAddressSetExtensionAlloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1024-1051",
    "snippet": "static int\nvirDomainPCIAddressSetExtensionAlloc(virDomainPCIAddressSetPtr addrs,\n                                     virPCIDeviceAddressExtensionFlags extFlags)\n{\n    if (extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) {\n        if (addrs->zpciIds)\n            return 0;\n\n        if (VIR_ALLOC(addrs->zpciIds) < 0)\n            return -1;\n\n        addrs->zpciIds->uids = virHashCreateFull(10, NULL,\n                                                 virZPCIAddrKeyCode,\n                                                 virZPCIAddrKeyEqual,\n                                                 virZPCIAddrKeyCopy,\n                                                 virZPCIAddrKeyPrintHuman,\n                                                 virZPCIAddrKeyFree);\n\n        addrs->zpciIds->fids = virHashCreateFull(10, NULL,\n                                                 virZPCIAddrKeyCode,\n                                                 virZPCIAddrKeyEqual,\n                                                 virZPCIAddrKeyCopy,\n                                                 virZPCIAddrKeyPrintHuman,\n                                                 virZPCIAddrKeyFree);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashCreateFull",
          "args": [
            "10",
            "NULL",
            "virZPCIAddrKeyCode",
            "virZPCIAddrKeyEqual",
            "virZPCIAddrKeyCopy",
            "virZPCIAddrKeyPrintHuman",
            "virZPCIAddrKeyFree"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreateFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "141-169",
          "snippet": "virHashTablePtr virHashCreateFull(ssize_t size,\n                                  virHashDataFree dataFree,\n                                  virHashKeyCode keyCode,\n                                  virHashKeyEqual keyEqual,\n                                  virHashKeyCopy keyCopy,\n                                  virHashKeyPrintHuman keyPrint,\n                                  virHashKeyFree keyFree)\n{\n    virHashTablePtr table = NULL;\n\n    if (size <= 0)\n        size = 256;\n\n    table = g_new0(virHashTable, 1);\n\n    table->seed = virRandomBits(32);\n    table->size = size;\n    table->nbElems = 0;\n    table->dataFree = dataFree;\n    table->keyCode = keyCode;\n    table->keyEqual = keyEqual;\n    table->keyCopy = keyCopy;\n    table->keyPrint = keyPrint;\n    table->keyFree = keyFree;\n\n    table->table = g_new0(virHashEntryPtr, table->size);\n\n    return table;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreateFull(ssize_t size,\n                                  virHashDataFree dataFree,\n                                  virHashKeyCode keyCode,\n                                  virHashKeyEqual keyEqual,\n                                  virHashKeyCopy keyCopy,\n                                  virHashKeyPrintHuman keyPrint,\n                                  virHashKeyFree keyFree)\n{\n    virHashTablePtr table = NULL;\n\n    if (size <= 0)\n        size = 256;\n\n    table = g_new0(virHashTable, 1);\n\n    table->seed = virRandomBits(32);\n    table->size = size;\n    table->nbElems = 0;\n    table->dataFree = dataFree;\n    table->keyCode = keyCode;\n    table->keyEqual = keyEqual;\n    table->keyCopy = keyCopy;\n    table->keyPrint = keyPrint;\n    table->keyFree = keyFree;\n\n    table->table = g_new0(virHashEntryPtr, table->size);\n\n    return table;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "addrs->zpciIds"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainPCIAddressSetExtensionAlloc(virDomainPCIAddressSetPtr addrs,\n                                     virPCIDeviceAddressExtensionFlags extFlags)\n{\n    if (extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) {\n        if (addrs->zpciIds)\n            return 0;\n\n        if (VIR_ALLOC(addrs->zpciIds) < 0)\n            return -1;\n\n        addrs->zpciIds->uids = virHashCreateFull(10, NULL,\n                                                 virZPCIAddrKeyCode,\n                                                 virZPCIAddrKeyEqual,\n                                                 virZPCIAddrKeyCopy,\n                                                 virZPCIAddrKeyPrintHuman,\n                                                 virZPCIAddrKeyFree);\n\n        addrs->zpciIds->fids = virHashCreateFull(10, NULL,\n                                                 virZPCIAddrKeyCode,\n                                                 virZPCIAddrKeyEqual,\n                                                 virZPCIAddrKeyCopy,\n                                                 virZPCIAddrKeyPrintHuman,\n                                                 virZPCIAddrKeyFree);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainPCIAddressSetExtensionFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1012-1021",
    "snippet": "static void\nvirDomainPCIAddressSetExtensionFree(virDomainPCIAddressSetPtr addrs)\n{\n    if (!addrs || !addrs->zpciIds)\n        return;\n\n    virHashFree(addrs->zpciIds->uids);\n    virHashFree(addrs->zpciIds->fids);\n    VIR_FREE(addrs->zpciIds);\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addrs->zpciIds"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "addrs->zpciIds->fids"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainPCIAddressSetExtensionFree(virDomainPCIAddressSetPtr addrs)\n{\n    if (!addrs || !addrs->zpciIds)\n        return;\n\n    virHashFree(addrs->zpciIds->uids);\n    virHashFree(addrs->zpciIds->fids);\n    VIR_FREE(addrs->zpciIds);\n}"
  },
  {
    "function_name": "virZPCIAddrKeyFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "1005-1009",
    "snippet": "static void\nvirZPCIAddrKeyFree(void *name)\n{\n    VIR_FREE(name);\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirZPCIAddrKeyFree(void *name)\n{\n    VIR_FREE(name);\n}"
  },
  {
    "function_name": "virZPCIAddrKeyPrintHuman",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "998-1002",
    "snippet": "static char *\nvirZPCIAddrKeyPrintHuman(const void *name)\n{\n    return g_strdup_printf(\"%u\", *((unsigned int *)name));\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%u\"",
            "*((unsigned int *)name)"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char *\nvirZPCIAddrKeyPrintHuman(const void *name)\n{\n    return g_strdup_printf(\"%u\", *((unsigned int *)name));\n}"
  },
  {
    "function_name": "virZPCIAddrKeyCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "988-995",
    "snippet": "static void *\nvirZPCIAddrKeyCopy(const void *name)\n{\n    unsigned int *copy = g_new0(unsigned int, 1);\n\n    *copy = *((unsigned int *)name);\n    return (void *)copy;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "unsignedint",
            "1"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void *\nvirZPCIAddrKeyCopy(const void *name)\n{\n    unsigned int *copy = g_new0(unsigned int, 1);\n\n    *copy = *((unsigned int *)name);\n    return (void *)copy;\n}"
  },
  {
    "function_name": "virZPCIAddrKeyEqual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "980-985",
    "snippet": "static bool\nvirZPCIAddrKeyEqual(const void *namea,\n                    const void *nameb)\n{\n    return *((unsigned int *)namea) == *((unsigned int *)nameb);\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic bool\nvirZPCIAddrKeyEqual(const void *namea,\n                    const void *nameb)\n{\n    return *((unsigned int *)namea) == *((unsigned int *)nameb);\n}"
  },
  {
    "function_name": "virZPCIAddrKeyCode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "971-977",
    "snippet": "static uint32_t\nvirZPCIAddrKeyCode(const void *name,\n                   uint32_t seed)\n{\n    unsigned int value = *((unsigned int *)name);\n    return virHashCodeGen(&value, sizeof(value), seed);\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashCodeGen",
          "args": [
            "&value",
            "sizeof(value)",
            "seed"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCodeGen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhashcode.c",
          "lines": "63-125",
          "snippet": "uint32_t virHashCodeGen(const void *key, size_t len, uint32_t seed)\n{\n    const uint8_t *blocks;\n    const uint8_t *tail;\n    size_t nblocks;\n    uint32_t h1;\n    uint32_t k1;\n    uint32_t c1;\n    uint32_t c2;\n    size_t i;\n\n    blocks = (const uint8_t *)key;\n    nblocks = len / 4;\n    h1 = seed;\n    c1 = 0xcc9e2d51;\n    c2 = 0x1b873593;\n\n    /* body */\n\n    for (i = 0; i < nblocks; i++) {\n\n        k1 = getblock(blocks, i);\n\n        k1 *= c1;\n        k1 = rotl32(k1, 15);\n        k1 *= c2;\n\n        h1 ^= k1;\n        h1 = rotl32(h1, 13);\n        h1 = h1 * 5 + 0xe6546b64;\n    }\n\n    /* tail */\n\n    tail = (const uint8_t *)key + nblocks * 4;\n\n    k1 = 0;\n\n    switch (len & 3) {\n    case 3:\n        k1 ^= tail[2] << 16;\n        G_GNUC_FALLTHROUGH;\n    case 2:\n        k1 ^= tail[1] << 8;\n        G_GNUC_FALLTHROUGH;\n    case 1:\n        k1 ^= tail[0];\n        k1 *= c1;\n        k1 = rotl32(k1, 15);\n        k1 *= c2;\n        h1 ^= k1;\n        G_GNUC_FALLTHROUGH;\n    default:\n        break;\n    }\n\n    /* finalization */\n\n    h1 ^= len;\n    h1 = fmix(h1);\n\n    return h1;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include <config.h>\n\nuint32_t virHashCodeGen(const void *key, size_t len, uint32_t seed)\n{\n    const uint8_t *blocks;\n    const uint8_t *tail;\n    size_t nblocks;\n    uint32_t h1;\n    uint32_t k1;\n    uint32_t c1;\n    uint32_t c2;\n    size_t i;\n\n    blocks = (const uint8_t *)key;\n    nblocks = len / 4;\n    h1 = seed;\n    c1 = 0xcc9e2d51;\n    c2 = 0x1b873593;\n\n    /* body */\n\n    for (i = 0; i < nblocks; i++) {\n\n        k1 = getblock(blocks, i);\n\n        k1 *= c1;\n        k1 = rotl32(k1, 15);\n        k1 *= c2;\n\n        h1 ^= k1;\n        h1 = rotl32(h1, 13);\n        h1 = h1 * 5 + 0xe6546b64;\n    }\n\n    /* tail */\n\n    tail = (const uint8_t *)key + nblocks * 4;\n\n    k1 = 0;\n\n    switch (len & 3) {\n    case 3:\n        k1 ^= tail[2] << 16;\n        G_GNUC_FALLTHROUGH;\n    case 2:\n        k1 ^= tail[1] << 8;\n        G_GNUC_FALLTHROUGH;\n    case 1:\n        k1 ^= tail[0];\n        k1 *= c1;\n        k1 = rotl32(k1, 15);\n        k1 *= c2;\n        h1 ^= k1;\n        G_GNUC_FALLTHROUGH;\n    default:\n        break;\n    }\n\n    /* finalization */\n\n    h1 ^= len;\n    h1 = fmix(h1);\n\n    return h1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic uint32_t\nvirZPCIAddrKeyCode(const void *name,\n                   uint32_t seed)\n{\n    unsigned int value = *((unsigned int *)name);\n    return virHashCodeGen(&value, sizeof(value), seed);\n}"
  },
  {
    "function_name": "virDomainPCIAddressReleaseAddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "963-968",
    "snippet": "void\nvirDomainPCIAddressReleaseAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr addr)\n{\n    addrs->buses[addr->bus].slot[addr->slot].functions &= ~(1 << addr->function);\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainPCIAddressReleaseAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr addr)\n{\n    addrs->buses[addr->bus].slot[addr->slot].functions &= ~(1 << addr->function);\n}"
  },
  {
    "function_name": "virDomainPCIAddressExtensionReleaseAddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "954-960",
    "snippet": "void\nvirDomainPCIAddressExtensionReleaseAddr(virDomainPCIAddressSetPtr addrs,\n                                        virPCIDeviceAddressPtr addr)\n{\n    if (addr->extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI)\n        virDomainZPCIAddressReleaseIds(addrs->zpciIds, &addr->zpci);\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReleaseIds",
          "args": [
            "addrs->zpciIds",
            "&addr->zpci"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReleaseIds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "144-154",
          "snippet": "static void\nvirDomainZPCIAddressReleaseIds(virDomainZPCIAddressIdsPtr zpciIds,\n                               virZPCIDeviceAddressPtr addr)\n{\n    if (!zpciIds || virZPCIDeviceAddressIsEmpty(addr))\n        return;\n\n    virDomainZPCIAddressReleaseUid(zpciIds->uids, addr);\n\n    virDomainZPCIAddressReleaseFid(zpciIds->fids, addr);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainZPCIAddressReleaseIds(virDomainZPCIAddressIdsPtr zpciIds,\n                               virZPCIDeviceAddressPtr addr)\n{\n    if (!zpciIds || virZPCIDeviceAddressIsEmpty(addr))\n        return;\n\n    virDomainZPCIAddressReleaseUid(zpciIds->uids, addr);\n\n    virDomainZPCIAddressReleaseFid(zpciIds->fids, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainPCIAddressExtensionReleaseAddr(virDomainPCIAddressSetPtr addrs,\n                                        virPCIDeviceAddressPtr addr)\n{\n    if (addr->extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI)\n        virDomainZPCIAddressReleaseIds(addrs->zpciIds, &addr->zpci);\n}"
  },
  {
    "function_name": "virDomainPCIAddressEnsureAddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "905-951",
    "snippet": "int\nvirDomainPCIAddressEnsureAddr(virDomainPCIAddressSetPtr addrs,\n                              virDomainDeviceInfoPtr dev,\n                              virDomainPCIConnectFlags flags)\n{\n    g_autofree char *addrStr = NULL;\n\n    /* if flags is 0, the particular model of this device on this\n     * machinetype doesn't need a PCI address, so we're done.\n     */\n    if (!flags)\n       return 0;\n\n    if (!(addrStr = virPCIDeviceAddressAsString(&dev->addr.pci)))\n        return -1;\n\n    if (virDeviceInfoPCIAddressIsPresent(dev)) {\n        /* We do not support hotplug multi-function PCI device now, so we should\n         * reserve the whole slot. The function of the PCI device must be 0.\n         */\n        if (dev->addr.pci.function != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Only PCI device addresses with function=0\"\n                             \" are supported\"));\n            return -1;\n        }\n\n        if (!virDomainPCIAddressValidate(addrs, &dev->addr.pci,\n                                         addrStr, flags, true))\n            return -1;\n\n        if (virDomainPCIAddressReserveAddrInternal(addrs, &dev->addr.pci,\n                                                   flags, dev->isolationGroup,\n                                                   true) < 0) {\n            return -1;\n        }\n    } else {\n        if (virDomainPCIAddressReserveNextAddr(addrs, dev, flags, -1) < 0)\n            return -1;\n    }\n\n    dev->addr.pci.extFlags = dev->pciAddrExtFlags;\n    if (virDomainPCIAddressExtensionEnsureAddr(addrs, &dev->addr.pci) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainPCIAddressExtensionEnsureAddr",
          "args": [
            "addrs",
            "&dev->addr.pci"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressExtensionEnsureAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "249-263",
          "snippet": "static int\nvirDomainPCIAddressExtensionEnsureAddr(virDomainPCIAddressSetPtr addrs,\n                                       virPCIDeviceAddressPtr addr)\n{\n    if (addr->extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) {\n        virZPCIDeviceAddressPtr zpci = &addr->zpci;\n\n        if (virZPCIDeviceAddressIsEmpty(zpci))\n            return virDomainZPCIAddressReserveNextAddr(addrs->zpciIds, zpci);\n        else\n            return virDomainZPCIAddressReserveAddr(addrs->zpciIds, zpci);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainPCIAddressExtensionEnsureAddr(virDomainPCIAddressSetPtr addrs,\n                                       virPCIDeviceAddressPtr addr)\n{\n    if (addr->extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) {\n        virZPCIDeviceAddressPtr zpci = &addr->zpci;\n\n        if (virZPCIDeviceAddressIsEmpty(zpci))\n            return virDomainZPCIAddressReserveNextAddr(addrs->zpciIds, zpci);\n        else\n            return virDomainZPCIAddressReserveAddr(addrs->zpciIds, zpci);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressReserveNextAddr",
          "args": [
            "addrs",
            "dev",
            "flags",
            "-1"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressReserveNextAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1260-1285",
          "snippet": "int\nvirDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                   virDomainDeviceInfoPtr dev,\n                                   virDomainPCIConnectFlags flags,\n                                   int function)\n{\n    virPCIDeviceAddress addr;\n\n    if (virDomainPCIAddressGetNextAddr(addrs, &addr, flags,\n                                       dev->isolationGroup, function) < 0)\n        return -1;\n\n    if (virDomainPCIAddressReserveAddrInternal(addrs, &addr, flags,\n                                               dev->isolationGroup, false) < 0)\n        return -1;\n\n    addr.extFlags = dev->addr.pci.extFlags;\n    addr.zpci = dev->addr.pci.zpci;\n\n    if (!addrs->dryRun) {\n        dev->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n        dev->addr.pci = addr;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                   virDomainDeviceInfoPtr dev,\n                                   virDomainPCIConnectFlags flags,\n                                   int function)\n{\n    virPCIDeviceAddress addr;\n\n    if (virDomainPCIAddressGetNextAddr(addrs, &addr, flags,\n                                       dev->isolationGroup, function) < 0)\n        return -1;\n\n    if (virDomainPCIAddressReserveAddrInternal(addrs, &addr, flags,\n                                               dev->isolationGroup, false) < 0)\n        return -1;\n\n    addr.extFlags = dev->addr.pci.extFlags;\n    addr.zpci = dev->addr.pci.zpci;\n\n    if (!addrs->dryRun) {\n        dev->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n        dev->addr.pci = addr;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressReserveAddrInternal",
          "args": [
            "addrs",
            "&dev->addr.pci",
            "flags",
            "dev->isolationGroup",
            "true"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressValidate",
          "args": [
            "addrs",
            "&dev->addr.pci",
            "addrStr",
            "flags",
            "true"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "441-500",
          "snippet": "bool\nvirDomainPCIAddressValidate(virDomainPCIAddressSetPtr addrs,\n                            virPCIDeviceAddressPtr addr,\n                            const char *addrStr,\n                            virDomainPCIConnectFlags flags,\n                            bool fromConfig)\n{\n    virDomainPCIAddressBusPtr bus;\n    virErrorNumber errType = (fromConfig\n                              ? VIR_ERR_XML_ERROR : VIR_ERR_INTERNAL_ERROR);\n\n    if (addrs->nbuses == 0) {\n        virReportError(errType, \"%s\", _(\"No PCI buses available\"));\n        return false;\n    }\n    if (addr->domain != 0) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI domain 0 is available\"),\n                       addrStr);\n        return false;\n    }\n    if (addr->bus >= addrs->nbuses) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI buses up to %zu are available\"),\n                       addrStr, addrs->nbuses - 1);\n        return false;\n    }\n\n    bus = &addrs->buses[addr->bus];\n\n    /* assure that at least one of the requested connection types is\n     * provided by this bus\n     */\n    if (!virDomainPCIAddressFlagsCompatible(addr, addrStr, bus->flags,\n                                            flags, true, fromConfig))\n        return false;\n\n    /* some \"buses\" are really just a single port */\n    if (bus->minSlot && addr->slot < bus->minSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be >= %zu\"),\n                       addrStr, bus->minSlot);\n        return false;\n    }\n    if (addr->slot > bus->maxSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be <= %zu\"),\n                       addrStr, bus->maxSlot);\n        return false;\n    }\n    if (addr->function > VIR_PCI_ADDRESS_FUNCTION_LAST) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. function must be <= %u\"),\n                       addrStr, VIR_PCI_ADDRESS_FUNCTION_LAST);\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainPCIAddressValidate(virDomainPCIAddressSetPtr addrs,\n                            virPCIDeviceAddressPtr addr,\n                            const char *addrStr,\n                            virDomainPCIConnectFlags flags,\n                            bool fromConfig)\n{\n    virDomainPCIAddressBusPtr bus;\n    virErrorNumber errType = (fromConfig\n                              ? VIR_ERR_XML_ERROR : VIR_ERR_INTERNAL_ERROR);\n\n    if (addrs->nbuses == 0) {\n        virReportError(errType, \"%s\", _(\"No PCI buses available\"));\n        return false;\n    }\n    if (addr->domain != 0) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI domain 0 is available\"),\n                       addrStr);\n        return false;\n    }\n    if (addr->bus >= addrs->nbuses) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI buses up to %zu are available\"),\n                       addrStr, addrs->nbuses - 1);\n        return false;\n    }\n\n    bus = &addrs->buses[addr->bus];\n\n    /* assure that at least one of the requested connection types is\n     * provided by this bus\n     */\n    if (!virDomainPCIAddressFlagsCompatible(addr, addrStr, bus->flags,\n                                            flags, true, fromConfig))\n        return false;\n\n    /* some \"buses\" are really just a single port */\n    if (bus->minSlot && addr->slot < bus->minSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be >= %zu\"),\n                       addrStr, bus->minSlot);\n        return false;\n    }\n    if (addr->slot > bus->maxSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be <= %zu\"),\n                       addrStr, bus->maxSlot);\n        return false;\n    }\n    if (addr->function > VIR_PCI_ADDRESS_FUNCTION_LAST) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. function must be <= %u\"),\n                       addrStr, VIR_PCI_ADDRESS_FUNCTION_LAST);\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Only PCI device addresses with function=0\"\n                             \" are supported\")"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Only PCI device addresses with function=0\"\n                             \" are supported\""
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDeviceInfoPCIAddressIsPresent",
          "args": [
            "dev"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "virDeviceInfoPCIAddressIsPresent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "191-196",
          "snippet": "bool\nvirDeviceInfoPCIAddressIsPresent(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n           !virPCIDeviceAddressIsEmpty(&info->addr.pci);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nbool\nvirDeviceInfoPCIAddressIsPresent(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n           !virPCIDeviceAddressIsEmpty(&info->addr.pci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressAsString",
          "args": [
            "&dev->addr.pci"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressAsString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1351-1362",
          "snippet": "char *\nvirPCIDeviceAddressAsString(const virPCIDeviceAddress *addr)\n{\n    char *str;\n\n    str = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT,\n                          addr->domain,\n                          addr->bus,\n                          addr->slot,\n                          addr->function);\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceAddressAsString(const virPCIDeviceAddress *addr)\n{\n    char *str;\n\n    str = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT,\n                          addr->domain,\n                          addr->bus,\n                          addr->slot,\n                          addr->function);\n    return str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressEnsureAddr(virDomainPCIAddressSetPtr addrs,\n                              virDomainDeviceInfoPtr dev,\n                              virDomainPCIConnectFlags flags)\n{\n    g_autofree char *addrStr = NULL;\n\n    /* if flags is 0, the particular model of this device on this\n     * machinetype doesn't need a PCI address, so we're done.\n     */\n    if (!flags)\n       return 0;\n\n    if (!(addrStr = virPCIDeviceAddressAsString(&dev->addr.pci)))\n        return -1;\n\n    if (virDeviceInfoPCIAddressIsPresent(dev)) {\n        /* We do not support hotplug multi-function PCI device now, so we should\n         * reserve the whole slot. The function of the PCI device must be 0.\n         */\n        if (dev->addr.pci.function != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Only PCI device addresses with function=0\"\n                             \" are supported\"));\n            return -1;\n        }\n\n        if (!virDomainPCIAddressValidate(addrs, &dev->addr.pci,\n                                         addrStr, flags, true))\n            return -1;\n\n        if (virDomainPCIAddressReserveAddrInternal(addrs, &dev->addr.pci,\n                                                   flags, dev->isolationGroup,\n                                                   true) < 0) {\n            return -1;\n        }\n    } else {\n        if (virDomainPCIAddressReserveNextAddr(addrs, dev, flags, -1) < 0)\n            return -1;\n    }\n\n    dev->addr.pci.extFlags = dev->pciAddrExtFlags;\n    if (virDomainPCIAddressExtensionEnsureAddr(addrs, &dev->addr.pci) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainPCIAddressReserveAddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "895-903",
    "snippet": "int\nvirDomainPCIAddressReserveAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr addr,\n                               virDomainPCIConnectFlags flags,\n                               unsigned int isolationGroup)\n{\n    return virDomainPCIAddressReserveAddrInternal(addrs, addr, flags,\n                                                  isolationGroup, true);\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainPCIAddressReserveAddrInternal",
          "args": [
            "addrs",
            "addr",
            "flags",
            "isolationGroup",
            "true"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressReserveAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr addr,\n                               virDomainPCIConnectFlags flags,\n                               unsigned int isolationGroup)\n{\n    return virDomainPCIAddressReserveAddrInternal(addrs, addr, flags,\n                                                  isolationGroup, true);\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "825-892",
    "snippet": "static int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirDomainPCIAddressReserveAddrInternal(virDomainPCIAddressSetPtr addrs,\n                                       virPCIDeviceAddressPtr addr,\n                                       virDomainPCIConnectFlags flags,\n                                       unsigned int isolationGroup,\n                                       bool fromConfig)\n{\n    g_autofree char *addrStr = NULL;\n    virDomainPCIAddressBusPtr bus;\n    virErrorNumber errType = (fromConfig\n                              ? VIR_ERR_XML_ERROR : VIR_ERR_INTERNAL_ERROR);\n\n    if (!(addrStr = virPCIDeviceAddressAsString(addr)))\n        return -1;\n\n    /* Add an extra bus if necessary */\n    if (addrs->dryRun && virDomainPCIAddressSetGrow(addrs, addr, flags) < 0)\n        return -1;\n    /* Check that the requested bus exists, is the correct type, and we\n     * are asking for a valid slot\n     */\n    if (!virDomainPCIAddressValidate(addrs, addr, addrStr, flags, fromConfig))\n        return -1;\n\n    bus = &addrs->buses[addr->bus];\n\n    if (bus->slot[addr->slot].functions & (1 << addr->function)) {\n        virReportError(errType,\n                       _(\"Attempted double use of PCI Address %s\"), addrStr);\n        return -1;\n    }\n\n    /* if this is the first function to be reserved on this slot, and\n     * the device it's being reserved for can aggregate multiples on a\n     * slot, set the slot's aggregate flag.\n    */\n    if (!bus->slot[addr->slot].functions &&\n        flags & VIR_PCI_CONNECT_AGGREGATE_SLOT) {\n        bus->slot[addr->slot].aggregate = true;\n    }\n\n    if (virDomainPCIAddressBusIsEmpty(bus) && !bus->isolationGroupLocked) {\n        /* The first device decides the isolation group for the\n         * entire bus */\n        bus->isolationGroup = isolationGroup;\n        VIR_DEBUG(\"PCI bus %04x:%02x assigned isolation group %u because of \"\n                  \"first device %s\",\n                  addr->domain, addr->bus, isolationGroup, addrStr);\n    } else if (bus->isolationGroup != isolationGroup && fromConfig) {\n        /* If this is not the first function and its isolation group\n         * doesn't match the bus', then it should not be using this\n         * address. However, if the address comes from the user then\n         * we comply with the request and change the isolation group\n         * back to the default (because at that point isolation can't\n         * be guaranteed anymore) */\n        bus->isolationGroup = 0;\n        VIR_DEBUG(\"PCI bus %04x:%02x assigned isolation group %u because of \"\n                  \"user assigned address %s\",\n                  addr->domain, addr->bus, isolationGroup, addrStr);\n    }\n\n    /* mark the requested function as reserved */\n    bus->slot[addr->slot].functions |= (1 << addr->function);\n    VIR_DEBUG(\"Reserving PCI address %s (aggregate='%s')\", addrStr,\n              bus->slot[addr->slot].aggregate ? \"true\" : \"false\");\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Reserving PCI address %s (aggregate='%s')\"",
            "addrStr",
            "bus->slot[addr->slot].aggregate ? \"true\" : \"false\""
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"PCI bus %04x:%02x assigned isolation group %u because of \"\n                  \"user assigned address %s\"",
            "addr->domain",
            "addr->bus",
            "isolationGroup",
            "addrStr"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"PCI bus %04x:%02x assigned isolation group %u because of \"\n                  \"first device %s\"",
            "addr->domain",
            "addr->bus",
            "isolationGroup",
            "addrStr"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressBusIsEmpty",
          "args": [
            "bus"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "errType",
            "_(\"Attempted double use of PCI Address %s\")",
            "addrStr"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Attempted double use of PCI Address %s\""
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressValidate",
          "args": [
            "addrs",
            "addr",
            "addrStr",
            "flags",
            "fromConfig"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "441-500",
          "snippet": "bool\nvirDomainPCIAddressValidate(virDomainPCIAddressSetPtr addrs,\n                            virPCIDeviceAddressPtr addr,\n                            const char *addrStr,\n                            virDomainPCIConnectFlags flags,\n                            bool fromConfig)\n{\n    virDomainPCIAddressBusPtr bus;\n    virErrorNumber errType = (fromConfig\n                              ? VIR_ERR_XML_ERROR : VIR_ERR_INTERNAL_ERROR);\n\n    if (addrs->nbuses == 0) {\n        virReportError(errType, \"%s\", _(\"No PCI buses available\"));\n        return false;\n    }\n    if (addr->domain != 0) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI domain 0 is available\"),\n                       addrStr);\n        return false;\n    }\n    if (addr->bus >= addrs->nbuses) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI buses up to %zu are available\"),\n                       addrStr, addrs->nbuses - 1);\n        return false;\n    }\n\n    bus = &addrs->buses[addr->bus];\n\n    /* assure that at least one of the requested connection types is\n     * provided by this bus\n     */\n    if (!virDomainPCIAddressFlagsCompatible(addr, addrStr, bus->flags,\n                                            flags, true, fromConfig))\n        return false;\n\n    /* some \"buses\" are really just a single port */\n    if (bus->minSlot && addr->slot < bus->minSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be >= %zu\"),\n                       addrStr, bus->minSlot);\n        return false;\n    }\n    if (addr->slot > bus->maxSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be <= %zu\"),\n                       addrStr, bus->maxSlot);\n        return false;\n    }\n    if (addr->function > VIR_PCI_ADDRESS_FUNCTION_LAST) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. function must be <= %u\"),\n                       addrStr, VIR_PCI_ADDRESS_FUNCTION_LAST);\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainPCIAddressValidate(virDomainPCIAddressSetPtr addrs,\n                            virPCIDeviceAddressPtr addr,\n                            const char *addrStr,\n                            virDomainPCIConnectFlags flags,\n                            bool fromConfig)\n{\n    virDomainPCIAddressBusPtr bus;\n    virErrorNumber errType = (fromConfig\n                              ? VIR_ERR_XML_ERROR : VIR_ERR_INTERNAL_ERROR);\n\n    if (addrs->nbuses == 0) {\n        virReportError(errType, \"%s\", _(\"No PCI buses available\"));\n        return false;\n    }\n    if (addr->domain != 0) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI domain 0 is available\"),\n                       addrStr);\n        return false;\n    }\n    if (addr->bus >= addrs->nbuses) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI buses up to %zu are available\"),\n                       addrStr, addrs->nbuses - 1);\n        return false;\n    }\n\n    bus = &addrs->buses[addr->bus];\n\n    /* assure that at least one of the requested connection types is\n     * provided by this bus\n     */\n    if (!virDomainPCIAddressFlagsCompatible(addr, addrStr, bus->flags,\n                                            flags, true, fromConfig))\n        return false;\n\n    /* some \"buses\" are really just a single port */\n    if (bus->minSlot && addr->slot < bus->minSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be >= %zu\"),\n                       addrStr, bus->minSlot);\n        return false;\n    }\n    if (addr->slot > bus->maxSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be <= %zu\"),\n                       addrStr, bus->maxSlot);\n        return false;\n    }\n    if (addr->function > VIR_PCI_ADDRESS_FUNCTION_LAST) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. function must be <= %u\"),\n                       addrStr, VIR_PCI_ADDRESS_FUNCTION_LAST);\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressSetGrow",
          "args": [
            "addrs",
            "addr",
            "flags"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressSetGrow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "641-804",
          "snippet": "static int\nvirDomainPCIAddressSetGrow(virDomainPCIAddressSetPtr addrs,\n                           virPCIDeviceAddressPtr addr,\n                           virDomainPCIConnectFlags flags)\n{\n    int add;\n    size_t i;\n    int model;\n    bool needDMIToPCIBridge = false;\n    bool needPCIeToPCIBridge = false;\n\n    add = addr->bus - addrs->nbuses + 1;\n    if (add <= 0)\n        return 0;\n\n    /* remember that the flags aren't for the type of controller that\n     * we want to add, they are the type of *device* that we want to\n     * plug in, and this function must decide on the appropriate\n     * controller to add in order to give us a slot for that device.\n     */\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCI_DEVICE) {\n        if (addrs->areMultipleRootsSupported) {\n            /* Use a pci-root controller to expand the guest's PCI\n             * topology if it supports having more than one */\n            model = VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT;\n        } else {\n            model = VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE;\n\n            /* if there aren't yet any buses that will accept a\n             * pci-bridge, but we need one for the device's PCI address\n             * to make sense, it means the guest only has a PCIe topology\n             * configured so far, and we need to create a traditional PCI\n             * topology to accommodate the new device.\n             */\n            needDMIToPCIBridge = true;\n            needPCIeToPCIBridge = true;\n            for (i = 0; i < addrs->nbuses; i++) {\n                if (addrs->buses[i].flags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE) {\n                    needDMIToPCIBridge = false;\n                    needPCIeToPCIBridge = false;\n                    break;\n                }\n            }\n\n            /* Prefer pcie-to-pci-bridge, fall back to dmi-to-pci-bridge */\n            if (addrs->isPCIeToPCIBridgeSupported)\n                needDMIToPCIBridge = false;\n            else\n                needPCIeToPCIBridge = false;\n\n            if ((needDMIToPCIBridge || needPCIeToPCIBridge) && add == 1) {\n                /* We need to add a single pci-bridge to provide the bus\n                 * our legacy PCI device will be plugged into; however, we\n                 * have also determined that there isn't yet any proper\n                 * place to connect that pci-bridge we're about to add,\n                 * which means we're dealing with a pure PCIe guest. We\n                 * need to create a traditional PCI topology, and for that\n                 * we have two options: dmi-to-pci-bridge + pci-bridge or\n                 * pcie-root-port + pcie-to-pci-bridge (the latter of which\n                 * is pretty much a pci-bridge as far as devices attached\n                 * to it are concerned and as such makes the pci-bridge\n                 * unnecessary). Either way, there's going to be one more\n                 * controller than initially expected, and the 'bus' part\n                 * of the device's address will need to be bumped.\n                 */\n                add++;\n                addr->bus++;\n            }\n        }\n    } else if (flags & (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                        VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT)) {\n        model = VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT;\n    } else {\n        /* The types of devices that we can't auto-add a controller for:\n         *\n         * VIR_CONNECT_TYPE_DMI_TO_PCI_BRIDGE &\n         * VIR_PCI_CONNECT_TYPE_ROOT_PORT - these can only plug into\n         *  pcie-root or pcie-expander-bus. By definition there is\n         *  only 1 pcie-root, and we don't support auto-adding\n         *  pcie-expander-bus (because it is intended for NUMA usage,\n         *  and we can't automatically decide which numa node to\n         *  associate it with)\n         *\n         * VIR_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT - we ndon't\n         *  support this, because it can only plug into an\n         *  upstream-port, and the upstream port might need a\n         *  root-port; supporting this extra layer needlessly\n         *  complicates the code, and upstream/downstream ports are\n         *  outside the scope of our \"automatic-bus-expansion\" model\n         *  anyway.\n         *\n         * VIR_CONNECT_TYPE_PCI[E]_EXPANDER_BUS - these were created\n         *  to support guest awareness of the NUMA node placement of\n         *  devices on the host, and are also outside the scope of our\n         *  \"automatic-bus-expansion\".\n         *\n         * VIR_PCI_CONNECT_TYPE_PCI_BRIDGE (when the root bus is\n         *  pci-root) - see the comment above in the case that handles\n         *  adding a slot for pci-bridge to a guest with pcie-root.\n         *\n         */\n        int existingContModel = virDomainPCIControllerConnectTypeToModel(flags);\n\n        if (existingContModel >= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"a PCI slot is needed to connect a PCI controller \"\n                             \"model='%s', but none is available, and it \"\n                             \"cannot be automatically added\"),\n                           virDomainControllerModelPCITypeToString(existingContModel));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cannot automatically add a new PCI bus for a \"\n                             \"device with connect flags %.2x\"), flags);\n        }\n        return -1;\n    }\n\n    i = addrs->nbuses;\n\n    if (VIR_EXPAND_N(addrs->buses, addrs->nbuses, add) < 0)\n        return -1;\n\n    if (needDMIToPCIBridge) {\n        /* first of the new buses is dmi-to-pci-bridge, the\n         * rest are of the requested type\n         */\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i++],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE) < 0) {\n            return -1;\n        }\n    }\n\n    if (needPCIeToPCIBridge) {\n        /* We need a pcie-root-port to plug pcie-to-pci-bridge into; however,\n         * qemuDomainAssignPCIAddresses() will, in some cases, create a dummy\n         * PCIe device and reserve an address for it in order to leave the\n         * user with an empty pcie-root-port ready for hotplugging, and if\n         * we didn't do anything other than adding the pcie-root-port here\n         * it would be used for that, which we don't want. So we change the\n         * connect flags to make sure only the pcie-to-pci-bridge will be\n         * connected to the pcie-root-port we just added, and another one\n         * will be allocated for the dummy PCIe device later on.\n         */\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT) < 0) {\n            return -1;\n        }\n        addrs->buses[i].flags = VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE;\n        i++;\n\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i++],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE) < 0) {\n            return -1;\n        }\n    }\n\n    for (; i < addrs->nbuses; i++) {\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i], model) < 0)\n            return -1;\n    }\n\n    return add;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainPCIAddressSetGrow(virDomainPCIAddressSetPtr addrs,\n                           virPCIDeviceAddressPtr addr,\n                           virDomainPCIConnectFlags flags)\n{\n    int add;\n    size_t i;\n    int model;\n    bool needDMIToPCIBridge = false;\n    bool needPCIeToPCIBridge = false;\n\n    add = addr->bus - addrs->nbuses + 1;\n    if (add <= 0)\n        return 0;\n\n    /* remember that the flags aren't for the type of controller that\n     * we want to add, they are the type of *device* that we want to\n     * plug in, and this function must decide on the appropriate\n     * controller to add in order to give us a slot for that device.\n     */\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCI_DEVICE) {\n        if (addrs->areMultipleRootsSupported) {\n            /* Use a pci-root controller to expand the guest's PCI\n             * topology if it supports having more than one */\n            model = VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT;\n        } else {\n            model = VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE;\n\n            /* if there aren't yet any buses that will accept a\n             * pci-bridge, but we need one for the device's PCI address\n             * to make sense, it means the guest only has a PCIe topology\n             * configured so far, and we need to create a traditional PCI\n             * topology to accommodate the new device.\n             */\n            needDMIToPCIBridge = true;\n            needPCIeToPCIBridge = true;\n            for (i = 0; i < addrs->nbuses; i++) {\n                if (addrs->buses[i].flags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE) {\n                    needDMIToPCIBridge = false;\n                    needPCIeToPCIBridge = false;\n                    break;\n                }\n            }\n\n            /* Prefer pcie-to-pci-bridge, fall back to dmi-to-pci-bridge */\n            if (addrs->isPCIeToPCIBridgeSupported)\n                needDMIToPCIBridge = false;\n            else\n                needPCIeToPCIBridge = false;\n\n            if ((needDMIToPCIBridge || needPCIeToPCIBridge) && add == 1) {\n                /* We need to add a single pci-bridge to provide the bus\n                 * our legacy PCI device will be plugged into; however, we\n                 * have also determined that there isn't yet any proper\n                 * place to connect that pci-bridge we're about to add,\n                 * which means we're dealing with a pure PCIe guest. We\n                 * need to create a traditional PCI topology, and for that\n                 * we have two options: dmi-to-pci-bridge + pci-bridge or\n                 * pcie-root-port + pcie-to-pci-bridge (the latter of which\n                 * is pretty much a pci-bridge as far as devices attached\n                 * to it are concerned and as such makes the pci-bridge\n                 * unnecessary). Either way, there's going to be one more\n                 * controller than initially expected, and the 'bus' part\n                 * of the device's address will need to be bumped.\n                 */\n                add++;\n                addr->bus++;\n            }\n        }\n    } else if (flags & (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                        VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT)) {\n        model = VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT;\n    } else {\n        /* The types of devices that we can't auto-add a controller for:\n         *\n         * VIR_CONNECT_TYPE_DMI_TO_PCI_BRIDGE &\n         * VIR_PCI_CONNECT_TYPE_ROOT_PORT - these can only plug into\n         *  pcie-root or pcie-expander-bus. By definition there is\n         *  only 1 pcie-root, and we don't support auto-adding\n         *  pcie-expander-bus (because it is intended for NUMA usage,\n         *  and we can't automatically decide which numa node to\n         *  associate it with)\n         *\n         * VIR_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT - we ndon't\n         *  support this, because it can only plug into an\n         *  upstream-port, and the upstream port might need a\n         *  root-port; supporting this extra layer needlessly\n         *  complicates the code, and upstream/downstream ports are\n         *  outside the scope of our \"automatic-bus-expansion\" model\n         *  anyway.\n         *\n         * VIR_CONNECT_TYPE_PCI[E]_EXPANDER_BUS - these were created\n         *  to support guest awareness of the NUMA node placement of\n         *  devices on the host, and are also outside the scope of our\n         *  \"automatic-bus-expansion\".\n         *\n         * VIR_PCI_CONNECT_TYPE_PCI_BRIDGE (when the root bus is\n         *  pci-root) - see the comment above in the case that handles\n         *  adding a slot for pci-bridge to a guest with pcie-root.\n         *\n         */\n        int existingContModel = virDomainPCIControllerConnectTypeToModel(flags);\n\n        if (existingContModel >= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"a PCI slot is needed to connect a PCI controller \"\n                             \"model='%s', but none is available, and it \"\n                             \"cannot be automatically added\"),\n                           virDomainControllerModelPCITypeToString(existingContModel));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cannot automatically add a new PCI bus for a \"\n                             \"device with connect flags %.2x\"), flags);\n        }\n        return -1;\n    }\n\n    i = addrs->nbuses;\n\n    if (VIR_EXPAND_N(addrs->buses, addrs->nbuses, add) < 0)\n        return -1;\n\n    if (needDMIToPCIBridge) {\n        /* first of the new buses is dmi-to-pci-bridge, the\n         * rest are of the requested type\n         */\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i++],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE) < 0) {\n            return -1;\n        }\n    }\n\n    if (needPCIeToPCIBridge) {\n        /* We need a pcie-root-port to plug pcie-to-pci-bridge into; however,\n         * qemuDomainAssignPCIAddresses() will, in some cases, create a dummy\n         * PCIe device and reserve an address for it in order to leave the\n         * user with an empty pcie-root-port ready for hotplugging, and if\n         * we didn't do anything other than adding the pcie-root-port here\n         * it would be used for that, which we don't want. So we change the\n         * connect flags to make sure only the pcie-to-pci-bridge will be\n         * connected to the pcie-root-port we just added, and another one\n         * will be allocated for the dummy PCIe device later on.\n         */\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT) < 0) {\n            return -1;\n        }\n        addrs->buses[i].flags = VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE;\n        i++;\n\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i++],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE) < 0) {\n            return -1;\n        }\n    }\n\n    for (; i < addrs->nbuses; i++) {\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i], model) < 0)\n            return -1;\n    }\n\n    return add;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressAsString",
          "args": [
            "addr"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressAsString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1351-1362",
          "snippet": "char *\nvirPCIDeviceAddressAsString(const virPCIDeviceAddress *addr)\n{\n    char *str;\n\n    str = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT,\n                          addr->domain,\n                          addr->bus,\n                          addr->slot,\n                          addr->function);\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceAddressAsString(const virPCIDeviceAddress *addr)\n{\n    char *str;\n\n    str = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT,\n                          addr->domain,\n                          addr->bus,\n                          addr->slot,\n                          addr->function);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressReserveAddrInternal",
          "args": [
            "virDomainPCIAddressSetPtraddrs",
            "virPCIDeviceAddressPtraddr",
            "virDomainPCIConnectFlagsflags",
            "unsigned intisolationGroup",
            "boolfromConfig"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirDomainPCIAddressReserveAddrInternal(virDomainPCIAddressSetPtr addrs,\n                                       virPCIDeviceAddressPtr addr,\n                                       virDomainPCIConnectFlags flags,\n                                       unsigned int isolationGroup,\n                                       bool fromConfig)\n{\n    g_autofree char *addrStr = NULL;\n    virDomainPCIAddressBusPtr bus;\n    virErrorNumber errType = (fromConfig\n                              ? VIR_ERR_XML_ERROR : VIR_ERR_INTERNAL_ERROR);\n\n    if (!(addrStr = virPCIDeviceAddressAsString(addr)))\n        return -1;\n\n    /* Add an extra bus if necessary */\n    if (addrs->dryRun && virDomainPCIAddressSetGrow(addrs, addr, flags) < 0)\n        return -1;\n    /* Check that the requested bus exists, is the correct type, and we\n     * are asking for a valid slot\n     */\n    if (!virDomainPCIAddressValidate(addrs, addr, addrStr, flags, fromConfig))\n        return -1;\n\n    bus = &addrs->buses[addr->bus];\n\n    if (bus->slot[addr->slot].functions & (1 << addr->function)) {\n        virReportError(errType,\n                       _(\"Attempted double use of PCI Address %s\"), addrStr);\n        return -1;\n    }\n\n    /* if this is the first function to be reserved on this slot, and\n     * the device it's being reserved for can aggregate multiples on a\n     * slot, set the slot's aggregate flag.\n    */\n    if (!bus->slot[addr->slot].functions &&\n        flags & VIR_PCI_CONNECT_AGGREGATE_SLOT) {\n        bus->slot[addr->slot].aggregate = true;\n    }\n\n    if (virDomainPCIAddressBusIsEmpty(bus) && !bus->isolationGroupLocked) {\n        /* The first device decides the isolation group for the\n         * entire bus */\n        bus->isolationGroup = isolationGroup;\n        VIR_DEBUG(\"PCI bus %04x:%02x assigned isolation group %u because of \"\n                  \"first device %s\",\n                  addr->domain, addr->bus, isolationGroup, addrStr);\n    } else if (bus->isolationGroup != isolationGroup && fromConfig) {\n        /* If this is not the first function and its isolation group\n         * doesn't match the bus', then it should not be using this\n         * address. However, if the address comes from the user then\n         * we comply with the request and change the isolation group\n         * back to the default (because at that point isolation can't\n         * be guaranteed anymore) */\n        bus->isolationGroup = 0;\n        VIR_DEBUG(\"PCI bus %04x:%02x assigned isolation group %u because of \"\n                  \"user assigned address %s\",\n                  addr->domain, addr->bus, isolationGroup, addrStr);\n    }\n\n    /* mark the requested function as reserved */\n    bus->slot[addr->slot].functions |= (1 << addr->function);\n    VIR_DEBUG(\"Reserving PCI address %s (aggregate='%s')\", addrStr,\n              bus->slot[addr->slot].aggregate ? \"true\" : \"false\");\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainPCIAddressSlotInUse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "810-815",
    "snippet": "bool\nvirDomainPCIAddressSlotInUse(virDomainPCIAddressSetPtr addrs,\n                             virPCIDeviceAddressPtr addr)\n{\n    return !!addrs->buses[addr->bus].slot[addr->slot].functions;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainPCIAddressSlotInUse(virDomainPCIAddressSetPtr addrs,\n                             virPCIDeviceAddressPtr addr)\n{\n    return !!addrs->buses[addr->bus].slot[addr->slot].functions;\n}"
  },
  {
    "function_name": "virDomainPCIAddressSetGrow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "641-804",
    "snippet": "static int\nvirDomainPCIAddressSetGrow(virDomainPCIAddressSetPtr addrs,\n                           virPCIDeviceAddressPtr addr,\n                           virDomainPCIConnectFlags flags)\n{\n    int add;\n    size_t i;\n    int model;\n    bool needDMIToPCIBridge = false;\n    bool needPCIeToPCIBridge = false;\n\n    add = addr->bus - addrs->nbuses + 1;\n    if (add <= 0)\n        return 0;\n\n    /* remember that the flags aren't for the type of controller that\n     * we want to add, they are the type of *device* that we want to\n     * plug in, and this function must decide on the appropriate\n     * controller to add in order to give us a slot for that device.\n     */\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCI_DEVICE) {\n        if (addrs->areMultipleRootsSupported) {\n            /* Use a pci-root controller to expand the guest's PCI\n             * topology if it supports having more than one */\n            model = VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT;\n        } else {\n            model = VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE;\n\n            /* if there aren't yet any buses that will accept a\n             * pci-bridge, but we need one for the device's PCI address\n             * to make sense, it means the guest only has a PCIe topology\n             * configured so far, and we need to create a traditional PCI\n             * topology to accommodate the new device.\n             */\n            needDMIToPCIBridge = true;\n            needPCIeToPCIBridge = true;\n            for (i = 0; i < addrs->nbuses; i++) {\n                if (addrs->buses[i].flags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE) {\n                    needDMIToPCIBridge = false;\n                    needPCIeToPCIBridge = false;\n                    break;\n                }\n            }\n\n            /* Prefer pcie-to-pci-bridge, fall back to dmi-to-pci-bridge */\n            if (addrs->isPCIeToPCIBridgeSupported)\n                needDMIToPCIBridge = false;\n            else\n                needPCIeToPCIBridge = false;\n\n            if ((needDMIToPCIBridge || needPCIeToPCIBridge) && add == 1) {\n                /* We need to add a single pci-bridge to provide the bus\n                 * our legacy PCI device will be plugged into; however, we\n                 * have also determined that there isn't yet any proper\n                 * place to connect that pci-bridge we're about to add,\n                 * which means we're dealing with a pure PCIe guest. We\n                 * need to create a traditional PCI topology, and for that\n                 * we have two options: dmi-to-pci-bridge + pci-bridge or\n                 * pcie-root-port + pcie-to-pci-bridge (the latter of which\n                 * is pretty much a pci-bridge as far as devices attached\n                 * to it are concerned and as such makes the pci-bridge\n                 * unnecessary). Either way, there's going to be one more\n                 * controller than initially expected, and the 'bus' part\n                 * of the device's address will need to be bumped.\n                 */\n                add++;\n                addr->bus++;\n            }\n        }\n    } else if (flags & (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                        VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT)) {\n        model = VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT;\n    } else {\n        /* The types of devices that we can't auto-add a controller for:\n         *\n         * VIR_CONNECT_TYPE_DMI_TO_PCI_BRIDGE &\n         * VIR_PCI_CONNECT_TYPE_ROOT_PORT - these can only plug into\n         *  pcie-root or pcie-expander-bus. By definition there is\n         *  only 1 pcie-root, and we don't support auto-adding\n         *  pcie-expander-bus (because it is intended for NUMA usage,\n         *  and we can't automatically decide which numa node to\n         *  associate it with)\n         *\n         * VIR_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT - we ndon't\n         *  support this, because it can only plug into an\n         *  upstream-port, and the upstream port might need a\n         *  root-port; supporting this extra layer needlessly\n         *  complicates the code, and upstream/downstream ports are\n         *  outside the scope of our \"automatic-bus-expansion\" model\n         *  anyway.\n         *\n         * VIR_CONNECT_TYPE_PCI[E]_EXPANDER_BUS - these were created\n         *  to support guest awareness of the NUMA node placement of\n         *  devices on the host, and are also outside the scope of our\n         *  \"automatic-bus-expansion\".\n         *\n         * VIR_PCI_CONNECT_TYPE_PCI_BRIDGE (when the root bus is\n         *  pci-root) - see the comment above in the case that handles\n         *  adding a slot for pci-bridge to a guest with pcie-root.\n         *\n         */\n        int existingContModel = virDomainPCIControllerConnectTypeToModel(flags);\n\n        if (existingContModel >= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"a PCI slot is needed to connect a PCI controller \"\n                             \"model='%s', but none is available, and it \"\n                             \"cannot be automatically added\"),\n                           virDomainControllerModelPCITypeToString(existingContModel));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cannot automatically add a new PCI bus for a \"\n                             \"device with connect flags %.2x\"), flags);\n        }\n        return -1;\n    }\n\n    i = addrs->nbuses;\n\n    if (VIR_EXPAND_N(addrs->buses, addrs->nbuses, add) < 0)\n        return -1;\n\n    if (needDMIToPCIBridge) {\n        /* first of the new buses is dmi-to-pci-bridge, the\n         * rest are of the requested type\n         */\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i++],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE) < 0) {\n            return -1;\n        }\n    }\n\n    if (needPCIeToPCIBridge) {\n        /* We need a pcie-root-port to plug pcie-to-pci-bridge into; however,\n         * qemuDomainAssignPCIAddresses() will, in some cases, create a dummy\n         * PCIe device and reserve an address for it in order to leave the\n         * user with an empty pcie-root-port ready for hotplugging, and if\n         * we didn't do anything other than adding the pcie-root-port here\n         * it would be used for that, which we don't want. So we change the\n         * connect flags to make sure only the pcie-to-pci-bridge will be\n         * connected to the pcie-root-port we just added, and another one\n         * will be allocated for the dummy PCIe device later on.\n         */\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT) < 0) {\n            return -1;\n        }\n        addrs->buses[i].flags = VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE;\n        i++;\n\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i++],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE) < 0) {\n            return -1;\n        }\n    }\n\n    for (; i < addrs->nbuses; i++) {\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i], model) < 0)\n            return -1;\n    }\n\n    return add;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainPCIAddressBusSetModel",
          "args": [
            "&addrs->buses[i]",
            "model"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressBusSetModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "503-603",
          "snippet": "int\nvirDomainPCIAddressBusSetModel(virDomainPCIAddressBusPtr bus,\n                               virDomainControllerModelPCI model)\n{\n    /* set flags for what can be connected *downstream* from each\n     * bus.\n     */\n    switch (model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE |\n                      VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n        /* slots 1 - 31, no hotplug, PCIe endpoint device or\n         * pcie-root-port only, unless the address was specified in\n         * user config *and* the particular device being attached also\n         * allows it.\n         */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT |\n                      VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n        /* slots 0 - 31, standard PCI slots,\n         * but *not* hot-pluggable */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n        /* Same as pci-bridge: 32 hotpluggable traditional PCI slots (0-31),\n         * the first of which is not usable because of the SHPC */\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n        /* provides one slot which is pcie, can be used by endpoint\n         * devices, pcie-switch-upstream-ports or pcie-to-pci-bridges,\n         * and is hotpluggable */\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT |\n                      VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = 0;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n        /* 32 slots, can only accept pcie-switch-downstream-ports,\n         * no hotplug\n         */\n        bus->flags = VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT;\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n        /* 32 slots, no hotplug, only accepts pcie-root-port or\n         * dmi-to-pci-bridge\n         */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT |\n                      VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"PCI controller model was not set correctly\"));\n        return -1;\n    }\n\n    bus->model = model;\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressBusSetModel(virDomainPCIAddressBusPtr bus,\n                               virDomainControllerModelPCI model)\n{\n    /* set flags for what can be connected *downstream* from each\n     * bus.\n     */\n    switch (model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE |\n                      VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n        /* slots 1 - 31, no hotplug, PCIe endpoint device or\n         * pcie-root-port only, unless the address was specified in\n         * user config *and* the particular device being attached also\n         * allows it.\n         */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT |\n                      VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n        /* slots 0 - 31, standard PCI slots,\n         * but *not* hot-pluggable */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n        /* Same as pci-bridge: 32 hotpluggable traditional PCI slots (0-31),\n         * the first of which is not usable because of the SHPC */\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n        /* provides one slot which is pcie, can be used by endpoint\n         * devices, pcie-switch-upstream-ports or pcie-to-pci-bridges,\n         * and is hotpluggable */\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT |\n                      VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = 0;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n        /* 32 slots, can only accept pcie-switch-downstream-ports,\n         * no hotplug\n         */\n        bus->flags = VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT;\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n        /* 32 slots, no hotplug, only accepts pcie-root-port or\n         * dmi-to-pci-bridge\n         */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT |\n                      VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"PCI controller model was not set correctly\"));\n        return -1;\n    }\n\n    bus->model = model;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "addrs->buses",
            "addrs->nbuses",
            "add"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Cannot automatically add a new PCI bus for a \"\n                             \"device with connect flags %.2x\")",
            "flags"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot automatically add a new PCI bus for a \"\n                             \"device with connect flags %.2x\""
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"a PCI slot is needed to connect a PCI controller \"\n                             \"model='%s', but none is available, and it \"\n                             \"cannot be automatically added\")",
            "virDomainControllerModelPCITypeToString(existingContModel)"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainControllerModelPCITypeToString",
          "args": [
            "existingContModel"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainPCIControllerConnectTypeToModel",
          "args": [
            "flags"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIControllerConnectTypeToModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "312-338",
          "snippet": "static int\nvirDomainPCIControllerConnectTypeToModel(virDomainPCIConnectFlags flags)\n{\n    if (flags & VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE)\n        return VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE;\n\n    /* some connect types don't correspond to a controller model */\n    return -1;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainPCIControllerConnectTypeToModel(virDomainPCIConnectFlags flags)\n{\n    if (flags & VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE)\n        return VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE;\n\n    /* some connect types don't correspond to a controller model */\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainPCIAddressSetGrow(virDomainPCIAddressSetPtr addrs,\n                           virPCIDeviceAddressPtr addr,\n                           virDomainPCIConnectFlags flags)\n{\n    int add;\n    size_t i;\n    int model;\n    bool needDMIToPCIBridge = false;\n    bool needPCIeToPCIBridge = false;\n\n    add = addr->bus - addrs->nbuses + 1;\n    if (add <= 0)\n        return 0;\n\n    /* remember that the flags aren't for the type of controller that\n     * we want to add, they are the type of *device* that we want to\n     * plug in, and this function must decide on the appropriate\n     * controller to add in order to give us a slot for that device.\n     */\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCI_DEVICE) {\n        if (addrs->areMultipleRootsSupported) {\n            /* Use a pci-root controller to expand the guest's PCI\n             * topology if it supports having more than one */\n            model = VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT;\n        } else {\n            model = VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE;\n\n            /* if there aren't yet any buses that will accept a\n             * pci-bridge, but we need one for the device's PCI address\n             * to make sense, it means the guest only has a PCIe topology\n             * configured so far, and we need to create a traditional PCI\n             * topology to accommodate the new device.\n             */\n            needDMIToPCIBridge = true;\n            needPCIeToPCIBridge = true;\n            for (i = 0; i < addrs->nbuses; i++) {\n                if (addrs->buses[i].flags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE) {\n                    needDMIToPCIBridge = false;\n                    needPCIeToPCIBridge = false;\n                    break;\n                }\n            }\n\n            /* Prefer pcie-to-pci-bridge, fall back to dmi-to-pci-bridge */\n            if (addrs->isPCIeToPCIBridgeSupported)\n                needDMIToPCIBridge = false;\n            else\n                needPCIeToPCIBridge = false;\n\n            if ((needDMIToPCIBridge || needPCIeToPCIBridge) && add == 1) {\n                /* We need to add a single pci-bridge to provide the bus\n                 * our legacy PCI device will be plugged into; however, we\n                 * have also determined that there isn't yet any proper\n                 * place to connect that pci-bridge we're about to add,\n                 * which means we're dealing with a pure PCIe guest. We\n                 * need to create a traditional PCI topology, and for that\n                 * we have two options: dmi-to-pci-bridge + pci-bridge or\n                 * pcie-root-port + pcie-to-pci-bridge (the latter of which\n                 * is pretty much a pci-bridge as far as devices attached\n                 * to it are concerned and as such makes the pci-bridge\n                 * unnecessary). Either way, there's going to be one more\n                 * controller than initially expected, and the 'bus' part\n                 * of the device's address will need to be bumped.\n                 */\n                add++;\n                addr->bus++;\n            }\n        }\n    } else if (flags & (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                        VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT)) {\n        model = VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT;\n    } else {\n        /* The types of devices that we can't auto-add a controller for:\n         *\n         * VIR_CONNECT_TYPE_DMI_TO_PCI_BRIDGE &\n         * VIR_PCI_CONNECT_TYPE_ROOT_PORT - these can only plug into\n         *  pcie-root or pcie-expander-bus. By definition there is\n         *  only 1 pcie-root, and we don't support auto-adding\n         *  pcie-expander-bus (because it is intended for NUMA usage,\n         *  and we can't automatically decide which numa node to\n         *  associate it with)\n         *\n         * VIR_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT - we ndon't\n         *  support this, because it can only plug into an\n         *  upstream-port, and the upstream port might need a\n         *  root-port; supporting this extra layer needlessly\n         *  complicates the code, and upstream/downstream ports are\n         *  outside the scope of our \"automatic-bus-expansion\" model\n         *  anyway.\n         *\n         * VIR_CONNECT_TYPE_PCI[E]_EXPANDER_BUS - these were created\n         *  to support guest awareness of the NUMA node placement of\n         *  devices on the host, and are also outside the scope of our\n         *  \"automatic-bus-expansion\".\n         *\n         * VIR_PCI_CONNECT_TYPE_PCI_BRIDGE (when the root bus is\n         *  pci-root) - see the comment above in the case that handles\n         *  adding a slot for pci-bridge to a guest with pcie-root.\n         *\n         */\n        int existingContModel = virDomainPCIControllerConnectTypeToModel(flags);\n\n        if (existingContModel >= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"a PCI slot is needed to connect a PCI controller \"\n                             \"model='%s', but none is available, and it \"\n                             \"cannot be automatically added\"),\n                           virDomainControllerModelPCITypeToString(existingContModel));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cannot automatically add a new PCI bus for a \"\n                             \"device with connect flags %.2x\"), flags);\n        }\n        return -1;\n    }\n\n    i = addrs->nbuses;\n\n    if (VIR_EXPAND_N(addrs->buses, addrs->nbuses, add) < 0)\n        return -1;\n\n    if (needDMIToPCIBridge) {\n        /* first of the new buses is dmi-to-pci-bridge, the\n         * rest are of the requested type\n         */\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i++],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE) < 0) {\n            return -1;\n        }\n    }\n\n    if (needPCIeToPCIBridge) {\n        /* We need a pcie-root-port to plug pcie-to-pci-bridge into; however,\n         * qemuDomainAssignPCIAddresses() will, in some cases, create a dummy\n         * PCIe device and reserve an address for it in order to leave the\n         * user with an empty pcie-root-port ready for hotplugging, and if\n         * we didn't do anything other than adding the pcie-root-port here\n         * it would be used for that, which we don't want. So we change the\n         * connect flags to make sure only the pcie-to-pci-bridge will be\n         * connected to the pcie-root-port we just added, and another one\n         * will be allocated for the dummy PCIe device later on.\n         */\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT) < 0) {\n            return -1;\n        }\n        addrs->buses[i].flags = VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE;\n        i++;\n\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i++],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE) < 0) {\n            return -1;\n        }\n    }\n\n    for (; i < addrs->nbuses; i++) {\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i], model) < 0)\n            return -1;\n    }\n\n    return add;\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "620-628",
    "snippet": "static bool ATTRIBUTE_NONNULL(1)\nvirDomainPCIAddressBusIsEmpty(virDomainPCIAddressBusPtr bus)\n{\n    size_t i;\n\n    for (i = bus->minSlot; i <= bus->maxSlot; i++) {\n        if (bus->slot[i].functions)\n            return false;\n    }",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic bool ATTRIBUTE_NONNULL(1)\nvirDomainPCIAddressBusIsEmpty(virDomainPCIAddressBusPtr bus)\n{\n    size_t i;\n\n    for (i = bus->minSlot; i <= bus->maxSlot; i++) {\n        if (bus->slot[i].functions)\n            return false;\n    }"
  },
  {
    "function_name": "virDomainPCIAddressBusIsFullyReserved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "606-617",
    "snippet": "bool\nvirDomainPCIAddressBusIsFullyReserved(virDomainPCIAddressBusPtr bus)\n{\n    size_t i;\n\n    for (i = bus->minSlot; i <= bus->maxSlot; i++) {\n        if (!bus->slot[i].functions)\n            return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainPCIAddressBusIsFullyReserved(virDomainPCIAddressBusPtr bus)\n{\n    size_t i;\n\n    for (i = bus->minSlot; i <= bus->maxSlot; i++) {\n        if (!bus->slot[i].functions)\n            return false;\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "virDomainPCIAddressBusSetModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "503-603",
    "snippet": "int\nvirDomainPCIAddressBusSetModel(virDomainPCIAddressBusPtr bus,\n                               virDomainControllerModelPCI model)\n{\n    /* set flags for what can be connected *downstream* from each\n     * bus.\n     */\n    switch (model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE |\n                      VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n        /* slots 1 - 31, no hotplug, PCIe endpoint device or\n         * pcie-root-port only, unless the address was specified in\n         * user config *and* the particular device being attached also\n         * allows it.\n         */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT |\n                      VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n        /* slots 0 - 31, standard PCI slots,\n         * but *not* hot-pluggable */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n        /* Same as pci-bridge: 32 hotpluggable traditional PCI slots (0-31),\n         * the first of which is not usable because of the SHPC */\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n        /* provides one slot which is pcie, can be used by endpoint\n         * devices, pcie-switch-upstream-ports or pcie-to-pci-bridges,\n         * and is hotpluggable */\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT |\n                      VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = 0;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n        /* 32 slots, can only accept pcie-switch-downstream-ports,\n         * no hotplug\n         */\n        bus->flags = VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT;\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n        /* 32 slots, no hotplug, only accepts pcie-root-port or\n         * dmi-to-pci-bridge\n         */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT |\n                      VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"PCI controller model was not set correctly\"));\n        return -1;\n    }\n\n    bus->model = model;\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"PCI controller model was not set correctly\")"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"PCI controller model was not set correctly\""
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressBusSetModel(virDomainPCIAddressBusPtr bus,\n                               virDomainControllerModelPCI model)\n{\n    /* set flags for what can be connected *downstream* from each\n     * bus.\n     */\n    switch (model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE |\n                      VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n        /* slots 1 - 31, no hotplug, PCIe endpoint device or\n         * pcie-root-port only, unless the address was specified in\n         * user config *and* the particular device being attached also\n         * allows it.\n         */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT |\n                      VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n        /* slots 0 - 31, standard PCI slots,\n         * but *not* hot-pluggable */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n        /* Same as pci-bridge: 32 hotpluggable traditional PCI slots (0-31),\n         * the first of which is not usable because of the SHPC */\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n        /* provides one slot which is pcie, can be used by endpoint\n         * devices, pcie-switch-upstream-ports or pcie-to-pci-bridges,\n         * and is hotpluggable */\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT |\n                      VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = 0;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n        /* 32 slots, can only accept pcie-switch-downstream-ports,\n         * no hotplug\n         */\n        bus->flags = VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT;\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n        /* 32 slots, no hotplug, only accepts pcie-root-port or\n         * dmi-to-pci-bridge\n         */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT |\n                      VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"PCI controller model was not set correctly\"));\n        return -1;\n    }\n\n    bus->model = model;\n    return 0;\n}"
  },
  {
    "function_name": "virDomainPCIAddressValidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "441-500",
    "snippet": "bool\nvirDomainPCIAddressValidate(virDomainPCIAddressSetPtr addrs,\n                            virPCIDeviceAddressPtr addr,\n                            const char *addrStr,\n                            virDomainPCIConnectFlags flags,\n                            bool fromConfig)\n{\n    virDomainPCIAddressBusPtr bus;\n    virErrorNumber errType = (fromConfig\n                              ? VIR_ERR_XML_ERROR : VIR_ERR_INTERNAL_ERROR);\n\n    if (addrs->nbuses == 0) {\n        virReportError(errType, \"%s\", _(\"No PCI buses available\"));\n        return false;\n    }\n    if (addr->domain != 0) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI domain 0 is available\"),\n                       addrStr);\n        return false;\n    }\n    if (addr->bus >= addrs->nbuses) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI buses up to %zu are available\"),\n                       addrStr, addrs->nbuses - 1);\n        return false;\n    }\n\n    bus = &addrs->buses[addr->bus];\n\n    /* assure that at least one of the requested connection types is\n     * provided by this bus\n     */\n    if (!virDomainPCIAddressFlagsCompatible(addr, addrStr, bus->flags,\n                                            flags, true, fromConfig))\n        return false;\n\n    /* some \"buses\" are really just a single port */\n    if (bus->minSlot && addr->slot < bus->minSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be >= %zu\"),\n                       addrStr, bus->minSlot);\n        return false;\n    }\n    if (addr->slot > bus->maxSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be <= %zu\"),\n                       addrStr, bus->maxSlot);\n        return false;\n    }\n    if (addr->function > VIR_PCI_ADDRESS_FUNCTION_LAST) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. function must be <= %u\"),\n                       addrStr, VIR_PCI_ADDRESS_FUNCTION_LAST);\n        return false;\n    }\n    return true;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "errType",
            "_(\"Invalid PCI address %s. function must be <= %u\")",
            "addrStr",
            "VIR_PCI_ADDRESS_FUNCTION_LAST"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid PCI address %s. function must be <= %u\""
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "errType",
            "_(\"Invalid PCI address %s. slot must be <= %zu\")",
            "addrStr",
            "bus->maxSlot"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "errType",
            "_(\"Invalid PCI address %s. slot must be >= %zu\")",
            "addrStr",
            "bus->minSlot"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressFlagsCompatible",
          "args": [
            "addr",
            "addrStr",
            "bus->flags",
            "flags",
            "true",
            "fromConfig"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressFlagsCompatible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "341-434",
          "snippet": "static bool\nvirDomainPCIAddressFlagsCompatible(virPCIDeviceAddressPtr addr,\n                                   const char *addrStr,\n                                   virDomainPCIConnectFlags busFlags,\n                                   virDomainPCIConnectFlags devFlags,\n                                   bool reportError,\n                                   bool fromConfig)\n{\n    virErrorNumber errType = (fromConfig\n                              ? VIR_ERR_XML_ERROR : VIR_ERR_INTERNAL_ERROR);\n\n    if (fromConfig) {\n        /* If the requested connection was manually specified in\n         * config, allow a PCI device to connect to a PCIe slot, or\n         * vice versa. In order to do so, we add *both* the PCI_DEVICE\n         * and the PCIE_DEVICE flags to the bus if it already has either\n         * of them, using the ENDPOINT mask.\n         */\n        if (busFlags & VIR_PCI_CONNECT_TYPES_ENDPOINT)\n            busFlags |= VIR_PCI_CONNECT_TYPES_ENDPOINT;\n        /* Also allow manual specification of bus to override\n         * libvirt's assumptions about whether or not hotplug\n         * capability will be required.\n         */\n        if (devFlags & VIR_PCI_CONNECT_HOTPLUGGABLE)\n            busFlags |= VIR_PCI_CONNECT_HOTPLUGGABLE;\n        /* if the device is a pci-bridge, allow manually\n         * assigning to any bus that would also accept a\n         * standard PCI device.\n         */\n        if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE)\n            devFlags |= VIR_PCI_CONNECT_TYPE_PCI_DEVICE;\n    }\n\n    /* If this bus doesn't allow the type of connection (PCI\n     * vs. PCIe) required by the device, or if the device requires\n     * hot-plug and this bus doesn't have it, return false.\n     */\n    if (!(devFlags & busFlags & VIR_PCI_CONNECT_TYPES_MASK)) {\n        const char *connectStr;\n\n        if (!reportError)\n            return false;\n\n        if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_DEVICE) {\n            connectStr = \"standard PCI device\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_DEVICE) {\n            connectStr = \"PCI Express device\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT) {\n            connectStr = \"pcie-root-port\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT) {\n            connectStr = \"pcie-switch-upstream-port\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT) {\n            connectStr = \"pcie-switch-downstream-port\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE) {\n            connectStr = \"dmi-to-pci-bridge\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE) {\n            connectStr = \"pcie-to-pci-bridge\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS) {\n            connectStr = \"pci-expander-bus\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS) {\n            connectStr = \"pcie-expander-bus\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE) {\n            connectStr = \"pci-bridge\";\n        } else {\n            /* this should never happen. If it does, there is a\n             * bug in the code that sets the flag bits for devices.\n             */\n            virReportError(errType,\n                           _(\"The device at PCI address %s has \"\n                             \"unrecognized connection type flags 0x%.2x\"),\n                           addrStr, devFlags & VIR_PCI_CONNECT_TYPES_MASK);\n            return false;\n        }\n        virReportError(errType,\n                       _(\"The device at PCI address %s cannot be \"\n                         \"plugged into the PCI controller with index='%d'. \"\n                         \"It requires a controller that accepts a %s.\"),\n                       addrStr, addr->bus, connectStr);\n        return false;\n    }\n    if ((devFlags & VIR_PCI_CONNECT_HOTPLUGGABLE) &&\n        !(busFlags & VIR_PCI_CONNECT_HOTPLUGGABLE)) {\n        if (reportError) {\n            virReportError(errType,\n                           _(\"The device at PCI address %s requires \"\n                             \"hotplug capability, but the PCI controller \"\n                             \"with index='%d' doesn't support hotplug\"),\n                           addrStr, addr->bus);\n        }\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic bool\nvirDomainPCIAddressFlagsCompatible(virPCIDeviceAddressPtr addr,\n                                   const char *addrStr,\n                                   virDomainPCIConnectFlags busFlags,\n                                   virDomainPCIConnectFlags devFlags,\n                                   bool reportError,\n                                   bool fromConfig)\n{\n    virErrorNumber errType = (fromConfig\n                              ? VIR_ERR_XML_ERROR : VIR_ERR_INTERNAL_ERROR);\n\n    if (fromConfig) {\n        /* If the requested connection was manually specified in\n         * config, allow a PCI device to connect to a PCIe slot, or\n         * vice versa. In order to do so, we add *both* the PCI_DEVICE\n         * and the PCIE_DEVICE flags to the bus if it already has either\n         * of them, using the ENDPOINT mask.\n         */\n        if (busFlags & VIR_PCI_CONNECT_TYPES_ENDPOINT)\n            busFlags |= VIR_PCI_CONNECT_TYPES_ENDPOINT;\n        /* Also allow manual specification of bus to override\n         * libvirt's assumptions about whether or not hotplug\n         * capability will be required.\n         */\n        if (devFlags & VIR_PCI_CONNECT_HOTPLUGGABLE)\n            busFlags |= VIR_PCI_CONNECT_HOTPLUGGABLE;\n        /* if the device is a pci-bridge, allow manually\n         * assigning to any bus that would also accept a\n         * standard PCI device.\n         */\n        if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE)\n            devFlags |= VIR_PCI_CONNECT_TYPE_PCI_DEVICE;\n    }\n\n    /* If this bus doesn't allow the type of connection (PCI\n     * vs. PCIe) required by the device, or if the device requires\n     * hot-plug and this bus doesn't have it, return false.\n     */\n    if (!(devFlags & busFlags & VIR_PCI_CONNECT_TYPES_MASK)) {\n        const char *connectStr;\n\n        if (!reportError)\n            return false;\n\n        if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_DEVICE) {\n            connectStr = \"standard PCI device\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_DEVICE) {\n            connectStr = \"PCI Express device\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT) {\n            connectStr = \"pcie-root-port\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT) {\n            connectStr = \"pcie-switch-upstream-port\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT) {\n            connectStr = \"pcie-switch-downstream-port\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE) {\n            connectStr = \"dmi-to-pci-bridge\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE) {\n            connectStr = \"pcie-to-pci-bridge\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS) {\n            connectStr = \"pci-expander-bus\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS) {\n            connectStr = \"pcie-expander-bus\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE) {\n            connectStr = \"pci-bridge\";\n        } else {\n            /* this should never happen. If it does, there is a\n             * bug in the code that sets the flag bits for devices.\n             */\n            virReportError(errType,\n                           _(\"The device at PCI address %s has \"\n                             \"unrecognized connection type flags 0x%.2x\"),\n                           addrStr, devFlags & VIR_PCI_CONNECT_TYPES_MASK);\n            return false;\n        }\n        virReportError(errType,\n                       _(\"The device at PCI address %s cannot be \"\n                         \"plugged into the PCI controller with index='%d'. \"\n                         \"It requires a controller that accepts a %s.\"),\n                       addrStr, addr->bus, connectStr);\n        return false;\n    }\n    if ((devFlags & VIR_PCI_CONNECT_HOTPLUGGABLE) &&\n        !(busFlags & VIR_PCI_CONNECT_HOTPLUGGABLE)) {\n        if (reportError) {\n            virReportError(errType,\n                           _(\"The device at PCI address %s requires \"\n                             \"hotplug capability, but the PCI controller \"\n                             \"with index='%d' doesn't support hotplug\"),\n                           addrStr, addr->bus);\n        }\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "errType",
            "_(\"Invalid PCI address %s. \"\n                         \"Only PCI buses up to %zu are available\")",
            "addrStr",
            "addrs->nbuses - 1"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "errType",
            "_(\"Invalid PCI address %s. \"\n                         \"Only PCI domain 0 is available\")",
            "addrStr"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "errType",
            "\"%s\"",
            "_(\"No PCI buses available\")"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainPCIAddressValidate(virDomainPCIAddressSetPtr addrs,\n                            virPCIDeviceAddressPtr addr,\n                            const char *addrStr,\n                            virDomainPCIConnectFlags flags,\n                            bool fromConfig)\n{\n    virDomainPCIAddressBusPtr bus;\n    virErrorNumber errType = (fromConfig\n                              ? VIR_ERR_XML_ERROR : VIR_ERR_INTERNAL_ERROR);\n\n    if (addrs->nbuses == 0) {\n        virReportError(errType, \"%s\", _(\"No PCI buses available\"));\n        return false;\n    }\n    if (addr->domain != 0) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI domain 0 is available\"),\n                       addrStr);\n        return false;\n    }\n    if (addr->bus >= addrs->nbuses) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI buses up to %zu are available\"),\n                       addrStr, addrs->nbuses - 1);\n        return false;\n    }\n\n    bus = &addrs->buses[addr->bus];\n\n    /* assure that at least one of the requested connection types is\n     * provided by this bus\n     */\n    if (!virDomainPCIAddressFlagsCompatible(addr, addrStr, bus->flags,\n                                            flags, true, fromConfig))\n        return false;\n\n    /* some \"buses\" are really just a single port */\n    if (bus->minSlot && addr->slot < bus->minSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be >= %zu\"),\n                       addrStr, bus->minSlot);\n        return false;\n    }\n    if (addr->slot > bus->maxSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be <= %zu\"),\n                       addrStr, bus->maxSlot);\n        return false;\n    }\n    if (addr->function > VIR_PCI_ADDRESS_FUNCTION_LAST) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. function must be <= %u\"),\n                       addrStr, VIR_PCI_ADDRESS_FUNCTION_LAST);\n        return false;\n    }\n    return true;\n}"
  },
  {
    "function_name": "virDomainPCIAddressFlagsCompatible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "341-434",
    "snippet": "static bool\nvirDomainPCIAddressFlagsCompatible(virPCIDeviceAddressPtr addr,\n                                   const char *addrStr,\n                                   virDomainPCIConnectFlags busFlags,\n                                   virDomainPCIConnectFlags devFlags,\n                                   bool reportError,\n                                   bool fromConfig)\n{\n    virErrorNumber errType = (fromConfig\n                              ? VIR_ERR_XML_ERROR : VIR_ERR_INTERNAL_ERROR);\n\n    if (fromConfig) {\n        /* If the requested connection was manually specified in\n         * config, allow a PCI device to connect to a PCIe slot, or\n         * vice versa. In order to do so, we add *both* the PCI_DEVICE\n         * and the PCIE_DEVICE flags to the bus if it already has either\n         * of them, using the ENDPOINT mask.\n         */\n        if (busFlags & VIR_PCI_CONNECT_TYPES_ENDPOINT)\n            busFlags |= VIR_PCI_CONNECT_TYPES_ENDPOINT;\n        /* Also allow manual specification of bus to override\n         * libvirt's assumptions about whether or not hotplug\n         * capability will be required.\n         */\n        if (devFlags & VIR_PCI_CONNECT_HOTPLUGGABLE)\n            busFlags |= VIR_PCI_CONNECT_HOTPLUGGABLE;\n        /* if the device is a pci-bridge, allow manually\n         * assigning to any bus that would also accept a\n         * standard PCI device.\n         */\n        if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE)\n            devFlags |= VIR_PCI_CONNECT_TYPE_PCI_DEVICE;\n    }\n\n    /* If this bus doesn't allow the type of connection (PCI\n     * vs. PCIe) required by the device, or if the device requires\n     * hot-plug and this bus doesn't have it, return false.\n     */\n    if (!(devFlags & busFlags & VIR_PCI_CONNECT_TYPES_MASK)) {\n        const char *connectStr;\n\n        if (!reportError)\n            return false;\n\n        if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_DEVICE) {\n            connectStr = \"standard PCI device\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_DEVICE) {\n            connectStr = \"PCI Express device\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT) {\n            connectStr = \"pcie-root-port\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT) {\n            connectStr = \"pcie-switch-upstream-port\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT) {\n            connectStr = \"pcie-switch-downstream-port\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE) {\n            connectStr = \"dmi-to-pci-bridge\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE) {\n            connectStr = \"pcie-to-pci-bridge\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS) {\n            connectStr = \"pci-expander-bus\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS) {\n            connectStr = \"pcie-expander-bus\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE) {\n            connectStr = \"pci-bridge\";\n        } else {\n            /* this should never happen. If it does, there is a\n             * bug in the code that sets the flag bits for devices.\n             */\n            virReportError(errType,\n                           _(\"The device at PCI address %s has \"\n                             \"unrecognized connection type flags 0x%.2x\"),\n                           addrStr, devFlags & VIR_PCI_CONNECT_TYPES_MASK);\n            return false;\n        }\n        virReportError(errType,\n                       _(\"The device at PCI address %s cannot be \"\n                         \"plugged into the PCI controller with index='%d'. \"\n                         \"It requires a controller that accepts a %s.\"),\n                       addrStr, addr->bus, connectStr);\n        return false;\n    }\n    if ((devFlags & VIR_PCI_CONNECT_HOTPLUGGABLE) &&\n        !(busFlags & VIR_PCI_CONNECT_HOTPLUGGABLE)) {\n        if (reportError) {\n            virReportError(errType,\n                           _(\"The device at PCI address %s requires \"\n                             \"hotplug capability, but the PCI controller \"\n                             \"with index='%d' doesn't support hotplug\"),\n                           addrStr, addr->bus);\n        }\n        return false;\n    }\n    return true;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "errType",
            "_(\"The device at PCI address %s requires \"\n                             \"hotplug capability, but the PCI controller \"\n                             \"with index='%d' doesn't support hotplug\")",
            "addrStr",
            "addr->bus"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"The device at PCI address %s requires \"\n                             \"hotplug capability, but the PCI controller \"\n                             \"with index='%d' doesn't support hotplug\""
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "errType",
            "_(\"The device at PCI address %s cannot be \"\n                         \"plugged into the PCI controller with index='%d'. \"\n                         \"It requires a controller that accepts a %s.\")",
            "addrStr",
            "addr->bus",
            "connectStr"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "errType",
            "_(\"The device at PCI address %s has \"\n                             \"unrecognized connection type flags 0x%.2x\")",
            "addrStr",
            "devFlags & VIR_PCI_CONNECT_TYPES_MASK"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic bool\nvirDomainPCIAddressFlagsCompatible(virPCIDeviceAddressPtr addr,\n                                   const char *addrStr,\n                                   virDomainPCIConnectFlags busFlags,\n                                   virDomainPCIConnectFlags devFlags,\n                                   bool reportError,\n                                   bool fromConfig)\n{\n    virErrorNumber errType = (fromConfig\n                              ? VIR_ERR_XML_ERROR : VIR_ERR_INTERNAL_ERROR);\n\n    if (fromConfig) {\n        /* If the requested connection was manually specified in\n         * config, allow a PCI device to connect to a PCIe slot, or\n         * vice versa. In order to do so, we add *both* the PCI_DEVICE\n         * and the PCIE_DEVICE flags to the bus if it already has either\n         * of them, using the ENDPOINT mask.\n         */\n        if (busFlags & VIR_PCI_CONNECT_TYPES_ENDPOINT)\n            busFlags |= VIR_PCI_CONNECT_TYPES_ENDPOINT;\n        /* Also allow manual specification of bus to override\n         * libvirt's assumptions about whether or not hotplug\n         * capability will be required.\n         */\n        if (devFlags & VIR_PCI_CONNECT_HOTPLUGGABLE)\n            busFlags |= VIR_PCI_CONNECT_HOTPLUGGABLE;\n        /* if the device is a pci-bridge, allow manually\n         * assigning to any bus that would also accept a\n         * standard PCI device.\n         */\n        if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE)\n            devFlags |= VIR_PCI_CONNECT_TYPE_PCI_DEVICE;\n    }\n\n    /* If this bus doesn't allow the type of connection (PCI\n     * vs. PCIe) required by the device, or if the device requires\n     * hot-plug and this bus doesn't have it, return false.\n     */\n    if (!(devFlags & busFlags & VIR_PCI_CONNECT_TYPES_MASK)) {\n        const char *connectStr;\n\n        if (!reportError)\n            return false;\n\n        if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_DEVICE) {\n            connectStr = \"standard PCI device\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_DEVICE) {\n            connectStr = \"PCI Express device\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT) {\n            connectStr = \"pcie-root-port\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT) {\n            connectStr = \"pcie-switch-upstream-port\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT) {\n            connectStr = \"pcie-switch-downstream-port\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE) {\n            connectStr = \"dmi-to-pci-bridge\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE) {\n            connectStr = \"pcie-to-pci-bridge\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS) {\n            connectStr = \"pci-expander-bus\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS) {\n            connectStr = \"pcie-expander-bus\";\n        } else if (devFlags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE) {\n            connectStr = \"pci-bridge\";\n        } else {\n            /* this should never happen. If it does, there is a\n             * bug in the code that sets the flag bits for devices.\n             */\n            virReportError(errType,\n                           _(\"The device at PCI address %s has \"\n                             \"unrecognized connection type flags 0x%.2x\"),\n                           addrStr, devFlags & VIR_PCI_CONNECT_TYPES_MASK);\n            return false;\n        }\n        virReportError(errType,\n                       _(\"The device at PCI address %s cannot be \"\n                         \"plugged into the PCI controller with index='%d'. \"\n                         \"It requires a controller that accepts a %s.\"),\n                       addrStr, addr->bus, connectStr);\n        return false;\n    }\n    if ((devFlags & VIR_PCI_CONNECT_HOTPLUGGABLE) &&\n        !(busFlags & VIR_PCI_CONNECT_HOTPLUGGABLE)) {\n        if (reportError) {\n            virReportError(errType,\n                           _(\"The device at PCI address %s requires \"\n                             \"hotplug capability, but the PCI controller \"\n                             \"with index='%d' doesn't support hotplug\"),\n                           addrStr, addr->bus);\n        }\n        return false;\n    }\n    return true;\n}"
  },
  {
    "function_name": "virDomainPCIControllerConnectTypeToModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "312-338",
    "snippet": "static int\nvirDomainPCIControllerConnectTypeToModel(virDomainPCIConnectFlags flags)\n{\n    if (flags & VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE)\n        return VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE;\n\n    /* some connect types don't correspond to a controller model */\n    return -1;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainPCIControllerConnectTypeToModel(virDomainPCIConnectFlags flags)\n{\n    if (flags & VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE)\n        return VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS;\n\n    if (flags & VIR_PCI_CONNECT_TYPE_PCI_BRIDGE)\n        return VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE;\n\n    /* some connect types don't correspond to a controller model */\n    return -1;\n}"
  },
  {
    "function_name": "virDomainPCIControllerModelToConnectType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "266-309",
    "snippet": "virDomainPCIConnectFlags\nvirDomainPCIControllerModelToConnectType(virDomainControllerModelPCI model)\n{\n    /* given a VIR_DOMAIN_CONTROLLER_MODEL_PCI*, return\n     * the equivalent VIR_PCI_CONNECT_TYPE_*.\n     */\n    switch (model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n        /* pci-root and pcie-root are implicit in the machine,\n         * and have no upstream connection, \"last\" will never actually\n         * happen, it's just there so that all possible cases are\n         * covered in the switch (keeps the compiler happy).\n         */\n        return 0;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n        return VIR_PCI_CONNECT_TYPE_PCI_BRIDGE;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n        return VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n        return VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n        return VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n        return VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n        return VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT | VIR_PCI_CONNECT_AGGREGATE_SLOT;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n        return VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n        return VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvirDomainPCIConnectFlags\nvirDomainPCIControllerModelToConnectType(virDomainControllerModelPCI model)\n{\n    /* given a VIR_DOMAIN_CONTROLLER_MODEL_PCI*, return\n     * the equivalent VIR_PCI_CONNECT_TYPE_*.\n     */\n    switch (model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n        /* pci-root and pcie-root are implicit in the machine,\n         * and have no upstream connection, \"last\" will never actually\n         * happen, it's just there so that all possible cases are\n         * covered in the switch (keeps the compiler happy).\n         */\n        return 0;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n        return VIR_PCI_CONNECT_TYPE_PCI_BRIDGE;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n        return VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n        return VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n        return VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n        return VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n        return VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT | VIR_PCI_CONNECT_AGGREGATE_SLOT;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n        return VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n        return VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virDomainPCIAddressExtensionEnsureAddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "249-263",
    "snippet": "static int\nvirDomainPCIAddressExtensionEnsureAddr(virDomainPCIAddressSetPtr addrs,\n                                       virPCIDeviceAddressPtr addr)\n{\n    if (addr->extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) {\n        virZPCIDeviceAddressPtr zpci = &addr->zpci;\n\n        if (virZPCIDeviceAddressIsEmpty(zpci))\n            return virDomainZPCIAddressReserveNextAddr(addrs->zpciIds, zpci);\n        else\n            return virDomainZPCIAddressReserveAddr(addrs->zpciIds, zpci);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReserveAddr",
          "args": [
            "addrs->zpciIds",
            "zpci"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReserveAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "185-198",
          "snippet": "static int\nvirDomainZPCIAddressReserveAddr(virDomainZPCIAddressIdsPtr zpciIds,\n                                virZPCIDeviceAddressPtr addr)\n{\n    if (virDomainZPCIAddressReserveUid(zpciIds->uids, addr) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveFid(zpciIds->fids, addr) < 0) {\n        virDomainZPCIAddressReleaseUid(zpciIds->uids, addr);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveAddr(virDomainZPCIAddressIdsPtr zpciIds,\n                                virZPCIDeviceAddressPtr addr)\n{\n    if (virDomainZPCIAddressReserveUid(zpciIds->uids, addr) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveFid(zpciIds->fids, addr) < 0) {\n        virDomainZPCIAddressReleaseUid(zpciIds->uids, addr);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReserveNextAddr",
          "args": [
            "addrs->zpciIds",
            "zpci"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReserveNextAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "201-214",
          "snippet": "static int\nvirDomainZPCIAddressReserveNextAddr(virDomainZPCIAddressIdsPtr zpciIds,\n                                    virZPCIDeviceAddressPtr addr)\n{\n    if (virDomainZPCIAddressReserveNextUid(zpciIds->uids, addr) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveNextFid(zpciIds->fids, addr) < 0) {\n        virDomainZPCIAddressReleaseUid(zpciIds->uids, addr);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveNextAddr(virDomainZPCIAddressIdsPtr zpciIds,\n                                    virZPCIDeviceAddressPtr addr)\n{\n    if (virDomainZPCIAddressReserveNextUid(zpciIds->uids, addr) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveNextFid(zpciIds->fids, addr) < 0) {\n        virDomainZPCIAddressReleaseUid(zpciIds->uids, addr);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virZPCIDeviceAddressIsEmpty",
          "args": [
            "zpci"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "virZPCIDeviceAddressIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2188-2192",
          "snippet": "bool\nvirZPCIDeviceAddressIsEmpty(const virZPCIDeviceAddress *addr)\n{\n    return !(addr->uid || addr->fid);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirZPCIDeviceAddressIsEmpty(const virZPCIDeviceAddress *addr)\n{\n    return !(addr->uid || addr->fid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainPCIAddressExtensionEnsureAddr(virDomainPCIAddressSetPtr addrs,\n                                       virPCIDeviceAddressPtr addr)\n{\n    if (addr->extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) {\n        virZPCIDeviceAddressPtr zpci = &addr->zpci;\n\n        if (virZPCIDeviceAddressIsEmpty(zpci))\n            return virDomainZPCIAddressReserveNextAddr(addrs->zpciIds, zpci);\n        else\n            return virDomainZPCIAddressReserveAddr(addrs->zpciIds, zpci);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainPCIAddressExtensionReserveNextAddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "232-247",
    "snippet": "int\nvirDomainPCIAddressExtensionReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                            virPCIDeviceAddressPtr addr)\n{\n    if (addr->extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) {\n        virZPCIDeviceAddress zpci = { 0 };\n\n        if (virDomainZPCIAddressReserveNextAddr(addrs->zpciIds, &zpci) < 0)\n            return -1;\n\n        if (!addrs->dryRun)\n            addr->zpci = zpci;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReserveNextAddr",
          "args": [
            "addrs->zpciIds",
            "&zpci"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReserveNextAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "201-214",
          "snippet": "static int\nvirDomainZPCIAddressReserveNextAddr(virDomainZPCIAddressIdsPtr zpciIds,\n                                    virZPCIDeviceAddressPtr addr)\n{\n    if (virDomainZPCIAddressReserveNextUid(zpciIds->uids, addr) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveNextFid(zpciIds->fids, addr) < 0) {\n        virDomainZPCIAddressReleaseUid(zpciIds->uids, addr);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveNextAddr(virDomainZPCIAddressIdsPtr zpciIds,\n                                    virZPCIDeviceAddressPtr addr)\n{\n    if (virDomainZPCIAddressReserveNextUid(zpciIds->uids, addr) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveNextFid(zpciIds->fids, addr) < 0) {\n        virDomainZPCIAddressReleaseUid(zpciIds->uids, addr);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressExtensionReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                            virPCIDeviceAddressPtr addr)\n{\n    if (addr->extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) {\n        virZPCIDeviceAddress zpci = { 0 };\n\n        if (virDomainZPCIAddressReserveNextAddr(addrs->zpciIds, &zpci) < 0)\n            return -1;\n\n        if (!addrs->dryRun)\n            addr->zpci = zpci;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainPCIAddressExtensionReserveAddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "217-229",
    "snippet": "int\nvirDomainPCIAddressExtensionReserveAddr(virDomainPCIAddressSetPtr addrs,\n                                        virPCIDeviceAddressPtr addr)\n{\n    if (addr->extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) {\n        /* Reserve uid/fid to ZPCI device which has defined uid/fid\n         * in the domain.\n         */\n        return virDomainZPCIAddressReserveAddr(addrs->zpciIds, &addr->zpci);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReserveAddr",
          "args": [
            "addrs->zpciIds",
            "&addr->zpci"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReserveAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "185-198",
          "snippet": "static int\nvirDomainZPCIAddressReserveAddr(virDomainZPCIAddressIdsPtr zpciIds,\n                                virZPCIDeviceAddressPtr addr)\n{\n    if (virDomainZPCIAddressReserveUid(zpciIds->uids, addr) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveFid(zpciIds->fids, addr) < 0) {\n        virDomainZPCIAddressReleaseUid(zpciIds->uids, addr);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveAddr(virDomainZPCIAddressIdsPtr zpciIds,\n                                virZPCIDeviceAddressPtr addr)\n{\n    if (virDomainZPCIAddressReserveUid(zpciIds->uids, addr) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveFid(zpciIds->fids, addr) < 0) {\n        virDomainZPCIAddressReleaseUid(zpciIds->uids, addr);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressExtensionReserveAddr(virDomainPCIAddressSetPtr addrs,\n                                        virPCIDeviceAddressPtr addr)\n{\n    if (addr->extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) {\n        /* Reserve uid/fid to ZPCI device which has defined uid/fid\n         * in the domain.\n         */\n        return virDomainZPCIAddressReserveAddr(addrs->zpciIds, &addr->zpci);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainZPCIAddressReserveNextAddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "201-214",
    "snippet": "static int\nvirDomainZPCIAddressReserveNextAddr(virDomainZPCIAddressIdsPtr zpciIds,\n                                    virZPCIDeviceAddressPtr addr)\n{\n    if (virDomainZPCIAddressReserveNextUid(zpciIds->uids, addr) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveNextFid(zpciIds->fids, addr) < 0) {\n        virDomainZPCIAddressReleaseUid(zpciIds->uids, addr);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReleaseUid",
          "args": [
            "zpciIds->uids",
            "addr"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReleaseUid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "128-133",
          "snippet": "static void\nvirDomainZPCIAddressReleaseUid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    virDomainZPCIAddressReleaseId(set, &addr->uid, \"uid\");\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainZPCIAddressReleaseUid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    virDomainZPCIAddressReleaseId(set, &addr->uid, \"uid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReserveNextFid",
          "args": [
            "zpciIds->fids",
            "addr"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReserveNextFid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "171-182",
          "snippet": "static int\nvirDomainZPCIAddressReserveNextFid(virHashTablePtr fids,\n                                   virZPCIDeviceAddressPtr zpci)\n{\n    if (virDomainZPCIAddressAssignFid(fids, zpci) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveFid(fids, zpci) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveNextFid(virHashTablePtr fids,\n                                   virZPCIDeviceAddressPtr zpci)\n{\n    if (virDomainZPCIAddressAssignFid(fids, zpci) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveFid(fids, zpci) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReserveNextUid",
          "args": [
            "zpciIds->uids",
            "addr"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReserveNextUid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "157-168",
          "snippet": "static int\nvirDomainZPCIAddressReserveNextUid(virHashTablePtr uids,\n                                   virZPCIDeviceAddressPtr zpci)\n{\n    if (virDomainZPCIAddressAssignUid(uids, zpci) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveUid(uids, zpci) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveNextUid(virHashTablePtr uids,\n                                   virZPCIDeviceAddressPtr zpci)\n{\n    if (virDomainZPCIAddressAssignUid(uids, zpci) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveUid(uids, zpci) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveNextAddr(virDomainZPCIAddressIdsPtr zpciIds,\n                                    virZPCIDeviceAddressPtr addr)\n{\n    if (virDomainZPCIAddressReserveNextUid(zpciIds->uids, addr) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveNextFid(zpciIds->fids, addr) < 0) {\n        virDomainZPCIAddressReleaseUid(zpciIds->uids, addr);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainZPCIAddressReserveAddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "185-198",
    "snippet": "static int\nvirDomainZPCIAddressReserveAddr(virDomainZPCIAddressIdsPtr zpciIds,\n                                virZPCIDeviceAddressPtr addr)\n{\n    if (virDomainZPCIAddressReserveUid(zpciIds->uids, addr) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveFid(zpciIds->fids, addr) < 0) {\n        virDomainZPCIAddressReleaseUid(zpciIds->uids, addr);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReleaseUid",
          "args": [
            "zpciIds->uids",
            "addr"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReleaseUid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "128-133",
          "snippet": "static void\nvirDomainZPCIAddressReleaseUid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    virDomainZPCIAddressReleaseId(set, &addr->uid, \"uid\");\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainZPCIAddressReleaseUid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    virDomainZPCIAddressReleaseId(set, &addr->uid, \"uid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReserveFid",
          "args": [
            "zpciIds->fids",
            "addr"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReserveFid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "65-70",
          "snippet": "static int\nvirDomainZPCIAddressReserveFid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressReserveId(set, addr->fid, \"fid\");\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveFid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressReserveId(set, addr->fid, \"fid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReserveUid",
          "args": [
            "zpciIds->uids",
            "addr"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReserveUid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "57-62",
          "snippet": "static int\nvirDomainZPCIAddressReserveUid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressReserveId(set, addr->uid, \"uid\");\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveUid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressReserveId(set, addr->uid, \"uid\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveAddr(virDomainZPCIAddressIdsPtr zpciIds,\n                                virZPCIDeviceAddressPtr addr)\n{\n    if (virDomainZPCIAddressReserveUid(zpciIds->uids, addr) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveFid(zpciIds->fids, addr) < 0) {\n        virDomainZPCIAddressReleaseUid(zpciIds->uids, addr);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainZPCIAddressReserveNextFid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "171-182",
    "snippet": "static int\nvirDomainZPCIAddressReserveNextFid(virHashTablePtr fids,\n                                   virZPCIDeviceAddressPtr zpci)\n{\n    if (virDomainZPCIAddressAssignFid(fids, zpci) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveFid(fids, zpci) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReserveFid",
          "args": [
            "fids",
            "zpci"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReserveFid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "65-70",
          "snippet": "static int\nvirDomainZPCIAddressReserveFid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressReserveId(set, addr->fid, \"fid\");\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveFid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressReserveId(set, addr->fid, \"fid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainZPCIAddressAssignFid",
          "args": [
            "fids",
            "zpci"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressAssignFid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "104-110",
          "snippet": "static int\nvirDomainZPCIAddressAssignFid(virHashTablePtr set,\n                              virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressAssignId(set, &addr->fid, 0,\n                                        VIR_DOMAIN_DEVICE_ZPCI_MAX_FID, \"fid\");\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressAssignFid(virHashTablePtr set,\n                              virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressAssignId(set, &addr->fid, 0,\n                                        VIR_DOMAIN_DEVICE_ZPCI_MAX_FID, \"fid\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveNextFid(virHashTablePtr fids,\n                                   virZPCIDeviceAddressPtr zpci)\n{\n    if (virDomainZPCIAddressAssignFid(fids, zpci) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveFid(fids, zpci) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainZPCIAddressReserveNextUid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "157-168",
    "snippet": "static int\nvirDomainZPCIAddressReserveNextUid(virHashTablePtr uids,\n                                   virZPCIDeviceAddressPtr zpci)\n{\n    if (virDomainZPCIAddressAssignUid(uids, zpci) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveUid(uids, zpci) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReserveUid",
          "args": [
            "uids",
            "zpci"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReserveUid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "57-62",
          "snippet": "static int\nvirDomainZPCIAddressReserveUid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressReserveId(set, addr->uid, \"uid\");\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveUid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressReserveId(set, addr->uid, \"uid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainZPCIAddressAssignUid",
          "args": [
            "uids",
            "zpci"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressAssignUid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "95-101",
          "snippet": "static int\nvirDomainZPCIAddressAssignUid(virHashTablePtr set,\n                              virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressAssignId(set, &addr->uid, 1,\n                                        VIR_DOMAIN_DEVICE_ZPCI_MAX_UID, \"uid\");\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressAssignUid(virHashTablePtr set,\n                              virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressAssignId(set, &addr->uid, 1,\n                                        VIR_DOMAIN_DEVICE_ZPCI_MAX_UID, \"uid\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveNextUid(virHashTablePtr uids,\n                                   virZPCIDeviceAddressPtr zpci)\n{\n    if (virDomainZPCIAddressAssignUid(uids, zpci) < 0)\n        return -1;\n\n    if (virDomainZPCIAddressReserveUid(uids, zpci) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainZPCIAddressReleaseIds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "144-154",
    "snippet": "static void\nvirDomainZPCIAddressReleaseIds(virDomainZPCIAddressIdsPtr zpciIds,\n                               virZPCIDeviceAddressPtr addr)\n{\n    if (!zpciIds || virZPCIDeviceAddressIsEmpty(addr))\n        return;\n\n    virDomainZPCIAddressReleaseUid(zpciIds->uids, addr);\n\n    virDomainZPCIAddressReleaseFid(zpciIds->fids, addr);\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReleaseFid",
          "args": [
            "zpciIds->fids",
            "addr"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReleaseFid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "136-141",
          "snippet": "static void\nvirDomainZPCIAddressReleaseFid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    virDomainZPCIAddressReleaseId(set, &addr->fid, \"fid\");\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainZPCIAddressReleaseFid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    virDomainZPCIAddressReleaseId(set, &addr->fid, \"fid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReleaseUid",
          "args": [
            "zpciIds->uids",
            "addr"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReleaseUid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "128-133",
          "snippet": "static void\nvirDomainZPCIAddressReleaseUid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    virDomainZPCIAddressReleaseId(set, &addr->uid, \"uid\");\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainZPCIAddressReleaseUid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    virDomainZPCIAddressReleaseId(set, &addr->uid, \"uid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virZPCIDeviceAddressIsEmpty",
          "args": [
            "addr"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "virZPCIDeviceAddressIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2188-2192",
          "snippet": "bool\nvirZPCIDeviceAddressIsEmpty(const virZPCIDeviceAddress *addr)\n{\n    return !(addr->uid || addr->fid);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirZPCIDeviceAddressIsEmpty(const virZPCIDeviceAddress *addr)\n{\n    return !(addr->uid || addr->fid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainZPCIAddressReleaseIds(virDomainZPCIAddressIdsPtr zpciIds,\n                               virZPCIDeviceAddressPtr addr)\n{\n    if (!zpciIds || virZPCIDeviceAddressIsEmpty(addr))\n        return;\n\n    virDomainZPCIAddressReleaseUid(zpciIds->uids, addr);\n\n    virDomainZPCIAddressReleaseFid(zpciIds->fids, addr);\n}"
  },
  {
    "function_name": "virDomainZPCIAddressReleaseFid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "136-141",
    "snippet": "static void\nvirDomainZPCIAddressReleaseFid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    virDomainZPCIAddressReleaseId(set, &addr->fid, \"fid\");\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReleaseId",
          "args": [
            "set",
            "&addr->fid",
            "\"fid\""
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReleaseId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "113-125",
          "snippet": "static void\nvirDomainZPCIAddressReleaseId(virHashTablePtr set,\n                              unsigned int *id,\n                              const char *name)\n{\n    if (virHashRemoveEntry(set, id) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Release %s %o failed\"),\n                       name, *id);\n    }\n\n    *id = 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainZPCIAddressReleaseId(virHashTablePtr set,\n                              unsigned int *id,\n                              const char *name)\n{\n    if (virHashRemoveEntry(set, id) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Release %s %o failed\"),\n                       name, *id);\n    }\n\n    *id = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainZPCIAddressReleaseFid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    virDomainZPCIAddressReleaseId(set, &addr->fid, \"fid\");\n}"
  },
  {
    "function_name": "virDomainZPCIAddressReleaseUid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "128-133",
    "snippet": "static void\nvirDomainZPCIAddressReleaseUid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    virDomainZPCIAddressReleaseId(set, &addr->uid, \"uid\");\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReleaseId",
          "args": [
            "set",
            "&addr->uid",
            "\"uid\""
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReleaseId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "113-125",
          "snippet": "static void\nvirDomainZPCIAddressReleaseId(virHashTablePtr set,\n                              unsigned int *id,\n                              const char *name)\n{\n    if (virHashRemoveEntry(set, id) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Release %s %o failed\"),\n                       name, *id);\n    }\n\n    *id = 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainZPCIAddressReleaseId(virHashTablePtr set,\n                              unsigned int *id,\n                              const char *name)\n{\n    if (virHashRemoveEntry(set, id) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Release %s %o failed\"),\n                       name, *id);\n    }\n\n    *id = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainZPCIAddressReleaseUid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    virDomainZPCIAddressReleaseId(set, &addr->uid, \"uid\");\n}"
  },
  {
    "function_name": "virDomainZPCIAddressReleaseId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "113-125",
    "snippet": "static void\nvirDomainZPCIAddressReleaseId(virHashTablePtr set,\n                              unsigned int *id,\n                              const char *name)\n{\n    if (virHashRemoveEntry(set, id) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Release %s %o failed\"),\n                       name, *id);\n    }\n\n    *id = 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Release %s %o failed\")",
            "name",
            "*id"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Release %s %o failed\""
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashRemoveEntry",
          "args": [
            "set",
            "id"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "virHashRemoveEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "584-609",
          "snippet": "int\nvirHashRemoveEntry(virHashTablePtr table, const void *name)\n{\n    virHashEntryPtr entry;\n    virHashEntryPtr *nextptr;\n\n    if (table == NULL || name == NULL)\n        return -1;\n\n    nextptr = table->table + virHashComputeKey(table, name);\n    for (entry = *nextptr; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (table->dataFree)\n                table->dataFree(entry->payload);\n            if (table->keyFree)\n                table->keyFree(entry->name);\n            *nextptr = entry->next;\n            VIR_FREE(entry);\n            table->nbElems--;\n            return 0;\n        }\n        nextptr = &entry->next;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashRemoveEntry(virHashTablePtr table, const void *name)\n{\n    virHashEntryPtr entry;\n    virHashEntryPtr *nextptr;\n\n    if (table == NULL || name == NULL)\n        return -1;\n\n    nextptr = table->table + virHashComputeKey(table, name);\n    for (entry = *nextptr; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (table->dataFree)\n                table->dataFree(entry->payload);\n            if (table->keyFree)\n                table->keyFree(entry->name);\n            *nextptr = entry->next;\n            VIR_FREE(entry);\n            table->nbElems--;\n            return 0;\n        }\n        nextptr = &entry->next;\n    }\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirDomainZPCIAddressReleaseId(virHashTablePtr set,\n                              unsigned int *id,\n                              const char *name)\n{\n    if (virHashRemoveEntry(set, id) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Release %s %o failed\"),\n                       name, *id);\n    }\n\n    *id = 0;\n}"
  },
  {
    "function_name": "virDomainZPCIAddressAssignFid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "104-110",
    "snippet": "static int\nvirDomainZPCIAddressAssignFid(virHashTablePtr set,\n                              virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressAssignId(set, &addr->fid, 0,\n                                        VIR_DOMAIN_DEVICE_ZPCI_MAX_FID, \"fid\");\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainZPCIAddressAssignId",
          "args": [
            "set",
            "&addr->fid",
            "0",
            "VIR_DOMAIN_DEVICE_ZPCI_MAX_FID",
            "\"fid\""
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressAssignId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "73-92",
          "snippet": "static int\nvirDomainZPCIAddressAssignId(virHashTablePtr set,\n                             unsigned int *id,\n                             unsigned int min,\n                             unsigned int max,\n                             const char *name)\n{\n    while (virHashLookup(set, &min)) {\n        if (min == max) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"There is no more free %s.\"),\n                           name);\n            return -1;\n        }\n        ++min;\n    }\n    *id = min;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressAssignId(virHashTablePtr set,\n                             unsigned int *id,\n                             unsigned int min,\n                             unsigned int max,\n                             const char *name)\n{\n    while (virHashLookup(set, &min)) {\n        if (min == max) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"There is no more free %s.\"),\n                           name);\n            return -1;\n        }\n        ++min;\n    }\n    *id = min;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressAssignFid(virHashTablePtr set,\n                              virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressAssignId(set, &addr->fid, 0,\n                                        VIR_DOMAIN_DEVICE_ZPCI_MAX_FID, \"fid\");\n}"
  },
  {
    "function_name": "virDomainZPCIAddressAssignUid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "95-101",
    "snippet": "static int\nvirDomainZPCIAddressAssignUid(virHashTablePtr set,\n                              virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressAssignId(set, &addr->uid, 1,\n                                        VIR_DOMAIN_DEVICE_ZPCI_MAX_UID, \"uid\");\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainZPCIAddressAssignId",
          "args": [
            "set",
            "&addr->uid",
            "1",
            "VIR_DOMAIN_DEVICE_ZPCI_MAX_UID",
            "\"uid\""
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressAssignId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "73-92",
          "snippet": "static int\nvirDomainZPCIAddressAssignId(virHashTablePtr set,\n                             unsigned int *id,\n                             unsigned int min,\n                             unsigned int max,\n                             const char *name)\n{\n    while (virHashLookup(set, &min)) {\n        if (min == max) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"There is no more free %s.\"),\n                           name);\n            return -1;\n        }\n        ++min;\n    }\n    *id = min;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressAssignId(virHashTablePtr set,\n                             unsigned int *id,\n                             unsigned int min,\n                             unsigned int max,\n                             const char *name)\n{\n    while (virHashLookup(set, &min)) {\n        if (min == max) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"There is no more free %s.\"),\n                           name);\n            return -1;\n        }\n        ++min;\n    }\n    *id = min;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressAssignUid(virHashTablePtr set,\n                              virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressAssignId(set, &addr->uid, 1,\n                                        VIR_DOMAIN_DEVICE_ZPCI_MAX_UID, \"uid\");\n}"
  },
  {
    "function_name": "virDomainZPCIAddressAssignId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "73-92",
    "snippet": "static int\nvirDomainZPCIAddressAssignId(virHashTablePtr set,\n                             unsigned int *id,\n                             unsigned int min,\n                             unsigned int max,\n                             const char *name)\n{\n    while (virHashLookup(set, &min)) {\n        if (min == max) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"There is no more free %s.\"),\n                           name);\n            return -1;\n        }\n        ++min;\n    }\n    *id = min;\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"There is no more free %s.\")",
            "name"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"There is no more free %s.\""
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "set",
            "&min"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressAssignId(virHashTablePtr set,\n                             unsigned int *id,\n                             unsigned int min,\n                             unsigned int max,\n                             const char *name)\n{\n    while (virHashLookup(set, &min)) {\n        if (min == max) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"There is no more free %s.\"),\n                           name);\n            return -1;\n        }\n        ++min;\n    }\n    *id = min;\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainZPCIAddressReserveFid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "65-70",
    "snippet": "static int\nvirDomainZPCIAddressReserveFid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressReserveId(set, addr->fid, \"fid\");\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReserveId",
          "args": [
            "set",
            "addr->fid",
            "\"fid\""
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReserveId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "34-54",
          "snippet": "static int\nvirDomainZPCIAddressReserveId(virHashTablePtr set,\n                              unsigned int id,\n                              const char *name)\n{\n    if (virHashLookup(set, &id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"zPCI %s %o is already reserved\"),\n                       name, id);\n        return -1;\n    }\n\n    if (virHashAddEntry(set, &id, (void*)1) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to reserve %s %o\"),\n                       name, id);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveId(virHashTablePtr set,\n                              unsigned int id,\n                              const char *name)\n{\n    if (virHashLookup(set, &id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"zPCI %s %o is already reserved\"),\n                       name, id);\n        return -1;\n    }\n\n    if (virHashAddEntry(set, &id, (void*)1) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to reserve %s %o\"),\n                       name, id);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveFid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressReserveId(set, addr->fid, \"fid\");\n}"
  },
  {
    "function_name": "virDomainZPCIAddressReserveUid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "57-62",
    "snippet": "static int\nvirDomainZPCIAddressReserveUid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressReserveId(set, addr->uid, \"uid\");\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainZPCIAddressReserveId",
          "args": [
            "set",
            "addr->uid",
            "\"uid\""
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainZPCIAddressReserveId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "34-54",
          "snippet": "static int\nvirDomainZPCIAddressReserveId(virHashTablePtr set,\n                              unsigned int id,\n                              const char *name)\n{\n    if (virHashLookup(set, &id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"zPCI %s %o is already reserved\"),\n                       name, id);\n        return -1;\n    }\n\n    if (virHashAddEntry(set, &id, (void*)1) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to reserve %s %o\"),\n                       name, id);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveId(virHashTablePtr set,\n                              unsigned int id,\n                              const char *name)\n{\n    if (virHashLookup(set, &id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"zPCI %s %o is already reserved\"),\n                       name, id);\n        return -1;\n    }\n\n    if (virHashAddEntry(set, &id, (void*)1) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to reserve %s %o\"),\n                       name, id);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveUid(virHashTablePtr set,\n                               virZPCIDeviceAddressPtr addr)\n{\n    return virDomainZPCIAddressReserveId(set, addr->uid, \"uid\");\n}"
  },
  {
    "function_name": "virDomainZPCIAddressReserveId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
    "lines": "34-54",
    "snippet": "static int\nvirDomainZPCIAddressReserveId(virHashTablePtr set,\n                              unsigned int id,\n                              const char *name)\n{\n    if (virHashLookup(set, &id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"zPCI %s %o is already reserved\"),\n                       name, id);\n        return -1;\n    }\n\n    if (virHashAddEntry(set, &id, (void*)1) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to reserve %s %o\"),\n                       name, id);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhashcode.h\"",
      "#include \"domain_addr.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to reserve %s %o\")",
            "name",
            "id"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to reserve %s %o\""
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1950-1956",
          "snippet": "static char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic char * ATTRIBUTE_NONNULL(1)\nvirDomainUSBAddressPortFormat(unsigned int *port)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virDomainUSBAddressPortFormatBuf(&buf, port);\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashAddEntry",
          "args": [
            "set",
            "&id",
            "(void*)1"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAddEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "404-408",
          "snippet": "int\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"zPCI %s %o is already reserved\")",
            "name",
            "id"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "set",
            "&id"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int\nvirDomainZPCIAddressReserveId(virHashTablePtr set,\n                              unsigned int id,\n                              const char *name)\n{\n    if (virHashLookup(set, &id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"zPCI %s %o is already reserved\"),\n                       name, id);\n        return -1;\n    }\n\n    if (virHashAddEntry(set, &id, (void*)1) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to reserve %s %o\"),\n                       name, id);\n        return -1;\n    }\n\n    return 0;\n}"
  }
]