[
  {
    "function_name": "qemuExtVhostUserGPUSetupCgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_vhost_user_gpu.c",
    "lines": "241-267",
    "snippet": "int\nqemuExtVhostUserGPUSetupCgroup(virQEMUDriverPtr driver,\n                               virDomainDefPtr def,\n                               virDomainVideoDefPtr video,\n                               virCgroupPtr cgroup)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *shortname = NULL;\n    int rc;\n    pid_t pid;\n\n    shortname = virDomainDefGetShortName(def);\n    if (!shortname)\n        return -1;\n\n    rc = qemuVhostUserGPUGetPid(video->driver->vhost_user_binary,\n                                cfg->stateDir, shortname, video->info.alias, &pid);\n    if (rc < 0 || (rc == 0 && pid == (pid_t)-1)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not get process id of vhost-user-gpu\"));\n        return -1;\n    }\n    if (virCgroupAddProcess(cgroup, pid) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virpidfile.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"configmake.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_vhost_user.h\"",
      "#include \"qemu_vhost_user_gpu.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCgroupAddProcess",
          "args": [
            "cgroup",
            "pid"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "virCgroupAddProcess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircgroup.c",
          "lines": "2919-2926",
          "snippet": "int\nvirCgroupAddProcess(virCgroupPtr group G_GNUC_UNUSED,\n                    pid_t pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENXIO, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircgroupbackend.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"vircgrouppriv.h\"",
            "# include <unistd.h>",
            "# include <dirent.h>",
            "# include <signal.h>",
            "# include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <sys/stat.h>",
            "# include <fcntl.h>",
            "# include <sys/mount.h>",
            "# include <mntent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virhostcpu.h\"\n#include \"virtypedparam.h\"\n#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhashcode.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircgroupbackend.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"vircgrouppriv.h\"\n# include <unistd.h>\n# include <dirent.h>\n# include <signal.h>\n# include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n# include <sys/mount.h>\n# include <mntent.h>\n#include <config.h>\n\nint\nvirCgroupAddProcess(virCgroupPtr group G_GNUC_UNUSED,\n                    pid_t pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENXIO, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not get process id of vhost-user-gpu\")"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not get process id of vhost-user-gpu\""
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuVhostUserGPUGetPid",
          "args": [
            "video->driver->vhost_user_binary",
            "cfg->stateDir",
            "shortname",
            "video->info.alias",
            "&pid"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "qemuVhostUserGPUGetPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_vhost_user_gpu.c",
          "lines": "67-83",
          "snippet": "static int\nqemuVhostUserGPUGetPid(const char *binPath,\n                       const char *stateDir,\n                       const char *shortName,\n                       const char *alias,\n                       pid_t *pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (!(pidfile = qemuVhostUserGPUCreatePidFilename(stateDir, shortName, alias)))\n        return -1;\n\n    if (virPidFileReadPathIfAlive(pidfile, pid, binPath) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virpidfile.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_vhost_user_gpu.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include <config.h>\n\nstatic int\nqemuVhostUserGPUGetPid(const char *binPath,\n                       const char *stateDir,\n                       const char *shortName,\n                       const char *alias,\n                       pid_t *pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (!(pidfile = qemuVhostUserGPUCreatePidFilename(stateDir, shortName, alias)))\n        return -1;\n\n    if (virPidFileReadPathIfAlive(pidfile, pid, binPath) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetShortName",
          "args": [
            "def"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetShortName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30900-30952",
          "snippet": "char *\nvirDomainDefGetShortName(const virDomainDef *def)\n{\n    wchar_t wshortname[VIR_DOMAIN_SHORT_NAME_MAX + 1] = {0};\n    size_t len = 0;\n    char *ret = NULL;\n    g_autofree char *shortname = NULL;\n\n    /* No need to do the whole conversion thing when there are no multibyte\n     * characters.  The same applies for illegal sequences as they can occur\n     * with incompatible locales. */\n    len = mbstowcs(NULL, def->name, 0);\n    if ((len == (size_t) -1 && errno == EILSEQ) ||\n        len == strlen(def->name)) {\n        ret = g_strdup_printf(\"%d-%.*s\", def->id, VIR_DOMAIN_SHORT_NAME_MAX, def->name);\n        return ret;\n    }\n\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    if (mbstowcs(wshortname, def->name, VIR_DOMAIN_SHORT_NAME_MAX) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    len = wcstombs(NULL, wshortname, 0);\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    if (VIR_ALLOC_N(shortname, len + 1) < 0)\n        return NULL;\n\n    if (wcstombs(shortname, wshortname, len) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%d-%s\", def->id, shortname);\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_SHORT_NAME_MAX 20"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_SHORT_NAME_MAX 20\n\nchar *\nvirDomainDefGetShortName(const virDomainDef *def)\n{\n    wchar_t wshortname[VIR_DOMAIN_SHORT_NAME_MAX + 1] = {0};\n    size_t len = 0;\n    char *ret = NULL;\n    g_autofree char *shortname = NULL;\n\n    /* No need to do the whole conversion thing when there are no multibyte\n     * characters.  The same applies for illegal sequences as they can occur\n     * with incompatible locales. */\n    len = mbstowcs(NULL, def->name, 0);\n    if ((len == (size_t) -1 && errno == EILSEQ) ||\n        len == strlen(def->name)) {\n        ret = g_strdup_printf(\"%d-%.*s\", def->id, VIR_DOMAIN_SHORT_NAME_MAX, def->name);\n        return ret;\n    }\n\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    if (mbstowcs(wshortname, def->name, VIR_DOMAIN_SHORT_NAME_MAX) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    len = wcstombs(NULL, wshortname, 0);\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    if (VIR_ALLOC_N(shortname, len + 1) < 0)\n        return NULL;\n\n    if (wcstombs(shortname, wshortname, len) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%d-%s\", def->id, shortname);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include <config.h>\n\nint\nqemuExtVhostUserGPUSetupCgroup(virQEMUDriverPtr driver,\n                               virDomainDefPtr def,\n                               virDomainVideoDefPtr video,\n                               virCgroupPtr cgroup)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *shortname = NULL;\n    int rc;\n    pid_t pid;\n\n    shortname = virDomainDefGetShortName(def);\n    if (!shortname)\n        return -1;\n\n    rc = qemuVhostUserGPUGetPid(video->driver->vhost_user_binary,\n                                cfg->stateDir, shortname, video->info.alias, &pid);\n    if (rc < 0 || (rc == 0 && pid == (pid_t)-1)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not get process id of vhost-user-gpu\"));\n        return -1;\n    }\n    if (virCgroupAddProcess(cgroup, pid) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuExtVhostUserGPUStop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_vhost_user_gpu.c",
    "lines": "208-228",
    "snippet": "void qemuExtVhostUserGPUStop(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             virDomainVideoDefPtr video)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *pidfile = NULL;\n    g_autofree char *shortname = NULL;\n    virErrorPtr orig_err;\n\n    shortname = virDomainDefGetShortName(vm->def);\n    if (!(pidfile = qemuVhostUserGPUCreatePidFilename(\n              cfg->stateDir, shortname, video->info.alias))) {\n        VIR_WARN(\"Unable to construct vhost-user-gpu pidfile path\");\n        return;\n    }\n\n    virErrorPreserveLast(&orig_err);\n    if (virPidFileForceCleanupPath(pidfile) < 0)\n        VIR_WARN(\"Unable to kill vhost-user-gpu process\");\n    virErrorRestore(&orig_err);\n}",
    "includes": [
      "#include \"virpidfile.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"configmake.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_vhost_user.h\"",
      "#include \"qemu_vhost_user_gpu.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&orig_err"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to kill vhost-user-gpu process\""
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileForceCleanupPath",
          "args": [
            "pidfile"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileForceCleanupPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "515-545",
          "snippet": "int\nvirPidFileForceCleanupPath(const char *path)\n{\n    pid_t pid = 0;\n    int fd = -1;\n\n    if (!virFileExists(path))\n        return 0;\n\n    if (virPidFileReadPath(path, &pid) < 0)\n        return -1;\n\n    fd = virPidFileAcquirePath(path, false, 0);\n    if (fd < 0) {\n        virResetLastError();\n\n        /* Only kill the process if the pid is valid one.  0 means\n         * there is somebody else doing the same pidfile cleanup\n         * machinery. */\n        if (pid)\n            virProcessKillPainfully(pid, true);\n\n        if (virPidFileDeletePath(path) < 0)\n            return -1;\n    }\n\n    if (fd)\n        virPidFileReleasePath(path, fd);\n\n    return 0;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirPidFileForceCleanupPath(const char *path)\n{\n    pid_t pid = 0;\n    int fd = -1;\n\n    if (!virFileExists(path))\n        return 0;\n\n    if (virPidFileReadPath(path, &pid) < 0)\n        return -1;\n\n    fd = virPidFileAcquirePath(path, false, 0);\n    if (fd < 0) {\n        virResetLastError();\n\n        /* Only kill the process if the pid is valid one.  0 means\n         * there is somebody else doing the same pidfile cleanup\n         * machinery. */\n        if (pid)\n            virProcessKillPainfully(pid, true);\n\n        if (virPidFileDeletePath(path) < 0)\n            return -1;\n    }\n\n    if (fd)\n        virPidFileReleasePath(path, fd);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&orig_err"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to construct vhost-user-gpu pidfile path\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuVhostUserGPUCreatePidFilename",
          "args": [
            "cfg->stateDir",
            "shortname",
            "video->info.alias"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "qemuVhostUserGPUCreatePidFilename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_vhost_user_gpu.c",
          "lines": "42-52",
          "snippet": "static char *\nqemuVhostUserGPUCreatePidFilename(const char *stateDir,\n                                  const char *shortName,\n                                  const char *alias)\n{\n    g_autofree char *devicename = NULL;\n\n    devicename = g_strdup_printf(\"%s-%s-vhost-user-gpu\", shortName, alias);\n\n    return virPidFileBuildPath(stateDir, devicename);\n}",
          "includes": [
            "#include \"virpidfile.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_vhost_user_gpu.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include <config.h>\n\nstatic char *\nqemuVhostUserGPUCreatePidFilename(const char *stateDir,\n                                  const char *shortName,\n                                  const char *alias)\n{\n    g_autofree char *devicename = NULL;\n\n    devicename = g_strdup_printf(\"%s-%s-vhost-user-gpu\", shortName, alias);\n\n    return virPidFileBuildPath(stateDir, devicename);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetShortName",
          "args": [
            "vm->def"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetShortName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30900-30952",
          "snippet": "char *\nvirDomainDefGetShortName(const virDomainDef *def)\n{\n    wchar_t wshortname[VIR_DOMAIN_SHORT_NAME_MAX + 1] = {0};\n    size_t len = 0;\n    char *ret = NULL;\n    g_autofree char *shortname = NULL;\n\n    /* No need to do the whole conversion thing when there are no multibyte\n     * characters.  The same applies for illegal sequences as they can occur\n     * with incompatible locales. */\n    len = mbstowcs(NULL, def->name, 0);\n    if ((len == (size_t) -1 && errno == EILSEQ) ||\n        len == strlen(def->name)) {\n        ret = g_strdup_printf(\"%d-%.*s\", def->id, VIR_DOMAIN_SHORT_NAME_MAX, def->name);\n        return ret;\n    }\n\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    if (mbstowcs(wshortname, def->name, VIR_DOMAIN_SHORT_NAME_MAX) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    len = wcstombs(NULL, wshortname, 0);\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    if (VIR_ALLOC_N(shortname, len + 1) < 0)\n        return NULL;\n\n    if (wcstombs(shortname, wshortname, len) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%d-%s\", def->id, shortname);\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_SHORT_NAME_MAX 20"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_SHORT_NAME_MAX 20\n\nchar *\nvirDomainDefGetShortName(const virDomainDef *def)\n{\n    wchar_t wshortname[VIR_DOMAIN_SHORT_NAME_MAX + 1] = {0};\n    size_t len = 0;\n    char *ret = NULL;\n    g_autofree char *shortname = NULL;\n\n    /* No need to do the whole conversion thing when there are no multibyte\n     * characters.  The same applies for illegal sequences as they can occur\n     * with incompatible locales. */\n    len = mbstowcs(NULL, def->name, 0);\n    if ((len == (size_t) -1 && errno == EILSEQ) ||\n        len == strlen(def->name)) {\n        ret = g_strdup_printf(\"%d-%.*s\", def->id, VIR_DOMAIN_SHORT_NAME_MAX, def->name);\n        return ret;\n    }\n\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    if (mbstowcs(wshortname, def->name, VIR_DOMAIN_SHORT_NAME_MAX) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    len = wcstombs(NULL, wshortname, 0);\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    if (VIR_ALLOC_N(shortname, len + 1) < 0)\n        return NULL;\n\n    if (wcstombs(shortname, wshortname, len) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%d-%s\", def->id, shortname);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include <config.h>\n\nvoid qemuExtVhostUserGPUStop(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             virDomainVideoDefPtr video)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *pidfile = NULL;\n    g_autofree char *shortname = NULL;\n    virErrorPtr orig_err;\n\n    shortname = virDomainDefGetShortName(vm->def);\n    if (!(pidfile = qemuVhostUserGPUCreatePidFilename(\n              cfg->stateDir, shortname, video->info.alias))) {\n        VIR_WARN(\"Unable to construct vhost-user-gpu pidfile path\");\n        return;\n    }\n\n    virErrorPreserveLast(&orig_err);\n    if (virPidFileForceCleanupPath(pidfile) < 0)\n        VIR_WARN(\"Unable to kill vhost-user-gpu process\");\n    virErrorRestore(&orig_err);\n}"
  },
  {
    "function_name": "qemuExtVhostUserGPUStart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_vhost_user_gpu.c",
    "lines": "104-195",
    "snippet": "int qemuExtVhostUserGPUStart(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             virDomainVideoDefPtr video)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *shortname = NULL;\n    g_autofree char *pidfile = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    int pair[2] = { -1, -1 };\n    int cmdret = 0, rc;\n    int exitstatus = 0;\n    pid_t pid;\n    int ret = -1;\n\n    shortname = virDomainDefGetShortName(vm->def);\n    if (!shortname)\n        goto error;\n\n    /* stop any left-over for this VM */\n    qemuExtVhostUserGPUStop(driver, vm, video);\n\n    if (!(pidfile = qemuVhostUserGPUCreatePidFilename(\n              cfg->stateDir, shortname, video->info.alias)))\n        goto error;\n\n    if (qemuSecuritySetSocketLabel(driver->securityManager, vm->def) < 0)\n        goto error;\n\n    if (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"failed to create socket\"));\n        goto error;\n    }\n\n    if (qemuSecurityClearSocketLabel(driver->securityManager, vm->def) < 0)\n        goto error;\n\n    cmd = virCommandNew(video->driver->vhost_user_binary);\n    if (!cmd)\n        goto error;\n\n    virCommandClearCaps(cmd);\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandDaemonize(cmd);\n\n    if (qemuExtDeviceLogCommand(driver, vm, cmd, \"vhost-user-gpu\") < 0)\n        goto error;\n\n    virCommandAddArgFormat(cmd, \"--fd=%d\", pair[0]);\n    virCommandPassFD(cmd, pair[0], VIR_COMMAND_PASS_FD_CLOSE_PARENT);\n    pair[0] = -1;\n\n    if (video->accel) {\n        if (video->accel->accel3d)\n            virCommandAddArg(cmd, \"--virgl\");\n\n        if (video->accel->rendernode)\n            virCommandAddArgFormat(cmd, \"--render-node=%s\", video->accel->rendernode);\n    }\n\n    if (qemuSecurityStartVhostUserGPU(driver, vm, cmd,\n                                      &exitstatus, &cmdret) < 0)\n        goto error;\n\n    if (cmdret < 0 || exitstatus != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not start 'vhost-user-gpu'. exitstatus: %d\"), exitstatus);\n        goto cleanup;\n    }\n\n    rc = virPidFileReadPath(pidfile, &pid);\n    if (rc < 0) {\n        virReportSystemError(-rc,\n                             _(\"Unable to read vhost-user-gpu pidfile '%s'\"),\n                             pidfile);\n        goto cleanup;\n    }\n\n    ret = 0;\n    QEMU_DOMAIN_VIDEO_PRIVATE(video)->vhost_user_fd = pair[1];\n    pair[1] = -1;\n\n cleanup:\n    VIR_FORCE_CLOSE(pair[0]);\n    VIR_FORCE_CLOSE(pair[1]);\n\n    return ret;\n\n error:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"vhost-user-gpu failed to start\"));\n    goto cleanup;\n}",
    "includes": [
      "#include \"virpidfile.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"configmake.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_vhost_user.h\"",
      "#include \"qemu_vhost_user_gpu.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"vhost-user-gpu failed to start\")"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"vhost-user-gpu failed to start\""
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "pair[1]"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "pair[0]"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_VIDEO_PRIVATE",
          "args": [
            "video"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-rc",
            "_(\"Unable to read vhost-user-gpu pidfile '%s'\")",
            "pidfile"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileReadPath",
          "args": [
            "pidfile",
            "&pid"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReadPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "105-145",
          "snippet": "int virPidFileReadPath(const char *path,\n                       pid_t *pid)\n{\n    int fd;\n    int rc;\n    ssize_t bytes;\n    long long pid_value = 0;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n    char *endptr = NULL;\n\n    *pid = 0;\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    bytes = saferead(fd, pidstr, sizeof(pidstr));\n    if (bytes < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n    pidstr[bytes] = '\\0';\n\n    if (virStrToLong_ll(pidstr, &endptr, 10, &pid_value) < 0 ||\n        !(*endptr == '\\0' || g_ascii_isspace(*endptr)) ||\n        (pid_t) pid_value != pid_value) {\n        rc = -EINVAL;\n        goto cleanup;\n    }\n\n    *pid = pid_value;\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadPath(const char *path,\n                       pid_t *pid)\n{\n    int fd;\n    int rc;\n    ssize_t bytes;\n    long long pid_value = 0;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n    char *endptr = NULL;\n\n    *pid = 0;\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    bytes = saferead(fd, pidstr, sizeof(pidstr));\n    if (bytes < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n    pidstr[bytes] = '\\0';\n\n    if (virStrToLong_ll(pidstr, &endptr, 10, &pid_value) < 0 ||\n        !(*endptr == '\\0' || g_ascii_isspace(*endptr)) ||\n        (pid_t) pid_value != pid_value) {\n        rc = -EINVAL;\n        goto cleanup;\n    }\n\n    *pid = pid_value;\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not start 'vhost-user-gpu'. exitstatus: %d\")",
            "exitstatus"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuSecurityStartVhostUserGPU",
          "args": [
            "driver",
            "vm",
            "cmd",
            "&exitstatus",
            "&cmdret"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSecurityStartVhostUserGPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_security.c",
          "lines": "457-479",
          "snippet": "int\nqemuSecurityStartVhostUserGPU(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              virCommandPtr cmd,\n                              int *exitstatus,\n                              int *cmdret)\n{\n    if (virSecurityManagerSetChildProcessLabel(driver->securityManager,\n                                               vm->def, cmd) < 0)\n        return -1;\n\n    if (virSecurityManagerPreFork(driver->securityManager) < 0)\n        return -1;\n\n    *cmdret = virCommandRun(cmd, exitstatus);\n\n    virSecurityManagerPostFork(driver->securityManager);\n\n    if (*cmdret < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"qemu_security.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuSecurityStartVhostUserGPU(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              virCommandPtr cmd,\n                              int *exitstatus,\n                              int *cmdret)\n{\n    if (virSecurityManagerSetChildProcessLabel(driver->securityManager,\n                                               vm->def, cmd) < 0)\n        return -1;\n\n    if (virSecurityManagerPreFork(driver->securityManager) < 0)\n        return -1;\n\n    *cmdret = virCommandRun(cmd, exitstatus);\n\n    virSecurityManagerPostFork(driver->securityManager);\n\n    if (*cmdret < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"--render-node=%s\"",
            "video->accel->rendernode"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "\"--virgl\""
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandPassFD",
          "args": [
            "cmd",
            "pair[0]",
            "VIR_COMMAND_PASS_FD_CLOSE_PARENT"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandPassFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1024-1049",
          "snippet": "void\nvirCommandPassFD(virCommandPtr cmd, int fd, unsigned int flags)\n{\n    int ret = 0;\n\n    if (!cmd) {\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n\n    if (fd <= STDERR_FILENO) {\n        VIR_DEBUG(\"invalid fd %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        if (!cmd->has_error)\n            cmd->has_error = -1;\n        return;\n    }\n\n    if ((ret = virCommandFDSet(cmd, fd, flags)) != 0) {\n        if (!cmd->has_error)\n            cmd->has_error = ret;\n        VIR_DEBUG(\"cannot preserve %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandPassFD(virCommandPtr cmd, int fd, unsigned int flags)\n{\n    int ret = 0;\n\n    if (!cmd) {\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n\n    if (fd <= STDERR_FILENO) {\n        VIR_DEBUG(\"invalid fd %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        if (!cmd->has_error)\n            cmd->has_error = -1;\n        return;\n    }\n\n    if ((ret = virCommandFDSet(cmd, fd, flags)) != 0) {\n        if (!cmd->has_error)\n            cmd->has_error = ret;\n        VIR_DEBUG(\"cannot preserve %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuExtDeviceLogCommand",
          "args": [
            "driver",
            "vm",
            "cmd",
            "\"vhost-user-gpu\""
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "qemuExtDeviceLogCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_extdevice.c",
          "lines": "42-57",
          "snippet": "int\nqemuExtDeviceLogCommand(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        virCommandPtr cmd,\n                        const char *info)\n{\n    g_autofree char *timestamp = virTimeStringNow();\n    g_autofree char *cmds = virCommandToString(cmd, false);\n\n    if (!timestamp || !cmds)\n        return -1;\n\n    return qemuDomainLogAppendMessage(driver, vm,\n                                      _(\"%s: Starting external device: %s\\n%s\\n\"),\n                                      timestamp, info, cmds);\n}",
          "includes": [
            "#include \"virpidfile.h\"",
            "#include \"virtpm.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_virtiofs.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_tpm.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_vhost_user_gpu.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_command.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtpm.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_tpm.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_command.h\"\n#include <config.h>\n\nint\nqemuExtDeviceLogCommand(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        virCommandPtr cmd,\n                        const char *info)\n{\n    g_autofree char *timestamp = virTimeStringNow();\n    g_autofree char *cmds = virCommandToString(cmd, false);\n\n    if (!timestamp || !cmds)\n        return -1;\n\n    return qemuDomainLogAppendMessage(driver, vm,\n                                      _(\"%s: Starting external device: %s\\n%s\\n\"),\n                                      timestamp, info, cmds);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandDaemonize",
          "args": [
            "cmd"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandDaemonize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1263-1270",
          "snippet": "void\nvirCommandDaemonize(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_DAEMON;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandDaemonize(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_DAEMON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetPidFile",
          "args": [
            "cmd",
            "pidfile"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetPidFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1086-1094",
          "snippet": "void\nvirCommandSetPidFile(virCommandPtr cmd, const char *pidfile)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    VIR_FREE(cmd->pidfile);\n    cmd->pidfile = g_strdup(pidfile);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetPidFile(virCommandPtr cmd, const char *pidfile)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    VIR_FREE(cmd->pidfile);\n    cmd->pidfile = g_strdup(pidfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandClearCaps",
          "args": [
            "cmd"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandClearCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1179-1186",
          "snippet": "void\nvirCommandClearCaps(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_CLEAR_CAPS;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandClearCaps(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_CLEAR_CAPS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "video->driver->vhost_user_binary"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuSecurityClearSocketLabel",
          "args": [
            "driver->securityManager",
            "vm->def"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"failed to create socket\")"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0",
            "pair"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuSecuritySetSocketLabel",
          "args": [
            "driver->securityManager",
            "vm->def"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuVhostUserGPUCreatePidFilename",
          "args": [
            "cfg->stateDir",
            "shortname",
            "video->info.alias"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "qemuVhostUserGPUCreatePidFilename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_vhost_user_gpu.c",
          "lines": "42-52",
          "snippet": "static char *\nqemuVhostUserGPUCreatePidFilename(const char *stateDir,\n                                  const char *shortName,\n                                  const char *alias)\n{\n    g_autofree char *devicename = NULL;\n\n    devicename = g_strdup_printf(\"%s-%s-vhost-user-gpu\", shortName, alias);\n\n    return virPidFileBuildPath(stateDir, devicename);\n}",
          "includes": [
            "#include \"virpidfile.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_vhost_user_gpu.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include <config.h>\n\nstatic char *\nqemuVhostUserGPUCreatePidFilename(const char *stateDir,\n                                  const char *shortName,\n                                  const char *alias)\n{\n    g_autofree char *devicename = NULL;\n\n    devicename = g_strdup_printf(\"%s-%s-vhost-user-gpu\", shortName, alias);\n\n    return virPidFileBuildPath(stateDir, devicename);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuExtVhostUserGPUStop",
          "args": [
            "driver",
            "vm",
            "video"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "qemuExtVhostUserGPUStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_vhost_user_gpu.c",
          "lines": "208-228",
          "snippet": "void qemuExtVhostUserGPUStop(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             virDomainVideoDefPtr video)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *pidfile = NULL;\n    g_autofree char *shortname = NULL;\n    virErrorPtr orig_err;\n\n    shortname = virDomainDefGetShortName(vm->def);\n    if (!(pidfile = qemuVhostUserGPUCreatePidFilename(\n              cfg->stateDir, shortname, video->info.alias))) {\n        VIR_WARN(\"Unable to construct vhost-user-gpu pidfile path\");\n        return;\n    }\n\n    virErrorPreserveLast(&orig_err);\n    if (virPidFileForceCleanupPath(pidfile) < 0)\n        VIR_WARN(\"Unable to kill vhost-user-gpu process\");\n    virErrorRestore(&orig_err);\n}",
          "includes": [
            "#include \"virpidfile.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_vhost_user_gpu.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include <config.h>\n\nvoid qemuExtVhostUserGPUStop(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             virDomainVideoDefPtr video)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *pidfile = NULL;\n    g_autofree char *shortname = NULL;\n    virErrorPtr orig_err;\n\n    shortname = virDomainDefGetShortName(vm->def);\n    if (!(pidfile = qemuVhostUserGPUCreatePidFilename(\n              cfg->stateDir, shortname, video->info.alias))) {\n        VIR_WARN(\"Unable to construct vhost-user-gpu pidfile path\");\n        return;\n    }\n\n    virErrorPreserveLast(&orig_err);\n    if (virPidFileForceCleanupPath(pidfile) < 0)\n        VIR_WARN(\"Unable to kill vhost-user-gpu process\");\n    virErrorRestore(&orig_err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetShortName",
          "args": [
            "vm->def"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetShortName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30900-30952",
          "snippet": "char *\nvirDomainDefGetShortName(const virDomainDef *def)\n{\n    wchar_t wshortname[VIR_DOMAIN_SHORT_NAME_MAX + 1] = {0};\n    size_t len = 0;\n    char *ret = NULL;\n    g_autofree char *shortname = NULL;\n\n    /* No need to do the whole conversion thing when there are no multibyte\n     * characters.  The same applies for illegal sequences as they can occur\n     * with incompatible locales. */\n    len = mbstowcs(NULL, def->name, 0);\n    if ((len == (size_t) -1 && errno == EILSEQ) ||\n        len == strlen(def->name)) {\n        ret = g_strdup_printf(\"%d-%.*s\", def->id, VIR_DOMAIN_SHORT_NAME_MAX, def->name);\n        return ret;\n    }\n\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    if (mbstowcs(wshortname, def->name, VIR_DOMAIN_SHORT_NAME_MAX) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    len = wcstombs(NULL, wshortname, 0);\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    if (VIR_ALLOC_N(shortname, len + 1) < 0)\n        return NULL;\n\n    if (wcstombs(shortname, wshortname, len) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%d-%s\", def->id, shortname);\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_SHORT_NAME_MAX 20"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_SHORT_NAME_MAX 20\n\nchar *\nvirDomainDefGetShortName(const virDomainDef *def)\n{\n    wchar_t wshortname[VIR_DOMAIN_SHORT_NAME_MAX + 1] = {0};\n    size_t len = 0;\n    char *ret = NULL;\n    g_autofree char *shortname = NULL;\n\n    /* No need to do the whole conversion thing when there are no multibyte\n     * characters.  The same applies for illegal sequences as they can occur\n     * with incompatible locales. */\n    len = mbstowcs(NULL, def->name, 0);\n    if ((len == (size_t) -1 && errno == EILSEQ) ||\n        len == strlen(def->name)) {\n        ret = g_strdup_printf(\"%d-%.*s\", def->id, VIR_DOMAIN_SHORT_NAME_MAX, def->name);\n        return ret;\n    }\n\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    if (mbstowcs(wshortname, def->name, VIR_DOMAIN_SHORT_NAME_MAX) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    len = wcstombs(NULL, wshortname, 0);\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    if (VIR_ALLOC_N(shortname, len + 1) < 0)\n        return NULL;\n\n    if (wcstombs(shortname, wshortname, len) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%d-%s\", def->id, shortname);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include <config.h>\n\nint qemuExtVhostUserGPUStart(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             virDomainVideoDefPtr video)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *shortname = NULL;\n    g_autofree char *pidfile = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    int pair[2] = { -1, -1 };\n    int cmdret = 0, rc;\n    int exitstatus = 0;\n    pid_t pid;\n    int ret = -1;\n\n    shortname = virDomainDefGetShortName(vm->def);\n    if (!shortname)\n        goto error;\n\n    /* stop any left-over for this VM */\n    qemuExtVhostUserGPUStop(driver, vm, video);\n\n    if (!(pidfile = qemuVhostUserGPUCreatePidFilename(\n              cfg->stateDir, shortname, video->info.alias)))\n        goto error;\n\n    if (qemuSecuritySetSocketLabel(driver->securityManager, vm->def) < 0)\n        goto error;\n\n    if (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"failed to create socket\"));\n        goto error;\n    }\n\n    if (qemuSecurityClearSocketLabel(driver->securityManager, vm->def) < 0)\n        goto error;\n\n    cmd = virCommandNew(video->driver->vhost_user_binary);\n    if (!cmd)\n        goto error;\n\n    virCommandClearCaps(cmd);\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandDaemonize(cmd);\n\n    if (qemuExtDeviceLogCommand(driver, vm, cmd, \"vhost-user-gpu\") < 0)\n        goto error;\n\n    virCommandAddArgFormat(cmd, \"--fd=%d\", pair[0]);\n    virCommandPassFD(cmd, pair[0], VIR_COMMAND_PASS_FD_CLOSE_PARENT);\n    pair[0] = -1;\n\n    if (video->accel) {\n        if (video->accel->accel3d)\n            virCommandAddArg(cmd, \"--virgl\");\n\n        if (video->accel->rendernode)\n            virCommandAddArgFormat(cmd, \"--render-node=%s\", video->accel->rendernode);\n    }\n\n    if (qemuSecurityStartVhostUserGPU(driver, vm, cmd,\n                                      &exitstatus, &cmdret) < 0)\n        goto error;\n\n    if (cmdret < 0 || exitstatus != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not start 'vhost-user-gpu'. exitstatus: %d\"), exitstatus);\n        goto cleanup;\n    }\n\n    rc = virPidFileReadPath(pidfile, &pid);\n    if (rc < 0) {\n        virReportSystemError(-rc,\n                             _(\"Unable to read vhost-user-gpu pidfile '%s'\"),\n                             pidfile);\n        goto cleanup;\n    }\n\n    ret = 0;\n    QEMU_DOMAIN_VIDEO_PRIVATE(video)->vhost_user_fd = pair[1];\n    pair[1] = -1;\n\n cleanup:\n    VIR_FORCE_CLOSE(pair[0]);\n    VIR_FORCE_CLOSE(pair[1]);\n\n    return ret;\n\n error:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"vhost-user-gpu failed to start\"));\n    goto cleanup;\n}"
  },
  {
    "function_name": "qemuExtVhostUserGPUPrepareDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_vhost_user_gpu.c",
    "lines": "86-90",
    "snippet": "int qemuExtVhostUserGPUPrepareDomain(virQEMUDriverPtr driver,\n                                     virDomainVideoDefPtr video)\n{\n    return qemuVhostUserFillDomainGPU(driver, video);\n}",
    "includes": [
      "#include \"virpidfile.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"configmake.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_vhost_user.h\"",
      "#include \"qemu_vhost_user_gpu.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuVhostUserFillDomainGPU",
          "args": [
            "driver",
            "video"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "qemuVhostUserFillDomainGPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_vhost_user.c",
          "lines": "335-418",
          "snippet": "int\nqemuVhostUserFillDomainGPU(virQEMUDriverPtr driver,\n                           virDomainVideoDefPtr video)\n{\n    qemuVhostUserPtr *vus = NULL;\n    qemuVhostUserPtr vu = NULL;\n    ssize_t nvus = 0;\n    ssize_t i;\n    int ret = -1;\n\n    if ((nvus = qemuVhostUserFetchParsedConfigs(driver->privileged,\n                                                &vus, NULL)) < 0)\n        goto end;\n\n    for (i = 0; i < nvus; i++) {\n        g_autoptr(virJSONValue) doc = NULL;\n        g_autofree char *output = NULL;\n        g_autoptr(virCommand) cmd = NULL;\n\n        vu = vus[i];\n        if (vu->type != QEMU_VHOST_USER_TYPE_GPU)\n            continue;\n\n        cmd = virCommandNewArgList(vu->binary, \"--print-capabilities\", NULL);\n        virCommandSetOutputBuffer(cmd, &output);\n        if (virCommandRun(cmd, NULL) < 0)\n            continue;\n\n        if (!(doc = virJSONValueFromString(output))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse json capabilities '%s'\"),\n                           vu->binary);\n            continue;\n        }\n\n        if (qemuVhostUserGPUFillCapabilities(vu, doc) < 0)\n            continue;\n\n        if (video->accel) {\n            if (video->accel->accel3d &&\n                !qemuVhostUserGPUHasFeature(&vu->capabilities.gpu,\n                                            QEMU_VHOST_USER_GPU_FEATURE_VIRGL))\n                continue;\n\n            if (video->accel->rendernode &&\n                !qemuVhostUserGPUHasFeature(&vu->capabilities.gpu,\n                                            QEMU_VHOST_USER_GPU_FEATURE_RENDER_NODE))\n                continue;\n        }\n\n        if (!video->driver && VIR_ALLOC(video->driver) < 0)\n            goto end;\n\n        VIR_FREE(video->driver->vhost_user_binary);\n        video->driver->vhost_user_binary = g_strdup(vu->binary);\n\n        break;\n    }\n\n    if (i == nvus) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Unable to find a satisfying vhost-user-gpu\"));\n        goto end;\n    }\n\n    if (!video->accel && VIR_ALLOC(video->accel) < 0)\n        goto end;\n\n    if (!video->accel->rendernode &&\n        qemuVhostUserGPUHasFeature(&vu->capabilities.gpu,\n                                   QEMU_VHOST_USER_GPU_FEATURE_RENDER_NODE)) {\n        video->accel->rendernode = virHostGetDRMRenderNode();\n        if (!video->accel->rendernode)\n            goto end;\n    }\n\n    ret = 0;\n\n end:\n    for (i = 0; i < nvus; i++)\n        qemuVhostUserFree(vus[i]);\n    VIR_FREE(vus);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_vhost_user.h\"\n#include <config.h>\n\nint\nqemuVhostUserFillDomainGPU(virQEMUDriverPtr driver,\n                           virDomainVideoDefPtr video)\n{\n    qemuVhostUserPtr *vus = NULL;\n    qemuVhostUserPtr vu = NULL;\n    ssize_t nvus = 0;\n    ssize_t i;\n    int ret = -1;\n\n    if ((nvus = qemuVhostUserFetchParsedConfigs(driver->privileged,\n                                                &vus, NULL)) < 0)\n        goto end;\n\n    for (i = 0; i < nvus; i++) {\n        g_autoptr(virJSONValue) doc = NULL;\n        g_autofree char *output = NULL;\n        g_autoptr(virCommand) cmd = NULL;\n\n        vu = vus[i];\n        if (vu->type != QEMU_VHOST_USER_TYPE_GPU)\n            continue;\n\n        cmd = virCommandNewArgList(vu->binary, \"--print-capabilities\", NULL);\n        virCommandSetOutputBuffer(cmd, &output);\n        if (virCommandRun(cmd, NULL) < 0)\n            continue;\n\n        if (!(doc = virJSONValueFromString(output))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse json capabilities '%s'\"),\n                           vu->binary);\n            continue;\n        }\n\n        if (qemuVhostUserGPUFillCapabilities(vu, doc) < 0)\n            continue;\n\n        if (video->accel) {\n            if (video->accel->accel3d &&\n                !qemuVhostUserGPUHasFeature(&vu->capabilities.gpu,\n                                            QEMU_VHOST_USER_GPU_FEATURE_VIRGL))\n                continue;\n\n            if (video->accel->rendernode &&\n                !qemuVhostUserGPUHasFeature(&vu->capabilities.gpu,\n                                            QEMU_VHOST_USER_GPU_FEATURE_RENDER_NODE))\n                continue;\n        }\n\n        if (!video->driver && VIR_ALLOC(video->driver) < 0)\n            goto end;\n\n        VIR_FREE(video->driver->vhost_user_binary);\n        video->driver->vhost_user_binary = g_strdup(vu->binary);\n\n        break;\n    }\n\n    if (i == nvus) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Unable to find a satisfying vhost-user-gpu\"));\n        goto end;\n    }\n\n    if (!video->accel && VIR_ALLOC(video->accel) < 0)\n        goto end;\n\n    if (!video->accel->rendernode &&\n        qemuVhostUserGPUHasFeature(&vu->capabilities.gpu,\n                                   QEMU_VHOST_USER_GPU_FEATURE_RENDER_NODE)) {\n        video->accel->rendernode = virHostGetDRMRenderNode();\n        if (!video->accel->rendernode)\n            goto end;\n    }\n\n    ret = 0;\n\n end:\n    for (i = 0; i < nvus; i++)\n        qemuVhostUserFree(vus[i]);\n    VIR_FREE(vus);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include <config.h>\n\nint qemuExtVhostUserGPUPrepareDomain(virQEMUDriverPtr driver,\n                                     virDomainVideoDefPtr video)\n{\n    return qemuVhostUserFillDomainGPU(driver, video);\n}"
  },
  {
    "function_name": "qemuVhostUserGPUGetPid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_vhost_user_gpu.c",
    "lines": "67-83",
    "snippet": "static int\nqemuVhostUserGPUGetPid(const char *binPath,\n                       const char *stateDir,\n                       const char *shortName,\n                       const char *alias,\n                       pid_t *pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (!(pidfile = qemuVhostUserGPUCreatePidFilename(stateDir, shortName, alias)))\n        return -1;\n\n    if (virPidFileReadPathIfAlive(pidfile, pid, binPath) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virpidfile.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"configmake.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_vhost_user.h\"",
      "#include \"qemu_vhost_user_gpu.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPidFileReadPathIfAlive",
          "args": [
            "pidfile",
            "pid",
            "binPath"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReadPathIfAlive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "187-264",
          "snippet": "int virPidFileReadPathIfAlive(const char *path,\n                              pid_t *pid,\n                              const char *binPath)\n{\n    int rc;\n    bool isLink = false;\n    size_t procLinkLen;\n    const char deletedText[] = \" (deleted)\";\n    size_t deletedTextLen = strlen(deletedText);\n    pid_t retPid;\n    g_autofree char *procPath = NULL;\n    g_autofree char *procLink = NULL;\n    g_autofree char *resolvedBinPath = NULL;\n    g_autofree char *resolvedProcLink = NULL;\n\n    /* only set this at the very end on success */\n    *pid = -1;\n\n    if (virPidFileReadPath(path, &retPid) < 0)\n        return -1;\n\n#ifndef WIN32\n    /* Check that it's still alive.  Safe to skip this sanity check on\n     * mingw, which lacks kill().  */\n    if (kill(retPid, 0) < 0) {\n        *pid = -1;\n        return 0;\n    }\n#endif\n\n    if (!binPath) {\n        /* we only knew the pid, and that pid is alive, so we can\n         * return it.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    procPath = g_strdup_printf(\"/proc/%lld/exe\", (long long)retPid);\n\n    if ((rc = virFileIsLink(procPath)) < 0)\n        return -1;\n\n    if (rc == 1)\n        isLink = true;\n\n    if (isLink && virFileLinkPointsTo(procPath, binPath)) {\n        /* the link in /proc/$pid/exe is a symlink to a file\n         * that has the same inode as the file at binpath.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    /* Even if virFileLinkPointsTo returns a mismatch, it could be\n     * that the binary was deleted/replaced after it was executed. In\n     * that case the link in /proc/$pid/exe will contain\n     * \"$procpath (deleted)\".  Read that link, remove the \" (deleted)\"\n     * part, and see if it has the same canonicalized name as binpath.\n     */\n    if (!(procLink = g_file_read_link(procPath, NULL)))\n        return -1;\n\n    procLinkLen = strlen(procLink);\n    if (procLinkLen > deletedTextLen)\n        procLink[procLinkLen - deletedTextLen] = 0;\n\n    if (virFileResolveAllLinks(binPath, &resolvedBinPath) < 0)\n        return -1;\n    if (virFileResolveAllLinks(procLink, &resolvedProcLink) < 0)\n        return -1;\n\n    if (STRNEQ(resolvedBinPath, resolvedProcLink))\n        return -1;\n\n    *pid = retPid;\n    return 0;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadPathIfAlive(const char *path,\n                              pid_t *pid,\n                              const char *binPath)\n{\n    int rc;\n    bool isLink = false;\n    size_t procLinkLen;\n    const char deletedText[] = \" (deleted)\";\n    size_t deletedTextLen = strlen(deletedText);\n    pid_t retPid;\n    g_autofree char *procPath = NULL;\n    g_autofree char *procLink = NULL;\n    g_autofree char *resolvedBinPath = NULL;\n    g_autofree char *resolvedProcLink = NULL;\n\n    /* only set this at the very end on success */\n    *pid = -1;\n\n    if (virPidFileReadPath(path, &retPid) < 0)\n        return -1;\n\n#ifndef WIN32\n    /* Check that it's still alive.  Safe to skip this sanity check on\n     * mingw, which lacks kill().  */\n    if (kill(retPid, 0) < 0) {\n        *pid = -1;\n        return 0;\n    }\n#endif\n\n    if (!binPath) {\n        /* we only knew the pid, and that pid is alive, so we can\n         * return it.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    procPath = g_strdup_printf(\"/proc/%lld/exe\", (long long)retPid);\n\n    if ((rc = virFileIsLink(procPath)) < 0)\n        return -1;\n\n    if (rc == 1)\n        isLink = true;\n\n    if (isLink && virFileLinkPointsTo(procPath, binPath)) {\n        /* the link in /proc/$pid/exe is a symlink to a file\n         * that has the same inode as the file at binpath.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    /* Even if virFileLinkPointsTo returns a mismatch, it could be\n     * that the binary was deleted/replaced after it was executed. In\n     * that case the link in /proc/$pid/exe will contain\n     * \"$procpath (deleted)\".  Read that link, remove the \" (deleted)\"\n     * part, and see if it has the same canonicalized name as binpath.\n     */\n    if (!(procLink = g_file_read_link(procPath, NULL)))\n        return -1;\n\n    procLinkLen = strlen(procLink);\n    if (procLinkLen > deletedTextLen)\n        procLink[procLinkLen - deletedTextLen] = 0;\n\n    if (virFileResolveAllLinks(binPath, &resolvedBinPath) < 0)\n        return -1;\n    if (virFileResolveAllLinks(procLink, &resolvedProcLink) < 0)\n        return -1;\n\n    if (STRNEQ(resolvedBinPath, resolvedProcLink))\n        return -1;\n\n    *pid = retPid;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuVhostUserGPUCreatePidFilename",
          "args": [
            "stateDir",
            "shortName",
            "alias"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "qemuVhostUserGPUCreatePidFilename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_vhost_user_gpu.c",
          "lines": "42-52",
          "snippet": "static char *\nqemuVhostUserGPUCreatePidFilename(const char *stateDir,\n                                  const char *shortName,\n                                  const char *alias)\n{\n    g_autofree char *devicename = NULL;\n\n    devicename = g_strdup_printf(\"%s-%s-vhost-user-gpu\", shortName, alias);\n\n    return virPidFileBuildPath(stateDir, devicename);\n}",
          "includes": [
            "#include \"virpidfile.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_vhost_user_gpu.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include <config.h>\n\nstatic char *\nqemuVhostUserGPUCreatePidFilename(const char *stateDir,\n                                  const char *shortName,\n                                  const char *alias)\n{\n    g_autofree char *devicename = NULL;\n\n    devicename = g_strdup_printf(\"%s-%s-vhost-user-gpu\", shortName, alias);\n\n    return virPidFileBuildPath(stateDir, devicename);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include <config.h>\n\nstatic int\nqemuVhostUserGPUGetPid(const char *binPath,\n                       const char *stateDir,\n                       const char *shortName,\n                       const char *alias,\n                       pid_t *pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (!(pidfile = qemuVhostUserGPUCreatePidFilename(stateDir, shortName, alias)))\n        return -1;\n\n    if (virPidFileReadPathIfAlive(pidfile, pid, binPath) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuVhostUserGPUCreatePidFilename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_vhost_user_gpu.c",
    "lines": "42-52",
    "snippet": "static char *\nqemuVhostUserGPUCreatePidFilename(const char *stateDir,\n                                  const char *shortName,\n                                  const char *alias)\n{\n    g_autofree char *devicename = NULL;\n\n    devicename = g_strdup_printf(\"%s-%s-vhost-user-gpu\", shortName, alias);\n\n    return virPidFileBuildPath(stateDir, devicename);\n}",
    "includes": [
      "#include \"virpidfile.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"configmake.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_vhost_user.h\"",
      "#include \"qemu_vhost_user_gpu.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPidFileBuildPath",
          "args": [
            "stateDir",
            "devicename"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileBuildPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "43-51",
          "snippet": "char *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s-%s-vhost-user-gpu\"",
            "shortName",
            "alias"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include <config.h>\n\nstatic char *\nqemuVhostUserGPUCreatePidFilename(const char *stateDir,\n                                  const char *shortName,\n                                  const char *alias)\n{\n    g_autofree char *devicename = NULL;\n\n    devicename = g_strdup_printf(\"%s-%s-vhost-user-gpu\", shortName, alias);\n\n    return virPidFileBuildPath(stateDir, devicename);\n}"
  }
]