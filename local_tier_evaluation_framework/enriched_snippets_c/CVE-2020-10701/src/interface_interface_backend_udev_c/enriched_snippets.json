[
  {
    "function_name": "udevIfaceRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "1308-1321",
    "snippet": "int\nudevIfaceRegister(void)\n{\n    if (virRegisterConnectDriver(&udevConnectDriver, false) < 0)\n        return -1;\n    if (virSetSharedInterfaceDriver(&udevIfaceDriver) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to register udev interface driver\"));\n        return -1;\n    }\n    if (virRegisterStateDriver(&interfaceStateDriver) < 0)\n        return -1;\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct udev_iface_driver *driver;",
      "static virInterfaceDriver udevIfaceDriver = {\n    .name = \"udev\",\n    .connectNumOfInterfaces = udevConnectNumOfInterfaces, /* 1.0.0 */\n    .connectListInterfaces = udevConnectListInterfaces, /* 1.0.0 */\n    .connectNumOfDefinedInterfaces = udevConnectNumOfDefinedInterfaces, /* 1.0.0 */\n    .connectListDefinedInterfaces = udevConnectListDefinedInterfaces, /* 1.0.0 */\n    .connectListAllInterfaces = udevConnectListAllInterfaces, /* 1.0.0 */\n    .interfaceLookupByName = udevInterfaceLookupByName, /* 1.0.0 */\n    .interfaceLookupByMACString = udevInterfaceLookupByMACString, /* 1.0.0 */\n    .interfaceIsActive = udevInterfaceIsActive, /* 1.0.0 */\n    .interfaceGetXMLDesc = udevInterfaceGetXMLDesc, /* 1.0.0 */\n};",
      "static virConnectDriver udevConnectDriver = {\n    .localOnly = true,\n    .uriSchemes = (const char *[]){ \"interface\", NULL },\n    .hypervisorDriver = &udevHypervisorDriver,\n    .interfaceDriver = &udevIfaceDriver,\n};",
      "static virStateDriver interfaceStateDriver = {\n    .name = \"udev\",\n    .stateInitialize = udevStateInitialize,\n    .stateCleanup = udevStateCleanup,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virRegisterStateDriver",
          "args": [
            "&interfaceStateDriver"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "virRegisterStateDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "588-602",
          "snippet": "int\nvirRegisterStateDriver(virStateDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virStateDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->name);\n        return -1;\n    }\n\n    virStateDriverTab[virStateDriverTabCount] = driver;\n    return virStateDriverTabCount++;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_DRIVERS 21"
          ],
          "globals_used": [
            "static virStateDriverPtr virStateDriverTab[MAX_DRIVERS];",
            "static int virStateDriverTabCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define MAX_DRIVERS 21\n\nstatic virStateDriverPtr virStateDriverTab[MAX_DRIVERS];\nstatic int virStateDriverTabCount;\n\nint\nvirRegisterStateDriver(virStateDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virStateDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->name);\n        return -1;\n    }\n\n    virStateDriverTab[virStateDriverTabCount] = driver;\n    return virStateDriverTabCount++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to register udev interface driver\")"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to register udev interface driver\""
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "968-1074",
          "snippet": "static virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include <libudev.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetSharedInterfaceDriver",
          "args": [
            "&udevIfaceDriver"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "virSetSharedInterfaceDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "383-398",
          "snippet": "int\nvirSetSharedInterfaceDriver(virInterfaceDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedInterfaceDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A interface driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as interface driver\", driver->name);\n\n    virSharedInterfaceDriver = driver;\n    return 0;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virInterfaceDriverPtr virSharedInterfaceDriver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virInterfaceDriverPtr virSharedInterfaceDriver;\n\nint\nvirSetSharedInterfaceDriver(virInterfaceDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedInterfaceDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A interface driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as interface driver\", driver->name);\n\n    virSharedInterfaceDriver = driver;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virRegisterConnectDriver",
          "args": [
            "&udevConnectDriver",
            "false"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "virRegisterConnectDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "515-550",
          "snippet": "int\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_DRIVERS 21"
          ],
          "globals_used": [
            "static virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];",
            "static int virConnectDriverTabCount;",
            "static virNetworkDriverPtr virSharedNetworkDriver;",
            "static virInterfaceDriverPtr virSharedInterfaceDriver;",
            "static virStorageDriverPtr virSharedStorageDriver;",
            "static virNodeDeviceDriverPtr virSharedNodeDeviceDriver;",
            "static virSecretDriverPtr virSharedSecretDriver;",
            "static virNWFilterDriverPtr virSharedNWFilterDriver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define MAX_DRIVERS 21\n\nstatic virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];\nstatic int virConnectDriverTabCount;\nstatic virNetworkDriverPtr virSharedNetworkDriver;\nstatic virInterfaceDriverPtr virSharedInterfaceDriver;\nstatic virStorageDriverPtr virSharedStorageDriver;\nstatic virNodeDeviceDriverPtr virSharedNodeDeviceDriver;\nstatic virSecretDriverPtr virSharedSecretDriver;\nstatic virNWFilterDriverPtr virSharedNWFilterDriver;\n\nint\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic struct udev_iface_driver *driver;\nstatic virInterfaceDriver udevIfaceDriver = {\n    .name = \"udev\",\n    .connectNumOfInterfaces = udevConnectNumOfInterfaces, /* 1.0.0 */\n    .connectListInterfaces = udevConnectListInterfaces, /* 1.0.0 */\n    .connectNumOfDefinedInterfaces = udevConnectNumOfDefinedInterfaces, /* 1.0.0 */\n    .connectListDefinedInterfaces = udevConnectListDefinedInterfaces, /* 1.0.0 */\n    .connectListAllInterfaces = udevConnectListAllInterfaces, /* 1.0.0 */\n    .interfaceLookupByName = udevInterfaceLookupByName, /* 1.0.0 */\n    .interfaceLookupByMACString = udevInterfaceLookupByMACString, /* 1.0.0 */\n    .interfaceIsActive = udevInterfaceIsActive, /* 1.0.0 */\n    .interfaceGetXMLDesc = udevInterfaceGetXMLDesc, /* 1.0.0 */\n};\nstatic virConnectDriver udevConnectDriver = {\n    .localOnly = true,\n    .uriSchemes = (const char *[]){ \"interface\", NULL },\n    .hypervisorDriver = &udevHypervisorDriver,\n    .interfaceDriver = &udevIfaceDriver,\n};\nstatic virStateDriver interfaceStateDriver = {\n    .name = \"udev\",\n    .stateInitialize = udevStateInitialize,\n    .stateCleanup = udevStateCleanup,\n};\n\nint\nudevIfaceRegister(void)\n{\n    if (virRegisterConnectDriver(&udevConnectDriver, false) < 0)\n        return -1;\n    if (virSetSharedInterfaceDriver(&udevIfaceDriver) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to register udev interface driver\"));\n        return -1;\n    }\n    if (virRegisterStateDriver(&interfaceStateDriver) < 0)\n        return -1;\n    return 0;\n}"
  },
  {
    "function_name": "udevConnectIsAlive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "1264-1267",
    "snippet": "static int udevConnectIsAlive(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return 1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int udevConnectIsAlive(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return 1;\n}"
  },
  {
    "function_name": "udevConnectIsEncrypted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "1257-1261",
    "snippet": "static int udevConnectIsEncrypted(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* Not encrypted, but remote driver takes care of that */\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct udev_iface_driver *driver;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic struct udev_iface_driver *driver;\n\nstatic int udevConnectIsEncrypted(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* Not encrypted, but remote driver takes care of that */\n    return 0;\n}"
  },
  {
    "function_name": "udevConnectIsSecure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "1250-1254",
    "snippet": "static int udevConnectIsSecure(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* Trivially secure, since always inside the daemon */\n    return 1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int udevConnectIsSecure(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* Trivially secure, since always inside the daemon */\n    return 1;\n}"
  },
  {
    "function_name": "udevConnectClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "1244-1247",
    "snippet": "static int udevConnectClose(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int udevConnectClose(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return 0;\n}"
  },
  {
    "function_name": "udevConnectOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "1219-1242",
    "snippet": "static virDrvOpenStatus\nudevConnectOpen(virConnectPtr conn,\n                virConnectAuthPtr auth G_GNUC_UNUSED,\n                virConfPtr conf G_GNUC_UNUSED,\n                unsigned int flags)\n{\n    virCheckFlags(VIR_CONNECT_RO, VIR_DRV_OPEN_ERROR);\n\n    if (driver == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"interface state driver is not active\"));\n        return VIR_DRV_OPEN_ERROR;\n    }\n\n    if (!virConnectValidateURIPath(conn->uri->path,\n                                   \"interface\",\n                                   driver->privileged))\n        return VIR_DRV_OPEN_ERROR;\n\n    if (virConnectOpenEnsureACL(conn) < 0)\n        return VIR_DRV_OPEN_ERROR;\n\n    return VIR_DRV_OPEN_SUCCESS;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct udev_iface_driver *driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virConnectOpenEnsureACL",
          "args": [
            "conn"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConnectValidateURIPath",
          "args": [
            "conn->uri->path",
            "\"interface\"",
            "driver->privileged"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectValidateURIPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "260-296",
          "snippet": "bool\nvirConnectValidateURIPath(const char *uriPath,\n                          const char *entityName,\n                          bool privileged)\n{\n    if (privileged) {\n        /* TODO: qemu and vbox drivers allow '/session'\n         * connections as root. This is not ideal, but changing\n         * these drivers to refuse privileged '/session'\n         * connections, like everyone else is already doing, can\n         * break existing applications. Until we decide what to do,\n         * for now we can handle them as exception in this validate\n         * function.\n         */\n        bool compatSessionRoot = (STREQ(entityName, \"qemu\") ||\n                                  STREQ(entityName, \"vbox\")) &&\n                                  STREQ(uriPath, \"/session\");\n\n        if (STRNEQ(uriPath, \"/system\") && !compatSessionRoot) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///system\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    } else {\n        if (STRNEQ(uriPath, \"/session\")) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///session\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirConnectValidateURIPath(const char *uriPath,\n                          const char *entityName,\n                          bool privileged)\n{\n    if (privileged) {\n        /* TODO: qemu and vbox drivers allow '/session'\n         * connections as root. This is not ideal, but changing\n         * these drivers to refuse privileged '/session'\n         * connections, like everyone else is already doing, can\n         * break existing applications. Until we decide what to do,\n         * for now we can handle them as exception in this validate\n         * function.\n         */\n        bool compatSessionRoot = (STREQ(entityName, \"qemu\") ||\n                                  STREQ(entityName, \"vbox\")) &&\n                                  STREQ(uriPath, \"/session\");\n\n        if (STRNEQ(uriPath, \"/system\") && !compatSessionRoot) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///system\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    } else {\n        if (STRNEQ(uriPath, \"/session\")) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///session\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"interface state driver is not active\")"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"interface state driver is not active\""
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "968-1074",
          "snippet": "static virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include <libudev.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_CONNECT_RO",
            "VIR_DRV_OPEN_ERROR"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic struct udev_iface_driver *driver;\n\nstatic virDrvOpenStatus\nudevConnectOpen(virConnectPtr conn,\n                virConnectAuthPtr auth G_GNUC_UNUSED,\n                virConfPtr conf G_GNUC_UNUSED,\n                unsigned int flags)\n{\n    virCheckFlags(VIR_CONNECT_RO, VIR_DRV_OPEN_ERROR);\n\n    if (driver == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"interface state driver is not active\"));\n        return VIR_DRV_OPEN_ERROR;\n    }\n\n    if (!virConnectValidateURIPath(conn->uri->path,\n                                   \"interface\",\n                                   driver->privileged))\n        return VIR_DRV_OPEN_ERROR;\n\n    if (virConnectOpenEnsureACL(conn) < 0)\n        return VIR_DRV_OPEN_ERROR;\n\n    return VIR_DRV_OPEN_SUCCESS;\n}"
  },
  {
    "function_name": "udevStateCleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "1201-1216",
    "snippet": "static int\nudevStateCleanup(void)\n{\n    if (!driver)\n        return -1;\n\n    if (driver->udev)\n        udev_unref(driver->udev);\n\n    if (driver->lockFD != -1)\n        virPidFileRelease(driver->stateDir, \"driver\", driver->lockFD);\n\n    VIR_FREE(driver->stateDir);\n    VIR_FREE(driver);\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct udev_iface_driver *driver;",
      "static int\nudevStateCleanup(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver->stateDir"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileRelease",
          "args": [
            "driver->stateDir",
            "\"driver\"",
            "driver->lockFD"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "453-466",
          "snippet": "int virPidFileRelease(const char *dir,\n                      const char *name,\n                      int fd)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileReleasePath(pidfile, fd);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileRelease(const char *dir,\n                      const char *name,\n                      int fd)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileReleasePath(pidfile, fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_unref",
          "args": [
            "driver->udev"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic struct udev_iface_driver *driver;\nstatic int\nudevStateCleanup(void);\n\nstatic int\nudevStateCleanup(void)\n{\n    if (!driver)\n        return -1;\n\n    if (driver->udev)\n        udev_unref(driver->udev);\n\n    if (driver->lockFD != -1)\n        virPidFileRelease(driver->stateDir, \"driver\", driver->lockFD);\n\n    VIR_FREE(driver->stateDir);\n    VIR_FREE(driver);\n    return 0;\n}"
  },
  {
    "function_name": "udevStateInitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "1147-1199",
    "snippet": "static int\nudevStateInitialize(bool privileged,\n                    const char *root,\n                    virStateInhibitCallback callback G_GNUC_UNUSED,\n                    void *opaque G_GNUC_UNUSED)\n{\n    int ret = VIR_DRV_STATE_INIT_ERROR;\n\n    if (root != NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Driver does not support embedded mode\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(driver) < 0)\n        goto cleanup;\n\n    driver->lockFD = -1;\n\n    if (privileged) {\n        driver->stateDir = g_strdup_printf(\"%s/libvirt/interface\", RUNSTATEDIR);\n    } else {\n        g_autofree char *rundir = NULL;\n\n        rundir = virGetUserRuntimeDirectory();\n        driver->stateDir = g_strdup_printf(\"%s/interface/run\", rundir);\n    }\n\n    if (virFileMakePathWithMode(driver->stateDir, S_IRWXU) < 0) {\n        virReportSystemError(errno, _(\"cannot create state directory '%s'\"),\n                             driver->stateDir);\n        goto cleanup;\n    }\n\n    if ((driver->lockFD =\n         virPidFileAcquire(driver->stateDir, \"driver\", false, getpid())) < 0)\n        goto cleanup;\n\n    driver->udev = udev_new();\n    if (!driver->udev) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to create udev context\"));\n        goto cleanup;\n    }\n    driver->privileged = privileged;\n\n    ret = VIR_DRV_STATE_INIT_COMPLETE;\n\n cleanup:\n    if (ret < 0)\n        udevStateCleanup();\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct udev_iface_driver *driver;",
      "static int\nudevStateCleanup(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevStateCleanup",
          "args": [],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "udevStateCleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "1201-1216",
          "snippet": "static int\nudevStateCleanup(void)\n{\n    if (!driver)\n        return -1;\n\n    if (driver->udev)\n        udev_unref(driver->udev);\n\n    if (driver->lockFD != -1)\n        virPidFileRelease(driver->stateDir, \"driver\", driver->lockFD);\n\n    VIR_FREE(driver->stateDir);\n    VIR_FREE(driver);\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include <libudev.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct udev_iface_driver *driver;",
            "static int\nudevStateCleanup(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic struct udev_iface_driver *driver;\nstatic int\nudevStateCleanup(void);\n\nstatic int\nudevStateCleanup(void)\n{\n    if (!driver)\n        return -1;\n\n    if (driver->udev)\n        udev_unref(driver->udev);\n\n    if (driver->lockFD != -1)\n        virPidFileRelease(driver->stateDir, \"driver\", driver->lockFD);\n\n    VIR_FREE(driver->stateDir);\n    VIR_FREE(driver);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to create udev context\")"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to create udev context\""
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "968-1074",
          "snippet": "static virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include <libudev.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_new",
          "args": [],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileAcquire",
          "args": [
            "driver->stateDir",
            "\"driver\"",
            "false",
            "getpid()"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileAcquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "413-427",
          "snippet": "int virPidFileAcquire(const char *dir,\n                      const char *name,\n                      bool waitForLock,\n                      pid_t pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileAcquirePath(pidfile, waitForLock, pid);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileAcquire(const char *dir,\n                      const char *name,\n                      bool waitForLock,\n                      pid_t pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileAcquirePath(pidfile, waitForLock, pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot create state directory '%s'\")",
            "driver->stateDir"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileMakePathWithMode",
          "args": [
            "driver->stateDir",
            "S_IRWXU"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePathWithMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3082-3091",
          "snippet": "int\nvirFileMakePathWithMode(const char *path,\n                        mode_t mode)\n{\n    g_autofree char *tmp = NULL;\n\n    tmp = g_strdup(path);\n\n    return virFileMakePathHelper(tmp, mode);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePathWithMode(const char *path,\n                        mode_t mode)\n{\n    g_autofree char *tmp = NULL;\n\n    tmp = g_strdup(path);\n\n    return virFileMakePathHelper(tmp, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/interface/run\"",
            "rundir"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetUserRuntimeDirectory",
          "args": [],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserRuntimeDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "594-601",
          "snippet": "char *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "driver"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Driver does not support embedded mode\")"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic struct udev_iface_driver *driver;\nstatic int\nudevStateCleanup(void);\n\nstatic int\nudevStateInitialize(bool privileged,\n                    const char *root,\n                    virStateInhibitCallback callback G_GNUC_UNUSED,\n                    void *opaque G_GNUC_UNUSED)\n{\n    int ret = VIR_DRV_STATE_INIT_ERROR;\n\n    if (root != NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Driver does not support embedded mode\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(driver) < 0)\n        goto cleanup;\n\n    driver->lockFD = -1;\n\n    if (privileged) {\n        driver->stateDir = g_strdup_printf(\"%s/libvirt/interface\", RUNSTATEDIR);\n    } else {\n        g_autofree char *rundir = NULL;\n\n        rundir = virGetUserRuntimeDirectory();\n        driver->stateDir = g_strdup_printf(\"%s/interface/run\", rundir);\n    }\n\n    if (virFileMakePathWithMode(driver->stateDir, S_IRWXU) < 0) {\n        virReportSystemError(errno, _(\"cannot create state directory '%s'\"),\n                             driver->stateDir);\n        goto cleanup;\n    }\n\n    if ((driver->lockFD =\n         virPidFileAcquire(driver->stateDir, \"driver\", false, getpid())) < 0)\n        goto cleanup;\n\n    driver->udev = udev_new();\n    if (!driver->udev) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to create udev context\"));\n        goto cleanup;\n    }\n    driver->privileged = privileged;\n\n    ret = VIR_DRV_STATE_INIT_COMPLETE;\n\n cleanup:\n    if (ret < 0)\n        udevStateCleanup();\n    return ret;\n}"
  },
  {
    "function_name": "udevInterfaceIsActive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "1108-1141",
    "snippet": "static int\nudevInterfaceIsActive(virInterfacePtr ifinfo)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    struct udev_device *dev;\n    virInterfaceDefPtr def = NULL;\n    int status = -1;\n\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\",\n                                                 ifinfo->name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"),\n                       ifinfo->name);\n        goto cleanup;\n    }\n\n    if (!(def = udevGetMinimalDefForDevice(dev)))\n        goto cleanup;\n\n    if (virInterfaceIsActiveEnsureACL(ifinfo->conn, def) < 0)\n       goto cleanup;\n\n    /* Check if it's active or not */\n    status = STREQ(udev_device_get_sysattr_value(dev, \"operstate\"), \"up\");\n\n    udev_device_unref(dev);\n\n cleanup:\n    udev_unref(udev);\n    virInterfaceDefFree(def);\n\n    return status;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct udev_iface_driver *driver;",
      "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "def"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_unref",
          "args": [
            "udev"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_unref",
          "args": [
            "dev"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "udev_device_get_sysattr_value(dev, \"operstate\")",
            "\"up\""
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "dev",
            "\"operstate\""
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceIsActiveEnsureACL",
          "args": [
            "ifinfo->conn",
            "def"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetMinimalDefForDevice",
          "args": [
            "dev"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_INTERFACE",
            "_(\"couldn't find interface named '%s'\")",
            "ifinfo->name"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"couldn't find interface named '%s'\""
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "968-1074",
          "snippet": "static virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include <libudev.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_new_from_subsystem_sysname",
          "args": [
            "udev",
            "\"net\"",
            "ifinfo->name"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_ref",
          "args": [
            "driver->udev"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic struct udev_iface_driver *driver;\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic int\nudevInterfaceIsActive(virInterfacePtr ifinfo)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    struct udev_device *dev;\n    virInterfaceDefPtr def = NULL;\n    int status = -1;\n\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\",\n                                                 ifinfo->name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"),\n                       ifinfo->name);\n        goto cleanup;\n    }\n\n    if (!(def = udevGetMinimalDefForDevice(dev)))\n        goto cleanup;\n\n    if (virInterfaceIsActiveEnsureACL(ifinfo->conn, def) < 0)\n       goto cleanup;\n\n    /* Check if it's active or not */\n    status = STREQ(udev_device_get_sysattr_value(dev, \"operstate\"), \"up\");\n\n    udev_device_unref(dev);\n\n cleanup:\n    udev_unref(udev);\n    virInterfaceDefFree(def);\n\n    return status;\n}"
  },
  {
    "function_name": "udevInterfaceGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "1076-1106",
    "snippet": "static char *\nudevInterfaceGetXMLDesc(virInterfacePtr ifinfo,\n                        unsigned int flags)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    virInterfaceDef *ifacedef;\n    char *xmlstr = NULL;\n\n    virCheckFlags(VIR_INTERFACE_XML_INACTIVE, NULL);\n\n    /* Recursively build up the interface XML based on the requested\n     * interface name\n     */\n    ifacedef = udevGetIfaceDef(udev, ifinfo->name);\n\n    if (!ifacedef)\n        goto cleanup;\n\n    if (virInterfaceGetXMLDescEnsureACL(ifinfo->conn, ifacedef) < 0)\n        goto cleanup;\n\n    xmlstr = virInterfaceDefFormat(ifacedef);\n\n    virInterfaceDefFree(ifacedef);\n\n cleanup:\n    /* decrement our udev ptr */\n    udev_unref(udev);\n\n    return xmlstr;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct udev_iface_driver *driver;",
      "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udev_unref",
          "args": [
            "udev"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "ifacedef"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFormat",
          "args": [
            "ifacedef"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "1130-1140",
          "snippet": "char *\nvirInterfaceDefFormat(const virInterfaceDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virInterfaceDefDevFormat(&buf, def, VIR_INTERFACE_TYPE_LAST) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nchar *\nvirInterfaceDefFormat(const virInterfaceDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virInterfaceDefDevFormat(&buf, def, VIR_INTERFACE_TYPE_LAST) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceGetXMLDescEnsureACL",
          "args": [
            "ifinfo->conn",
            "ifacedef"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetIfaceDef",
          "args": [
            "udev",
            "ifinfo->name"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_INTERFACE_XML_INACTIVE",
            "NULL"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_ref",
          "args": [
            "driver->udev"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic struct udev_iface_driver *driver;\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic char *\nudevInterfaceGetXMLDesc(virInterfacePtr ifinfo,\n                        unsigned int flags)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    virInterfaceDef *ifacedef;\n    char *xmlstr = NULL;\n\n    virCheckFlags(VIR_INTERFACE_XML_INACTIVE, NULL);\n\n    /* Recursively build up the interface XML based on the requested\n     * interface name\n     */\n    ifacedef = udevGetIfaceDef(udev, ifinfo->name);\n\n    if (!ifacedef)\n        goto cleanup;\n\n    if (virInterfaceGetXMLDescEnsureACL(ifinfo->conn, ifacedef) < 0)\n        goto cleanup;\n\n    xmlstr = virInterfaceDefFormat(ifacedef);\n\n    virInterfaceDefFree(ifacedef);\n\n cleanup:\n    /* decrement our udev ptr */\n    udev_unref(udev);\n\n    return xmlstr;\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "968-1074",
    "snippet": "static virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "ifacedef"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_unref",
          "args": [
            "dev"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_unref",
          "args": [
            "dev"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetIfaceDefBond",
          "args": [
            "udev",
            "dev",
            "name",
            "ifacedef"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetIfaceDefBridge",
          "args": [
            "udev",
            "dev",
            "name",
            "ifacedef"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetIfaceDefVlan",
          "args": [
            "udev",
            "dev",
            "name",
            "ifacedef"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "dev",
            "\"bonding/mode\""
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "name",
            "'.'"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "devtype",
            "\"bond\""
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "devtype",
            "\"bridge\""
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "devtype",
            "\"vlan\""
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_devtype",
          "args": [
            "dev"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse MTU value '%s'\")",
            "mtu_str"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not parse MTU value '%s'\""
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "968-1074",
          "snippet": "static virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "mtu_str",
            "NULL",
            "10",
            "&mtu"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "dev",
            "\"mtu\""
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevGetLinkInfo",
          "args": [
            "ifacedef->name",
            "&ifacedef->lnk"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetLinkInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "2515-2524",
          "snippet": "int\nvirNetDevGetLinkInfo(const char *ifname,\n                     virNetDevIfLinkPtr lnk)\n{\n    /* Port me */\n    VIR_DEBUG(\"Getting link info on %s is not implemented on this platform\",\n              ifname);\n    lnk->speed = lnk->state = 0;\n    return 0;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevGetLinkInfo(const char *ifname,\n                     virNetDevIfLinkPtr lnk)\n{\n    /* Port me */\n    VIR_DEBUG(\"Getting link info on %s is not implemented on this platform\",\n              ifname);\n    lnk->speed = lnk->state = 0;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "udev_device_get_sysattr_value(dev, \"address\")"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "dev",
            "\"address\""
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_INTERFACE",
            "_(\"couldn't find interface named '%s'\")",
            "name"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_new_from_subsystem_sysname",
          "args": [
            "udev",
            "\"net\"",
            "name"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ifacedef"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetIfaceDef",
          "args": [
            "struct udev *udev",
            "const char *name"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "905-966",
    "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) G_GNUC_WARN_UNUSED_RESULT\nudevGetIfaceDefVlan(struct udev *udev G_GNUC_UNUSED,\n                    struct udev_device *dev G_GNUC_UNUSED,\n                    const char *name,\n                    virInterfaceDef *ifacedef)\n{\n    char *procpath = NULL;\n    char *buf = NULL;\n    char *vid_pos, *dev_pos;\n    size_t vid_len, dev_len;\n    const char *vid_prefix = \"VID: \";\n    const char *dev_prefix = \"\\nDevice: \";\n    int ret = -1;\n\n    procpath = g_strdup_printf(\"/proc/net/vlan/%s\", name);\n\n    if (virFileReadAll(procpath, BUFSIZ, &buf) < 0)\n        goto cleanup;\n\n    if ((vid_pos = strstr(buf, vid_prefix)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to find the VID for the VLAN device '%s'\"),\n                       name);\n        goto cleanup;\n    }\n    vid_pos += strlen(vid_prefix);\n\n    if ((vid_len = strspn(vid_pos, \"0123456789\")) == 0 ||\n        !g_ascii_isspace(vid_pos[vid_len])) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to find the VID for the VLAN device '%s'\"),\n                       name);\n        goto cleanup;\n    }\n\n    if ((dev_pos = strstr(vid_pos + vid_len, dev_prefix)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to find the real device for the VLAN device '%s'\"),\n                       name);\n        goto cleanup;\n    }\n    dev_pos += strlen(dev_prefix);\n\n    if ((dev_len = strcspn(dev_pos, \"\\n\")) == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to find the real device for the VLAN device '%s'\"),\n                       name);\n        goto cleanup;\n    }\n\n    ifacedef->data.vlan.tag = g_strndup(vid_pos, vid_len);\n    ifacedef->data.vlan.dev_name = g_strndup(dev_pos, dev_len);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(procpath);\n    VIR_FREE(buf);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "buf"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "procpath"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "dev_pos",
            "dev_len"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "vid_pos",
            "vid_len"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to find the real device for the VLAN device '%s'\")",
            "name"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to find the real device for the VLAN device '%s'\""
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "968-1074",
          "snippet": "static virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "dev_pos",
            "\"\\n\""
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dev_prefix"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to find the real device for the VLAN device '%s'\")",
            "name"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "vid_pos + vid_len",
            "dev_prefix"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to find the VID for the VLAN device '%s'\")",
            "name"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ascii_isspace",
          "args": [
            "vid_pos[vid_len]"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "vid_pos",
            "\"0123456789\""
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "vid_prefix"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to find the VID for the VLAN device '%s'\")",
            "name"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "buf",
            "vid_prefix"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadAll",
          "args": [
            "procpath",
            "BUFSIZ",
            "&buf"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"/proc/net/vlan/%s\"",
            "name"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetIfaceDefVlan",
          "args": [
            "struct udev *udev G_GNUC_UNUSED",
            "structudev_device *dev G_GNUC_UNUSED",
            "const char *name",
            "virInterfaceDef *ifacedef"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) G_GNUC_WARN_UNUSED_RESULT\nudevGetIfaceDefVlan(struct udev *udev G_GNUC_UNUSED,\n                    struct udev_device *dev G_GNUC_UNUSED,\n                    const char *name,\n                    virInterfaceDef *ifacedef)\n{\n    char *procpath = NULL;\n    char *buf = NULL;\n    char *vid_pos, *dev_pos;\n    size_t vid_len, dev_len;\n    const char *vid_prefix = \"VID: \";\n    const char *dev_prefix = \"\\nDevice: \";\n    int ret = -1;\n\n    procpath = g_strdup_printf(\"/proc/net/vlan/%s\", name);\n\n    if (virFileReadAll(procpath, BUFSIZ, &buf) < 0)\n        goto cleanup;\n\n    if ((vid_pos = strstr(buf, vid_prefix)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to find the VID for the VLAN device '%s'\"),\n                       name);\n        goto cleanup;\n    }\n    vid_pos += strlen(vid_prefix);\n\n    if ((vid_len = strspn(vid_pos, \"0123456789\")) == 0 ||\n        !g_ascii_isspace(vid_pos[vid_len])) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to find the VID for the VLAN device '%s'\"),\n                       name);\n        goto cleanup;\n    }\n\n    if ((dev_pos = strstr(vid_pos + vid_len, dev_prefix)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to find the real device for the VLAN device '%s'\"),\n                       name);\n        goto cleanup;\n    }\n    dev_pos += strlen(dev_prefix);\n\n    if ((dev_len = strcspn(dev_pos, \"\\n\")) == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to find the real device for the VLAN device '%s'\"),\n                       name);\n        goto cleanup;\n    }\n\n    ifacedef->data.vlan.tag = g_strndup(vid_pos, vid_len);\n    ifacedef->data.vlan.dev_name = g_strndup(dev_pos, dev_len);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(procpath);\n    VIR_FREE(buf);\n    return ret;\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "802-903",
    "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) G_GNUC_WARN_UNUSED_RESULT\nudevGetIfaceDefBridge(struct udev *udev,\n                      struct udev_device *dev,\n                      const char *name,\n                      virInterfaceDef *ifacedef)\n{\n    struct dirent **member_list = NULL;\n    int member_count = 0;\n    char *member_path;\n    const char *tmp_str;\n    int stp;\n    size_t i;\n\n    /* Set our type to Bridge  */\n    ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n\n    /* Retrieve the forward delay */\n    tmp_str = udev_device_get_sysattr_value(dev, \"bridge/forward_delay\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not retrieve 'bridge/forward_delay' for '%s'\"), name);\n        goto error;\n    }\n\n    ifacedef->data.bridge.delay = g_strdup(tmp_str);\n\n    /* Retrieve Spanning Tree State. Valid values = -1, 0, 1 */\n    tmp_str = udev_device_get_sysattr_value(dev, \"bridge/stp_state\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n            _(\"Could not retrieve 'bridge/stp_state' for '%s'\"), name);\n        goto error;\n    }\n\n    if (virStrToLong_i(tmp_str, NULL, 10, &stp) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse 'bridge/stp_state' '%s' for '%s'\"),\n                tmp_str, name);\n        goto error;\n    }\n\n    switch (stp) {\n    case -1:\n    case 0:\n    case 1:\n        ifacedef->data.bridge.stp = stp;\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n            _(\"Invalid STP state value %d received for '%s'. Must be \"\n              \"-1, 0, or 1.\"), stp, name);\n        goto error;\n    }\n\n    /* Members of the bridge */\n    member_path = g_strdup_printf(\"%s/%s\", udev_device_get_syspath(dev), \"brif\");\n\n    /* Get each member of the bridge */\n    member_count = scandir(member_path, &member_list,\n            udevBridgeScanDirFilter, alphasort);\n\n    /* Don't need the path anymore */\n    VIR_FREE(member_path);\n\n    if (member_count < 0) {\n        virReportSystemError(errno,\n                _(\"Could not get members of bridge '%s'\"),\n                name);\n        goto error;\n    }\n\n    /* Allocate our list of member devices */\n    if (VIR_ALLOC_N(ifacedef->data.bridge.itf, member_count) < 0)\n        goto error;\n    ifacedef->data.bridge.nbItf = member_count;\n\n    /* Get the interface definitions for each member of the bridge */\n    for (i = 0; i < member_count; i++) {\n        ifacedef->data.bridge.itf[i] =\n            udevGetIfaceDef(udev, member_list[i]->d_name);\n        if (!ifacedef->data.bridge.itf[i]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not get interface information for '%s', which is \"\n                  \"a member of bridge '%s'\"), member_list[i]->d_name, name);\n            goto error;\n        }\n        VIR_FREE(member_list[i]);\n    }\n\n    VIR_FREE(member_list);\n\n    return 0;\n\n error:\n    for (i = 0; member_count != -1 && i < member_count; i++)\n        VIR_FREE(member_list[i]);\n    VIR_FREE(member_list);\n\n    return -1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "member_list"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "member_list[i]"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "member_list"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "member_list[i]"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get interface information for '%s', which is \"\n                  \"a member of bridge '%s'\")",
            "member_list[i]->d_name",
            "name"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not get interface information for '%s', which is \"\n                  \"a member of bridge '%s'\""
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "968-1074",
          "snippet": "static virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "udevGetIfaceDef",
          "args": [
            "udev",
            "member_list[i]->d_name"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "ifacedef->data.bridge.itf",
            "member_count"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Could not get members of bridge '%s'\")",
            "name"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "member_path"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scandir",
          "args": [
            "member_path",
            "&member_list",
            "udevBridgeScanDirFilter",
            "alphasort"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s\"",
            "udev_device_get_syspath(dev)",
            "\"brif\""
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_get_syspath",
          "args": [
            "dev"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid STP state value %d received for '%s'. Must be \"\n              \"-1, 0, or 1.\")",
            "stp",
            "name"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse 'bridge/stp_state' '%s' for '%s'\")",
            "tmp_str",
            "name"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "tmp_str",
            "NULL",
            "10",
            "&stp"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not retrieve 'bridge/stp_state' for '%s'\")",
            "name"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "dev",
            "\"bridge/stp_state\""
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not retrieve 'bridge/forward_delay' for '%s'\")",
            "name"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "dev",
            "\"bridge/forward_delay\""
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetIfaceDefBridge",
          "args": [
            "struct udev *udev",
            "structudev_device *dev",
            "const char *name",
            "virInterfaceDef *ifacedef"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) G_GNUC_WARN_UNUSED_RESULT\nudevGetIfaceDefBridge(struct udev *udev,\n                      struct udev_device *dev,\n                      const char *name,\n                      virInterfaceDef *ifacedef)\n{\n    struct dirent **member_list = NULL;\n    int member_count = 0;\n    char *member_path;\n    const char *tmp_str;\n    int stp;\n    size_t i;\n\n    /* Set our type to Bridge  */\n    ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n\n    /* Retrieve the forward delay */\n    tmp_str = udev_device_get_sysattr_value(dev, \"bridge/forward_delay\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not retrieve 'bridge/forward_delay' for '%s'\"), name);\n        goto error;\n    }\n\n    ifacedef->data.bridge.delay = g_strdup(tmp_str);\n\n    /* Retrieve Spanning Tree State. Valid values = -1, 0, 1 */\n    tmp_str = udev_device_get_sysattr_value(dev, \"bridge/stp_state\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n            _(\"Could not retrieve 'bridge/stp_state' for '%s'\"), name);\n        goto error;\n    }\n\n    if (virStrToLong_i(tmp_str, NULL, 10, &stp) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse 'bridge/stp_state' '%s' for '%s'\"),\n                tmp_str, name);\n        goto error;\n    }\n\n    switch (stp) {\n    case -1:\n    case 0:\n    case 1:\n        ifacedef->data.bridge.stp = stp;\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n            _(\"Invalid STP state value %d received for '%s'. Must be \"\n              \"-1, 0, or 1.\"), stp, name);\n        goto error;\n    }\n\n    /* Members of the bridge */\n    member_path = g_strdup_printf(\"%s/%s\", udev_device_get_syspath(dev), \"brif\");\n\n    /* Get each member of the bridge */\n    member_count = scandir(member_path, &member_list,\n            udevBridgeScanDirFilter, alphasort);\n\n    /* Don't need the path anymore */\n    VIR_FREE(member_path);\n\n    if (member_count < 0) {\n        virReportSystemError(errno,\n                _(\"Could not get members of bridge '%s'\"),\n                name);\n        goto error;\n    }\n\n    /* Allocate our list of member devices */\n    if (VIR_ALLOC_N(ifacedef->data.bridge.itf, member_count) < 0)\n        goto error;\n    ifacedef->data.bridge.nbItf = member_count;\n\n    /* Get the interface definitions for each member of the bridge */\n    for (i = 0; i < member_count; i++) {\n        ifacedef->data.bridge.itf[i] =\n            udevGetIfaceDef(udev, member_list[i]->d_name);\n        if (!ifacedef->data.bridge.itf[i]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not get interface information for '%s', which is \"\n                  \"a member of bridge '%s'\"), member_list[i]->d_name, name);\n            goto error;\n        }\n        VIR_FREE(member_list[i]);\n    }\n\n    VIR_FREE(member_list);\n\n    return 0;\n\n error:\n    for (i = 0; member_count != -1 && i < member_count; i++)\n        VIR_FREE(member_list[i]);\n    VIR_FREE(member_list);\n\n    return -1;\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "578-800",
    "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) G_GNUC_WARN_UNUSED_RESULT\nudevGetIfaceDefBond(struct udev *udev,\n                    struct udev_device *dev,\n                    const char *name,\n                    virInterfaceDef *ifacedef)\n{\n    struct dirent **slave_list = NULL;\n    int slave_count = 0;\n    size_t i;\n    const char *tmp_str;\n    int tmp_int;\n\n    /* Initial defaults */\n    ifacedef->data.bond.target = NULL;\n    ifacedef->data.bond.nbItf = 0;\n    ifacedef->data.bond.itf = NULL;\n\n    /* Set the bond specifics */\n    tmp_str = udev_device_get_sysattr_value(dev, \"bonding/downdelay\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not retrieve 'bonding/downdelay' for '%s'\"), name);\n        goto error;\n    }\n    if (virStrToLong_i(tmp_str, NULL, 10, &tmp_int) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse 'bonding/downdelay' '%s' for '%s'\"),\n                tmp_str, name);\n        goto error;\n    }\n    ifacedef->data.bond.downdelay = tmp_int;\n\n    tmp_str = udev_device_get_sysattr_value(dev, \"bonding/updelay\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not retrieve 'bonding/updelay' for '%s'\"), name);\n        goto error;\n    }\n    if (virStrToLong_i(tmp_str, NULL, 10, &tmp_int) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse 'bonding/updelay' '%s' for '%s'\"),\n                tmp_str, name);\n        goto error;\n    }\n    ifacedef->data.bond.updelay = tmp_int;\n\n    tmp_str = udev_device_get_sysattr_value(dev, \"bonding/miimon\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not retrieve 'bonding/miimon' for '%s'\"), name);\n        goto error;\n    }\n    if (virStrToLong_i(tmp_str, NULL, 10, &tmp_int) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse 'bonding/miimon' '%s' for '%s'\"),\n                tmp_str, name);\n        goto error;\n    }\n    ifacedef->data.bond.frequency = tmp_int;\n\n    tmp_str = udev_device_get_sysattr_value(dev, \"bonding/arp_interval\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not retrieve 'bonding/arp_interval' for '%s'\"), name);\n        goto error;\n    }\n    if (virStrToLong_i(tmp_str, NULL, 10, &tmp_int) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse 'bonding/arp_interval' '%s' for '%s'\"),\n                tmp_str, name);\n        goto error;\n    }\n    ifacedef->data.bond.interval = tmp_int;\n\n    /* bonding/mode is in the format: \"balance-rr 0\" so we find the\n     * space and increment the pointer to get the number and convert\n     * it to an interger. libvirt uses 1 through 7 while the raw\n     * number is 0 through 6 so increment it by 1.\n     */\n    tmp_str = udev_device_get_sysattr_value(dev, \"bonding/mode\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not retrieve 'bonding/mode' for '%s'\"), name);\n        goto error;\n    }\n    tmp_str = strchr(tmp_str, ' ');\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Invalid format for 'bonding/mode' for '%s'\"), name);\n        goto error;\n    }\n    if (strlen(tmp_str) < 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Unable to find correct value in 'bonding/mode' for '%s'\"),\n                name);\n        goto error;\n    }\n    if (virStrToLong_i(tmp_str + 1, NULL, 10, &tmp_int) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse 'bonding/mode' '%s' for '%s'\"),\n                tmp_str, name);\n        goto error;\n    }\n    ifacedef->data.bond.mode = tmp_int + 1;\n\n    /* bonding/arp_validate is in the format: \"none 0\" so we find the\n     * space and increment the pointer to get the number and convert\n     * it to an interger.\n     */\n    tmp_str = udev_device_get_sysattr_value(dev, \"bonding/arp_validate\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not retrieve 'bonding/arp_validate' for '%s'\"), name);\n        goto error;\n    }\n    tmp_str = strchr(tmp_str, ' ');\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Invalid format for 'bonding/arp_validate' for '%s'\"), name);\n        goto error;\n    }\n    if (strlen(tmp_str) < 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Unable to find correct value in 'bonding/arp_validate' \"\n                \"for '%s'\"), name);\n        goto error;\n    }\n    if (virStrToLong_i(tmp_str + 1, NULL, 10, &tmp_int) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse 'bonding/arp_validate' '%s' for '%s'\"),\n                tmp_str, name);\n        goto error;\n    }\n    ifacedef->data.bond.validate = tmp_int;\n\n    /* bonding/use_carrier is 0 or 1 and libvirt stores it as 1 or 2. */\n    tmp_str = udev_device_get_sysattr_value(dev, \"bonding/use_carrier\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not retrieve 'bonding/use_carrier' for '%s'\"), name);\n        goto error;\n    }\n    if (virStrToLong_i(tmp_str, NULL, 10, &tmp_int) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse 'bonding/use_carrier' '%s' for '%s'\"),\n                tmp_str, name);\n        goto error;\n    }\n    ifacedef->data.bond.carrier = tmp_int + 1;\n\n    /* MII or ARP Monitoring is based on arp_interval and miimon.\n     * if arp_interval > 0 then ARP monitoring is in play, if\n     * miimon > 0 then MII monitoring is in play.\n     */\n    if (ifacedef->data.bond.interval > 0)\n        ifacedef->data.bond.monit = VIR_INTERFACE_BOND_MONIT_ARP;\n    else if (ifacedef->data.bond.frequency > 0)\n        ifacedef->data.bond.monit = VIR_INTERFACE_BOND_MONIT_MII;\n    else\n        ifacedef->data.bond.monit = VIR_INTERFACE_BOND_MONIT_NONE;\n\n    tmp_str = udev_device_get_sysattr_value(dev, \"bonding/arp_ip_target\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not retrieve 'bonding/arp_ip_target' for '%s'\"), name);\n        goto error;\n    }\n    ifacedef->data.bond.target = g_strdup(tmp_str);\n\n    /* Slaves of the bond */\n    /* Get each slave in the bond */\n    slave_count = scandir(udev_device_get_syspath(dev), &slave_list,\n            udevBondScanDirFilter, alphasort);\n\n    if (slave_count < 0) {\n        virReportSystemError(errno,\n                _(\"Could not get slaves of bond '%s'\"), name);\n        goto error;\n    }\n\n    /* Allocate our list of slave devices */\n    if (VIR_ALLOC_N(ifacedef->data.bond.itf, slave_count) < 0)\n        goto error;\n    ifacedef->data.bond.nbItf = slave_count;\n\n    for (i = 0; i < slave_count; i++) {\n        /* Names are slave_interface. e.g. slave_eth0\n         * so we use the part after the _\n         */\n        tmp_str = strchr(slave_list[i]->d_name, '_');\n        if (!tmp_str || strlen(tmp_str) < 2) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid enslaved interface name '%s' seen for \"\n                             \"bond '%s'\"), slave_list[i]->d_name, name);\n            goto error;\n        }\n        /* go past the _ */\n        tmp_str++;\n\n        ifacedef->data.bond.itf[i] =\n            udevGetIfaceDef(udev, tmp_str);\n        if (!ifacedef->data.bond.itf[i]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not get interface information for '%s', which is \"\n                  \"a enslaved in bond '%s'\"), slave_list[i]->d_name, name);\n            goto error;\n        }\n        VIR_FREE(slave_list[i]);\n    }\n\n    VIR_FREE(slave_list);\n\n    return 0;\n\n error:\n    for (i = 0; slave_count != -1 && i < slave_count; i++)\n        VIR_FREE(slave_list[i]);\n    VIR_FREE(slave_list);\n\n    return -1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "slave_list"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "slave_list[i]"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "slave_list"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "slave_list[i]"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get interface information for '%s', which is \"\n                  \"a enslaved in bond '%s'\")",
            "slave_list[i]->d_name",
            "name"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not get interface information for '%s', which is \"\n                  \"a enslaved in bond '%s'\""
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "968-1074",
          "snippet": "static virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "udevGetIfaceDef",
          "args": [
            "udev",
            "tmp_str"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid enslaved interface name '%s' seen for \"\n                             \"bond '%s'\")",
            "slave_list[i]->d_name",
            "name"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp_str"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "slave_list[i]->d_name",
            "'_'"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "ifacedef->data.bond.itf",
            "slave_count"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Could not get slaves of bond '%s'\")",
            "name"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scandir",
          "args": [
            "udev_device_get_syspath(dev)",
            "&slave_list",
            "udevBondScanDirFilter",
            "alphasort"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_syspath",
          "args": [
            "dev"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "tmp_str"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not retrieve 'bonding/arp_ip_target' for '%s'\")",
            "name"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "dev",
            "\"bonding/arp_ip_target\""
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse 'bonding/use_carrier' '%s' for '%s'\")",
            "tmp_str",
            "name"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "tmp_str",
            "NULL",
            "10",
            "&tmp_int"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not retrieve 'bonding/use_carrier' for '%s'\")",
            "name"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "dev",
            "\"bonding/use_carrier\""
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse 'bonding/arp_validate' '%s' for '%s'\")",
            "tmp_str",
            "name"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to find correct value in 'bonding/arp_validate' \"\n                \"for '%s'\")",
            "name"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp_str"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid format for 'bonding/arp_validate' for '%s'\")",
            "name"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "tmp_str",
            "' '"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not retrieve 'bonding/arp_validate' for '%s'\")",
            "name"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "dev",
            "\"bonding/arp_validate\""
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse 'bonding/mode' '%s' for '%s'\")",
            "tmp_str",
            "name"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to find correct value in 'bonding/mode' for '%s'\")",
            "name"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp_str"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid format for 'bonding/mode' for '%s'\")",
            "name"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "tmp_str",
            "' '"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not retrieve 'bonding/mode' for '%s'\")",
            "name"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "dev",
            "\"bonding/mode\""
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse 'bonding/arp_interval' '%s' for '%s'\")",
            "tmp_str",
            "name"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not retrieve 'bonding/arp_interval' for '%s'\")",
            "name"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "dev",
            "\"bonding/arp_interval\""
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse 'bonding/miimon' '%s' for '%s'\")",
            "tmp_str",
            "name"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not retrieve 'bonding/miimon' for '%s'\")",
            "name"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "dev",
            "\"bonding/miimon\""
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse 'bonding/updelay' '%s' for '%s'\")",
            "tmp_str",
            "name"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not retrieve 'bonding/updelay' for '%s'\")",
            "name"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "dev",
            "\"bonding/updelay\""
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse 'bonding/downdelay' '%s' for '%s'\")",
            "tmp_str",
            "name"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not retrieve 'bonding/downdelay' for '%s'\")",
            "name"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "dev",
            "\"bonding/downdelay\""
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetIfaceDefBond",
          "args": [
            "struct udev *udev",
            "structudev_device *dev",
            "const char *name",
            "virInterfaceDef *ifacedef"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) G_GNUC_WARN_UNUSED_RESULT\nudevGetIfaceDefBond(struct udev *udev,\n                    struct udev_device *dev,\n                    const char *name,\n                    virInterfaceDef *ifacedef)\n{\n    struct dirent **slave_list = NULL;\n    int slave_count = 0;\n    size_t i;\n    const char *tmp_str;\n    int tmp_int;\n\n    /* Initial defaults */\n    ifacedef->data.bond.target = NULL;\n    ifacedef->data.bond.nbItf = 0;\n    ifacedef->data.bond.itf = NULL;\n\n    /* Set the bond specifics */\n    tmp_str = udev_device_get_sysattr_value(dev, \"bonding/downdelay\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not retrieve 'bonding/downdelay' for '%s'\"), name);\n        goto error;\n    }\n    if (virStrToLong_i(tmp_str, NULL, 10, &tmp_int) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse 'bonding/downdelay' '%s' for '%s'\"),\n                tmp_str, name);\n        goto error;\n    }\n    ifacedef->data.bond.downdelay = tmp_int;\n\n    tmp_str = udev_device_get_sysattr_value(dev, \"bonding/updelay\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not retrieve 'bonding/updelay' for '%s'\"), name);\n        goto error;\n    }\n    if (virStrToLong_i(tmp_str, NULL, 10, &tmp_int) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse 'bonding/updelay' '%s' for '%s'\"),\n                tmp_str, name);\n        goto error;\n    }\n    ifacedef->data.bond.updelay = tmp_int;\n\n    tmp_str = udev_device_get_sysattr_value(dev, \"bonding/miimon\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not retrieve 'bonding/miimon' for '%s'\"), name);\n        goto error;\n    }\n    if (virStrToLong_i(tmp_str, NULL, 10, &tmp_int) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse 'bonding/miimon' '%s' for '%s'\"),\n                tmp_str, name);\n        goto error;\n    }\n    ifacedef->data.bond.frequency = tmp_int;\n\n    tmp_str = udev_device_get_sysattr_value(dev, \"bonding/arp_interval\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not retrieve 'bonding/arp_interval' for '%s'\"), name);\n        goto error;\n    }\n    if (virStrToLong_i(tmp_str, NULL, 10, &tmp_int) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse 'bonding/arp_interval' '%s' for '%s'\"),\n                tmp_str, name);\n        goto error;\n    }\n    ifacedef->data.bond.interval = tmp_int;\n\n    /* bonding/mode is in the format: \"balance-rr 0\" so we find the\n     * space and increment the pointer to get the number and convert\n     * it to an interger. libvirt uses 1 through 7 while the raw\n     * number is 0 through 6 so increment it by 1.\n     */\n    tmp_str = udev_device_get_sysattr_value(dev, \"bonding/mode\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not retrieve 'bonding/mode' for '%s'\"), name);\n        goto error;\n    }\n    tmp_str = strchr(tmp_str, ' ');\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Invalid format for 'bonding/mode' for '%s'\"), name);\n        goto error;\n    }\n    if (strlen(tmp_str) < 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Unable to find correct value in 'bonding/mode' for '%s'\"),\n                name);\n        goto error;\n    }\n    if (virStrToLong_i(tmp_str + 1, NULL, 10, &tmp_int) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse 'bonding/mode' '%s' for '%s'\"),\n                tmp_str, name);\n        goto error;\n    }\n    ifacedef->data.bond.mode = tmp_int + 1;\n\n    /* bonding/arp_validate is in the format: \"none 0\" so we find the\n     * space and increment the pointer to get the number and convert\n     * it to an interger.\n     */\n    tmp_str = udev_device_get_sysattr_value(dev, \"bonding/arp_validate\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not retrieve 'bonding/arp_validate' for '%s'\"), name);\n        goto error;\n    }\n    tmp_str = strchr(tmp_str, ' ');\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Invalid format for 'bonding/arp_validate' for '%s'\"), name);\n        goto error;\n    }\n    if (strlen(tmp_str) < 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Unable to find correct value in 'bonding/arp_validate' \"\n                \"for '%s'\"), name);\n        goto error;\n    }\n    if (virStrToLong_i(tmp_str + 1, NULL, 10, &tmp_int) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse 'bonding/arp_validate' '%s' for '%s'\"),\n                tmp_str, name);\n        goto error;\n    }\n    ifacedef->data.bond.validate = tmp_int;\n\n    /* bonding/use_carrier is 0 or 1 and libvirt stores it as 1 or 2. */\n    tmp_str = udev_device_get_sysattr_value(dev, \"bonding/use_carrier\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not retrieve 'bonding/use_carrier' for '%s'\"), name);\n        goto error;\n    }\n    if (virStrToLong_i(tmp_str, NULL, 10, &tmp_int) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse 'bonding/use_carrier' '%s' for '%s'\"),\n                tmp_str, name);\n        goto error;\n    }\n    ifacedef->data.bond.carrier = tmp_int + 1;\n\n    /* MII or ARP Monitoring is based on arp_interval and miimon.\n     * if arp_interval > 0 then ARP monitoring is in play, if\n     * miimon > 0 then MII monitoring is in play.\n     */\n    if (ifacedef->data.bond.interval > 0)\n        ifacedef->data.bond.monit = VIR_INTERFACE_BOND_MONIT_ARP;\n    else if (ifacedef->data.bond.frequency > 0)\n        ifacedef->data.bond.monit = VIR_INTERFACE_BOND_MONIT_MII;\n    else\n        ifacedef->data.bond.monit = VIR_INTERFACE_BOND_MONIT_NONE;\n\n    tmp_str = udev_device_get_sysattr_value(dev, \"bonding/arp_ip_target\");\n    if (!tmp_str) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not retrieve 'bonding/arp_ip_target' for '%s'\"), name);\n        goto error;\n    }\n    ifacedef->data.bond.target = g_strdup(tmp_str);\n\n    /* Slaves of the bond */\n    /* Get each slave in the bond */\n    slave_count = scandir(udev_device_get_syspath(dev), &slave_list,\n            udevBondScanDirFilter, alphasort);\n\n    if (slave_count < 0) {\n        virReportSystemError(errno,\n                _(\"Could not get slaves of bond '%s'\"), name);\n        goto error;\n    }\n\n    /* Allocate our list of slave devices */\n    if (VIR_ALLOC_N(ifacedef->data.bond.itf, slave_count) < 0)\n        goto error;\n    ifacedef->data.bond.nbItf = slave_count;\n\n    for (i = 0; i < slave_count; i++) {\n        /* Names are slave_interface. e.g. slave_eth0\n         * so we use the part after the _\n         */\n        tmp_str = strchr(slave_list[i]->d_name, '_');\n        if (!tmp_str || strlen(tmp_str) < 2) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid enslaved interface name '%s' seen for \"\n                             \"bond '%s'\"), slave_list[i]->d_name, name);\n            goto error;\n        }\n        /* go past the _ */\n        tmp_str++;\n\n        ifacedef->data.bond.itf[i] =\n            udevGetIfaceDef(udev, tmp_str);\n        if (!ifacedef->data.bond.itf[i]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not get interface information for '%s', which is \"\n                  \"a enslaved in bond '%s'\"), slave_list[i]->d_name, name);\n            goto error;\n        }\n        VIR_FREE(slave_list[i]);\n    }\n\n    VIR_FREE(slave_list);\n\n    return 0;\n\n error:\n    for (i = 0; slave_count != -1 && i < slave_count; i++)\n        VIR_FREE(slave_list[i]);\n    VIR_FREE(slave_list);\n\n    return -1;\n}"
  },
  {
    "function_name": "udevBridgeScanDirFilter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "558-575",
    "snippet": "static int\nudevBridgeScanDirFilter(const struct dirent *entry)\n{\n    if (STREQ(entry->d_name, \".\") || STREQ(entry->d_name, \"..\"))\n        return 0;\n\n    /* Omit the domain interfaces from the list of bridge attached\n     * devices. All we can do is check for the device name matching\n     * vnet%d. Improvements to this check are welcome.\n     */\n    if (strlen(entry->d_name) >= 5) {\n        if (STRPREFIX(entry->d_name, VIR_NET_GENERATED_TAP_PREFIX) &&\n            g_ascii_isdigit(entry->d_name[4]))\n            return 0;\n    }\n\n    return 1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_ascii_isdigit",
          "args": [
            "entry->d_name[4]"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "entry->d_name",
            "VIR_NET_GENERATED_TAP_PREFIX"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "entry->d_name"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "entry->d_name",
            "\"..\""
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "entry->d_name",
            "\".\""
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic int\nudevBridgeScanDirFilter(const struct dirent *entry)\n{\n    if (STREQ(entry->d_name, \".\") || STREQ(entry->d_name, \"..\"))\n        return 0;\n\n    /* Omit the domain interfaces from the list of bridge attached\n     * devices. All we can do is check for the device name matching\n     * vnet%d. Improvements to this check are welcome.\n     */\n    if (strlen(entry->d_name) >= 5) {\n        if (STRPREFIX(entry->d_name, VIR_NET_GENERATED_TAP_PREFIX) &&\n            g_ascii_isdigit(entry->d_name[4]))\n            return 0;\n    }\n\n    return 1;\n}"
  },
  {
    "function_name": "udevBondScanDirFilter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "537-549",
    "snippet": "static int\nudevBondScanDirFilter(const struct dirent *entry)\n{\n    /* This is ugly so if anyone has a better suggestion, please improve\n     * this. Unfortunately the kernel stores everything in the top level\n     * interface sysfs entry and references the slaves as slave_eth0 for\n     * example.\n     */\n    if (STRPREFIX(entry->d_name, \"slave_\"))\n        return 1;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "entry->d_name",
            "\"slave_\""
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nudevBondScanDirFilter(const struct dirent *entry)\n{\n    /* This is ugly so if anyone has a better suggestion, please improve\n     * this. Unfortunately the kernel stores everything in the top level\n     * interface sysfs entry and references the slaves as slave_eth0 for\n     * example.\n     */\n    if (STRPREFIX(entry->d_name, \"slave_\"))\n        return 1;\n\n    return 0;\n}"
  },
  {
    "function_name": "udevInterfaceLookupByMACString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "466-528",
    "snippet": "static virInterfacePtr\nudevInterfaceLookupByMACString(virConnectPtr conn, const char *macstr)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    struct udev_enumerate *enumerate = NULL;\n    struct udev_list_entry *dev_entry;\n    struct udev_device *dev;\n    virInterfaceDefPtr def = NULL;\n    virInterfacePtr ret = NULL;\n\n    enumerate = udevGetDevices(udev, VIR_UDEV_IFACE_ALL);\n\n    if (!enumerate) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to lookup interface with MAC address '%s'\"),\n                       macstr);\n        goto cleanup;\n    }\n\n    /* Match on MAC */\n    udev_enumerate_add_match_sysattr(enumerate, \"address\", macstr);\n\n    /* Do the scan to load up the enumeration */\n    udev_enumerate_scan_devices(enumerate);\n\n    /* Get a list we can walk */\n    dev_entry = udev_enumerate_get_list_entry(enumerate);\n\n    /* Check that we got something back */\n    if (!dev_entry) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface with MAC address '%s'\"),\n                       macstr);\n        goto cleanup;\n    }\n\n    /* Check that we didn't get multiple items back */\n    if (udev_list_entry_get_next(dev_entry)) {\n        virReportError(VIR_ERR_MULTIPLE_INTERFACES,\n                       _(\"the MAC address '%s' matches multiple interfaces\"),\n                       macstr);\n        goto cleanup;\n    }\n\n    dev = udev_device_new_from_syspath(udev, udev_list_entry_get_name(dev_entry));\n\n    if (!(def = udevGetMinimalDefForDevice(dev)))\n        goto cleanup;\n\n    if (virInterfaceLookupByMACStringEnsureACL(conn, def) < 0)\n       goto cleanup;\n\n    ret = virGetInterface(conn, def->name, def->mac);\n    udev_device_unref(dev);\n\n cleanup:\n    if (enumerate)\n        udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n    virInterfaceDefFree(def);\n\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct udev_iface_driver *driver;",
      "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "def"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_unref",
          "args": [
            "udev"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_unref",
          "args": [
            "enumerate"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_unref",
          "args": [
            "dev"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetInterface",
          "args": [
            "conn",
            "def->name",
            "def->mac"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "virGetInterface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "460-488",
          "snippet": "virInterfacePtr\nvirGetInterface(virConnectPtr conn, const char *name, const char *mac)\n{\n    virInterfacePtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n\n    /* a NULL mac from caller is okay. Treat it as blank */\n    if (mac == NULL)\n       mac = \"\";\n\n    if (!(ret = virObjectNew(virInterfaceClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n    ret->mac = g_strdup(mac);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virInterfaceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virInterfaceClass;\n\nvirInterfacePtr\nvirGetInterface(virConnectPtr conn, const char *name, const char *mac)\n{\n    virInterfacePtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n\n    /* a NULL mac from caller is okay. Treat it as blank */\n    if (mac == NULL)\n       mac = \"\";\n\n    if (!(ret = virObjectNew(virInterfaceClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n    ret->mac = g_strdup(mac);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceLookupByMACStringEnsureACL",
          "args": [
            "conn",
            "def"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetMinimalDefForDevice",
          "args": [
            "dev"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_new_from_syspath",
          "args": [
            "udev",
            "udev_list_entry_get_name(dev_entry)"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_list_entry_get_name",
          "args": [
            "dev_entry"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_MULTIPLE_INTERFACES",
            "_(\"the MAC address '%s' matches multiple interfaces\")",
            "macstr"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"the MAC address '%s' matches multiple interfaces\""
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "968-1074",
          "snippet": "static virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include <libudev.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_list_entry_get_next",
          "args": [
            "dev_entry"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_INTERFACE",
            "_(\"couldn't find interface with MAC address '%s'\")",
            "macstr"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_get_list_entry",
          "args": [
            "enumerate"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_scan_devices",
          "args": [
            "enumerate"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_add_match_sysattr",
          "args": [
            "enumerate",
            "\"address\"",
            "macstr"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to lookup interface with MAC address '%s'\")",
            "macstr"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetDevices",
          "args": [
            "udev",
            "VIR_UDEV_IFACE_ALL"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_ref",
          "args": [
            "driver->udev"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic struct udev_iface_driver *driver;\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic virInterfacePtr\nudevInterfaceLookupByMACString(virConnectPtr conn, const char *macstr)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    struct udev_enumerate *enumerate = NULL;\n    struct udev_list_entry *dev_entry;\n    struct udev_device *dev;\n    virInterfaceDefPtr def = NULL;\n    virInterfacePtr ret = NULL;\n\n    enumerate = udevGetDevices(udev, VIR_UDEV_IFACE_ALL);\n\n    if (!enumerate) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to lookup interface with MAC address '%s'\"),\n                       macstr);\n        goto cleanup;\n    }\n\n    /* Match on MAC */\n    udev_enumerate_add_match_sysattr(enumerate, \"address\", macstr);\n\n    /* Do the scan to load up the enumeration */\n    udev_enumerate_scan_devices(enumerate);\n\n    /* Get a list we can walk */\n    dev_entry = udev_enumerate_get_list_entry(enumerate);\n\n    /* Check that we got something back */\n    if (!dev_entry) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface with MAC address '%s'\"),\n                       macstr);\n        goto cleanup;\n    }\n\n    /* Check that we didn't get multiple items back */\n    if (udev_list_entry_get_next(dev_entry)) {\n        virReportError(VIR_ERR_MULTIPLE_INTERFACES,\n                       _(\"the MAC address '%s' matches multiple interfaces\"),\n                       macstr);\n        goto cleanup;\n    }\n\n    dev = udev_device_new_from_syspath(udev, udev_list_entry_get_name(dev_entry));\n\n    if (!(def = udevGetMinimalDefForDevice(dev)))\n        goto cleanup;\n\n    if (virInterfaceLookupByMACStringEnsureACL(conn, def) < 0)\n       goto cleanup;\n\n    ret = virGetInterface(conn, def->name, def->mac);\n    udev_device_unref(dev);\n\n cleanup:\n    if (enumerate)\n        udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n    virInterfaceDefFree(def);\n\n    return ret;\n}"
  },
  {
    "function_name": "udevInterfaceLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "433-464",
    "snippet": "static virInterfacePtr\nudevInterfaceLookupByName(virConnectPtr conn, const char *name)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    struct udev_device *dev;\n    virInterfacePtr ret = NULL;\n    virInterfaceDefPtr def = NULL;\n\n    /* get a device reference based on the device name */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"),\n                       name);\n        goto cleanup;\n    }\n\n    if (!(def = udevGetMinimalDefForDevice(dev)))\n        goto cleanup;\n\n    if (virInterfaceLookupByNameEnsureACL(conn, def) < 0)\n       goto cleanup;\n\n    ret = virGetInterface(conn, def->name, def->mac);\n    udev_device_unref(dev);\n\n cleanup:\n    udev_unref(udev);\n    virInterfaceDefFree(def);\n\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct udev_iface_driver *driver;",
      "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "def"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_unref",
          "args": [
            "udev"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_unref",
          "args": [
            "dev"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetInterface",
          "args": [
            "conn",
            "def->name",
            "def->mac"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "virGetInterface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "460-488",
          "snippet": "virInterfacePtr\nvirGetInterface(virConnectPtr conn, const char *name, const char *mac)\n{\n    virInterfacePtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n\n    /* a NULL mac from caller is okay. Treat it as blank */\n    if (mac == NULL)\n       mac = \"\";\n\n    if (!(ret = virObjectNew(virInterfaceClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n    ret->mac = g_strdup(mac);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virInterfaceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virInterfaceClass;\n\nvirInterfacePtr\nvirGetInterface(virConnectPtr conn, const char *name, const char *mac)\n{\n    virInterfacePtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n\n    /* a NULL mac from caller is okay. Treat it as blank */\n    if (mac == NULL)\n       mac = \"\";\n\n    if (!(ret = virObjectNew(virInterfaceClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n    ret->mac = g_strdup(mac);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceLookupByNameEnsureACL",
          "args": [
            "conn",
            "def"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetMinimalDefForDevice",
          "args": [
            "dev"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_INTERFACE",
            "_(\"couldn't find interface named '%s'\")",
            "name"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"couldn't find interface named '%s'\""
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "968-1074",
          "snippet": "static virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include <libudev.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_new_from_subsystem_sysname",
          "args": [
            "udev",
            "\"net\"",
            "name"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_ref",
          "args": [
            "driver->udev"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic struct udev_iface_driver *driver;\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic virInterfacePtr\nudevInterfaceLookupByName(virConnectPtr conn, const char *name)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    struct udev_device *dev;\n    virInterfacePtr ret = NULL;\n    virInterfaceDefPtr def = NULL;\n\n    /* get a device reference based on the device name */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"),\n                       name);\n        goto cleanup;\n    }\n\n    if (!(def = udevGetMinimalDefForDevice(dev)))\n        goto cleanup;\n\n    if (virInterfaceLookupByNameEnsureACL(conn, def) < 0)\n       goto cleanup;\n\n    ret = virGetInterface(conn, def->name, def->mac);\n    udev_device_unref(dev);\n\n cleanup:\n    udev_unref(udev);\n    virInterfaceDefFree(def);\n\n    return ret;\n}"
  },
  {
    "function_name": "udevConnectListAllInterfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "302-431",
    "snippet": "static int\nudevConnectListAllInterfaces(virConnectPtr conn,\n                             virInterfacePtr **ifaces,\n                             unsigned int flags)\n{\n    struct udev *udev;\n    struct udev_enumerate *enumerate = NULL;\n    struct udev_list_entry *devices;\n    struct udev_list_entry *dev_entry;\n    virInterfacePtr *ifaces_list = NULL;\n    virInterfacePtr iface_obj;\n    int tmp_count;\n    int count = 0;\n    int status = 0;\n    int ret;\n\n    virCheckFlags(VIR_CONNECT_LIST_INTERFACES_FILTERS_ACTIVE, -1);\n\n    if (virConnectListAllInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    /* Grab a udev reference */\n    udev = udev_ref(driver->udev);\n\n    /* List all interfaces in case we support more filter flags in the future */\n    enumerate = udevGetDevices(udev, VIR_UDEV_IFACE_ALL);\n\n    if (!enumerate) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get list of %s interfaces on host\"),\n                       virUdevStatusString(status));\n        ret = -1;\n        goto cleanup;\n    }\n\n    /* Do the scan to load up the enumeration */\n    udev_enumerate_scan_devices(enumerate);\n\n    /* Get a list we can walk */\n    devices = udev_enumerate_get_list_entry(enumerate);\n\n    /* For each item so we can count */\n    udev_list_entry_foreach(dev_entry, devices) {\n        count++;\n    }\n\n    /* If we've got nothing, exit out */\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* If we're asked for the ifaces then alloc up memory */\n    if (ifaces && VIR_ALLOC_N(ifaces_list, count + 1) < 0) {\n        ret = -1;\n        goto cleanup;\n    }\n\n    /* Get a list we can walk */\n    devices = udev_enumerate_get_list_entry(enumerate);\n\n    /* reset our iterator */\n    count = 0;\n\n    /* Walk through each device */\n    udev_list_entry_foreach(dev_entry, devices) {\n        struct udev_device *dev;\n        const char *path;\n        const char *name;\n        const char *macaddr;\n        virInterfaceDefPtr def;\n\n        path = udev_list_entry_get_name(dev_entry);\n        dev = udev_device_new_from_syspath(udev, path);\n        name = udev_device_get_sysname(dev);\n        macaddr = udev_device_get_sysattr_value(dev, \"address\");\n        status = STREQ(udev_device_get_sysattr_value(dev, \"operstate\"), \"up\");\n\n        def = udevGetMinimalDefForDevice(dev);\n        if (!virConnectListAllInterfacesCheckACL(conn, def)) {\n            udev_device_unref(dev);\n            virInterfaceDefFree(def);\n            continue;\n        }\n        virInterfaceDefFree(def);\n\n        /* Filter the results */\n        if (MATCH(VIR_CONNECT_LIST_INTERFACES_FILTERS_ACTIVE) &&\n            !((MATCH(VIR_CONNECT_LIST_INTERFACES_ACTIVE) && status) ||\n              (MATCH(VIR_CONNECT_LIST_INTERFACES_INACTIVE) && !status))) {\n            udev_device_unref(dev);\n            continue;\n        }\n\n        /* If we matched a filter, then add it */\n        if (ifaces) {\n            iface_obj = virGetInterface(conn, name, macaddr);\n            ifaces_list[count++] = iface_obj;\n        }\n        udev_device_unref(dev);\n    }\n\n    /* Drop our refcounts */\n    udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    /* Trim the array to its final size */\n    if (ifaces) {\n        ignore_value(VIR_REALLOC_N(ifaces_list, count + 1));\n        *ifaces = ifaces_list;\n        ifaces_list = NULL;\n    }\n\n    return count;\n\n cleanup:\n    if (enumerate)\n        udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    if (ifaces) {\n        for (tmp_count = 0; tmp_count < count; tmp_count++)\n            virObjectUnref(ifaces_list[tmp_count]);\n    }\n\n    VIR_FREE(ifaces_list);\n\n    return ret;\n\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct udev_iface_driver *driver;",
      "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ifaces_list"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "ifaces_list[tmp_count]"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_unref",
          "args": [
            "udev"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_unref",
          "args": [
            "enumerate"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "VIR_REALLOC_N(ifaces_list, count + 1)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "ifaces_list",
            "count + 1"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_unref",
          "args": [
            "udev"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_unref",
          "args": [
            "enumerate"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_unref",
          "args": [
            "dev"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetInterface",
          "args": [
            "conn",
            "name",
            "macaddr"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "virGetInterface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "460-488",
          "snippet": "virInterfacePtr\nvirGetInterface(virConnectPtr conn, const char *name, const char *mac)\n{\n    virInterfacePtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n\n    /* a NULL mac from caller is okay. Treat it as blank */\n    if (mac == NULL)\n       mac = \"\";\n\n    if (!(ret = virObjectNew(virInterfaceClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n    ret->mac = g_strdup(mac);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virInterfaceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virInterfaceClass;\n\nvirInterfacePtr\nvirGetInterface(virConnectPtr conn, const char *name, const char *mac)\n{\n    virInterfacePtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n\n    /* a NULL mac from caller is okay. Treat it as blank */\n    if (mac == NULL)\n       mac = \"\";\n\n    if (!(ret = virObjectNew(virInterfaceClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n    ret->mac = g_strdup(mac);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_unref",
          "args": [
            "dev"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_INTERFACES_INACTIVE"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_INTERFACES_ACTIVE"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_INTERFACES_FILTERS_ACTIVE"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "def"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_unref",
          "args": [
            "dev"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConnectListAllInterfacesCheckACL",
          "args": [
            "conn",
            "def"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetMinimalDefForDevice",
          "args": [
            "dev"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "udev_device_get_sysattr_value(dev, \"operstate\")",
            "\"up\""
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "dev",
            "\"operstate\""
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "dev",
            "\"address\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysname",
          "args": [
            "dev"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_new_from_syspath",
          "args": [
            "udev",
            "path"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_list_entry_get_name",
          "args": [
            "dev_entry"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_list_entry_foreach",
          "args": [
            "dev_entry",
            "devices"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_get_list_entry",
          "args": [
            "enumerate"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "ifaces_list",
            "count + 1"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_list_entry_foreach",
          "args": [
            "dev_entry",
            "devices"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_get_list_entry",
          "args": [
            "enumerate"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_scan_devices",
          "args": [
            "enumerate"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to get list of %s interfaces on host\")",
            "virUdevStatusString(status)"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUdevStatusString",
          "args": [
            "status"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "virUdevStatusString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "63-76",
          "snippet": "static const char *\nvirUdevStatusString(virUdevStatus status)\n{\n    switch (status) {\n        case VIR_UDEV_IFACE_ACTIVE:\n            return \"active\";\n        case VIR_UDEV_IFACE_INACTIVE:\n            return \"inactive\";\n        case VIR_UDEV_IFACE_ALL:\n            return \"all\";\n    }\n\n    return \"\";\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include <libudev.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic const char *\nvirUdevStatusString(virUdevStatus status)\n{\n    switch (status) {\n        case VIR_UDEV_IFACE_ACTIVE:\n            return \"active\";\n        case VIR_UDEV_IFACE_INACTIVE:\n            return \"inactive\";\n        case VIR_UDEV_IFACE_ALL:\n            return \"all\";\n    }\n\n    return \"\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to get list of %s interfaces on host\""
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "968-1074",
          "snippet": "static virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include <libudev.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetDevices",
          "args": [
            "udev",
            "VIR_UDEV_IFACE_ALL"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_ref",
          "args": [
            "driver->udev"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConnectListAllInterfacesEnsureACL",
          "args": [
            "conn"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_CONNECT_LIST_INTERFACES_FILTERS_ACTIVE",
            "-1"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic struct udev_iface_driver *driver;\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic int\nudevConnectListAllInterfaces(virConnectPtr conn,\n                             virInterfacePtr **ifaces,\n                             unsigned int flags)\n{\n    struct udev *udev;\n    struct udev_enumerate *enumerate = NULL;\n    struct udev_list_entry *devices;\n    struct udev_list_entry *dev_entry;\n    virInterfacePtr *ifaces_list = NULL;\n    virInterfacePtr iface_obj;\n    int tmp_count;\n    int count = 0;\n    int status = 0;\n    int ret;\n\n    virCheckFlags(VIR_CONNECT_LIST_INTERFACES_FILTERS_ACTIVE, -1);\n\n    if (virConnectListAllInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    /* Grab a udev reference */\n    udev = udev_ref(driver->udev);\n\n    /* List all interfaces in case we support more filter flags in the future */\n    enumerate = udevGetDevices(udev, VIR_UDEV_IFACE_ALL);\n\n    if (!enumerate) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get list of %s interfaces on host\"),\n                       virUdevStatusString(status));\n        ret = -1;\n        goto cleanup;\n    }\n\n    /* Do the scan to load up the enumeration */\n    udev_enumerate_scan_devices(enumerate);\n\n    /* Get a list we can walk */\n    devices = udev_enumerate_get_list_entry(enumerate);\n\n    /* For each item so we can count */\n    udev_list_entry_foreach(dev_entry, devices) {\n        count++;\n    }\n\n    /* If we've got nothing, exit out */\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* If we're asked for the ifaces then alloc up memory */\n    if (ifaces && VIR_ALLOC_N(ifaces_list, count + 1) < 0) {\n        ret = -1;\n        goto cleanup;\n    }\n\n    /* Get a list we can walk */\n    devices = udev_enumerate_get_list_entry(enumerate);\n\n    /* reset our iterator */\n    count = 0;\n\n    /* Walk through each device */\n    udev_list_entry_foreach(dev_entry, devices) {\n        struct udev_device *dev;\n        const char *path;\n        const char *name;\n        const char *macaddr;\n        virInterfaceDefPtr def;\n\n        path = udev_list_entry_get_name(dev_entry);\n        dev = udev_device_new_from_syspath(udev, path);\n        name = udev_device_get_sysname(dev);\n        macaddr = udev_device_get_sysattr_value(dev, \"address\");\n        status = STREQ(udev_device_get_sysattr_value(dev, \"operstate\"), \"up\");\n\n        def = udevGetMinimalDefForDevice(dev);\n        if (!virConnectListAllInterfacesCheckACL(conn, def)) {\n            udev_device_unref(dev);\n            virInterfaceDefFree(def);\n            continue;\n        }\n        virInterfaceDefFree(def);\n\n        /* Filter the results */\n        if (MATCH(VIR_CONNECT_LIST_INTERFACES_FILTERS_ACTIVE) &&\n            !((MATCH(VIR_CONNECT_LIST_INTERFACES_ACTIVE) && status) ||\n              (MATCH(VIR_CONNECT_LIST_INTERFACES_INACTIVE) && !status))) {\n            udev_device_unref(dev);\n            continue;\n        }\n\n        /* If we matched a filter, then add it */\n        if (ifaces) {\n            iface_obj = virGetInterface(conn, name, macaddr);\n            ifaces_list[count++] = iface_obj;\n        }\n        udev_device_unref(dev);\n    }\n\n    /* Drop our refcounts */\n    udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    /* Trim the array to its final size */\n    if (ifaces) {\n        ignore_value(VIR_REALLOC_N(ifaces_list, count + 1));\n        *ifaces = ifaces_list;\n        ifaces_list = NULL;\n    }\n\n    return count;\n\n cleanup:\n    if (enumerate)\n        udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    if (ifaces) {\n        for (tmp_count = 0; tmp_count < count; tmp_count++)\n            virObjectUnref(ifaces_list[tmp_count]);\n    }\n\n    VIR_FREE(ifaces_list);\n\n    return ret;\n\n}"
  },
  {
    "function_name": "udevConnectListDefinedInterfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "288-299",
    "snippet": "static int\nudevConnectListDefinedInterfaces(virConnectPtr conn,\n                                 char **const names,\n                                 int names_len)\n{\n    if (virConnectListDefinedInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    return udevListInterfacesByStatus(conn, names, names_len,\n                                      VIR_UDEV_IFACE_INACTIVE,\n                                      virConnectListDefinedInterfacesCheckACL);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevListInterfacesByStatus",
          "args": [
            "conn",
            "names",
            "names_len",
            "VIR_UDEV_IFACE_INACTIVE",
            "virConnectListDefinedInterfacesCheckACL"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "udevListInterfacesByStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "189-253",
          "snippet": "static int\nudevListInterfacesByStatus(virConnectPtr conn,\n                           char **const names,\n                           int names_len,\n                           virUdevStatus status,\n                           virInterfaceObjListFilter filter)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    struct udev_enumerate *enumerate = NULL;\n    struct udev_list_entry *devices;\n    struct udev_list_entry *dev_entry;\n    int count = 0;\n\n    enumerate = udevGetDevices(udev, status);\n\n    if (!enumerate) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get list of %s interfaces on host\"),\n                       virUdevStatusString(status));\n        goto error;\n    }\n\n    /* Do the scan to load up the enumeration */\n    udev_enumerate_scan_devices(enumerate);\n\n    /* Get a list we can walk */\n    devices = udev_enumerate_get_list_entry(enumerate);\n\n    /* For each item so we can count */\n    udev_list_entry_foreach(dev_entry, devices) {\n        struct udev_device *dev;\n        const char *path;\n        virInterfaceDefPtr def;\n\n        /* Ensure we won't exceed the size of our array */\n        if (count > names_len)\n            break;\n\n        path = udev_list_entry_get_name(dev_entry);\n        dev = udev_device_new_from_syspath(udev, path);\n\n        def = udevGetMinimalDefForDevice(dev);\n        if (filter(conn, def)) {\n            names[count] = g_strdup(udev_device_get_sysname(dev));\n            count++;\n        }\n        udev_device_unref(dev);\n        virInterfaceDefFree(def);\n    }\n\n    udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    return count;\n\n error:\n    if (enumerate)\n        udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    for (names_len = 0; names_len < count; names_len++)\n        VIR_FREE(names[names_len]);\n\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include <libudev.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct udev_iface_driver *driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic struct udev_iface_driver *driver;\n\nstatic int\nudevListInterfacesByStatus(virConnectPtr conn,\n                           char **const names,\n                           int names_len,\n                           virUdevStatus status,\n                           virInterfaceObjListFilter filter)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    struct udev_enumerate *enumerate = NULL;\n    struct udev_list_entry *devices;\n    struct udev_list_entry *dev_entry;\n    int count = 0;\n\n    enumerate = udevGetDevices(udev, status);\n\n    if (!enumerate) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get list of %s interfaces on host\"),\n                       virUdevStatusString(status));\n        goto error;\n    }\n\n    /* Do the scan to load up the enumeration */\n    udev_enumerate_scan_devices(enumerate);\n\n    /* Get a list we can walk */\n    devices = udev_enumerate_get_list_entry(enumerate);\n\n    /* For each item so we can count */\n    udev_list_entry_foreach(dev_entry, devices) {\n        struct udev_device *dev;\n        const char *path;\n        virInterfaceDefPtr def;\n\n        /* Ensure we won't exceed the size of our array */\n        if (count > names_len)\n            break;\n\n        path = udev_list_entry_get_name(dev_entry);\n        dev = udev_device_new_from_syspath(udev, path);\n\n        def = udevGetMinimalDefForDevice(dev);\n        if (filter(conn, def)) {\n            names[count] = g_strdup(udev_device_get_sysname(dev));\n            count++;\n        }\n        udev_device_unref(dev);\n        virInterfaceDefFree(def);\n    }\n\n    udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    return count;\n\n error:\n    if (enumerate)\n        udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    for (names_len = 0; names_len < count; names_len++)\n        VIR_FREE(names[names_len]);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectListDefinedInterfacesEnsureACL",
          "args": [
            "conn"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nudevConnectListDefinedInterfaces(virConnectPtr conn,\n                                 char **const names,\n                                 int names_len)\n{\n    if (virConnectListDefinedInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    return udevListInterfacesByStatus(conn, names, names_len,\n                                      VIR_UDEV_IFACE_INACTIVE,\n                                      virConnectListDefinedInterfacesCheckACL);\n}"
  },
  {
    "function_name": "udevConnectNumOfDefinedInterfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "278-286",
    "snippet": "static int\nudevConnectNumOfDefinedInterfaces(virConnectPtr conn)\n{\n    if (virConnectNumOfDefinedInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    return udevNumOfInterfacesByStatus(conn, VIR_UDEV_IFACE_INACTIVE,\n                                       virConnectNumOfDefinedInterfacesCheckACL);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevNumOfInterfacesByStatus",
          "args": [
            "conn",
            "VIR_UDEV_IFACE_INACTIVE",
            "virConnectNumOfDefinedInterfacesCheckACL"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "udevNumOfInterfacesByStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "139-187",
          "snippet": "static int\nudevNumOfInterfacesByStatus(virConnectPtr conn, virUdevStatus status,\n                            virInterfaceObjListFilter filter)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    struct udev_enumerate *enumerate = NULL;\n    struct udev_list_entry *devices;\n    struct udev_list_entry *dev_entry;\n    int count = 0;\n\n    enumerate = udevGetDevices(udev, status);\n\n    if (!enumerate) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get number of %s interfaces on host\"),\n                       virUdevStatusString(status));\n        count = -1;\n        goto cleanup;\n    }\n\n    /* Do the scan to load up the enumeration */\n    udev_enumerate_scan_devices(enumerate);\n\n    /* Get a list we can walk */\n    devices = udev_enumerate_get_list_entry(enumerate);\n\n    /* For each item so we can count */\n    udev_list_entry_foreach(dev_entry, devices) {\n        struct udev_device *dev;\n        const char *path;\n        virInterfaceDefPtr def;\n\n        path = udev_list_entry_get_name(dev_entry);\n        dev = udev_device_new_from_syspath(udev, path);\n\n        def = udevGetMinimalDefForDevice(dev);\n        if (filter(conn, def))\n            count++;\n        udev_device_unref(dev);\n        virInterfaceDefFree(def);\n    }\n\n cleanup:\n    if (enumerate)\n        udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    return count;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include <libudev.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct udev_iface_driver *driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic struct udev_iface_driver *driver;\n\nstatic int\nudevNumOfInterfacesByStatus(virConnectPtr conn, virUdevStatus status,\n                            virInterfaceObjListFilter filter)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    struct udev_enumerate *enumerate = NULL;\n    struct udev_list_entry *devices;\n    struct udev_list_entry *dev_entry;\n    int count = 0;\n\n    enumerate = udevGetDevices(udev, status);\n\n    if (!enumerate) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get number of %s interfaces on host\"),\n                       virUdevStatusString(status));\n        count = -1;\n        goto cleanup;\n    }\n\n    /* Do the scan to load up the enumeration */\n    udev_enumerate_scan_devices(enumerate);\n\n    /* Get a list we can walk */\n    devices = udev_enumerate_get_list_entry(enumerate);\n\n    /* For each item so we can count */\n    udev_list_entry_foreach(dev_entry, devices) {\n        struct udev_device *dev;\n        const char *path;\n        virInterfaceDefPtr def;\n\n        path = udev_list_entry_get_name(dev_entry);\n        dev = udev_device_new_from_syspath(udev, path);\n\n        def = udevGetMinimalDefForDevice(dev);\n        if (filter(conn, def))\n            count++;\n        udev_device_unref(dev);\n        virInterfaceDefFree(def);\n    }\n\n cleanup:\n    if (enumerate)\n        udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    return count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectNumOfDefinedInterfacesEnsureACL",
          "args": [
            "conn"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nudevConnectNumOfDefinedInterfaces(virConnectPtr conn)\n{\n    if (virConnectNumOfDefinedInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    return udevNumOfInterfacesByStatus(conn, VIR_UDEV_IFACE_INACTIVE,\n                                       virConnectNumOfDefinedInterfacesCheckACL);\n}"
  },
  {
    "function_name": "udevConnectListInterfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "265-276",
    "snippet": "static int\nudevConnectListInterfaces(virConnectPtr conn,\n                          char **const names,\n                          int names_len)\n{\n    if (virConnectListInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    return udevListInterfacesByStatus(conn, names, names_len,\n                                      VIR_UDEV_IFACE_ACTIVE,\n                                      virConnectListInterfacesCheckACL);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevListInterfacesByStatus",
          "args": [
            "conn",
            "names",
            "names_len",
            "VIR_UDEV_IFACE_ACTIVE",
            "virConnectListInterfacesCheckACL"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "udevListInterfacesByStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "189-253",
          "snippet": "static int\nudevListInterfacesByStatus(virConnectPtr conn,\n                           char **const names,\n                           int names_len,\n                           virUdevStatus status,\n                           virInterfaceObjListFilter filter)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    struct udev_enumerate *enumerate = NULL;\n    struct udev_list_entry *devices;\n    struct udev_list_entry *dev_entry;\n    int count = 0;\n\n    enumerate = udevGetDevices(udev, status);\n\n    if (!enumerate) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get list of %s interfaces on host\"),\n                       virUdevStatusString(status));\n        goto error;\n    }\n\n    /* Do the scan to load up the enumeration */\n    udev_enumerate_scan_devices(enumerate);\n\n    /* Get a list we can walk */\n    devices = udev_enumerate_get_list_entry(enumerate);\n\n    /* For each item so we can count */\n    udev_list_entry_foreach(dev_entry, devices) {\n        struct udev_device *dev;\n        const char *path;\n        virInterfaceDefPtr def;\n\n        /* Ensure we won't exceed the size of our array */\n        if (count > names_len)\n            break;\n\n        path = udev_list_entry_get_name(dev_entry);\n        dev = udev_device_new_from_syspath(udev, path);\n\n        def = udevGetMinimalDefForDevice(dev);\n        if (filter(conn, def)) {\n            names[count] = g_strdup(udev_device_get_sysname(dev));\n            count++;\n        }\n        udev_device_unref(dev);\n        virInterfaceDefFree(def);\n    }\n\n    udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    return count;\n\n error:\n    if (enumerate)\n        udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    for (names_len = 0; names_len < count; names_len++)\n        VIR_FREE(names[names_len]);\n\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include <libudev.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct udev_iface_driver *driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic struct udev_iface_driver *driver;\n\nstatic int\nudevListInterfacesByStatus(virConnectPtr conn,\n                           char **const names,\n                           int names_len,\n                           virUdevStatus status,\n                           virInterfaceObjListFilter filter)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    struct udev_enumerate *enumerate = NULL;\n    struct udev_list_entry *devices;\n    struct udev_list_entry *dev_entry;\n    int count = 0;\n\n    enumerate = udevGetDevices(udev, status);\n\n    if (!enumerate) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get list of %s interfaces on host\"),\n                       virUdevStatusString(status));\n        goto error;\n    }\n\n    /* Do the scan to load up the enumeration */\n    udev_enumerate_scan_devices(enumerate);\n\n    /* Get a list we can walk */\n    devices = udev_enumerate_get_list_entry(enumerate);\n\n    /* For each item so we can count */\n    udev_list_entry_foreach(dev_entry, devices) {\n        struct udev_device *dev;\n        const char *path;\n        virInterfaceDefPtr def;\n\n        /* Ensure we won't exceed the size of our array */\n        if (count > names_len)\n            break;\n\n        path = udev_list_entry_get_name(dev_entry);\n        dev = udev_device_new_from_syspath(udev, path);\n\n        def = udevGetMinimalDefForDevice(dev);\n        if (filter(conn, def)) {\n            names[count] = g_strdup(udev_device_get_sysname(dev));\n            count++;\n        }\n        udev_device_unref(dev);\n        virInterfaceDefFree(def);\n    }\n\n    udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    return count;\n\n error:\n    if (enumerate)\n        udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    for (names_len = 0; names_len < count; names_len++)\n        VIR_FREE(names[names_len]);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectListInterfacesEnsureACL",
          "args": [
            "conn"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nudevConnectListInterfaces(virConnectPtr conn,\n                          char **const names,\n                          int names_len)\n{\n    if (virConnectListInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    return udevListInterfacesByStatus(conn, names, names_len,\n                                      VIR_UDEV_IFACE_ACTIVE,\n                                      virConnectListInterfacesCheckACL);\n}"
  },
  {
    "function_name": "udevConnectNumOfInterfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "255-263",
    "snippet": "static int\nudevConnectNumOfInterfaces(virConnectPtr conn)\n{\n    if (virConnectNumOfInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    return udevNumOfInterfacesByStatus(conn, VIR_UDEV_IFACE_ACTIVE,\n                                       virConnectNumOfInterfacesCheckACL);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevNumOfInterfacesByStatus",
          "args": [
            "conn",
            "VIR_UDEV_IFACE_ACTIVE",
            "virConnectNumOfInterfacesCheckACL"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "udevNumOfInterfacesByStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "139-187",
          "snippet": "static int\nudevNumOfInterfacesByStatus(virConnectPtr conn, virUdevStatus status,\n                            virInterfaceObjListFilter filter)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    struct udev_enumerate *enumerate = NULL;\n    struct udev_list_entry *devices;\n    struct udev_list_entry *dev_entry;\n    int count = 0;\n\n    enumerate = udevGetDevices(udev, status);\n\n    if (!enumerate) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get number of %s interfaces on host\"),\n                       virUdevStatusString(status));\n        count = -1;\n        goto cleanup;\n    }\n\n    /* Do the scan to load up the enumeration */\n    udev_enumerate_scan_devices(enumerate);\n\n    /* Get a list we can walk */\n    devices = udev_enumerate_get_list_entry(enumerate);\n\n    /* For each item so we can count */\n    udev_list_entry_foreach(dev_entry, devices) {\n        struct udev_device *dev;\n        const char *path;\n        virInterfaceDefPtr def;\n\n        path = udev_list_entry_get_name(dev_entry);\n        dev = udev_device_new_from_syspath(udev, path);\n\n        def = udevGetMinimalDefForDevice(dev);\n        if (filter(conn, def))\n            count++;\n        udev_device_unref(dev);\n        virInterfaceDefFree(def);\n    }\n\n cleanup:\n    if (enumerate)\n        udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    return count;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include <libudev.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct udev_iface_driver *driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic struct udev_iface_driver *driver;\n\nstatic int\nudevNumOfInterfacesByStatus(virConnectPtr conn, virUdevStatus status,\n                            virInterfaceObjListFilter filter)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    struct udev_enumerate *enumerate = NULL;\n    struct udev_list_entry *devices;\n    struct udev_list_entry *dev_entry;\n    int count = 0;\n\n    enumerate = udevGetDevices(udev, status);\n\n    if (!enumerate) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get number of %s interfaces on host\"),\n                       virUdevStatusString(status));\n        count = -1;\n        goto cleanup;\n    }\n\n    /* Do the scan to load up the enumeration */\n    udev_enumerate_scan_devices(enumerate);\n\n    /* Get a list we can walk */\n    devices = udev_enumerate_get_list_entry(enumerate);\n\n    /* For each item so we can count */\n    udev_list_entry_foreach(dev_entry, devices) {\n        struct udev_device *dev;\n        const char *path;\n        virInterfaceDefPtr def;\n\n        path = udev_list_entry_get_name(dev_entry);\n        dev = udev_device_new_from_syspath(udev, path);\n\n        def = udevGetMinimalDefForDevice(dev);\n        if (filter(conn, def))\n            count++;\n        udev_device_unref(dev);\n        virInterfaceDefFree(def);\n    }\n\n cleanup:\n    if (enumerate)\n        udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    return count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectNumOfInterfacesEnsureACL",
          "args": [
            "conn"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nudevConnectNumOfInterfaces(virConnectPtr conn)\n{\n    if (virConnectNumOfInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    return udevNumOfInterfacesByStatus(conn, VIR_UDEV_IFACE_ACTIVE,\n                                       virConnectNumOfInterfacesCheckACL);\n}"
  },
  {
    "function_name": "udevListInterfacesByStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "189-253",
    "snippet": "static int\nudevListInterfacesByStatus(virConnectPtr conn,\n                           char **const names,\n                           int names_len,\n                           virUdevStatus status,\n                           virInterfaceObjListFilter filter)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    struct udev_enumerate *enumerate = NULL;\n    struct udev_list_entry *devices;\n    struct udev_list_entry *dev_entry;\n    int count = 0;\n\n    enumerate = udevGetDevices(udev, status);\n\n    if (!enumerate) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get list of %s interfaces on host\"),\n                       virUdevStatusString(status));\n        goto error;\n    }\n\n    /* Do the scan to load up the enumeration */\n    udev_enumerate_scan_devices(enumerate);\n\n    /* Get a list we can walk */\n    devices = udev_enumerate_get_list_entry(enumerate);\n\n    /* For each item so we can count */\n    udev_list_entry_foreach(dev_entry, devices) {\n        struct udev_device *dev;\n        const char *path;\n        virInterfaceDefPtr def;\n\n        /* Ensure we won't exceed the size of our array */\n        if (count > names_len)\n            break;\n\n        path = udev_list_entry_get_name(dev_entry);\n        dev = udev_device_new_from_syspath(udev, path);\n\n        def = udevGetMinimalDefForDevice(dev);\n        if (filter(conn, def)) {\n            names[count] = g_strdup(udev_device_get_sysname(dev));\n            count++;\n        }\n        udev_device_unref(dev);\n        virInterfaceDefFree(def);\n    }\n\n    udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    return count;\n\n error:\n    if (enumerate)\n        udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    for (names_len = 0; names_len < count; names_len++)\n        VIR_FREE(names[names_len]);\n\n    return -1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct udev_iface_driver *driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "names[names_len]"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_unref",
          "args": [
            "udev"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_unref",
          "args": [
            "enumerate"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_unref",
          "args": [
            "udev"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_unref",
          "args": [
            "enumerate"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "def"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_unref",
          "args": [
            "dev"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "udev_device_get_sysname(dev)"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysname",
          "args": [
            "dev"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter",
          "args": [
            "conn",
            "def"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "make_nonnull_nwfilter_binding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_dispatch.c",
          "lines": "7368-7373",
          "snippet": "static void\nmake_nonnull_nwfilter_binding(remote_nonnull_nwfilter_binding *binding_dst, virNWFilterBindingPtr binding_src)\n{\n    binding_dst->portdev = g_strdup(binding_src->portdev);\n    binding_dst->filtername = g_strdup(binding_src->filtername);\n}",
          "includes": [
            "#include \"lxc_daemon_dispatch_stubs.h\"",
            "#include \"qemu_daemon_dispatch_stubs.h\"",
            "#include \"remote_daemon_dispatch_stubs.h\"",
            "#include \"access/viraccessapicheck.h\"",
            "#include \"configmake.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virpolkit.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virprobe.h\"",
            "#include \"network_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"object_event.h\"",
            "#include \"virstring.h\"",
            "#include \"lxc_protocol.h\"",
            "#include \"qemu_protocol.h\"",
            "#include \"remote_protocol.h\"",
            "#include \"virprocess.h\"",
            "#include \"virdbus.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virnetserverservice.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void make_nonnull_nwfilter_binding(remote_nonnull_nwfilter_binding *binding_dst, virNWFilterBindingPtr binding_src);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc_daemon_dispatch_stubs.h\"\n#include \"qemu_daemon_dispatch_stubs.h\"\n#include \"remote_daemon_dispatch_stubs.h\"\n#include \"access/viraccessapicheck.h\"\n#include \"configmake.h\"\n#include \"virthreadjob.h\"\n#include \"virpolkit.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virprobe.h\"\n#include \"network_conf.h\"\n#include \"domain_conf.h\"\n#include \"object_event.h\"\n#include \"virstring.h\"\n#include \"lxc_protocol.h\"\n#include \"qemu_protocol.h\"\n#include \"remote_protocol.h\"\n#include \"virprocess.h\"\n#include \"virdbus.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virnetserver.h\"\n#include \"virnetserverservice.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"remote_daemon_stream.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"libvirt_internal.h\"\n#include \"remote_daemon.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic void make_nonnull_nwfilter_binding(remote_nonnull_nwfilter_binding *binding_dst, virNWFilterBindingPtr binding_src);\n\nstatic void\nmake_nonnull_nwfilter_binding(remote_nonnull_nwfilter_binding *binding_dst, virNWFilterBindingPtr binding_src)\n{\n    binding_dst->portdev = g_strdup(binding_src->portdev);\n    binding_dst->filtername = g_strdup(binding_src->filtername);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetMinimalDefForDevice",
          "args": [
            "dev"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_new_from_syspath",
          "args": [
            "udev",
            "path"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_list_entry_get_name",
          "args": [
            "dev_entry"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_list_entry_foreach",
          "args": [
            "dev_entry",
            "devices"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_get_list_entry",
          "args": [
            "enumerate"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_scan_devices",
          "args": [
            "enumerate"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to get list of %s interfaces on host\")",
            "virUdevStatusString(status)"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUdevStatusString",
          "args": [
            "status"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "virUdevStatusString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "63-76",
          "snippet": "static const char *\nvirUdevStatusString(virUdevStatus status)\n{\n    switch (status) {\n        case VIR_UDEV_IFACE_ACTIVE:\n            return \"active\";\n        case VIR_UDEV_IFACE_INACTIVE:\n            return \"inactive\";\n        case VIR_UDEV_IFACE_ALL:\n            return \"all\";\n    }\n\n    return \"\";\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include <libudev.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic const char *\nvirUdevStatusString(virUdevStatus status)\n{\n    switch (status) {\n        case VIR_UDEV_IFACE_ACTIVE:\n            return \"active\";\n        case VIR_UDEV_IFACE_INACTIVE:\n            return \"inactive\";\n        case VIR_UDEV_IFACE_ALL:\n            return \"all\";\n    }\n\n    return \"\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to get list of %s interfaces on host\""
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "968-1074",
          "snippet": "static virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include <libudev.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetDevices",
          "args": [
            "udev",
            "status"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_ref",
          "args": [
            "driver->udev"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic struct udev_iface_driver *driver;\n\nstatic int\nudevListInterfacesByStatus(virConnectPtr conn,\n                           char **const names,\n                           int names_len,\n                           virUdevStatus status,\n                           virInterfaceObjListFilter filter)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    struct udev_enumerate *enumerate = NULL;\n    struct udev_list_entry *devices;\n    struct udev_list_entry *dev_entry;\n    int count = 0;\n\n    enumerate = udevGetDevices(udev, status);\n\n    if (!enumerate) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get list of %s interfaces on host\"),\n                       virUdevStatusString(status));\n        goto error;\n    }\n\n    /* Do the scan to load up the enumeration */\n    udev_enumerate_scan_devices(enumerate);\n\n    /* Get a list we can walk */\n    devices = udev_enumerate_get_list_entry(enumerate);\n\n    /* For each item so we can count */\n    udev_list_entry_foreach(dev_entry, devices) {\n        struct udev_device *dev;\n        const char *path;\n        virInterfaceDefPtr def;\n\n        /* Ensure we won't exceed the size of our array */\n        if (count > names_len)\n            break;\n\n        path = udev_list_entry_get_name(dev_entry);\n        dev = udev_device_new_from_syspath(udev, path);\n\n        def = udevGetMinimalDefForDevice(dev);\n        if (filter(conn, def)) {\n            names[count] = g_strdup(udev_device_get_sysname(dev));\n            count++;\n        }\n        udev_device_unref(dev);\n        virInterfaceDefFree(def);\n    }\n\n    udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    return count;\n\n error:\n    if (enumerate)\n        udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    for (names_len = 0; names_len < count; names_len++)\n        VIR_FREE(names[names_len]);\n\n    return -1;\n}"
  },
  {
    "function_name": "udevNumOfInterfacesByStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "139-187",
    "snippet": "static int\nudevNumOfInterfacesByStatus(virConnectPtr conn, virUdevStatus status,\n                            virInterfaceObjListFilter filter)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    struct udev_enumerate *enumerate = NULL;\n    struct udev_list_entry *devices;\n    struct udev_list_entry *dev_entry;\n    int count = 0;\n\n    enumerate = udevGetDevices(udev, status);\n\n    if (!enumerate) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get number of %s interfaces on host\"),\n                       virUdevStatusString(status));\n        count = -1;\n        goto cleanup;\n    }\n\n    /* Do the scan to load up the enumeration */\n    udev_enumerate_scan_devices(enumerate);\n\n    /* Get a list we can walk */\n    devices = udev_enumerate_get_list_entry(enumerate);\n\n    /* For each item so we can count */\n    udev_list_entry_foreach(dev_entry, devices) {\n        struct udev_device *dev;\n        const char *path;\n        virInterfaceDefPtr def;\n\n        path = udev_list_entry_get_name(dev_entry);\n        dev = udev_device_new_from_syspath(udev, path);\n\n        def = udevGetMinimalDefForDevice(dev);\n        if (filter(conn, def))\n            count++;\n        udev_device_unref(dev);\n        virInterfaceDefFree(def);\n    }\n\n cleanup:\n    if (enumerate)\n        udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    return count;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct udev_iface_driver *driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udev_unref",
          "args": [
            "udev"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_unref",
          "args": [
            "enumerate"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "def"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_unref",
          "args": [
            "dev"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter",
          "args": [
            "conn",
            "def"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "make_nonnull_nwfilter_binding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_dispatch.c",
          "lines": "7368-7373",
          "snippet": "static void\nmake_nonnull_nwfilter_binding(remote_nonnull_nwfilter_binding *binding_dst, virNWFilterBindingPtr binding_src)\n{\n    binding_dst->portdev = g_strdup(binding_src->portdev);\n    binding_dst->filtername = g_strdup(binding_src->filtername);\n}",
          "includes": [
            "#include \"lxc_daemon_dispatch_stubs.h\"",
            "#include \"qemu_daemon_dispatch_stubs.h\"",
            "#include \"remote_daemon_dispatch_stubs.h\"",
            "#include \"access/viraccessapicheck.h\"",
            "#include \"configmake.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virpolkit.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virprobe.h\"",
            "#include \"network_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"object_event.h\"",
            "#include \"virstring.h\"",
            "#include \"lxc_protocol.h\"",
            "#include \"qemu_protocol.h\"",
            "#include \"remote_protocol.h\"",
            "#include \"virprocess.h\"",
            "#include \"virdbus.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virnetserverservice.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void make_nonnull_nwfilter_binding(remote_nonnull_nwfilter_binding *binding_dst, virNWFilterBindingPtr binding_src);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc_daemon_dispatch_stubs.h\"\n#include \"qemu_daemon_dispatch_stubs.h\"\n#include \"remote_daemon_dispatch_stubs.h\"\n#include \"access/viraccessapicheck.h\"\n#include \"configmake.h\"\n#include \"virthreadjob.h\"\n#include \"virpolkit.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virprobe.h\"\n#include \"network_conf.h\"\n#include \"domain_conf.h\"\n#include \"object_event.h\"\n#include \"virstring.h\"\n#include \"lxc_protocol.h\"\n#include \"qemu_protocol.h\"\n#include \"remote_protocol.h\"\n#include \"virprocess.h\"\n#include \"virdbus.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virnetserver.h\"\n#include \"virnetserverservice.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"remote_daemon_stream.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"libvirt_internal.h\"\n#include \"remote_daemon.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic void make_nonnull_nwfilter_binding(remote_nonnull_nwfilter_binding *binding_dst, virNWFilterBindingPtr binding_src);\n\nstatic void\nmake_nonnull_nwfilter_binding(remote_nonnull_nwfilter_binding *binding_dst, virNWFilterBindingPtr binding_src)\n{\n    binding_dst->portdev = g_strdup(binding_src->portdev);\n    binding_dst->filtername = g_strdup(binding_src->filtername);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetMinimalDefForDevice",
          "args": [
            "dev"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_new_from_syspath",
          "args": [
            "udev",
            "path"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_list_entry_get_name",
          "args": [
            "dev_entry"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_list_entry_foreach",
          "args": [
            "dev_entry",
            "devices"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_get_list_entry",
          "args": [
            "enumerate"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_scan_devices",
          "args": [
            "enumerate"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to get number of %s interfaces on host\")",
            "virUdevStatusString(status)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUdevStatusString",
          "args": [
            "status"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "virUdevStatusString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "63-76",
          "snippet": "static const char *\nvirUdevStatusString(virUdevStatus status)\n{\n    switch (status) {\n        case VIR_UDEV_IFACE_ACTIVE:\n            return \"active\";\n        case VIR_UDEV_IFACE_INACTIVE:\n            return \"inactive\";\n        case VIR_UDEV_IFACE_ALL:\n            return \"all\";\n    }\n\n    return \"\";\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include <libudev.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic const char *\nvirUdevStatusString(virUdevStatus status)\n{\n    switch (status) {\n        case VIR_UDEV_IFACE_ACTIVE:\n            return \"active\";\n        case VIR_UDEV_IFACE_INACTIVE:\n            return \"inactive\";\n        case VIR_UDEV_IFACE_ALL:\n            return \"all\";\n    }\n\n    return \"\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to get number of %s interfaces on host\""
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
          "lines": "968-1074",
          "snippet": "static virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include <libudev.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetIfaceDef(struct udev *udev, const char *name)\n{\n    struct udev_device *dev = NULL;\n    virInterfaceDef *ifacedef;\n    unsigned int mtu;\n    const char *mtu_str;\n    char *vlan_parent_dev = NULL;\n    const char *devtype;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(ifacedef) < 0)\n        return NULL;\n\n    /* Clear our structure and set safe defaults */\n    ifacedef->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    ifacedef->name = g_strdup(name);\n\n    /* Lookup the device we've been asked about */\n    dev = udev_device_new_from_subsystem_sysname(udev, \"net\", name);\n    if (!dev) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface named '%s'\"), name);\n        goto error;\n    }\n\n    /* MAC address */\n    ifacedef->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    /* Link state and speed */\n    if (virNetDevGetLinkInfo(ifacedef->name, &ifacedef->lnk) < 0)\n        goto error;\n\n    /* MTU */\n    mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n    if (virStrToLong_ui(mtu_str, NULL, 10, &mtu) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Could not parse MTU value '%s'\"), mtu_str);\n        goto error;\n    }\n    ifacedef->mtu = mtu;\n\n    /* Number of IP protocols this interface has assigned */\n    /* XXX: Do we want a netlink query or a call out to ip or leave it? */\n    ifacedef->nprotos = 0;\n    ifacedef->protos = NULL;\n\n    /* Check the type of device we are working with based on the devtype */\n    devtype = udev_device_get_devtype(dev);\n\n    /* Set our type to ethernet as the default case */\n    ifacedef->type = VIR_INTERFACE_TYPE_ETHERNET;\n\n    if (STREQ_NULLABLE(devtype, \"vlan\")) {\n        /* This only works on modern kernels (3.7 and newer)\n         * e949b09b71d975a82f13ac88ce4ad338fed213da\n         */\n        ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n    } else if (STREQ_NULLABLE(devtype, \"bridge\")) {\n        ifacedef->type = VIR_INTERFACE_TYPE_BRIDGE;\n    } else if (STREQ_NULLABLE(devtype, \"bond\")) {\n        /* This only works on modern kernels (3.9 and newer) */\n        ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    /* Fallback checks if the devtype check didn't work. */\n    if (ifacedef->type == VIR_INTERFACE_TYPE_ETHERNET) {\n        /* First check if its a VLAN based on the name containing a dot,\n         * to prevent false positives\n         */\n        vlan_parent_dev = strrchr(name, '.');\n        if (vlan_parent_dev)\n            ifacedef->type = VIR_INTERFACE_TYPE_VLAN;\n\n        /* Fallback check to see if this is a bond device */\n        if (udev_device_get_sysattr_value(dev, \"bonding/mode\"))\n            ifacedef->type = VIR_INTERFACE_TYPE_BOND;\n    }\n\n    switch (ifacedef->type) {\n    case VIR_INTERFACE_TYPE_VLAN:\n        if (udevGetIfaceDefVlan(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BRIDGE:\n        if (udevGetIfaceDefBridge(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_BOND:\n        if (udevGetIfaceDefBond(udev, dev, name, ifacedef) < 0)\n            goto error;\n        break;\n    case VIR_INTERFACE_TYPE_ETHERNET:\n        break;\n    }\n\n    udev_device_unref(dev);\n\n    return ifacedef;\n\n error:\n    udev_device_unref(dev);\n\n    virInterfaceDefFree(ifacedef);\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetDevices",
          "args": [
            "udev",
            "status"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_ref",
          "args": [
            "driver->udev"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic struct udev_iface_driver *driver;\n\nstatic int\nudevNumOfInterfacesByStatus(virConnectPtr conn, virUdevStatus status,\n                            virInterfaceObjListFilter filter)\n{\n    struct udev *udev = udev_ref(driver->udev);\n    struct udev_enumerate *enumerate = NULL;\n    struct udev_list_entry *devices;\n    struct udev_list_entry *dev_entry;\n    int count = 0;\n\n    enumerate = udevGetDevices(udev, status);\n\n    if (!enumerate) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get number of %s interfaces on host\"),\n                       virUdevStatusString(status));\n        count = -1;\n        goto cleanup;\n    }\n\n    /* Do the scan to load up the enumeration */\n    udev_enumerate_scan_devices(enumerate);\n\n    /* Get a list we can walk */\n    devices = udev_enumerate_get_list_entry(enumerate);\n\n    /* For each item so we can count */\n    udev_list_entry_foreach(dev_entry, devices) {\n        struct udev_device *dev;\n        const char *path;\n        virInterfaceDefPtr def;\n\n        path = udev_list_entry_get_name(dev_entry);\n        dev = udev_device_new_from_syspath(udev, path);\n\n        def = udevGetMinimalDefForDevice(dev);\n        if (filter(conn, def))\n            count++;\n        udev_device_unref(dev);\n        virInterfaceDefFree(def);\n    }\n\n cleanup:\n    if (enumerate)\n        udev_enumerate_unref(enumerate);\n    udev_unref(udev);\n\n    return count;\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "99-137",
    "snippet": "static struct udev_enumerate * ATTRIBUTE_NONNULL(1)\nudevGetDevices(struct udev *udev, virUdevStatus status)\n{\n    struct udev_enumerate *enumerate;\n\n    /* Create a new enumeration to create a list */\n    enumerate = udev_enumerate_new(udev);\n\n    if (!enumerate)\n        return NULL;\n\n    /* Enumerate all network subsystem devices */\n    udev_enumerate_add_match_subsystem(enumerate, \"net\");\n\n    /* Ignore devices that are part of a bridge */\n    udev_enumerate_add_nomatch_sysattr(enumerate, \"brport/state\", NULL);\n\n    /* State of the device */\n    switch (status) {\n        case VIR_UDEV_IFACE_ACTIVE:\n            udev_enumerate_add_match_sysattr(enumerate, \"operstate\", \"up\");\n            break;\n\n        case VIR_UDEV_IFACE_INACTIVE:\n            udev_enumerate_add_match_sysattr(enumerate, \"operstate\", \"down\");\n            break;\n\n        case VIR_UDEV_IFACE_ALL:\n            break;\n    }\n\n    /* We don't want to see the TUN devices that QEMU creates for other guests\n     * running on this machine. By saying nomatch NULL, we just are getting\n     * devices without the tun_flags sysattr.\n     */\n    udev_enumerate_add_nomatch_sysattr(enumerate, \"tun_flags\", NULL);\n\n    return enumerate;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udev_enumerate_add_nomatch_sysattr",
          "args": [
            "enumerate",
            "\"tun_flags\"",
            "NULL"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_add_match_sysattr",
          "args": [
            "enumerate",
            "\"operstate\"",
            "\"down\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_add_match_sysattr",
          "args": [
            "enumerate",
            "\"operstate\"",
            "\"up\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_add_nomatch_sysattr",
          "args": [
            "enumerate",
            "\"brport/state\"",
            "NULL"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_add_match_subsystem",
          "args": [
            "enumerate",
            "\"net\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_new",
          "args": [
            "udev"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetDevices",
          "args": [
            "struct udev *udev",
            "virUdevStatusstatus"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic struct udev_enumerate * ATTRIBUTE_NONNULL(1)\nudevGetDevices(struct udev *udev, virUdevStatus status)\n{\n    struct udev_enumerate *enumerate;\n\n    /* Create a new enumeration to create a list */\n    enumerate = udev_enumerate_new(udev);\n\n    if (!enumerate)\n        return NULL;\n\n    /* Enumerate all network subsystem devices */\n    udev_enumerate_add_match_subsystem(enumerate, \"net\");\n\n    /* Ignore devices that are part of a bridge */\n    udev_enumerate_add_nomatch_sysattr(enumerate, \"brport/state\", NULL);\n\n    /* State of the device */\n    switch (status) {\n        case VIR_UDEV_IFACE_ACTIVE:\n            udev_enumerate_add_match_sysattr(enumerate, \"operstate\", \"up\");\n            break;\n\n        case VIR_UDEV_IFACE_INACTIVE:\n            udev_enumerate_add_match_sysattr(enumerate, \"operstate\", \"down\");\n            break;\n\n        case VIR_UDEV_IFACE_ALL:\n            break;\n    }\n\n    /* We don't want to see the TUN devices that QEMU creates for other guests\n     * running on this machine. By saying nomatch NULL, we just are getting\n     * devices without the tun_flags sysattr.\n     */\n    udev_enumerate_add_nomatch_sysattr(enumerate, \"tun_flags\", NULL);\n\n    return enumerate;\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "83-96",
    "snippet": "static virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetMinimalDefForDevice(struct udev_device *dev)\n{\n    virInterfaceDef *def;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->name = g_strdup(udev_device_get_sysname(dev));\n    def->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    return def;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "udev_device_get_sysattr_value(dev, \"address\")"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "dev",
            "\"address\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysname",
          "args": [
            "dev"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetMinimalDefForDevice",
          "args": [
            "structudev_device *dev"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virInterfaceDef *udevGetIfaceDef(struct udev *udev, const char *name);\n\nstatic virInterfaceDef * ATTRIBUTE_NONNULL(1)\nudevGetMinimalDefForDevice(struct udev_device *dev)\n{\n    virInterfaceDef *def;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->name = g_strdup(udev_device_get_sysname(dev));\n    def->mac = g_strdup(udev_device_get_sysattr_value(dev, \"address\"));\n\n    return def;\n}"
  },
  {
    "function_name": "virUdevStatusString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_udev.c",
    "lines": "63-76",
    "snippet": "static const char *\nvirUdevStatusString(virUdevStatus status)\n{\n    switch (status) {\n        case VIR_UDEV_IFACE_ACTIVE:\n            return \"active\";\n        case VIR_UDEV_IFACE_INACTIVE:\n            return \"inactive\";\n        case VIR_UDEV_IFACE_ALL:\n            return \"all\";\n    }\n\n    return \"\";\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include <libudev.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include <libudev.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic const char *\nvirUdevStatusString(virUdevStatus status)\n{\n    switch (status) {\n        case VIR_UDEV_IFACE_ACTIVE:\n            return \"active\";\n        case VIR_UDEV_IFACE_INACTIVE:\n            return \"inactive\";\n        case VIR_UDEV_IFACE_ALL:\n            return \"all\";\n    }\n\n    return \"\";\n}"
  }
]