[
  {
    "function_name": "virCPUDefListFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "1192-1204",
    "snippet": "void\nvirCPUDefListFree(virCPUDefPtr *cpus)\n{\n    virCPUDefPtr *cpu;\n\n    if (!cpus)\n        return;\n\n    for (cpu = cpus; *cpu != NULL; cpu++)\n        virCPUDefFree(*cpu);\n\n    VIR_FREE(cpus);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpus"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "*cpu"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefListFree(virCPUDefPtr *cpus)\n{\n    virCPUDefPtr *cpu;\n\n    if (!cpus)\n        return;\n\n    for (cpu = cpus; *cpu != NULL; cpu++)\n        virCPUDefFree(*cpu);\n\n    VIR_FREE(cpus);\n}"
  },
  {
    "function_name": "virCPUDefListParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "1135-1186",
    "snippet": "virCPUDefPtr *\nvirCPUDefListParse(const char **xmlCPUs,\n                   unsigned int ncpus,\n                   virCPUType cpuType)\n{\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    virCPUDefPtr *cpus = NULL;\n    size_t i;\n\n    VIR_DEBUG(\"xmlCPUs=%p, ncpus=%u\", xmlCPUs, ncpus);\n\n    if (xmlCPUs) {\n        for (i = 0; i < ncpus; i++)\n            VIR_DEBUG(\"xmlCPUs[%zu]=%s\", i, NULLSTR(xmlCPUs[i]));\n    }\n\n    if (!xmlCPUs && ncpus != 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"nonzero ncpus doesn't match with NULL xmlCPUs\"));\n        goto error;\n    }\n\n    if (ncpus == 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"no CPUs given\"));\n        goto error;\n    }\n\n    if (VIR_ALLOC_N(cpus, ncpus + 1))\n        goto error;\n\n    for (i = 0; i < ncpus; i++) {\n        if (!(doc = virXMLParseStringCtxt(xmlCPUs[i], _(\"(CPU_definition)\"), &ctxt)))\n            goto error;\n\n        if (virCPUDefParseXML(ctxt, NULL, cpuType, &cpus[i]) < 0)\n            goto error;\n\n        xmlXPathFreeContext(ctxt);\n        xmlFreeDoc(doc);\n        ctxt = NULL;\n        doc = NULL;\n    }\n\n    return cpus;\n\n error:\n    virCPUDefListFree(cpus);\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n    return NULL;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "doc"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "ctxt"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefListFree",
          "args": [
            "cpus"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "1192-1204",
          "snippet": "void\nvirCPUDefListFree(virCPUDefPtr *cpus)\n{\n    virCPUDefPtr *cpu;\n\n    if (!cpus)\n        return;\n\n    for (cpu = cpus; *cpu != NULL; cpu++)\n        virCPUDefFree(*cpu);\n\n    VIR_FREE(cpus);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefListFree(virCPUDefPtr *cpus)\n{\n    virCPUDefPtr *cpu;\n\n    if (!cpus)\n        return;\n\n    for (cpu = cpus; *cpu != NULL; cpu++)\n        virCPUDefFree(*cpu);\n\n    VIR_FREE(cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "doc"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "ctxt"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefParseXML",
          "args": [
            "ctxt",
            "NULL",
            "cpuType",
            "&cpus[i]"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "329-681",
          "snippet": "int\nvirCPUDefParseXML(xmlXPathContextPtr ctxt,\n                  const char *xpath,\n                  virCPUType type,\n                  virCPUDefPtr *cpu)\n{\n    virCPUDefPtr def = NULL;\n    xmlNodePtr *nodes = NULL;\n    xmlNodePtr oldnode = ctxt->node;\n    int n;\n    size_t i;\n    char *cpuMode;\n    char *fallback = NULL;\n    char *vendor_id = NULL;\n    char *tscScaling = NULL;\n    virHostCPUTscInfoPtr tsc = NULL;\n    int ret = -1;\n\n    *cpu = NULL;\n\n    if (xpath && !(ctxt->node = virXPathNode(xpath, ctxt))) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virXMLNodeNameEqual(ctxt->node, \"cpu\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"XML does not contain expected 'cpu' element\"));\n        goto cleanup;\n    }\n\n    def = virCPUDefNew();\n\n    if (type == VIR_CPU_TYPE_AUTO) {\n        if (virXPathBoolean(\"boolean(./arch)\", ctxt)) {\n            if (virXPathBoolean(\"boolean(./@match)\", ctxt)) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"'arch' element cannot be used inside 'cpu'\"\n                                 \" element with 'match' attribute'\"));\n                goto cleanup;\n            }\n            def->type = VIR_CPU_TYPE_HOST;\n        } else {\n            def->type = VIR_CPU_TYPE_GUEST;\n        }\n    } else {\n        def->type = type;\n    }\n\n    if ((cpuMode = virXMLPropString(ctxt->node, \"mode\"))) {\n        if (def->type == VIR_CPU_TYPE_HOST) {\n            VIR_FREE(cpuMode);\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Attribute mode is only allowed for guest CPU\"));\n            goto cleanup;\n        } else {\n            def->mode = virCPUModeTypeFromString(cpuMode);\n\n            if (def->mode < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid mode attribute '%s'\"),\n                               cpuMode);\n                VIR_FREE(cpuMode);\n                goto cleanup;\n            }\n            VIR_FREE(cpuMode);\n        }\n    } else {\n        if (def->type == VIR_CPU_TYPE_HOST)\n            def->mode = -1;\n        else\n            def->mode = VIR_CPU_MODE_CUSTOM;\n    }\n\n    if (def->type == VIR_CPU_TYPE_GUEST) {\n        char *match = virXMLPropString(ctxt->node, \"match\");\n        char *check;\n\n        if (match) {\n            def->match = virCPUMatchTypeFromString(match);\n            VIR_FREE(match);\n\n            if (def->match < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid match attribute for CPU \"\n                                 \"specification\"));\n                goto cleanup;\n            }\n        }\n\n        if ((check = virXMLPropString(ctxt->node, \"check\"))) {\n            int value = virCPUCheckTypeFromString(check);\n            VIR_FREE(check);\n\n            if (value < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid check attribute for CPU \"\n                                 \"specification\"));\n                goto cleanup;\n            }\n            def->check = value;\n        }\n    }\n\n    if (def->type == VIR_CPU_TYPE_HOST) {\n        char *arch = virXPathString(\"string(./arch[1])\", ctxt);\n        if (!arch) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing CPU architecture\"));\n            goto cleanup;\n        }\n        if ((def->arch = virArchFromString(arch)) == VIR_ARCH_NONE) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unknown architecture %s\"), arch);\n            VIR_FREE(arch);\n            goto cleanup;\n        }\n        VIR_FREE(arch);\n\n        if (virXPathBoolean(\"boolean(./microcode[1]/@version)\", ctxt) > 0 &&\n            virXPathUInt(\"string(./microcode[1]/@version)\", ctxt,\n                         &def->microcodeVersion) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"invalid microcode version\"));\n            goto cleanup;\n        }\n\n        if (virXPathBoolean(\"boolean(./counter[@name='tsc'])\", ctxt) > 0) {\n            if (VIR_ALLOC(tsc) < 0)\n                goto cleanup;\n\n            if (virXPathULongLong(\"string(./counter[@name='tsc']/@frequency)\",\n                                  ctxt, &tsc->frequency) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid TSC frequency\"));\n                goto cleanup;\n            }\n\n            tscScaling = virXPathString(\"string(./counter[@name='tsc']/@scaling)\",\n                                        ctxt);\n            if (tscScaling) {\n                int scaling = virTristateBoolTypeFromString(tscScaling);\n                if (scaling < 0) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Invalid TSC scaling attribute\"));\n                    goto cleanup;\n                }\n                tsc->scaling = scaling;\n            }\n\n            def->tsc = g_steal_pointer(&tsc);\n        }\n    }\n\n    if (!(def->model = virXPathString(\"string(./model[1])\", ctxt)) &&\n        def->type == VIR_CPU_TYPE_HOST) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                        _(\"Missing CPU model name\"));\n        goto cleanup;\n    }\n\n    if (def->type == VIR_CPU_TYPE_GUEST &&\n        def->mode != VIR_CPU_MODE_HOST_PASSTHROUGH) {\n\n        if ((fallback = virXPathString(\"string(./model[1]/@fallback)\", ctxt))) {\n            if ((def->fallback = virCPUFallbackTypeFromString(fallback)) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid fallback attribute\"));\n                goto cleanup;\n            }\n        }\n\n        if ((vendor_id = virXPathString(\"string(./model[1]/@vendor_id)\",\n                                        ctxt))) {\n            if (strlen(vendor_id) != VIR_CPU_VENDOR_ID_LENGTH) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"vendor_id must be exactly %d characters long\"),\n                               VIR_CPU_VENDOR_ID_LENGTH);\n                goto cleanup;\n            }\n\n            /* ensure that the string can be passed to qemu */\n            if (strchr(vendor_id, ',')) {\n                    virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                                   _(\"vendor id is invalid\"));\n                    goto cleanup;\n            }\n\n            def->vendor_id = vendor_id;\n            vendor_id = NULL;\n        }\n    }\n\n    def->vendor = virXPathString(\"string(./vendor[1])\", ctxt);\n    if (def->vendor && !def->model) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"CPU vendor specified without CPU model\"));\n        goto cleanup;\n    }\n\n    if (virXPathNode(\"./topology[1]\", ctxt)) {\n        unsigned long ul;\n\n        if (virXPathULong(\"string(./topology[1]/@sockets)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'sockets' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->sockets = (unsigned int) ul;\n\n        if (virXPathNode(\"./topology[1]/@dies\", ctxt)) {\n            if (virXPathULong(\"string(./topology[1]/@dies)\", ctxt, &ul) < 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"Malformed 'dies' attribute in CPU topology\"));\n                goto cleanup;\n            }\n            def->dies = (unsigned int) ul;\n        } else {\n            def->dies = 1;\n        }\n\n        if (virXPathULong(\"string(./topology[1]/@cores)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'cores' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->cores = (unsigned int) ul;\n\n        if (virXPathULong(\"string(./topology[1]/@threads)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'threads' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->threads = (unsigned int) ul;\n\n        if (!def->sockets || !def->cores || !def->threads || !def->dies) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Invalid CPU topology\"));\n            goto cleanup;\n        }\n    }\n\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    if (n > 0) {\n        if (!def->model && def->mode == VIR_CPU_MODE_CUSTOM) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Non-empty feature list specified without \"\n                             \"CPU model\"));\n            goto cleanup;\n        }\n\n        if (VIR_RESIZE_N(def->features, def->nfeatures_max,\n                         def->nfeatures, n) < 0)\n            goto cleanup;\n\n        def->nfeatures = n;\n    }\n\n    for (i = 0; i < n; i++) {\n        char *name;\n        int policy; /* enum virDomainCPUFeaturePolicy */\n        size_t j;\n\n        if (def->type == VIR_CPU_TYPE_GUEST) {\n            char *strpolicy;\n\n            strpolicy = virXMLPropString(nodes[i], \"policy\");\n            if (strpolicy == NULL)\n                policy = VIR_CPU_FEATURE_REQUIRE;\n            else\n                policy = virCPUFeaturePolicyTypeFromString(strpolicy);\n            VIR_FREE(strpolicy);\n\n            if (policy < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid CPU feature policy\"));\n                goto cleanup;\n            }\n        } else {\n            policy = -1;\n        }\n\n        if (!(name = virXMLPropString(nodes[i], \"name\")) || *name == 0) {\n            VIR_FREE(name);\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Invalid CPU feature name\"));\n            goto cleanup;\n        }\n\n        for (j = 0; j < i; j++) {\n            if (STREQ(name, def->features[j].name)) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"CPU feature '%s' specified more than once\"),\n                               name);\n                VIR_FREE(name);\n                goto cleanup;\n            }\n        }\n\n        def->features[i].name = name;\n        def->features[i].policy = policy;\n    }\n\n    if (virXPathInt(\"count(./cache)\", ctxt, &n) < 0) {\n        goto cleanup;\n    } else if (n > 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"at most one CPU cache element may be specified\"));\n        goto cleanup;\n    } else if (n == 1) {\n        int level = -1;\n        char *strmode;\n        int mode;\n\n        if (virXPathBoolean(\"boolean(./cache[1]/@level)\", ctxt) == 1 &&\n            (virXPathInt(\"string(./cache[1]/@level)\", ctxt, &level) < 0 ||\n             level < 1 || level > 3)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"invalid CPU cache level, must be in range [1,3]\"));\n            goto cleanup;\n        }\n\n        if (!(strmode = virXPathString(\"string(./cache[1]/@mode)\", ctxt)) ||\n            (mode = virCPUCacheModeTypeFromString(strmode)) < 0) {\n            VIR_FREE(strmode);\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing or invalid CPU cache mode\"));\n            goto cleanup;\n        }\n        VIR_FREE(strmode);\n\n        if (VIR_ALLOC(def->cache) < 0)\n            goto cleanup;\n\n        def->cache->level = level;\n        def->cache->mode = mode;\n    }\n\n    *cpu = g_steal_pointer(&def);\n    ret = 0;\n\n cleanup:\n    ctxt->node = oldnode;\n    VIR_FREE(fallback);\n    VIR_FREE(vendor_id);\n    VIR_FREE(nodes);\n    VIR_FREE(tscScaling);\n    VIR_FREE(tsc);\n    virCPUDefFree(def);\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefParseXML(xmlXPathContextPtr ctxt,\n                  const char *xpath,\n                  virCPUType type,\n                  virCPUDefPtr *cpu)\n{\n    virCPUDefPtr def = NULL;\n    xmlNodePtr *nodes = NULL;\n    xmlNodePtr oldnode = ctxt->node;\n    int n;\n    size_t i;\n    char *cpuMode;\n    char *fallback = NULL;\n    char *vendor_id = NULL;\n    char *tscScaling = NULL;\n    virHostCPUTscInfoPtr tsc = NULL;\n    int ret = -1;\n\n    *cpu = NULL;\n\n    if (xpath && !(ctxt->node = virXPathNode(xpath, ctxt))) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virXMLNodeNameEqual(ctxt->node, \"cpu\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"XML does not contain expected 'cpu' element\"));\n        goto cleanup;\n    }\n\n    def = virCPUDefNew();\n\n    if (type == VIR_CPU_TYPE_AUTO) {\n        if (virXPathBoolean(\"boolean(./arch)\", ctxt)) {\n            if (virXPathBoolean(\"boolean(./@match)\", ctxt)) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"'arch' element cannot be used inside 'cpu'\"\n                                 \" element with 'match' attribute'\"));\n                goto cleanup;\n            }\n            def->type = VIR_CPU_TYPE_HOST;\n        } else {\n            def->type = VIR_CPU_TYPE_GUEST;\n        }\n    } else {\n        def->type = type;\n    }\n\n    if ((cpuMode = virXMLPropString(ctxt->node, \"mode\"))) {\n        if (def->type == VIR_CPU_TYPE_HOST) {\n            VIR_FREE(cpuMode);\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Attribute mode is only allowed for guest CPU\"));\n            goto cleanup;\n        } else {\n            def->mode = virCPUModeTypeFromString(cpuMode);\n\n            if (def->mode < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid mode attribute '%s'\"),\n                               cpuMode);\n                VIR_FREE(cpuMode);\n                goto cleanup;\n            }\n            VIR_FREE(cpuMode);\n        }\n    } else {\n        if (def->type == VIR_CPU_TYPE_HOST)\n            def->mode = -1;\n        else\n            def->mode = VIR_CPU_MODE_CUSTOM;\n    }\n\n    if (def->type == VIR_CPU_TYPE_GUEST) {\n        char *match = virXMLPropString(ctxt->node, \"match\");\n        char *check;\n\n        if (match) {\n            def->match = virCPUMatchTypeFromString(match);\n            VIR_FREE(match);\n\n            if (def->match < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid match attribute for CPU \"\n                                 \"specification\"));\n                goto cleanup;\n            }\n        }\n\n        if ((check = virXMLPropString(ctxt->node, \"check\"))) {\n            int value = virCPUCheckTypeFromString(check);\n            VIR_FREE(check);\n\n            if (value < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid check attribute for CPU \"\n                                 \"specification\"));\n                goto cleanup;\n            }\n            def->check = value;\n        }\n    }\n\n    if (def->type == VIR_CPU_TYPE_HOST) {\n        char *arch = virXPathString(\"string(./arch[1])\", ctxt);\n        if (!arch) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing CPU architecture\"));\n            goto cleanup;\n        }\n        if ((def->arch = virArchFromString(arch)) == VIR_ARCH_NONE) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unknown architecture %s\"), arch);\n            VIR_FREE(arch);\n            goto cleanup;\n        }\n        VIR_FREE(arch);\n\n        if (virXPathBoolean(\"boolean(./microcode[1]/@version)\", ctxt) > 0 &&\n            virXPathUInt(\"string(./microcode[1]/@version)\", ctxt,\n                         &def->microcodeVersion) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"invalid microcode version\"));\n            goto cleanup;\n        }\n\n        if (virXPathBoolean(\"boolean(./counter[@name='tsc'])\", ctxt) > 0) {\n            if (VIR_ALLOC(tsc) < 0)\n                goto cleanup;\n\n            if (virXPathULongLong(\"string(./counter[@name='tsc']/@frequency)\",\n                                  ctxt, &tsc->frequency) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid TSC frequency\"));\n                goto cleanup;\n            }\n\n            tscScaling = virXPathString(\"string(./counter[@name='tsc']/@scaling)\",\n                                        ctxt);\n            if (tscScaling) {\n                int scaling = virTristateBoolTypeFromString(tscScaling);\n                if (scaling < 0) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Invalid TSC scaling attribute\"));\n                    goto cleanup;\n                }\n                tsc->scaling = scaling;\n            }\n\n            def->tsc = g_steal_pointer(&tsc);\n        }\n    }\n\n    if (!(def->model = virXPathString(\"string(./model[1])\", ctxt)) &&\n        def->type == VIR_CPU_TYPE_HOST) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                        _(\"Missing CPU model name\"));\n        goto cleanup;\n    }\n\n    if (def->type == VIR_CPU_TYPE_GUEST &&\n        def->mode != VIR_CPU_MODE_HOST_PASSTHROUGH) {\n\n        if ((fallback = virXPathString(\"string(./model[1]/@fallback)\", ctxt))) {\n            if ((def->fallback = virCPUFallbackTypeFromString(fallback)) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid fallback attribute\"));\n                goto cleanup;\n            }\n        }\n\n        if ((vendor_id = virXPathString(\"string(./model[1]/@vendor_id)\",\n                                        ctxt))) {\n            if (strlen(vendor_id) != VIR_CPU_VENDOR_ID_LENGTH) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"vendor_id must be exactly %d characters long\"),\n                               VIR_CPU_VENDOR_ID_LENGTH);\n                goto cleanup;\n            }\n\n            /* ensure that the string can be passed to qemu */\n            if (strchr(vendor_id, ',')) {\n                    virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                                   _(\"vendor id is invalid\"));\n                    goto cleanup;\n            }\n\n            def->vendor_id = vendor_id;\n            vendor_id = NULL;\n        }\n    }\n\n    def->vendor = virXPathString(\"string(./vendor[1])\", ctxt);\n    if (def->vendor && !def->model) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"CPU vendor specified without CPU model\"));\n        goto cleanup;\n    }\n\n    if (virXPathNode(\"./topology[1]\", ctxt)) {\n        unsigned long ul;\n\n        if (virXPathULong(\"string(./topology[1]/@sockets)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'sockets' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->sockets = (unsigned int) ul;\n\n        if (virXPathNode(\"./topology[1]/@dies\", ctxt)) {\n            if (virXPathULong(\"string(./topology[1]/@dies)\", ctxt, &ul) < 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"Malformed 'dies' attribute in CPU topology\"));\n                goto cleanup;\n            }\n            def->dies = (unsigned int) ul;\n        } else {\n            def->dies = 1;\n        }\n\n        if (virXPathULong(\"string(./topology[1]/@cores)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'cores' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->cores = (unsigned int) ul;\n\n        if (virXPathULong(\"string(./topology[1]/@threads)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'threads' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->threads = (unsigned int) ul;\n\n        if (!def->sockets || !def->cores || !def->threads || !def->dies) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Invalid CPU topology\"));\n            goto cleanup;\n        }\n    }\n\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    if (n > 0) {\n        if (!def->model && def->mode == VIR_CPU_MODE_CUSTOM) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Non-empty feature list specified without \"\n                             \"CPU model\"));\n            goto cleanup;\n        }\n\n        if (VIR_RESIZE_N(def->features, def->nfeatures_max,\n                         def->nfeatures, n) < 0)\n            goto cleanup;\n\n        def->nfeatures = n;\n    }\n\n    for (i = 0; i < n; i++) {\n        char *name;\n        int policy; /* enum virDomainCPUFeaturePolicy */\n        size_t j;\n\n        if (def->type == VIR_CPU_TYPE_GUEST) {\n            char *strpolicy;\n\n            strpolicy = virXMLPropString(nodes[i], \"policy\");\n            if (strpolicy == NULL)\n                policy = VIR_CPU_FEATURE_REQUIRE;\n            else\n                policy = virCPUFeaturePolicyTypeFromString(strpolicy);\n            VIR_FREE(strpolicy);\n\n            if (policy < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid CPU feature policy\"));\n                goto cleanup;\n            }\n        } else {\n            policy = -1;\n        }\n\n        if (!(name = virXMLPropString(nodes[i], \"name\")) || *name == 0) {\n            VIR_FREE(name);\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Invalid CPU feature name\"));\n            goto cleanup;\n        }\n\n        for (j = 0; j < i; j++) {\n            if (STREQ(name, def->features[j].name)) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"CPU feature '%s' specified more than once\"),\n                               name);\n                VIR_FREE(name);\n                goto cleanup;\n            }\n        }\n\n        def->features[i].name = name;\n        def->features[i].policy = policy;\n    }\n\n    if (virXPathInt(\"count(./cache)\", ctxt, &n) < 0) {\n        goto cleanup;\n    } else if (n > 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"at most one CPU cache element may be specified\"));\n        goto cleanup;\n    } else if (n == 1) {\n        int level = -1;\n        char *strmode;\n        int mode;\n\n        if (virXPathBoolean(\"boolean(./cache[1]/@level)\", ctxt) == 1 &&\n            (virXPathInt(\"string(./cache[1]/@level)\", ctxt, &level) < 0 ||\n             level < 1 || level > 3)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"invalid CPU cache level, must be in range [1,3]\"));\n            goto cleanup;\n        }\n\n        if (!(strmode = virXPathString(\"string(./cache[1]/@mode)\", ctxt)) ||\n            (mode = virCPUCacheModeTypeFromString(strmode)) < 0) {\n            VIR_FREE(strmode);\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing or invalid CPU cache mode\"));\n            goto cleanup;\n        }\n        VIR_FREE(strmode);\n\n        if (VIR_ALLOC(def->cache) < 0)\n            goto cleanup;\n\n        def->cache->level = level;\n        def->cache->mode = mode;\n    }\n\n    *cpu = g_steal_pointer(&def);\n    ret = 0;\n\n cleanup:\n    ctxt->node = oldnode;\n    VIR_FREE(fallback);\n    VIR_FREE(vendor_id);\n    VIR_FREE(nodes);\n    VIR_FREE(tscScaling);\n    VIR_FREE(tsc);\n    virCPUDefFree(def);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLParseStringCtxt",
          "args": [
            "xmlCPUs[i]",
            "_(\"(CPU_definition)\")",
            "&ctxt"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"(CPU_definition)\""
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "cpus",
            "ncpus + 1"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"no CPUs given\")"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"nonzero ncpus doesn't match with NULL xmlCPUs\")"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"xmlCPUs[%zu]=%s\"",
            "i",
            "NULLSTR(xmlCPUs[i])"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "xmlCPUs[i]"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"xmlCPUs=%p, ncpus=%u\"",
            "xmlCPUs",
            "ncpus"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr *\nvirCPUDefListParse(const char **xmlCPUs,\n                   unsigned int ncpus,\n                   virCPUType cpuType)\n{\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    virCPUDefPtr *cpus = NULL;\n    size_t i;\n\n    VIR_DEBUG(\"xmlCPUs=%p, ncpus=%u\", xmlCPUs, ncpus);\n\n    if (xmlCPUs) {\n        for (i = 0; i < ncpus; i++)\n            VIR_DEBUG(\"xmlCPUs[%zu]=%s\", i, NULLSTR(xmlCPUs[i]));\n    }\n\n    if (!xmlCPUs && ncpus != 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"nonzero ncpus doesn't match with NULL xmlCPUs\"));\n        goto error;\n    }\n\n    if (ncpus == 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"no CPUs given\"));\n        goto error;\n    }\n\n    if (VIR_ALLOC_N(cpus, ncpus + 1))\n        goto error;\n\n    for (i = 0; i < ncpus; i++) {\n        if (!(doc = virXMLParseStringCtxt(xmlCPUs[i], _(\"(CPU_definition)\"), &ctxt)))\n            goto error;\n\n        if (virCPUDefParseXML(ctxt, NULL, cpuType, &cpus[i]) < 0)\n            goto error;\n\n        xmlXPathFreeContext(ctxt);\n        xmlFreeDoc(doc);\n        ctxt = NULL;\n        doc = NULL;\n    }\n\n    return cpus;\n\n error:\n    virCPUDefListFree(cpus);\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n    return NULL;\n}"
  },
  {
    "function_name": "virCPUDefIsEqual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "1007-1129",
    "snippet": "bool\nvirCPUDefIsEqual(virCPUDefPtr src,\n                 virCPUDefPtr dst,\n                 bool reportError)\n{\n    size_t i;\n\n    if (!src && !dst)\n        return true;\n\n#define MISMATCH(fmt, ...) \\\n    if (reportError) \\\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, fmt, __VA_ARGS__)\n\n    if ((src && !dst) || (!src && dst)) {\n        MISMATCH(\"%s\", _(\"Target CPU does not match source\"));\n        return false;\n    }\n\n    if (src->type != dst->type) {\n        MISMATCH(_(\"Target CPU type %s does not match source %s\"),\n                 virCPUTypeToString(dst->type),\n                 virCPUTypeToString(src->type));\n        return false;\n    }\n\n    if (src->mode != dst->mode) {\n        MISMATCH(_(\"Target CPU mode %s does not match source %s\"),\n                 virCPUModeTypeToString(dst->mode),\n                 virCPUModeTypeToString(src->mode));\n        return false;\n    }\n\n    if (src->check != dst->check) {\n        MISMATCH(_(\"Target CPU check %s does not match source %s\"),\n                 virCPUCheckTypeToString(dst->check),\n                 virCPUCheckTypeToString(src->check));\n        return false;\n    }\n\n    if (src->arch != dst->arch) {\n        MISMATCH(_(\"Target CPU arch %s does not match source %s\"),\n                 virArchToString(dst->arch),\n                 virArchToString(src->arch));\n        return false;\n    }\n\n    if (STRNEQ_NULLABLE(src->model, dst->model)) {\n        MISMATCH(_(\"Target CPU model %s does not match source %s\"),\n                 NULLSTR(dst->model), NULLSTR(src->model));\n        return false;\n    }\n\n    if (STRNEQ_NULLABLE(src->vendor, dst->vendor)) {\n        MISMATCH(_(\"Target CPU vendor %s does not match source %s\"),\n                 NULLSTR(dst->vendor), NULLSTR(src->vendor));\n        return false;\n    }\n\n    if (STRNEQ_NULLABLE(src->vendor_id, dst->vendor_id)) {\n        MISMATCH(_(\"Target CPU vendor id %s does not match source %s\"),\n                 NULLSTR(dst->vendor_id), NULLSTR(src->vendor_id));\n        return false;\n    }\n\n    if (src->sockets != dst->sockets) {\n        MISMATCH(_(\"Target CPU sockets %d does not match source %d\"),\n                 dst->sockets, src->sockets);\n        return false;\n    }\n\n    if (src->dies != dst->dies) {\n        MISMATCH(_(\"Target CPU dies %d does not match source %d\"),\n                 dst->dies, src->dies);\n        return false;\n    }\n\n    if (src->cores != dst->cores) {\n        MISMATCH(_(\"Target CPU cores %d does not match source %d\"),\n                 dst->cores, src->cores);\n        return false;\n    }\n\n    if (src->threads != dst->threads) {\n        MISMATCH(_(\"Target CPU threads %d does not match source %d\"),\n                 dst->threads, src->threads);\n        return false;\n    }\n\n    if (src->nfeatures != dst->nfeatures) {\n        MISMATCH(_(\"Target CPU feature count %zu does not match source %zu\"),\n                 dst->nfeatures, src->nfeatures);\n        return false;\n    }\n\n    for (i = 0; i < src->nfeatures; i++) {\n        if (STRNEQ(src->features[i].name, dst->features[i].name)) {\n            MISMATCH(_(\"Target CPU feature %s does not match source %s\"),\n                     dst->features[i].name, src->features[i].name);\n            return false;\n        }\n\n        if (src->features[i].policy != dst->features[i].policy) {\n            MISMATCH(_(\"Target CPU feature policy %s does not match source %s\"),\n                     virCPUFeaturePolicyTypeToString(dst->features[i].policy),\n                     virCPUFeaturePolicyTypeToString(src->features[i].policy));\n            return false;\n        }\n    }\n\n    if ((src->cache && !dst->cache) ||\n        (!src->cache && dst->cache) ||\n        (src->cache && dst->cache &&\n         (src->cache->level != dst->cache->level ||\n          src->cache->mode != dst->cache->mode))) {\n        MISMATCH(\"%s\", _(\"Target CPU cache does not match source\"));\n        return false;\n    }\n\n#undef MISMATCH\n\n    return true;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MISMATCH",
          "args": [
            "\"%s\"",
            "_(\"Target CPU cache does not match source\")"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Target CPU cache does not match source\""
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MISMATCH",
          "args": [
            "_(\"Target CPU feature policy %s does not match source %s\")",
            "virCPUFeaturePolicyTypeToString(dst->features[i].policy)",
            "virCPUFeaturePolicyTypeToString(src->features[i].policy)"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUFeaturePolicyTypeToString",
          "args": [
            "src->features[i].policy"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUFeaturePolicyTypeToString",
          "args": [
            "dst->features[i].policy"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MISMATCH",
          "args": [
            "_(\"Target CPU feature %s does not match source %s\")",
            "dst->features[i].name",
            "src->features[i].name"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "src->features[i].name",
            "dst->features[i].name"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MISMATCH",
          "args": [
            "_(\"Target CPU feature count %zu does not match source %zu\")",
            "dst->nfeatures",
            "src->nfeatures"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MISMATCH",
          "args": [
            "_(\"Target CPU threads %d does not match source %d\")",
            "dst->threads",
            "src->threads"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MISMATCH",
          "args": [
            "_(\"Target CPU cores %d does not match source %d\")",
            "dst->cores",
            "src->cores"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MISMATCH",
          "args": [
            "_(\"Target CPU dies %d does not match source %d\")",
            "dst->dies",
            "src->dies"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MISMATCH",
          "args": [
            "_(\"Target CPU sockets %d does not match source %d\")",
            "dst->sockets",
            "src->sockets"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MISMATCH",
          "args": [
            "_(\"Target CPU vendor id %s does not match source %s\")",
            "NULLSTR(dst->vendor_id)",
            "NULLSTR(src->vendor_id)"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "src->vendor_id"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "dst->vendor_id"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "src->vendor_id",
            "dst->vendor_id"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MISMATCH",
          "args": [
            "_(\"Target CPU vendor %s does not match source %s\")",
            "NULLSTR(dst->vendor)",
            "NULLSTR(src->vendor)"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "src->vendor"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "dst->vendor"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "src->vendor",
            "dst->vendor"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MISMATCH",
          "args": [
            "_(\"Target CPU model %s does not match source %s\")",
            "NULLSTR(dst->model)",
            "NULLSTR(src->model)"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "src->model"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "dst->model"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "src->model",
            "dst->model"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MISMATCH",
          "args": [
            "_(\"Target CPU arch %s does not match source %s\")",
            "virArchToString(dst->arch)",
            "virArchToString(src->arch)"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "src->arch"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MISMATCH",
          "args": [
            "_(\"Target CPU check %s does not match source %s\")",
            "virCPUCheckTypeToString(dst->check)",
            "virCPUCheckTypeToString(src->check)"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUCheckTypeToString",
          "args": [
            "src->check"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUCheckTypeToString",
          "args": [
            "dst->check"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MISMATCH",
          "args": [
            "_(\"Target CPU mode %s does not match source %s\")",
            "virCPUModeTypeToString(dst->mode)",
            "virCPUModeTypeToString(src->mode)"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUModeTypeToString",
          "args": [
            "src->mode"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUModeTypeToString",
          "args": [
            "dst->mode"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MISMATCH",
          "args": [
            "_(\"Target CPU type %s does not match source %s\")",
            "virCPUTypeToString(dst->type)",
            "virCPUTypeToString(src->type)"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUTypeToString",
          "args": [
            "src->type"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUTypeToString",
          "args": [
            "dst->type"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MISMATCH",
          "args": [
            "\"%s\"",
            "_(\"Target CPU does not match source\")"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nbool\nvirCPUDefIsEqual(virCPUDefPtr src,\n                 virCPUDefPtr dst,\n                 bool reportError)\n{\n    size_t i;\n\n    if (!src && !dst)\n        return true;\n\n#define MISMATCH(fmt, ...) \\\n    if (reportError) \\\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, fmt, __VA_ARGS__)\n\n    if ((src && !dst) || (!src && dst)) {\n        MISMATCH(\"%s\", _(\"Target CPU does not match source\"));\n        return false;\n    }\n\n    if (src->type != dst->type) {\n        MISMATCH(_(\"Target CPU type %s does not match source %s\"),\n                 virCPUTypeToString(dst->type),\n                 virCPUTypeToString(src->type));\n        return false;\n    }\n\n    if (src->mode != dst->mode) {\n        MISMATCH(_(\"Target CPU mode %s does not match source %s\"),\n                 virCPUModeTypeToString(dst->mode),\n                 virCPUModeTypeToString(src->mode));\n        return false;\n    }\n\n    if (src->check != dst->check) {\n        MISMATCH(_(\"Target CPU check %s does not match source %s\"),\n                 virCPUCheckTypeToString(dst->check),\n                 virCPUCheckTypeToString(src->check));\n        return false;\n    }\n\n    if (src->arch != dst->arch) {\n        MISMATCH(_(\"Target CPU arch %s does not match source %s\"),\n                 virArchToString(dst->arch),\n                 virArchToString(src->arch));\n        return false;\n    }\n\n    if (STRNEQ_NULLABLE(src->model, dst->model)) {\n        MISMATCH(_(\"Target CPU model %s does not match source %s\"),\n                 NULLSTR(dst->model), NULLSTR(src->model));\n        return false;\n    }\n\n    if (STRNEQ_NULLABLE(src->vendor, dst->vendor)) {\n        MISMATCH(_(\"Target CPU vendor %s does not match source %s\"),\n                 NULLSTR(dst->vendor), NULLSTR(src->vendor));\n        return false;\n    }\n\n    if (STRNEQ_NULLABLE(src->vendor_id, dst->vendor_id)) {\n        MISMATCH(_(\"Target CPU vendor id %s does not match source %s\"),\n                 NULLSTR(dst->vendor_id), NULLSTR(src->vendor_id));\n        return false;\n    }\n\n    if (src->sockets != dst->sockets) {\n        MISMATCH(_(\"Target CPU sockets %d does not match source %d\"),\n                 dst->sockets, src->sockets);\n        return false;\n    }\n\n    if (src->dies != dst->dies) {\n        MISMATCH(_(\"Target CPU dies %d does not match source %d\"),\n                 dst->dies, src->dies);\n        return false;\n    }\n\n    if (src->cores != dst->cores) {\n        MISMATCH(_(\"Target CPU cores %d does not match source %d\"),\n                 dst->cores, src->cores);\n        return false;\n    }\n\n    if (src->threads != dst->threads) {\n        MISMATCH(_(\"Target CPU threads %d does not match source %d\"),\n                 dst->threads, src->threads);\n        return false;\n    }\n\n    if (src->nfeatures != dst->nfeatures) {\n        MISMATCH(_(\"Target CPU feature count %zu does not match source %zu\"),\n                 dst->nfeatures, src->nfeatures);\n        return false;\n    }\n\n    for (i = 0; i < src->nfeatures; i++) {\n        if (STRNEQ(src->features[i].name, dst->features[i].name)) {\n            MISMATCH(_(\"Target CPU feature %s does not match source %s\"),\n                     dst->features[i].name, src->features[i].name);\n            return false;\n        }\n\n        if (src->features[i].policy != dst->features[i].policy) {\n            MISMATCH(_(\"Target CPU feature policy %s does not match source %s\"),\n                     virCPUFeaturePolicyTypeToString(dst->features[i].policy),\n                     virCPUFeaturePolicyTypeToString(src->features[i].policy));\n            return false;\n        }\n    }\n\n    if ((src->cache && !dst->cache) ||\n        (!src->cache && dst->cache) ||\n        (src->cache && dst->cache &&\n         (src->cache->level != dst->cache->level ||\n          src->cache->mode != dst->cache->mode))) {\n        MISMATCH(\"%s\", _(\"Target CPU cache does not match source\"));\n        return false;\n    }\n\n#undef MISMATCH\n\n    return true;\n}"
  },
  {
    "function_name": "virCPUDefCheckFeatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "982-1004",
    "snippet": "int\nvirCPUDefCheckFeatures(virCPUDefPtr cpu,\n                       virCPUDefFeatureFilter filter,\n                       void *opaque,\n                       char ***features)\n{\n    VIR_AUTOSTRINGLIST list = NULL;\n    size_t n = 0;\n    size_t i;\n\n    *features = NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        if (filter(cpu->features[i].name, cpu->features[i].policy, opaque)) {\n            if (virStringListAdd(&list, cpu->features[i].name) < 0)\n                return -1;\n            n++;\n        }\n    }\n\n    *features = g_steal_pointer(&list);\n    return n;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&list"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListAdd",
          "args": [
            "&list",
            "cpu->features[i].name"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "176-188",
          "snippet": "int\nvirStringListAdd(char ***strings,\n                 const char *item)\n{\n    size_t i = virStringListLength((const char **) *strings);\n\n    if (VIR_EXPAND_N(*strings, i, 2) < 0)\n        return -1;\n\n    (*strings)[i - 2] = g_strdup(item);\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStringListAdd(char ***strings,\n                 const char *item)\n{\n    size_t i = virStringListLength((const char **) *strings);\n\n    if (VIR_EXPAND_N(*strings, i, 2) < 0)\n        return -1;\n\n    (*strings)[i - 2] = g_strdup(item);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter",
          "args": [
            "cpu->features[i].name",
            "cpu->features[i].policy",
            "opaque"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "firewalld_dbus_filter_bridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "659-696",
          "snippet": "static DBusHandlerResult\nfirewalld_dbus_filter_bridge(DBusConnection *connection G_GNUC_UNUSED,\n                             DBusMessage *message,\n                             void *user_data)\n{\n    virNetworkDriverStatePtr driver = user_data;\n    bool reload = false;\n\n    if (dbus_message_is_signal(message,\n                               \"org.fedoraproject.FirewallD1\", \"Reloaded\")) {\n        reload = true;\n\n    } else if (dbus_message_is_signal(message,\n                                      DBUS_INTERFACE_DBUS, \"NameOwnerChanged\")) {\n\n        g_autofree char *name = NULL;\n        g_autofree char *old_owner = NULL;\n        g_autofree char *new_owner = NULL;\n\n        if (virDBusMessageDecode(message, \"sss\", &name, &old_owner, &new_owner) < 0) {\n            VIR_WARN(\"Failed to decode DBus NameOwnerChanged message\");\n            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n        }\n        /*\n         * if new_owner is empty, firewalld is shutting down. If it is\n         * non-empty, then it is starting\n         */\n        if (new_owner && *new_owner)\n            reload = true;\n    }\n\n    if (reload) {\n        VIR_DEBUG(\"Reload in bridge_driver because of firewalld.\");\n        networkReloadFirewallRules(driver, false);\n    }\n\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic DBusHandlerResult\nfirewalld_dbus_filter_bridge(DBusConnection *connection G_GNUC_UNUSED,\n                             DBusMessage *message,\n                             void *user_data)\n{\n    virNetworkDriverStatePtr driver = user_data;\n    bool reload = false;\n\n    if (dbus_message_is_signal(message,\n                               \"org.fedoraproject.FirewallD1\", \"Reloaded\")) {\n        reload = true;\n\n    } else if (dbus_message_is_signal(message,\n                                      DBUS_INTERFACE_DBUS, \"NameOwnerChanged\")) {\n\n        g_autofree char *name = NULL;\n        g_autofree char *old_owner = NULL;\n        g_autofree char *new_owner = NULL;\n\n        if (virDBusMessageDecode(message, \"sss\", &name, &old_owner, &new_owner) < 0) {\n            VIR_WARN(\"Failed to decode DBus NameOwnerChanged message\");\n            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n        }\n        /*\n         * if new_owner is empty, firewalld is shutting down. If it is\n         * non-empty, then it is starting\n         */\n        if (new_owner && *new_owner)\n            reload = true;\n    }\n\n    if (reload) {\n        VIR_DEBUG(\"Reload in bridge_driver because of firewalld.\");\n        networkReloadFirewallRules(driver, false);\n    }\n\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefCheckFeatures(virCPUDefPtr cpu,\n                       virCPUDefFeatureFilter filter,\n                       void *opaque,\n                       char ***features)\n{\n    VIR_AUTOSTRINGLIST list = NULL;\n    size_t n = 0;\n    size_t i;\n\n    *features = NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        if (filter(cpu->features[i].name, cpu->features[i].policy, opaque)) {\n            if (virStringListAdd(&list, cpu->features[i].name) < 0)\n                return -1;\n            n++;\n        }\n    }\n\n    *features = g_steal_pointer(&list);\n    return n;\n}"
  },
  {
    "function_name": "virCPUDefFilterFeatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "952-971",
    "snippet": "int\nvirCPUDefFilterFeatures(virCPUDefPtr cpu,\n                        virCPUDefFeatureFilter filter,\n                        void *opaque)\n{\n    size_t i = 0;\n\n    while (i < cpu->nfeatures) {\n        if (filter(cpu->features[i].name, cpu->features[i].policy, opaque)) {\n            i++;\n            continue;\n        }\n\n        VIR_FREE(cpu->features[i].name);\n        if (VIR_DELETE_ELEMENT_INPLACE(cpu->features, i, cpu->nfeatures) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT_INPLACE",
          "args": [
            "cpu->features",
            "i",
            "cpu->nfeatures"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpu->features[i].name"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter",
          "args": [
            "cpu->features[i].name",
            "cpu->features[i].policy",
            "opaque"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "firewalld_dbus_filter_bridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "659-696",
          "snippet": "static DBusHandlerResult\nfirewalld_dbus_filter_bridge(DBusConnection *connection G_GNUC_UNUSED,\n                             DBusMessage *message,\n                             void *user_data)\n{\n    virNetworkDriverStatePtr driver = user_data;\n    bool reload = false;\n\n    if (dbus_message_is_signal(message,\n                               \"org.fedoraproject.FirewallD1\", \"Reloaded\")) {\n        reload = true;\n\n    } else if (dbus_message_is_signal(message,\n                                      DBUS_INTERFACE_DBUS, \"NameOwnerChanged\")) {\n\n        g_autofree char *name = NULL;\n        g_autofree char *old_owner = NULL;\n        g_autofree char *new_owner = NULL;\n\n        if (virDBusMessageDecode(message, \"sss\", &name, &old_owner, &new_owner) < 0) {\n            VIR_WARN(\"Failed to decode DBus NameOwnerChanged message\");\n            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n        }\n        /*\n         * if new_owner is empty, firewalld is shutting down. If it is\n         * non-empty, then it is starting\n         */\n        if (new_owner && *new_owner)\n            reload = true;\n    }\n\n    if (reload) {\n        VIR_DEBUG(\"Reload in bridge_driver because of firewalld.\");\n        networkReloadFirewallRules(driver, false);\n    }\n\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic DBusHandlerResult\nfirewalld_dbus_filter_bridge(DBusConnection *connection G_GNUC_UNUSED,\n                             DBusMessage *message,\n                             void *user_data)\n{\n    virNetworkDriverStatePtr driver = user_data;\n    bool reload = false;\n\n    if (dbus_message_is_signal(message,\n                               \"org.fedoraproject.FirewallD1\", \"Reloaded\")) {\n        reload = true;\n\n    } else if (dbus_message_is_signal(message,\n                                      DBUS_INTERFACE_DBUS, \"NameOwnerChanged\")) {\n\n        g_autofree char *name = NULL;\n        g_autofree char *old_owner = NULL;\n        g_autofree char *new_owner = NULL;\n\n        if (virDBusMessageDecode(message, \"sss\", &name, &old_owner, &new_owner) < 0) {\n            VIR_WARN(\"Failed to decode DBus NameOwnerChanged message\");\n            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n        }\n        /*\n         * if new_owner is empty, firewalld is shutting down. If it is\n         * non-empty, then it is starting\n         */\n        if (new_owner && *new_owner)\n            reload = true;\n    }\n\n    if (reload) {\n        VIR_DEBUG(\"Reload in bridge_driver because of firewalld.\");\n        networkReloadFirewallRules(driver, false);\n    }\n\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefFilterFeatures(virCPUDefPtr cpu,\n                        virCPUDefFeatureFilter filter,\n                        void *opaque)\n{\n    size_t i = 0;\n\n    while (i < cpu->nfeatures) {\n        if (filter(cpu->features[i].name, cpu->features[i].policy, opaque)) {\n            i++;\n            continue;\n        }\n\n        VIR_FREE(cpu->features[i].name);\n        if (VIR_DELETE_ELEMENT_INPLACE(cpu->features, i, cpu->nfeatures) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virCPUDefFindFeature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "937-949",
    "snippet": "virCPUFeatureDefPtr\nvirCPUDefFindFeature(virCPUDefPtr def,\n                     const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < def->nfeatures; i++) {\n        if (STREQ(name, def->features[i].name))\n            return def->features + i;\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "def->features[i].name"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUFeatureDefPtr\nvirCPUDefFindFeature(virCPUDefPtr def,\n                     const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < def->nfeatures; i++) {\n        if (STREQ(name, def->features[i].name))\n            return def->features + i;\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "virCPUDefAddFeature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "928-934",
    "snippet": "int\nvirCPUDefAddFeature(virCPUDefPtr def,\n                    const char *name,\n                    int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, false);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefUpdateFeatureInternal",
          "args": [
            "def",
            "name",
            "policy",
            "false"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefUpdateFeatureInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "884-918",
          "snippet": "static int\nvirCPUDefUpdateFeatureInternal(virCPUDefPtr def,\n                               const char *name,\n                               int policy,\n                               bool update)\n{\n    virCPUFeatureDefPtr feat;\n\n    if (def->type == VIR_CPU_TYPE_HOST)\n        policy = -1;\n\n    if ((feat = virCPUDefFindFeature(def, name))) {\n        if (update) {\n            feat->policy = policy;\n            return 0;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"CPU feature '%s' specified more than once\"),\n                       name);\n\n        return -1;\n    }\n\n    if (VIR_RESIZE_N(def->features, def->nfeatures_max,\n                     def->nfeatures, 1) < 0)\n        return -1;\n\n    def->features[def->nfeatures].name = g_strdup(name);\n\n    def->features[def->nfeatures].policy = policy;\n    def->nfeatures++;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirCPUDefUpdateFeatureInternal(virCPUDefPtr def,\n                               const char *name,\n                               int policy,\n                               bool update)\n{\n    virCPUFeatureDefPtr feat;\n\n    if (def->type == VIR_CPU_TYPE_HOST)\n        policy = -1;\n\n    if ((feat = virCPUDefFindFeature(def, name))) {\n        if (update) {\n            feat->policy = policy;\n            return 0;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"CPU feature '%s' specified more than once\"),\n                       name);\n\n        return -1;\n    }\n\n    if (VIR_RESIZE_N(def->features, def->nfeatures_max,\n                     def->nfeatures, 1) < 0)\n        return -1;\n\n    def->features[def->nfeatures].name = g_strdup(name);\n\n    def->features[def->nfeatures].policy = policy;\n    def->nfeatures++;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefAddFeature(virCPUDefPtr def,\n                    const char *name,\n                    int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, false);\n}"
  },
  {
    "function_name": "virCPUDefUpdateFeature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "920-926",
    "snippet": "int\nvirCPUDefUpdateFeature(virCPUDefPtr def,\n                       const char *name,\n                       int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, true);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefUpdateFeatureInternal",
          "args": [
            "def",
            "name",
            "policy",
            "true"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefUpdateFeatureInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "884-918",
          "snippet": "static int\nvirCPUDefUpdateFeatureInternal(virCPUDefPtr def,\n                               const char *name,\n                               int policy,\n                               bool update)\n{\n    virCPUFeatureDefPtr feat;\n\n    if (def->type == VIR_CPU_TYPE_HOST)\n        policy = -1;\n\n    if ((feat = virCPUDefFindFeature(def, name))) {\n        if (update) {\n            feat->policy = policy;\n            return 0;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"CPU feature '%s' specified more than once\"),\n                       name);\n\n        return -1;\n    }\n\n    if (VIR_RESIZE_N(def->features, def->nfeatures_max,\n                     def->nfeatures, 1) < 0)\n        return -1;\n\n    def->features[def->nfeatures].name = g_strdup(name);\n\n    def->features[def->nfeatures].policy = policy;\n    def->nfeatures++;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirCPUDefUpdateFeatureInternal(virCPUDefPtr def,\n                               const char *name,\n                               int policy,\n                               bool update)\n{\n    virCPUFeatureDefPtr feat;\n\n    if (def->type == VIR_CPU_TYPE_HOST)\n        policy = -1;\n\n    if ((feat = virCPUDefFindFeature(def, name))) {\n        if (update) {\n            feat->policy = policy;\n            return 0;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"CPU feature '%s' specified more than once\"),\n                       name);\n\n        return -1;\n    }\n\n    if (VIR_RESIZE_N(def->features, def->nfeatures_max,\n                     def->nfeatures, 1) < 0)\n        return -1;\n\n    def->features[def->nfeatures].name = g_strdup(name);\n\n    def->features[def->nfeatures].policy = policy;\n    def->nfeatures++;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefUpdateFeature(virCPUDefPtr def,\n                       const char *name,\n                       int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, true);\n}"
  },
  {
    "function_name": "virCPUDefUpdateFeatureInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "884-918",
    "snippet": "static int\nvirCPUDefUpdateFeatureInternal(virCPUDefPtr def,\n                               const char *name,\n                               int policy,\n                               bool update)\n{\n    virCPUFeatureDefPtr feat;\n\n    if (def->type == VIR_CPU_TYPE_HOST)\n        policy = -1;\n\n    if ((feat = virCPUDefFindFeature(def, name))) {\n        if (update) {\n            feat->policy = policy;\n            return 0;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"CPU feature '%s' specified more than once\"),\n                       name);\n\n        return -1;\n    }\n\n    if (VIR_RESIZE_N(def->features, def->nfeatures_max,\n                     def->nfeatures, 1) < 0)\n        return -1;\n\n    def->features[def->nfeatures].name = g_strdup(name);\n\n    def->features[def->nfeatures].policy = policy;\n    def->nfeatures++;\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "name"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "def->features",
            "def->nfeatures_max",
            "def->nfeatures",
            "1"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"CPU feature '%s' specified more than once\")",
            "name"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"CPU feature '%s' specified more than once\""
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefFindFeature",
          "args": [
            "def",
            "name"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFindFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "937-949",
          "snippet": "virCPUFeatureDefPtr\nvirCPUDefFindFeature(virCPUDefPtr def,\n                     const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < def->nfeatures; i++) {\n        if (STREQ(name, def->features[i].name))\n            return def->features + i;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUFeatureDefPtr\nvirCPUDefFindFeature(virCPUDefPtr def,\n                     const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < def->nfeatures; i++) {\n        if (STREQ(name, def->features[i].name))\n            return def->features + i;\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirCPUDefUpdateFeatureInternal(virCPUDefPtr def,\n                               const char *name,\n                               int policy,\n                               bool update)\n{\n    virCPUFeatureDefPtr feat;\n\n    if (def->type == VIR_CPU_TYPE_HOST)\n        policy = -1;\n\n    if ((feat = virCPUDefFindFeature(def, name))) {\n        if (update) {\n            feat->policy = policy;\n            return 0;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"CPU feature '%s' specified more than once\"),\n                       name);\n\n        return -1;\n    }\n\n    if (VIR_RESIZE_N(def->features, def->nfeatures_max,\n                     def->nfeatures, 1) < 0)\n        return -1;\n\n    def->features[def->nfeatures].name = g_strdup(name);\n\n    def->features[def->nfeatures].policy = policy;\n    def->nfeatures++;\n\n    return 0;\n}"
  },
  {
    "function_name": "virCPUDefFormatBuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "775-882",
    "snippet": "int\nvirCPUDefFormatBuf(virBufferPtr buf,\n                   virCPUDefPtr def)\n{\n    size_t i;\n    bool formatModel;\n\n    if (!def)\n        return 0;\n\n    formatModel = (def->mode == VIR_CPU_MODE_CUSTOM ||\n                   def->mode == VIR_CPU_MODE_HOST_MODEL);\n\n    if (!def->model && def->mode == VIR_CPU_MODE_CUSTOM && def->nfeatures) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Non-empty feature list specified without CPU model\"));\n        return -1;\n    }\n\n    if (formatModel && (def->model || def->vendor_id)) {\n        virBufferAddLit(buf, \"<model\");\n\n        if (def->type == VIR_CPU_TYPE_GUEST && def->model) {\n            const char *fallback;\n\n            fallback = virCPUFallbackTypeToString(def->fallback);\n            if (!fallback) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected CPU fallback value: %d\"),\n                               def->fallback);\n                return -1;\n            }\n            virBufferAsprintf(buf, \" fallback='%s'\", fallback);\n        }\n\n        if (def->type == VIR_CPU_TYPE_GUEST)\n            virBufferEscapeString(buf, \" vendor_id='%s'\", def->vendor_id);\n\n        if (def->model)\n            virBufferEscapeString(buf, \">%s</model>\\n\", def->model);\n        else\n            virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (formatModel && def->vendor)\n        virBufferEscapeString(buf, \"<vendor>%s</vendor>\\n\", def->vendor);\n\n    if (def->type == VIR_CPU_TYPE_HOST && def->microcodeVersion)\n        virBufferAsprintf(buf, \"<microcode version='%u'/>\\n\",\n                          def->microcodeVersion);\n\n    if (def->type == VIR_CPU_TYPE_HOST && def->tsc) {\n        virBufferAddLit(buf, \"<counter name='tsc'\");\n        virBufferAsprintf(buf, \" frequency='%llu'\", def->tsc->frequency);\n        if (def->tsc->scaling) {\n            virBufferAsprintf(buf, \" scaling='%s'\",\n                              virTristateBoolTypeToString(def->tsc->scaling));\n        }\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->sockets && def->dies && def->cores && def->threads) {\n        virBufferAddLit(buf, \"<topology\");\n        virBufferAsprintf(buf, \" sockets='%u'\", def->sockets);\n        virBufferAsprintf(buf, \" dies='%u'\", def->dies);\n        virBufferAsprintf(buf, \" cores='%u'\", def->cores);\n        virBufferAsprintf(buf, \" threads='%u'\", def->threads);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->cache) {\n        virBufferAddLit(buf, \"<cache \");\n        if (def->cache->level != -1)\n            virBufferAsprintf(buf, \"level='%d' \", def->cache->level);\n        virBufferAsprintf(buf, \"mode='%s'\",\n                          virCPUCacheModeTypeToString(def->cache->mode));\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    for (i = 0; i < def->nfeatures; i++) {\n        virCPUFeatureDefPtr feature = def->features + i;\n\n        if (!feature->name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing CPU feature name\"));\n            return -1;\n        }\n\n        if (def->type == VIR_CPU_TYPE_GUEST) {\n            const char *policy;\n\n            policy = virCPUFeaturePolicyTypeToString(feature->policy);\n            if (!policy) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected CPU feature policy %d\"),\n                               feature->policy);\n                return -1;\n            }\n            virBufferAsprintf(buf, \"<feature policy='%s' name='%s'/>\\n\",\n                              policy, feature->name);\n        } else {\n            virBufferAsprintf(buf, \"<feature name='%s'/>\\n\",\n                              feature->name);\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<feature name='%s'/>\\n\"",
            "feature->name"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unexpected CPU feature policy %d\")",
            "feature->policy"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unexpected CPU feature policy %d\""
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUFeaturePolicyTypeToString",
          "args": [
            "feature->policy"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing CPU feature name\")"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUCacheModeTypeToString",
          "args": [
            "def->cache->mode"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<cache \""
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<topology\""
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeToString",
          "args": [
            "def->tsc->scaling"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<counter name='tsc'\""
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<vendor>%s</vendor>\\n\"",
            "def->vendor"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unexpected CPU fallback value: %d\")",
            "def->fallback"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUFallbackTypeToString",
          "args": [
            "def->fallback"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<model\""
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Non-empty feature list specified without CPU model\")"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefFormatBuf(virBufferPtr buf,\n                   virCPUDefPtr def)\n{\n    size_t i;\n    bool formatModel;\n\n    if (!def)\n        return 0;\n\n    formatModel = (def->mode == VIR_CPU_MODE_CUSTOM ||\n                   def->mode == VIR_CPU_MODE_HOST_MODEL);\n\n    if (!def->model && def->mode == VIR_CPU_MODE_CUSTOM && def->nfeatures) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Non-empty feature list specified without CPU model\"));\n        return -1;\n    }\n\n    if (formatModel && (def->model || def->vendor_id)) {\n        virBufferAddLit(buf, \"<model\");\n\n        if (def->type == VIR_CPU_TYPE_GUEST && def->model) {\n            const char *fallback;\n\n            fallback = virCPUFallbackTypeToString(def->fallback);\n            if (!fallback) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected CPU fallback value: %d\"),\n                               def->fallback);\n                return -1;\n            }\n            virBufferAsprintf(buf, \" fallback='%s'\", fallback);\n        }\n\n        if (def->type == VIR_CPU_TYPE_GUEST)\n            virBufferEscapeString(buf, \" vendor_id='%s'\", def->vendor_id);\n\n        if (def->model)\n            virBufferEscapeString(buf, \">%s</model>\\n\", def->model);\n        else\n            virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (formatModel && def->vendor)\n        virBufferEscapeString(buf, \"<vendor>%s</vendor>\\n\", def->vendor);\n\n    if (def->type == VIR_CPU_TYPE_HOST && def->microcodeVersion)\n        virBufferAsprintf(buf, \"<microcode version='%u'/>\\n\",\n                          def->microcodeVersion);\n\n    if (def->type == VIR_CPU_TYPE_HOST && def->tsc) {\n        virBufferAddLit(buf, \"<counter name='tsc'\");\n        virBufferAsprintf(buf, \" frequency='%llu'\", def->tsc->frequency);\n        if (def->tsc->scaling) {\n            virBufferAsprintf(buf, \" scaling='%s'\",\n                              virTristateBoolTypeToString(def->tsc->scaling));\n        }\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->sockets && def->dies && def->cores && def->threads) {\n        virBufferAddLit(buf, \"<topology\");\n        virBufferAsprintf(buf, \" sockets='%u'\", def->sockets);\n        virBufferAsprintf(buf, \" dies='%u'\", def->dies);\n        virBufferAsprintf(buf, \" cores='%u'\", def->cores);\n        virBufferAsprintf(buf, \" threads='%u'\", def->threads);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->cache) {\n        virBufferAddLit(buf, \"<cache \");\n        if (def->cache->level != -1)\n            virBufferAsprintf(buf, \"level='%d' \", def->cache->level);\n        virBufferAsprintf(buf, \"mode='%s'\",\n                          virCPUCacheModeTypeToString(def->cache->mode));\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    for (i = 0; i < def->nfeatures; i++) {\n        virCPUFeatureDefPtr feature = def->features + i;\n\n        if (!feature->name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing CPU feature name\"));\n            return -1;\n        }\n\n        if (def->type == VIR_CPU_TYPE_GUEST) {\n            const char *policy;\n\n            policy = virCPUFeaturePolicyTypeToString(feature->policy);\n            if (!policy) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected CPU feature policy %d\"),\n                               feature->policy);\n                return -1;\n            }\n            virBufferAsprintf(buf, \"<feature policy='%s' name='%s'/>\\n\",\n                              policy, feature->name);\n        } else {\n            virBufferAsprintf(buf, \"<feature name='%s'/>\\n\",\n                              feature->name);\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virCPUDefFormatBufFull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "701-773",
    "snippet": "int\nvirCPUDefFormatBufFull(virBufferPtr buf,\n                       virCPUDefPtr def,\n                       virDomainNumaPtr numa)\n{\n    int ret = -1;\n    virBuffer attributeBuf = VIR_BUFFER_INITIALIZER;\n    virBuffer childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n\n    if (!def)\n        return 0;\n\n    /* Format attributes for guest CPUs unless they only specify\n     * topology or cache. */\n    if (def->type == VIR_CPU_TYPE_GUEST &&\n        (def->mode != VIR_CPU_MODE_CUSTOM || def->model)) {\n        const char *tmp;\n\n        if (!(tmp = virCPUModeTypeToString(def->mode))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unexpected CPU mode %d\"), def->mode);\n            goto cleanup;\n        }\n        virBufferAsprintf(&attributeBuf, \" mode='%s'\", tmp);\n\n        if (def->mode == VIR_CPU_MODE_CUSTOM) {\n            if (!(tmp = virCPUMatchTypeToString(def->match))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected CPU match policy %d\"),\n                               def->match);\n                goto cleanup;\n            }\n            virBufferAsprintf(&attributeBuf, \" match='%s'\", tmp);\n        }\n\n        if (def->check) {\n            virBufferAsprintf(&attributeBuf, \" check='%s'\",\n                              virCPUCheckTypeToString(def->check));\n        }\n    }\n\n    /* Format children */\n    if (def->type == VIR_CPU_TYPE_HOST && def->arch)\n        virBufferAsprintf(&childrenBuf, \"<arch>%s</arch>\\n\",\n                          virArchToString(def->arch));\n    if (virCPUDefFormatBuf(&childrenBuf, def) < 0)\n        goto cleanup;\n\n    if (virDomainNumaDefCPUFormatXML(&childrenBuf, numa) < 0)\n        goto cleanup;\n\n    /* Put it all together */\n    if (virBufferUse(&attributeBuf) || virBufferUse(&childrenBuf)) {\n        virBufferAddLit(buf, \"<cpu\");\n\n        if (virBufferUse(&attributeBuf))\n            virBufferAddBuffer(buf, &attributeBuf);\n\n        if (virBufferUse(&childrenBuf)) {\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAddBuffer(buf, &childrenBuf);\n            virBufferAddLit(buf, \"</cpu>\\n\");\n        } else {\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&attributeBuf);\n    virBufferFreeAndReset(&childrenBuf);\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&childrenBuf"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</cpu>\\n\""
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddBuffer",
          "args": [
            "buf",
            "&childrenBuf"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "182-196",
          "snippet": "void\nvirBufferAddBuffer(virBufferPtr buf, virBufferPtr toadd)\n{\n    if (!toadd || !toadd->str)\n        return;\n\n    if (!buf)\n        goto cleanup;\n\n    virBufferInitialize(buf);\n    g_string_append_len(buf->str, toadd->str->str, toadd->str->len);\n\n cleanup:\n    virBufferFreeAndReset(toadd);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddBuffer(virBufferPtr buf, virBufferPtr toadd)\n{\n    if (!toadd || !toadd->str)\n        return;\n\n    if (!buf)\n        goto cleanup;\n\n    virBufferInitialize(buf);\n    g_string_append_len(buf->str, toadd->str->str, toadd->str->len);\n\n cleanup:\n    virBufferFreeAndReset(toadd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\">\\n\""
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferUse",
          "args": [
            "&childrenBuf"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferUse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "285-292",
          "snippet": "size_t\nvirBufferUse(const virBuffer *buf)\n{\n    if (!buf || !buf->str)\n        return 0;\n\n    return buf->str->len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nsize_t\nvirBufferUse(const virBuffer *buf)\n{\n    if (!buf || !buf->str)\n        return 0;\n\n    return buf->str->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<cpu\""
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNumaDefCPUFormatXML",
          "args": [
            "&childrenBuf",
            "numa"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaDefCPUFormatXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "973-1042",
          "snippet": "int\nvirDomainNumaDefCPUFormatXML(virBufferPtr buf,\n                             virDomainNumaPtr def)\n{\n    virDomainMemoryAccess memAccess;\n    virTristateBool discard;\n    char *cpustr;\n    size_t ncells = virDomainNumaGetNodeCount(def);\n    size_t i;\n\n    if (ncells == 0)\n        return 0;\n\n    virBufferAddLit(buf, \"<numa>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < ncells; i++) {\n        int ndistances;\n\n        memAccess = virDomainNumaGetNodeMemoryAccessMode(def, i);\n        discard = virDomainNumaGetNodeDiscard(def, i);\n\n        if (!(cpustr = virBitmapFormat(virDomainNumaGetNodeCpumask(def, i))))\n            return -1;\n\n        virBufferAddLit(buf, \"<cell\");\n        virBufferAsprintf(buf, \" id='%zu'\", i);\n        virBufferAsprintf(buf, \" cpus='%s'\", cpustr);\n        virBufferAsprintf(buf, \" memory='%llu'\",\n                          virDomainNumaGetNodeMemorySize(def, i));\n        virBufferAddLit(buf, \" unit='KiB'\");\n        if (memAccess)\n            virBufferAsprintf(buf, \" memAccess='%s'\",\n                              virDomainMemoryAccessTypeToString(memAccess));\n\n        if (discard)\n            virBufferAsprintf(buf, \" discard='%s'\",\n                              virTristateBoolTypeToString(discard));\n\n        ndistances = def->mem_nodes[i].ndistances;\n        if (ndistances == 0) {\n            virBufferAddLit(buf, \"/>\\n\");\n        } else {\n            size_t j;\n            virDomainNumaDistancePtr distances = def->mem_nodes[i].distances;\n\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n            virBufferAddLit(buf, \"<distances>\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (j = 0; j < ndistances; j++) {\n                if (distances[j].value) {\n                    virBufferAddLit(buf, \"<sibling\");\n                    virBufferAsprintf(buf, \" id='%d'\", distances[j].cellid);\n                    virBufferAsprintf(buf, \" value='%d'\", distances[j].value);\n                    virBufferAddLit(buf, \"/>\\n\");\n                }\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</distances>\\n\");\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</cell>\\n\");\n        }\n\n        VIR_FREE(cpustr);\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</numa>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nint\nvirDomainNumaDefCPUFormatXML(virBufferPtr buf,\n                             virDomainNumaPtr def)\n{\n    virDomainMemoryAccess memAccess;\n    virTristateBool discard;\n    char *cpustr;\n    size_t ncells = virDomainNumaGetNodeCount(def);\n    size_t i;\n\n    if (ncells == 0)\n        return 0;\n\n    virBufferAddLit(buf, \"<numa>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < ncells; i++) {\n        int ndistances;\n\n        memAccess = virDomainNumaGetNodeMemoryAccessMode(def, i);\n        discard = virDomainNumaGetNodeDiscard(def, i);\n\n        if (!(cpustr = virBitmapFormat(virDomainNumaGetNodeCpumask(def, i))))\n            return -1;\n\n        virBufferAddLit(buf, \"<cell\");\n        virBufferAsprintf(buf, \" id='%zu'\", i);\n        virBufferAsprintf(buf, \" cpus='%s'\", cpustr);\n        virBufferAsprintf(buf, \" memory='%llu'\",\n                          virDomainNumaGetNodeMemorySize(def, i));\n        virBufferAddLit(buf, \" unit='KiB'\");\n        if (memAccess)\n            virBufferAsprintf(buf, \" memAccess='%s'\",\n                              virDomainMemoryAccessTypeToString(memAccess));\n\n        if (discard)\n            virBufferAsprintf(buf, \" discard='%s'\",\n                              virTristateBoolTypeToString(discard));\n\n        ndistances = def->mem_nodes[i].ndistances;\n        if (ndistances == 0) {\n            virBufferAddLit(buf, \"/>\\n\");\n        } else {\n            size_t j;\n            virDomainNumaDistancePtr distances = def->mem_nodes[i].distances;\n\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n            virBufferAddLit(buf, \"<distances>\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (j = 0; j < ndistances; j++) {\n                if (distances[j].value) {\n                    virBufferAddLit(buf, \"<sibling\");\n                    virBufferAsprintf(buf, \" id='%d'\", distances[j].cellid);\n                    virBufferAsprintf(buf, \" value='%d'\", distances[j].value);\n                    virBufferAddLit(buf, \"/>\\n\");\n                }\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</distances>\\n\");\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</cell>\\n\");\n        }\n\n        VIR_FREE(cpustr);\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</numa>\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefFormatBuf",
          "args": [
            "&childrenBuf",
            "def"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFormatBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "775-882",
          "snippet": "int\nvirCPUDefFormatBuf(virBufferPtr buf,\n                   virCPUDefPtr def)\n{\n    size_t i;\n    bool formatModel;\n\n    if (!def)\n        return 0;\n\n    formatModel = (def->mode == VIR_CPU_MODE_CUSTOM ||\n                   def->mode == VIR_CPU_MODE_HOST_MODEL);\n\n    if (!def->model && def->mode == VIR_CPU_MODE_CUSTOM && def->nfeatures) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Non-empty feature list specified without CPU model\"));\n        return -1;\n    }\n\n    if (formatModel && (def->model || def->vendor_id)) {\n        virBufferAddLit(buf, \"<model\");\n\n        if (def->type == VIR_CPU_TYPE_GUEST && def->model) {\n            const char *fallback;\n\n            fallback = virCPUFallbackTypeToString(def->fallback);\n            if (!fallback) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected CPU fallback value: %d\"),\n                               def->fallback);\n                return -1;\n            }\n            virBufferAsprintf(buf, \" fallback='%s'\", fallback);\n        }\n\n        if (def->type == VIR_CPU_TYPE_GUEST)\n            virBufferEscapeString(buf, \" vendor_id='%s'\", def->vendor_id);\n\n        if (def->model)\n            virBufferEscapeString(buf, \">%s</model>\\n\", def->model);\n        else\n            virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (formatModel && def->vendor)\n        virBufferEscapeString(buf, \"<vendor>%s</vendor>\\n\", def->vendor);\n\n    if (def->type == VIR_CPU_TYPE_HOST && def->microcodeVersion)\n        virBufferAsprintf(buf, \"<microcode version='%u'/>\\n\",\n                          def->microcodeVersion);\n\n    if (def->type == VIR_CPU_TYPE_HOST && def->tsc) {\n        virBufferAddLit(buf, \"<counter name='tsc'\");\n        virBufferAsprintf(buf, \" frequency='%llu'\", def->tsc->frequency);\n        if (def->tsc->scaling) {\n            virBufferAsprintf(buf, \" scaling='%s'\",\n                              virTristateBoolTypeToString(def->tsc->scaling));\n        }\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->sockets && def->dies && def->cores && def->threads) {\n        virBufferAddLit(buf, \"<topology\");\n        virBufferAsprintf(buf, \" sockets='%u'\", def->sockets);\n        virBufferAsprintf(buf, \" dies='%u'\", def->dies);\n        virBufferAsprintf(buf, \" cores='%u'\", def->cores);\n        virBufferAsprintf(buf, \" threads='%u'\", def->threads);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->cache) {\n        virBufferAddLit(buf, \"<cache \");\n        if (def->cache->level != -1)\n            virBufferAsprintf(buf, \"level='%d' \", def->cache->level);\n        virBufferAsprintf(buf, \"mode='%s'\",\n                          virCPUCacheModeTypeToString(def->cache->mode));\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    for (i = 0; i < def->nfeatures; i++) {\n        virCPUFeatureDefPtr feature = def->features + i;\n\n        if (!feature->name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing CPU feature name\"));\n            return -1;\n        }\n\n        if (def->type == VIR_CPU_TYPE_GUEST) {\n            const char *policy;\n\n            policy = virCPUFeaturePolicyTypeToString(feature->policy);\n            if (!policy) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected CPU feature policy %d\"),\n                               feature->policy);\n                return -1;\n            }\n            virBufferAsprintf(buf, \"<feature policy='%s' name='%s'/>\\n\",\n                              policy, feature->name);\n        } else {\n            virBufferAsprintf(buf, \"<feature name='%s'/>\\n\",\n                              feature->name);\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefFormatBuf(virBufferPtr buf,\n                   virCPUDefPtr def)\n{\n    size_t i;\n    bool formatModel;\n\n    if (!def)\n        return 0;\n\n    formatModel = (def->mode == VIR_CPU_MODE_CUSTOM ||\n                   def->mode == VIR_CPU_MODE_HOST_MODEL);\n\n    if (!def->model && def->mode == VIR_CPU_MODE_CUSTOM && def->nfeatures) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Non-empty feature list specified without CPU model\"));\n        return -1;\n    }\n\n    if (formatModel && (def->model || def->vendor_id)) {\n        virBufferAddLit(buf, \"<model\");\n\n        if (def->type == VIR_CPU_TYPE_GUEST && def->model) {\n            const char *fallback;\n\n            fallback = virCPUFallbackTypeToString(def->fallback);\n            if (!fallback) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected CPU fallback value: %d\"),\n                               def->fallback);\n                return -1;\n            }\n            virBufferAsprintf(buf, \" fallback='%s'\", fallback);\n        }\n\n        if (def->type == VIR_CPU_TYPE_GUEST)\n            virBufferEscapeString(buf, \" vendor_id='%s'\", def->vendor_id);\n\n        if (def->model)\n            virBufferEscapeString(buf, \">%s</model>\\n\", def->model);\n        else\n            virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (formatModel && def->vendor)\n        virBufferEscapeString(buf, \"<vendor>%s</vendor>\\n\", def->vendor);\n\n    if (def->type == VIR_CPU_TYPE_HOST && def->microcodeVersion)\n        virBufferAsprintf(buf, \"<microcode version='%u'/>\\n\",\n                          def->microcodeVersion);\n\n    if (def->type == VIR_CPU_TYPE_HOST && def->tsc) {\n        virBufferAddLit(buf, \"<counter name='tsc'\");\n        virBufferAsprintf(buf, \" frequency='%llu'\", def->tsc->frequency);\n        if (def->tsc->scaling) {\n            virBufferAsprintf(buf, \" scaling='%s'\",\n                              virTristateBoolTypeToString(def->tsc->scaling));\n        }\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->sockets && def->dies && def->cores && def->threads) {\n        virBufferAddLit(buf, \"<topology\");\n        virBufferAsprintf(buf, \" sockets='%u'\", def->sockets);\n        virBufferAsprintf(buf, \" dies='%u'\", def->dies);\n        virBufferAsprintf(buf, \" cores='%u'\", def->cores);\n        virBufferAsprintf(buf, \" threads='%u'\", def->threads);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->cache) {\n        virBufferAddLit(buf, \"<cache \");\n        if (def->cache->level != -1)\n            virBufferAsprintf(buf, \"level='%d' \", def->cache->level);\n        virBufferAsprintf(buf, \"mode='%s'\",\n                          virCPUCacheModeTypeToString(def->cache->mode));\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    for (i = 0; i < def->nfeatures; i++) {\n        virCPUFeatureDefPtr feature = def->features + i;\n\n        if (!feature->name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing CPU feature name\"));\n            return -1;\n        }\n\n        if (def->type == VIR_CPU_TYPE_GUEST) {\n            const char *policy;\n\n            policy = virCPUFeaturePolicyTypeToString(feature->policy);\n            if (!policy) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected CPU feature policy %d\"),\n                               feature->policy);\n                return -1;\n            }\n            virBufferAsprintf(buf, \"<feature policy='%s' name='%s'/>\\n\",\n                              policy, feature->name);\n        } else {\n            virBufferAsprintf(buf, \"<feature name='%s'/>\\n\",\n                              feature->name);\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&childrenBuf",
            "\"<arch>%s</arch>\\n\"",
            "virArchToString(def->arch)"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "def->arch"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUCheckTypeToString",
          "args": [
            "def->check"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unexpected CPU match policy %d\")",
            "def->match"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unexpected CPU match policy %d\""
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUMatchTypeToString",
          "args": [
            "def->match"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unexpected CPU mode %d\")",
            "def->mode"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUModeTypeToString",
          "args": [
            "def->mode"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_BUFFER_INIT_CHILD",
          "args": [
            "buf"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefFormatBufFull(virBufferPtr buf,\n                       virCPUDefPtr def,\n                       virDomainNumaPtr numa)\n{\n    int ret = -1;\n    virBuffer attributeBuf = VIR_BUFFER_INITIALIZER;\n    virBuffer childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n\n    if (!def)\n        return 0;\n\n    /* Format attributes for guest CPUs unless they only specify\n     * topology or cache. */\n    if (def->type == VIR_CPU_TYPE_GUEST &&\n        (def->mode != VIR_CPU_MODE_CUSTOM || def->model)) {\n        const char *tmp;\n\n        if (!(tmp = virCPUModeTypeToString(def->mode))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unexpected CPU mode %d\"), def->mode);\n            goto cleanup;\n        }\n        virBufferAsprintf(&attributeBuf, \" mode='%s'\", tmp);\n\n        if (def->mode == VIR_CPU_MODE_CUSTOM) {\n            if (!(tmp = virCPUMatchTypeToString(def->match))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected CPU match policy %d\"),\n                               def->match);\n                goto cleanup;\n            }\n            virBufferAsprintf(&attributeBuf, \" match='%s'\", tmp);\n        }\n\n        if (def->check) {\n            virBufferAsprintf(&attributeBuf, \" check='%s'\",\n                              virCPUCheckTypeToString(def->check));\n        }\n    }\n\n    /* Format children */\n    if (def->type == VIR_CPU_TYPE_HOST && def->arch)\n        virBufferAsprintf(&childrenBuf, \"<arch>%s</arch>\\n\",\n                          virArchToString(def->arch));\n    if (virCPUDefFormatBuf(&childrenBuf, def) < 0)\n        goto cleanup;\n\n    if (virDomainNumaDefCPUFormatXML(&childrenBuf, numa) < 0)\n        goto cleanup;\n\n    /* Put it all together */\n    if (virBufferUse(&attributeBuf) || virBufferUse(&childrenBuf)) {\n        virBufferAddLit(buf, \"<cpu\");\n\n        if (virBufferUse(&attributeBuf))\n            virBufferAddBuffer(buf, &attributeBuf);\n\n        if (virBufferUse(&childrenBuf)) {\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAddBuffer(buf, &childrenBuf);\n            virBufferAddLit(buf, \"</cpu>\\n\");\n        } else {\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&attributeBuf);\n    virBufferFreeAndReset(&childrenBuf);\n    return ret;\n}"
  },
  {
    "function_name": "virCPUDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "684-698",
    "snippet": "char *\nvirCPUDefFormat(virCPUDefPtr def,\n                virDomainNumaPtr numa)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virCPUDefFormatBufFull(&buf, def, numa) < 0)\n        goto cleanup;\n\n    return virBufferContentAndReset(&buf);\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefFormatBufFull",
          "args": [
            "&buf",
            "def",
            "numa"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFormatBufFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "701-773",
          "snippet": "int\nvirCPUDefFormatBufFull(virBufferPtr buf,\n                       virCPUDefPtr def,\n                       virDomainNumaPtr numa)\n{\n    int ret = -1;\n    virBuffer attributeBuf = VIR_BUFFER_INITIALIZER;\n    virBuffer childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n\n    if (!def)\n        return 0;\n\n    /* Format attributes for guest CPUs unless they only specify\n     * topology or cache. */\n    if (def->type == VIR_CPU_TYPE_GUEST &&\n        (def->mode != VIR_CPU_MODE_CUSTOM || def->model)) {\n        const char *tmp;\n\n        if (!(tmp = virCPUModeTypeToString(def->mode))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unexpected CPU mode %d\"), def->mode);\n            goto cleanup;\n        }\n        virBufferAsprintf(&attributeBuf, \" mode='%s'\", tmp);\n\n        if (def->mode == VIR_CPU_MODE_CUSTOM) {\n            if (!(tmp = virCPUMatchTypeToString(def->match))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected CPU match policy %d\"),\n                               def->match);\n                goto cleanup;\n            }\n            virBufferAsprintf(&attributeBuf, \" match='%s'\", tmp);\n        }\n\n        if (def->check) {\n            virBufferAsprintf(&attributeBuf, \" check='%s'\",\n                              virCPUCheckTypeToString(def->check));\n        }\n    }\n\n    /* Format children */\n    if (def->type == VIR_CPU_TYPE_HOST && def->arch)\n        virBufferAsprintf(&childrenBuf, \"<arch>%s</arch>\\n\",\n                          virArchToString(def->arch));\n    if (virCPUDefFormatBuf(&childrenBuf, def) < 0)\n        goto cleanup;\n\n    if (virDomainNumaDefCPUFormatXML(&childrenBuf, numa) < 0)\n        goto cleanup;\n\n    /* Put it all together */\n    if (virBufferUse(&attributeBuf) || virBufferUse(&childrenBuf)) {\n        virBufferAddLit(buf, \"<cpu\");\n\n        if (virBufferUse(&attributeBuf))\n            virBufferAddBuffer(buf, &attributeBuf);\n\n        if (virBufferUse(&childrenBuf)) {\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAddBuffer(buf, &childrenBuf);\n            virBufferAddLit(buf, \"</cpu>\\n\");\n        } else {\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&attributeBuf);\n    virBufferFreeAndReset(&childrenBuf);\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefFormatBufFull(virBufferPtr buf,\n                       virCPUDefPtr def,\n                       virDomainNumaPtr numa)\n{\n    int ret = -1;\n    virBuffer attributeBuf = VIR_BUFFER_INITIALIZER;\n    virBuffer childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n\n    if (!def)\n        return 0;\n\n    /* Format attributes for guest CPUs unless they only specify\n     * topology or cache. */\n    if (def->type == VIR_CPU_TYPE_GUEST &&\n        (def->mode != VIR_CPU_MODE_CUSTOM || def->model)) {\n        const char *tmp;\n\n        if (!(tmp = virCPUModeTypeToString(def->mode))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unexpected CPU mode %d\"), def->mode);\n            goto cleanup;\n        }\n        virBufferAsprintf(&attributeBuf, \" mode='%s'\", tmp);\n\n        if (def->mode == VIR_CPU_MODE_CUSTOM) {\n            if (!(tmp = virCPUMatchTypeToString(def->match))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected CPU match policy %d\"),\n                               def->match);\n                goto cleanup;\n            }\n            virBufferAsprintf(&attributeBuf, \" match='%s'\", tmp);\n        }\n\n        if (def->check) {\n            virBufferAsprintf(&attributeBuf, \" check='%s'\",\n                              virCPUCheckTypeToString(def->check));\n        }\n    }\n\n    /* Format children */\n    if (def->type == VIR_CPU_TYPE_HOST && def->arch)\n        virBufferAsprintf(&childrenBuf, \"<arch>%s</arch>\\n\",\n                          virArchToString(def->arch));\n    if (virCPUDefFormatBuf(&childrenBuf, def) < 0)\n        goto cleanup;\n\n    if (virDomainNumaDefCPUFormatXML(&childrenBuf, numa) < 0)\n        goto cleanup;\n\n    /* Put it all together */\n    if (virBufferUse(&attributeBuf) || virBufferUse(&childrenBuf)) {\n        virBufferAddLit(buf, \"<cpu\");\n\n        if (virBufferUse(&attributeBuf))\n            virBufferAddBuffer(buf, &attributeBuf);\n\n        if (virBufferUse(&childrenBuf)) {\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAddBuffer(buf, &childrenBuf);\n            virBufferAddLit(buf, \"</cpu>\\n\");\n        } else {\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&attributeBuf);\n    virBufferFreeAndReset(&childrenBuf);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nchar *\nvirCPUDefFormat(virCPUDefPtr def,\n                virDomainNumaPtr numa)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virCPUDefFormatBufFull(&buf, def, numa) < 0)\n        goto cleanup;\n\n    return virBufferContentAndReset(&buf);\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
  },
  {
    "function_name": "virCPUDefParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "329-681",
    "snippet": "int\nvirCPUDefParseXML(xmlXPathContextPtr ctxt,\n                  const char *xpath,\n                  virCPUType type,\n                  virCPUDefPtr *cpu)\n{\n    virCPUDefPtr def = NULL;\n    xmlNodePtr *nodes = NULL;\n    xmlNodePtr oldnode = ctxt->node;\n    int n;\n    size_t i;\n    char *cpuMode;\n    char *fallback = NULL;\n    char *vendor_id = NULL;\n    char *tscScaling = NULL;\n    virHostCPUTscInfoPtr tsc = NULL;\n    int ret = -1;\n\n    *cpu = NULL;\n\n    if (xpath && !(ctxt->node = virXPathNode(xpath, ctxt))) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virXMLNodeNameEqual(ctxt->node, \"cpu\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"XML does not contain expected 'cpu' element\"));\n        goto cleanup;\n    }\n\n    def = virCPUDefNew();\n\n    if (type == VIR_CPU_TYPE_AUTO) {\n        if (virXPathBoolean(\"boolean(./arch)\", ctxt)) {\n            if (virXPathBoolean(\"boolean(./@match)\", ctxt)) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"'arch' element cannot be used inside 'cpu'\"\n                                 \" element with 'match' attribute'\"));\n                goto cleanup;\n            }\n            def->type = VIR_CPU_TYPE_HOST;\n        } else {\n            def->type = VIR_CPU_TYPE_GUEST;\n        }\n    } else {\n        def->type = type;\n    }\n\n    if ((cpuMode = virXMLPropString(ctxt->node, \"mode\"))) {\n        if (def->type == VIR_CPU_TYPE_HOST) {\n            VIR_FREE(cpuMode);\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Attribute mode is only allowed for guest CPU\"));\n            goto cleanup;\n        } else {\n            def->mode = virCPUModeTypeFromString(cpuMode);\n\n            if (def->mode < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid mode attribute '%s'\"),\n                               cpuMode);\n                VIR_FREE(cpuMode);\n                goto cleanup;\n            }\n            VIR_FREE(cpuMode);\n        }\n    } else {\n        if (def->type == VIR_CPU_TYPE_HOST)\n            def->mode = -1;\n        else\n            def->mode = VIR_CPU_MODE_CUSTOM;\n    }\n\n    if (def->type == VIR_CPU_TYPE_GUEST) {\n        char *match = virXMLPropString(ctxt->node, \"match\");\n        char *check;\n\n        if (match) {\n            def->match = virCPUMatchTypeFromString(match);\n            VIR_FREE(match);\n\n            if (def->match < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid match attribute for CPU \"\n                                 \"specification\"));\n                goto cleanup;\n            }\n        }\n\n        if ((check = virXMLPropString(ctxt->node, \"check\"))) {\n            int value = virCPUCheckTypeFromString(check);\n            VIR_FREE(check);\n\n            if (value < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid check attribute for CPU \"\n                                 \"specification\"));\n                goto cleanup;\n            }\n            def->check = value;\n        }\n    }\n\n    if (def->type == VIR_CPU_TYPE_HOST) {\n        char *arch = virXPathString(\"string(./arch[1])\", ctxt);\n        if (!arch) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing CPU architecture\"));\n            goto cleanup;\n        }\n        if ((def->arch = virArchFromString(arch)) == VIR_ARCH_NONE) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unknown architecture %s\"), arch);\n            VIR_FREE(arch);\n            goto cleanup;\n        }\n        VIR_FREE(arch);\n\n        if (virXPathBoolean(\"boolean(./microcode[1]/@version)\", ctxt) > 0 &&\n            virXPathUInt(\"string(./microcode[1]/@version)\", ctxt,\n                         &def->microcodeVersion) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"invalid microcode version\"));\n            goto cleanup;\n        }\n\n        if (virXPathBoolean(\"boolean(./counter[@name='tsc'])\", ctxt) > 0) {\n            if (VIR_ALLOC(tsc) < 0)\n                goto cleanup;\n\n            if (virXPathULongLong(\"string(./counter[@name='tsc']/@frequency)\",\n                                  ctxt, &tsc->frequency) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid TSC frequency\"));\n                goto cleanup;\n            }\n\n            tscScaling = virXPathString(\"string(./counter[@name='tsc']/@scaling)\",\n                                        ctxt);\n            if (tscScaling) {\n                int scaling = virTristateBoolTypeFromString(tscScaling);\n                if (scaling < 0) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Invalid TSC scaling attribute\"));\n                    goto cleanup;\n                }\n                tsc->scaling = scaling;\n            }\n\n            def->tsc = g_steal_pointer(&tsc);\n        }\n    }\n\n    if (!(def->model = virXPathString(\"string(./model[1])\", ctxt)) &&\n        def->type == VIR_CPU_TYPE_HOST) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                        _(\"Missing CPU model name\"));\n        goto cleanup;\n    }\n\n    if (def->type == VIR_CPU_TYPE_GUEST &&\n        def->mode != VIR_CPU_MODE_HOST_PASSTHROUGH) {\n\n        if ((fallback = virXPathString(\"string(./model[1]/@fallback)\", ctxt))) {\n            if ((def->fallback = virCPUFallbackTypeFromString(fallback)) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid fallback attribute\"));\n                goto cleanup;\n            }\n        }\n\n        if ((vendor_id = virXPathString(\"string(./model[1]/@vendor_id)\",\n                                        ctxt))) {\n            if (strlen(vendor_id) != VIR_CPU_VENDOR_ID_LENGTH) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"vendor_id must be exactly %d characters long\"),\n                               VIR_CPU_VENDOR_ID_LENGTH);\n                goto cleanup;\n            }\n\n            /* ensure that the string can be passed to qemu */\n            if (strchr(vendor_id, ',')) {\n                    virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                                   _(\"vendor id is invalid\"));\n                    goto cleanup;\n            }\n\n            def->vendor_id = vendor_id;\n            vendor_id = NULL;\n        }\n    }\n\n    def->vendor = virXPathString(\"string(./vendor[1])\", ctxt);\n    if (def->vendor && !def->model) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"CPU vendor specified without CPU model\"));\n        goto cleanup;\n    }\n\n    if (virXPathNode(\"./topology[1]\", ctxt)) {\n        unsigned long ul;\n\n        if (virXPathULong(\"string(./topology[1]/@sockets)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'sockets' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->sockets = (unsigned int) ul;\n\n        if (virXPathNode(\"./topology[1]/@dies\", ctxt)) {\n            if (virXPathULong(\"string(./topology[1]/@dies)\", ctxt, &ul) < 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"Malformed 'dies' attribute in CPU topology\"));\n                goto cleanup;\n            }\n            def->dies = (unsigned int) ul;\n        } else {\n            def->dies = 1;\n        }\n\n        if (virXPathULong(\"string(./topology[1]/@cores)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'cores' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->cores = (unsigned int) ul;\n\n        if (virXPathULong(\"string(./topology[1]/@threads)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'threads' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->threads = (unsigned int) ul;\n\n        if (!def->sockets || !def->cores || !def->threads || !def->dies) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Invalid CPU topology\"));\n            goto cleanup;\n        }\n    }\n\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    if (n > 0) {\n        if (!def->model && def->mode == VIR_CPU_MODE_CUSTOM) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Non-empty feature list specified without \"\n                             \"CPU model\"));\n            goto cleanup;\n        }\n\n        if (VIR_RESIZE_N(def->features, def->nfeatures_max,\n                         def->nfeatures, n) < 0)\n            goto cleanup;\n\n        def->nfeatures = n;\n    }\n\n    for (i = 0; i < n; i++) {\n        char *name;\n        int policy; /* enum virDomainCPUFeaturePolicy */\n        size_t j;\n\n        if (def->type == VIR_CPU_TYPE_GUEST) {\n            char *strpolicy;\n\n            strpolicy = virXMLPropString(nodes[i], \"policy\");\n            if (strpolicy == NULL)\n                policy = VIR_CPU_FEATURE_REQUIRE;\n            else\n                policy = virCPUFeaturePolicyTypeFromString(strpolicy);\n            VIR_FREE(strpolicy);\n\n            if (policy < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid CPU feature policy\"));\n                goto cleanup;\n            }\n        } else {\n            policy = -1;\n        }\n\n        if (!(name = virXMLPropString(nodes[i], \"name\")) || *name == 0) {\n            VIR_FREE(name);\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Invalid CPU feature name\"));\n            goto cleanup;\n        }\n\n        for (j = 0; j < i; j++) {\n            if (STREQ(name, def->features[j].name)) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"CPU feature '%s' specified more than once\"),\n                               name);\n                VIR_FREE(name);\n                goto cleanup;\n            }\n        }\n\n        def->features[i].name = name;\n        def->features[i].policy = policy;\n    }\n\n    if (virXPathInt(\"count(./cache)\", ctxt, &n) < 0) {\n        goto cleanup;\n    } else if (n > 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"at most one CPU cache element may be specified\"));\n        goto cleanup;\n    } else if (n == 1) {\n        int level = -1;\n        char *strmode;\n        int mode;\n\n        if (virXPathBoolean(\"boolean(./cache[1]/@level)\", ctxt) == 1 &&\n            (virXPathInt(\"string(./cache[1]/@level)\", ctxt, &level) < 0 ||\n             level < 1 || level > 3)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"invalid CPU cache level, must be in range [1,3]\"));\n            goto cleanup;\n        }\n\n        if (!(strmode = virXPathString(\"string(./cache[1]/@mode)\", ctxt)) ||\n            (mode = virCPUCacheModeTypeFromString(strmode)) < 0) {\n            VIR_FREE(strmode);\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing or invalid CPU cache mode\"));\n            goto cleanup;\n        }\n        VIR_FREE(strmode);\n\n        if (VIR_ALLOC(def->cache) < 0)\n            goto cleanup;\n\n        def->cache->level = level;\n        def->cache->mode = mode;\n    }\n\n    *cpu = g_steal_pointer(&def);\n    ret = 0;\n\n cleanup:\n    ctxt->node = oldnode;\n    VIR_FREE(fallback);\n    VIR_FREE(vendor_id);\n    VIR_FREE(nodes);\n    VIR_FREE(tscScaling);\n    VIR_FREE(tsc);\n    virCPUDefFree(def);\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "def"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tsc"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tscScaling"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vendor_id"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fallback"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&def"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def->cache"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "strmode"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing or invalid CPU cache mode\")"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing or invalid CPU cache mode\""
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "strmode"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUCacheModeTypeFromString",
          "args": [
            "strmode"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./cache[1]/@mode)\"",
            "ctxt"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"invalid CPU cache level, must be in range [1,3]\")"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathInt",
          "args": [
            "\"string(./cache[1]/@level)\"",
            "ctxt",
            "&level"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "223-238",
          "snippet": "int\nvirXPathInt(const char *xpath,\n            xmlXPathContextPtr ctxt,\n            int *value)\n{\n    long tmp;\n    int ret;\n\n    ret = virXPathLongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathInt(const char *xpath,\n            xmlXPathContextPtr ctxt,\n            int *value)\n{\n    long tmp;\n    int ret;\n\n    ret = virXPathLongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathBoolean",
          "args": [
            "\"boolean(./cache[1]/@level)\"",
            "ctxt"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "571-596",
          "snippet": "int\nvirXPathBoolean(const char *xpath,\n                xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathBoolean()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_BOOLEAN) ||\n        (obj->boolval < 0) || (obj->boolval > 1)) {\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n    ret = obj->boolval;\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathBoolean(const char *xpath,\n                xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathBoolean()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_BOOLEAN) ||\n        (obj->boolval < 0) || (obj->boolval > 1)) {\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n    ret = obj->boolval;\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"at most one CPU cache element may be specified\")"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"CPU feature '%s' specified more than once\")",
            "name"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "def->features[j].name"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Invalid CPU feature name\")"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "nodes[i]",
            "\"name\""
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Invalid CPU feature policy\")"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "strpolicy"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUFeaturePolicyTypeFromString",
          "args": [
            "strpolicy"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "def->features",
            "def->nfeatures_max",
            "def->nfeatures",
            "n"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Non-empty feature list specified without \"\n                             \"CPU model\")"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./feature\"",
            "ctxt",
            "&nodes"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Invalid CPU topology\")"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Missing 'threads' attribute in CPU topology\")"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathULong",
          "args": [
            "\"string(./topology[1]/@threads)\"",
            "ctxt",
            "&ul"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "398-430",
          "snippet": "int\nvirXPathULongLong(const char *xpath,\n                  xmlXPathContextPtr ctxt,\n                  unsigned long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathULong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ull((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (unsigned long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathULongLong(const char *xpath,\n                  xmlXPathContextPtr ctxt,\n                  unsigned long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathULong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ull((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (unsigned long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Missing 'cores' attribute in CPU topology\")"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Malformed 'dies' attribute in CPU topology\")"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./topology[1]/@dies\"",
            "ctxt"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Missing 'sockets' attribute in CPU topology\")"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"CPU vendor specified without CPU model\")"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"vendor id is invalid\")"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "vendor_id",
            "','"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"vendor_id must be exactly %d characters long\")",
            "VIR_CPU_VENDOR_ID_LENGTH"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "vendor_id"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Invalid fallback attribute\")"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUFallbackTypeFromString",
          "args": [
            "fallback"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Missing CPU model name\")"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&tsc"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Invalid TSC scaling attribute\")"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeFromString",
          "args": [
            "tscScaling"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Invalid TSC frequency\")"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "tsc"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"invalid microcode version\")"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathUInt",
          "args": [
            "\"string(./microcode[1]/@version)\"",
            "ctxt",
            "&def->microcodeVersion"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathUInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "328-343",
          "snippet": "int\nvirXPathUInt(const char *xpath,\n             xmlXPathContextPtr ctxt,\n             unsigned int *value)\n{\n    unsigned long tmp;\n    int ret;\n\n    ret = virXPathULongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((unsigned int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathUInt(const char *xpath,\n             xmlXPathContextPtr ctxt,\n             unsigned int *value)\n{\n    unsigned long tmp;\n    int ret;\n\n    ret = virXPathULongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((unsigned int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "arch"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "arch"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unknown architecture %s\")",
            "arch"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchFromString",
          "args": [
            "arch"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "142-152",
          "snippet": "virArch virArchFromString(const char *archstr)\n{\n    size_t i;\n    for (i = 1; i < VIR_ARCH_LAST; i++) {\n        if (STREQ(virArchData[i].name, archstr))\n            return i;\n    }\n\n    VIR_DEBUG(\"Unknown arch %s\", archstr);\n    return VIR_ARCH_NONE;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nvirArch virArchFromString(const char *archstr)\n{\n    size_t i;\n    for (i = 1; i < VIR_ARCH_LAST; i++) {\n        if (STREQ(virArchData[i].name, archstr))\n            return i;\n    }\n\n    VIR_DEBUG(\"Unknown arch %s\", archstr);\n    return VIR_ARCH_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Missing CPU architecture\")"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Invalid check attribute for CPU \"\n                                 \"specification\")"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "check"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUCheckTypeFromString",
          "args": [
            "check"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Invalid match attribute for CPU \"\n                                 \"specification\")"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "match"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUMatchTypeFromString",
          "args": [
            "match"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpuMode"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpuMode"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Invalid mode attribute '%s'\")",
            "cpuMode"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUModeTypeFromString",
          "args": [
            "cpuMode"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Attribute mode is only allowed for guest CPU\")"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpuMode"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"'arch' element cannot be used inside 'cpu'\"\n                                 \" element with 'match' attribute'\")"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefNew",
          "args": [],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "85-90",
          "snippet": "virCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"XML does not contain expected 'cpu' element\")"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLNodeNameEqual",
          "args": [
            "ctxt->node",
            "\"cpu\""
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeNameEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1013-1018",
          "snippet": "bool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nbool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefParseXML(xmlXPathContextPtr ctxt,\n                  const char *xpath,\n                  virCPUType type,\n                  virCPUDefPtr *cpu)\n{\n    virCPUDefPtr def = NULL;\n    xmlNodePtr *nodes = NULL;\n    xmlNodePtr oldnode = ctxt->node;\n    int n;\n    size_t i;\n    char *cpuMode;\n    char *fallback = NULL;\n    char *vendor_id = NULL;\n    char *tscScaling = NULL;\n    virHostCPUTscInfoPtr tsc = NULL;\n    int ret = -1;\n\n    *cpu = NULL;\n\n    if (xpath && !(ctxt->node = virXPathNode(xpath, ctxt))) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virXMLNodeNameEqual(ctxt->node, \"cpu\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"XML does not contain expected 'cpu' element\"));\n        goto cleanup;\n    }\n\n    def = virCPUDefNew();\n\n    if (type == VIR_CPU_TYPE_AUTO) {\n        if (virXPathBoolean(\"boolean(./arch)\", ctxt)) {\n            if (virXPathBoolean(\"boolean(./@match)\", ctxt)) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"'arch' element cannot be used inside 'cpu'\"\n                                 \" element with 'match' attribute'\"));\n                goto cleanup;\n            }\n            def->type = VIR_CPU_TYPE_HOST;\n        } else {\n            def->type = VIR_CPU_TYPE_GUEST;\n        }\n    } else {\n        def->type = type;\n    }\n\n    if ((cpuMode = virXMLPropString(ctxt->node, \"mode\"))) {\n        if (def->type == VIR_CPU_TYPE_HOST) {\n            VIR_FREE(cpuMode);\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Attribute mode is only allowed for guest CPU\"));\n            goto cleanup;\n        } else {\n            def->mode = virCPUModeTypeFromString(cpuMode);\n\n            if (def->mode < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid mode attribute '%s'\"),\n                               cpuMode);\n                VIR_FREE(cpuMode);\n                goto cleanup;\n            }\n            VIR_FREE(cpuMode);\n        }\n    } else {\n        if (def->type == VIR_CPU_TYPE_HOST)\n            def->mode = -1;\n        else\n            def->mode = VIR_CPU_MODE_CUSTOM;\n    }\n\n    if (def->type == VIR_CPU_TYPE_GUEST) {\n        char *match = virXMLPropString(ctxt->node, \"match\");\n        char *check;\n\n        if (match) {\n            def->match = virCPUMatchTypeFromString(match);\n            VIR_FREE(match);\n\n            if (def->match < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid match attribute for CPU \"\n                                 \"specification\"));\n                goto cleanup;\n            }\n        }\n\n        if ((check = virXMLPropString(ctxt->node, \"check\"))) {\n            int value = virCPUCheckTypeFromString(check);\n            VIR_FREE(check);\n\n            if (value < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid check attribute for CPU \"\n                                 \"specification\"));\n                goto cleanup;\n            }\n            def->check = value;\n        }\n    }\n\n    if (def->type == VIR_CPU_TYPE_HOST) {\n        char *arch = virXPathString(\"string(./arch[1])\", ctxt);\n        if (!arch) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing CPU architecture\"));\n            goto cleanup;\n        }\n        if ((def->arch = virArchFromString(arch)) == VIR_ARCH_NONE) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unknown architecture %s\"), arch);\n            VIR_FREE(arch);\n            goto cleanup;\n        }\n        VIR_FREE(arch);\n\n        if (virXPathBoolean(\"boolean(./microcode[1]/@version)\", ctxt) > 0 &&\n            virXPathUInt(\"string(./microcode[1]/@version)\", ctxt,\n                         &def->microcodeVersion) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"invalid microcode version\"));\n            goto cleanup;\n        }\n\n        if (virXPathBoolean(\"boolean(./counter[@name='tsc'])\", ctxt) > 0) {\n            if (VIR_ALLOC(tsc) < 0)\n                goto cleanup;\n\n            if (virXPathULongLong(\"string(./counter[@name='tsc']/@frequency)\",\n                                  ctxt, &tsc->frequency) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid TSC frequency\"));\n                goto cleanup;\n            }\n\n            tscScaling = virXPathString(\"string(./counter[@name='tsc']/@scaling)\",\n                                        ctxt);\n            if (tscScaling) {\n                int scaling = virTristateBoolTypeFromString(tscScaling);\n                if (scaling < 0) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Invalid TSC scaling attribute\"));\n                    goto cleanup;\n                }\n                tsc->scaling = scaling;\n            }\n\n            def->tsc = g_steal_pointer(&tsc);\n        }\n    }\n\n    if (!(def->model = virXPathString(\"string(./model[1])\", ctxt)) &&\n        def->type == VIR_CPU_TYPE_HOST) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                        _(\"Missing CPU model name\"));\n        goto cleanup;\n    }\n\n    if (def->type == VIR_CPU_TYPE_GUEST &&\n        def->mode != VIR_CPU_MODE_HOST_PASSTHROUGH) {\n\n        if ((fallback = virXPathString(\"string(./model[1]/@fallback)\", ctxt))) {\n            if ((def->fallback = virCPUFallbackTypeFromString(fallback)) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid fallback attribute\"));\n                goto cleanup;\n            }\n        }\n\n        if ((vendor_id = virXPathString(\"string(./model[1]/@vendor_id)\",\n                                        ctxt))) {\n            if (strlen(vendor_id) != VIR_CPU_VENDOR_ID_LENGTH) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"vendor_id must be exactly %d characters long\"),\n                               VIR_CPU_VENDOR_ID_LENGTH);\n                goto cleanup;\n            }\n\n            /* ensure that the string can be passed to qemu */\n            if (strchr(vendor_id, ',')) {\n                    virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                                   _(\"vendor id is invalid\"));\n                    goto cleanup;\n            }\n\n            def->vendor_id = vendor_id;\n            vendor_id = NULL;\n        }\n    }\n\n    def->vendor = virXPathString(\"string(./vendor[1])\", ctxt);\n    if (def->vendor && !def->model) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"CPU vendor specified without CPU model\"));\n        goto cleanup;\n    }\n\n    if (virXPathNode(\"./topology[1]\", ctxt)) {\n        unsigned long ul;\n\n        if (virXPathULong(\"string(./topology[1]/@sockets)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'sockets' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->sockets = (unsigned int) ul;\n\n        if (virXPathNode(\"./topology[1]/@dies\", ctxt)) {\n            if (virXPathULong(\"string(./topology[1]/@dies)\", ctxt, &ul) < 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"Malformed 'dies' attribute in CPU topology\"));\n                goto cleanup;\n            }\n            def->dies = (unsigned int) ul;\n        } else {\n            def->dies = 1;\n        }\n\n        if (virXPathULong(\"string(./topology[1]/@cores)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'cores' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->cores = (unsigned int) ul;\n\n        if (virXPathULong(\"string(./topology[1]/@threads)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'threads' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->threads = (unsigned int) ul;\n\n        if (!def->sockets || !def->cores || !def->threads || !def->dies) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Invalid CPU topology\"));\n            goto cleanup;\n        }\n    }\n\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    if (n > 0) {\n        if (!def->model && def->mode == VIR_CPU_MODE_CUSTOM) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Non-empty feature list specified without \"\n                             \"CPU model\"));\n            goto cleanup;\n        }\n\n        if (VIR_RESIZE_N(def->features, def->nfeatures_max,\n                         def->nfeatures, n) < 0)\n            goto cleanup;\n\n        def->nfeatures = n;\n    }\n\n    for (i = 0; i < n; i++) {\n        char *name;\n        int policy; /* enum virDomainCPUFeaturePolicy */\n        size_t j;\n\n        if (def->type == VIR_CPU_TYPE_GUEST) {\n            char *strpolicy;\n\n            strpolicy = virXMLPropString(nodes[i], \"policy\");\n            if (strpolicy == NULL)\n                policy = VIR_CPU_FEATURE_REQUIRE;\n            else\n                policy = virCPUFeaturePolicyTypeFromString(strpolicy);\n            VIR_FREE(strpolicy);\n\n            if (policy < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid CPU feature policy\"));\n                goto cleanup;\n            }\n        } else {\n            policy = -1;\n        }\n\n        if (!(name = virXMLPropString(nodes[i], \"name\")) || *name == 0) {\n            VIR_FREE(name);\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Invalid CPU feature name\"));\n            goto cleanup;\n        }\n\n        for (j = 0; j < i; j++) {\n            if (STREQ(name, def->features[j].name)) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"CPU feature '%s' specified more than once\"),\n                               name);\n                VIR_FREE(name);\n                goto cleanup;\n            }\n        }\n\n        def->features[i].name = name;\n        def->features[i].policy = policy;\n    }\n\n    if (virXPathInt(\"count(./cache)\", ctxt, &n) < 0) {\n        goto cleanup;\n    } else if (n > 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"at most one CPU cache element may be specified\"));\n        goto cleanup;\n    } else if (n == 1) {\n        int level = -1;\n        char *strmode;\n        int mode;\n\n        if (virXPathBoolean(\"boolean(./cache[1]/@level)\", ctxt) == 1 &&\n            (virXPathInt(\"string(./cache[1]/@level)\", ctxt, &level) < 0 ||\n             level < 1 || level > 3)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"invalid CPU cache level, must be in range [1,3]\"));\n            goto cleanup;\n        }\n\n        if (!(strmode = virXPathString(\"string(./cache[1]/@mode)\", ctxt)) ||\n            (mode = virCPUCacheModeTypeFromString(strmode)) < 0) {\n            VIR_FREE(strmode);\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing or invalid CPU cache mode\"));\n            goto cleanup;\n        }\n        VIR_FREE(strmode);\n\n        if (VIR_ALLOC(def->cache) < 0)\n            goto cleanup;\n\n        def->cache->level = level;\n        def->cache->mode = mode;\n    }\n\n    *cpu = g_steal_pointer(&def);\n    ret = 0;\n\n cleanup:\n    ctxt->node = oldnode;\n    VIR_FREE(fallback);\n    VIR_FREE(vendor_id);\n    VIR_FREE(nodes);\n    VIR_FREE(tscScaling);\n    VIR_FREE(tsc);\n    virCPUDefFree(def);\n    return ret;\n}"
  },
  {
    "function_name": "virCPUDefParseXMLString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "288-314",
    "snippet": "int\nvirCPUDefParseXMLString(const char *xml,\n                        virCPUType type,\n                        virCPUDefPtr *cpu)\n{\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    int ret = -1;\n\n    if (!xml) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"missing CPU definition\"));\n        goto cleanup;\n    }\n\n    if (!(doc = virXMLParseStringCtxt(xml, _(\"(CPU_definition)\"), &ctxt)))\n        goto cleanup;\n\n    if (virCPUDefParseXML(ctxt, NULL, type, cpu) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    xmlFreeDoc(doc);\n    xmlXPathFreeContext(ctxt);\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "ctxt"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "doc"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefParseXML",
          "args": [
            "ctxt",
            "NULL",
            "type",
            "cpu"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "329-681",
          "snippet": "int\nvirCPUDefParseXML(xmlXPathContextPtr ctxt,\n                  const char *xpath,\n                  virCPUType type,\n                  virCPUDefPtr *cpu)\n{\n    virCPUDefPtr def = NULL;\n    xmlNodePtr *nodes = NULL;\n    xmlNodePtr oldnode = ctxt->node;\n    int n;\n    size_t i;\n    char *cpuMode;\n    char *fallback = NULL;\n    char *vendor_id = NULL;\n    char *tscScaling = NULL;\n    virHostCPUTscInfoPtr tsc = NULL;\n    int ret = -1;\n\n    *cpu = NULL;\n\n    if (xpath && !(ctxt->node = virXPathNode(xpath, ctxt))) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virXMLNodeNameEqual(ctxt->node, \"cpu\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"XML does not contain expected 'cpu' element\"));\n        goto cleanup;\n    }\n\n    def = virCPUDefNew();\n\n    if (type == VIR_CPU_TYPE_AUTO) {\n        if (virXPathBoolean(\"boolean(./arch)\", ctxt)) {\n            if (virXPathBoolean(\"boolean(./@match)\", ctxt)) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"'arch' element cannot be used inside 'cpu'\"\n                                 \" element with 'match' attribute'\"));\n                goto cleanup;\n            }\n            def->type = VIR_CPU_TYPE_HOST;\n        } else {\n            def->type = VIR_CPU_TYPE_GUEST;\n        }\n    } else {\n        def->type = type;\n    }\n\n    if ((cpuMode = virXMLPropString(ctxt->node, \"mode\"))) {\n        if (def->type == VIR_CPU_TYPE_HOST) {\n            VIR_FREE(cpuMode);\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Attribute mode is only allowed for guest CPU\"));\n            goto cleanup;\n        } else {\n            def->mode = virCPUModeTypeFromString(cpuMode);\n\n            if (def->mode < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid mode attribute '%s'\"),\n                               cpuMode);\n                VIR_FREE(cpuMode);\n                goto cleanup;\n            }\n            VIR_FREE(cpuMode);\n        }\n    } else {\n        if (def->type == VIR_CPU_TYPE_HOST)\n            def->mode = -1;\n        else\n            def->mode = VIR_CPU_MODE_CUSTOM;\n    }\n\n    if (def->type == VIR_CPU_TYPE_GUEST) {\n        char *match = virXMLPropString(ctxt->node, \"match\");\n        char *check;\n\n        if (match) {\n            def->match = virCPUMatchTypeFromString(match);\n            VIR_FREE(match);\n\n            if (def->match < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid match attribute for CPU \"\n                                 \"specification\"));\n                goto cleanup;\n            }\n        }\n\n        if ((check = virXMLPropString(ctxt->node, \"check\"))) {\n            int value = virCPUCheckTypeFromString(check);\n            VIR_FREE(check);\n\n            if (value < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid check attribute for CPU \"\n                                 \"specification\"));\n                goto cleanup;\n            }\n            def->check = value;\n        }\n    }\n\n    if (def->type == VIR_CPU_TYPE_HOST) {\n        char *arch = virXPathString(\"string(./arch[1])\", ctxt);\n        if (!arch) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing CPU architecture\"));\n            goto cleanup;\n        }\n        if ((def->arch = virArchFromString(arch)) == VIR_ARCH_NONE) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unknown architecture %s\"), arch);\n            VIR_FREE(arch);\n            goto cleanup;\n        }\n        VIR_FREE(arch);\n\n        if (virXPathBoolean(\"boolean(./microcode[1]/@version)\", ctxt) > 0 &&\n            virXPathUInt(\"string(./microcode[1]/@version)\", ctxt,\n                         &def->microcodeVersion) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"invalid microcode version\"));\n            goto cleanup;\n        }\n\n        if (virXPathBoolean(\"boolean(./counter[@name='tsc'])\", ctxt) > 0) {\n            if (VIR_ALLOC(tsc) < 0)\n                goto cleanup;\n\n            if (virXPathULongLong(\"string(./counter[@name='tsc']/@frequency)\",\n                                  ctxt, &tsc->frequency) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid TSC frequency\"));\n                goto cleanup;\n            }\n\n            tscScaling = virXPathString(\"string(./counter[@name='tsc']/@scaling)\",\n                                        ctxt);\n            if (tscScaling) {\n                int scaling = virTristateBoolTypeFromString(tscScaling);\n                if (scaling < 0) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Invalid TSC scaling attribute\"));\n                    goto cleanup;\n                }\n                tsc->scaling = scaling;\n            }\n\n            def->tsc = g_steal_pointer(&tsc);\n        }\n    }\n\n    if (!(def->model = virXPathString(\"string(./model[1])\", ctxt)) &&\n        def->type == VIR_CPU_TYPE_HOST) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                        _(\"Missing CPU model name\"));\n        goto cleanup;\n    }\n\n    if (def->type == VIR_CPU_TYPE_GUEST &&\n        def->mode != VIR_CPU_MODE_HOST_PASSTHROUGH) {\n\n        if ((fallback = virXPathString(\"string(./model[1]/@fallback)\", ctxt))) {\n            if ((def->fallback = virCPUFallbackTypeFromString(fallback)) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid fallback attribute\"));\n                goto cleanup;\n            }\n        }\n\n        if ((vendor_id = virXPathString(\"string(./model[1]/@vendor_id)\",\n                                        ctxt))) {\n            if (strlen(vendor_id) != VIR_CPU_VENDOR_ID_LENGTH) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"vendor_id must be exactly %d characters long\"),\n                               VIR_CPU_VENDOR_ID_LENGTH);\n                goto cleanup;\n            }\n\n            /* ensure that the string can be passed to qemu */\n            if (strchr(vendor_id, ',')) {\n                    virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                                   _(\"vendor id is invalid\"));\n                    goto cleanup;\n            }\n\n            def->vendor_id = vendor_id;\n            vendor_id = NULL;\n        }\n    }\n\n    def->vendor = virXPathString(\"string(./vendor[1])\", ctxt);\n    if (def->vendor && !def->model) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"CPU vendor specified without CPU model\"));\n        goto cleanup;\n    }\n\n    if (virXPathNode(\"./topology[1]\", ctxt)) {\n        unsigned long ul;\n\n        if (virXPathULong(\"string(./topology[1]/@sockets)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'sockets' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->sockets = (unsigned int) ul;\n\n        if (virXPathNode(\"./topology[1]/@dies\", ctxt)) {\n            if (virXPathULong(\"string(./topology[1]/@dies)\", ctxt, &ul) < 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"Malformed 'dies' attribute in CPU topology\"));\n                goto cleanup;\n            }\n            def->dies = (unsigned int) ul;\n        } else {\n            def->dies = 1;\n        }\n\n        if (virXPathULong(\"string(./topology[1]/@cores)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'cores' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->cores = (unsigned int) ul;\n\n        if (virXPathULong(\"string(./topology[1]/@threads)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'threads' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->threads = (unsigned int) ul;\n\n        if (!def->sockets || !def->cores || !def->threads || !def->dies) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Invalid CPU topology\"));\n            goto cleanup;\n        }\n    }\n\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    if (n > 0) {\n        if (!def->model && def->mode == VIR_CPU_MODE_CUSTOM) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Non-empty feature list specified without \"\n                             \"CPU model\"));\n            goto cleanup;\n        }\n\n        if (VIR_RESIZE_N(def->features, def->nfeatures_max,\n                         def->nfeatures, n) < 0)\n            goto cleanup;\n\n        def->nfeatures = n;\n    }\n\n    for (i = 0; i < n; i++) {\n        char *name;\n        int policy; /* enum virDomainCPUFeaturePolicy */\n        size_t j;\n\n        if (def->type == VIR_CPU_TYPE_GUEST) {\n            char *strpolicy;\n\n            strpolicy = virXMLPropString(nodes[i], \"policy\");\n            if (strpolicy == NULL)\n                policy = VIR_CPU_FEATURE_REQUIRE;\n            else\n                policy = virCPUFeaturePolicyTypeFromString(strpolicy);\n            VIR_FREE(strpolicy);\n\n            if (policy < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid CPU feature policy\"));\n                goto cleanup;\n            }\n        } else {\n            policy = -1;\n        }\n\n        if (!(name = virXMLPropString(nodes[i], \"name\")) || *name == 0) {\n            VIR_FREE(name);\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Invalid CPU feature name\"));\n            goto cleanup;\n        }\n\n        for (j = 0; j < i; j++) {\n            if (STREQ(name, def->features[j].name)) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"CPU feature '%s' specified more than once\"),\n                               name);\n                VIR_FREE(name);\n                goto cleanup;\n            }\n        }\n\n        def->features[i].name = name;\n        def->features[i].policy = policy;\n    }\n\n    if (virXPathInt(\"count(./cache)\", ctxt, &n) < 0) {\n        goto cleanup;\n    } else if (n > 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"at most one CPU cache element may be specified\"));\n        goto cleanup;\n    } else if (n == 1) {\n        int level = -1;\n        char *strmode;\n        int mode;\n\n        if (virXPathBoolean(\"boolean(./cache[1]/@level)\", ctxt) == 1 &&\n            (virXPathInt(\"string(./cache[1]/@level)\", ctxt, &level) < 0 ||\n             level < 1 || level > 3)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"invalid CPU cache level, must be in range [1,3]\"));\n            goto cleanup;\n        }\n\n        if (!(strmode = virXPathString(\"string(./cache[1]/@mode)\", ctxt)) ||\n            (mode = virCPUCacheModeTypeFromString(strmode)) < 0) {\n            VIR_FREE(strmode);\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing or invalid CPU cache mode\"));\n            goto cleanup;\n        }\n        VIR_FREE(strmode);\n\n        if (VIR_ALLOC(def->cache) < 0)\n            goto cleanup;\n\n        def->cache->level = level;\n        def->cache->mode = mode;\n    }\n\n    *cpu = g_steal_pointer(&def);\n    ret = 0;\n\n cleanup:\n    ctxt->node = oldnode;\n    VIR_FREE(fallback);\n    VIR_FREE(vendor_id);\n    VIR_FREE(nodes);\n    VIR_FREE(tscScaling);\n    VIR_FREE(tsc);\n    virCPUDefFree(def);\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefParseXML(xmlXPathContextPtr ctxt,\n                  const char *xpath,\n                  virCPUType type,\n                  virCPUDefPtr *cpu)\n{\n    virCPUDefPtr def = NULL;\n    xmlNodePtr *nodes = NULL;\n    xmlNodePtr oldnode = ctxt->node;\n    int n;\n    size_t i;\n    char *cpuMode;\n    char *fallback = NULL;\n    char *vendor_id = NULL;\n    char *tscScaling = NULL;\n    virHostCPUTscInfoPtr tsc = NULL;\n    int ret = -1;\n\n    *cpu = NULL;\n\n    if (xpath && !(ctxt->node = virXPathNode(xpath, ctxt))) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virXMLNodeNameEqual(ctxt->node, \"cpu\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"XML does not contain expected 'cpu' element\"));\n        goto cleanup;\n    }\n\n    def = virCPUDefNew();\n\n    if (type == VIR_CPU_TYPE_AUTO) {\n        if (virXPathBoolean(\"boolean(./arch)\", ctxt)) {\n            if (virXPathBoolean(\"boolean(./@match)\", ctxt)) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"'arch' element cannot be used inside 'cpu'\"\n                                 \" element with 'match' attribute'\"));\n                goto cleanup;\n            }\n            def->type = VIR_CPU_TYPE_HOST;\n        } else {\n            def->type = VIR_CPU_TYPE_GUEST;\n        }\n    } else {\n        def->type = type;\n    }\n\n    if ((cpuMode = virXMLPropString(ctxt->node, \"mode\"))) {\n        if (def->type == VIR_CPU_TYPE_HOST) {\n            VIR_FREE(cpuMode);\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Attribute mode is only allowed for guest CPU\"));\n            goto cleanup;\n        } else {\n            def->mode = virCPUModeTypeFromString(cpuMode);\n\n            if (def->mode < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid mode attribute '%s'\"),\n                               cpuMode);\n                VIR_FREE(cpuMode);\n                goto cleanup;\n            }\n            VIR_FREE(cpuMode);\n        }\n    } else {\n        if (def->type == VIR_CPU_TYPE_HOST)\n            def->mode = -1;\n        else\n            def->mode = VIR_CPU_MODE_CUSTOM;\n    }\n\n    if (def->type == VIR_CPU_TYPE_GUEST) {\n        char *match = virXMLPropString(ctxt->node, \"match\");\n        char *check;\n\n        if (match) {\n            def->match = virCPUMatchTypeFromString(match);\n            VIR_FREE(match);\n\n            if (def->match < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid match attribute for CPU \"\n                                 \"specification\"));\n                goto cleanup;\n            }\n        }\n\n        if ((check = virXMLPropString(ctxt->node, \"check\"))) {\n            int value = virCPUCheckTypeFromString(check);\n            VIR_FREE(check);\n\n            if (value < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid check attribute for CPU \"\n                                 \"specification\"));\n                goto cleanup;\n            }\n            def->check = value;\n        }\n    }\n\n    if (def->type == VIR_CPU_TYPE_HOST) {\n        char *arch = virXPathString(\"string(./arch[1])\", ctxt);\n        if (!arch) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing CPU architecture\"));\n            goto cleanup;\n        }\n        if ((def->arch = virArchFromString(arch)) == VIR_ARCH_NONE) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unknown architecture %s\"), arch);\n            VIR_FREE(arch);\n            goto cleanup;\n        }\n        VIR_FREE(arch);\n\n        if (virXPathBoolean(\"boolean(./microcode[1]/@version)\", ctxt) > 0 &&\n            virXPathUInt(\"string(./microcode[1]/@version)\", ctxt,\n                         &def->microcodeVersion) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"invalid microcode version\"));\n            goto cleanup;\n        }\n\n        if (virXPathBoolean(\"boolean(./counter[@name='tsc'])\", ctxt) > 0) {\n            if (VIR_ALLOC(tsc) < 0)\n                goto cleanup;\n\n            if (virXPathULongLong(\"string(./counter[@name='tsc']/@frequency)\",\n                                  ctxt, &tsc->frequency) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid TSC frequency\"));\n                goto cleanup;\n            }\n\n            tscScaling = virXPathString(\"string(./counter[@name='tsc']/@scaling)\",\n                                        ctxt);\n            if (tscScaling) {\n                int scaling = virTristateBoolTypeFromString(tscScaling);\n                if (scaling < 0) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Invalid TSC scaling attribute\"));\n                    goto cleanup;\n                }\n                tsc->scaling = scaling;\n            }\n\n            def->tsc = g_steal_pointer(&tsc);\n        }\n    }\n\n    if (!(def->model = virXPathString(\"string(./model[1])\", ctxt)) &&\n        def->type == VIR_CPU_TYPE_HOST) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                        _(\"Missing CPU model name\"));\n        goto cleanup;\n    }\n\n    if (def->type == VIR_CPU_TYPE_GUEST &&\n        def->mode != VIR_CPU_MODE_HOST_PASSTHROUGH) {\n\n        if ((fallback = virXPathString(\"string(./model[1]/@fallback)\", ctxt))) {\n            if ((def->fallback = virCPUFallbackTypeFromString(fallback)) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid fallback attribute\"));\n                goto cleanup;\n            }\n        }\n\n        if ((vendor_id = virXPathString(\"string(./model[1]/@vendor_id)\",\n                                        ctxt))) {\n            if (strlen(vendor_id) != VIR_CPU_VENDOR_ID_LENGTH) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"vendor_id must be exactly %d characters long\"),\n                               VIR_CPU_VENDOR_ID_LENGTH);\n                goto cleanup;\n            }\n\n            /* ensure that the string can be passed to qemu */\n            if (strchr(vendor_id, ',')) {\n                    virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                                   _(\"vendor id is invalid\"));\n                    goto cleanup;\n            }\n\n            def->vendor_id = vendor_id;\n            vendor_id = NULL;\n        }\n    }\n\n    def->vendor = virXPathString(\"string(./vendor[1])\", ctxt);\n    if (def->vendor && !def->model) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"CPU vendor specified without CPU model\"));\n        goto cleanup;\n    }\n\n    if (virXPathNode(\"./topology[1]\", ctxt)) {\n        unsigned long ul;\n\n        if (virXPathULong(\"string(./topology[1]/@sockets)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'sockets' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->sockets = (unsigned int) ul;\n\n        if (virXPathNode(\"./topology[1]/@dies\", ctxt)) {\n            if (virXPathULong(\"string(./topology[1]/@dies)\", ctxt, &ul) < 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"Malformed 'dies' attribute in CPU topology\"));\n                goto cleanup;\n            }\n            def->dies = (unsigned int) ul;\n        } else {\n            def->dies = 1;\n        }\n\n        if (virXPathULong(\"string(./topology[1]/@cores)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'cores' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->cores = (unsigned int) ul;\n\n        if (virXPathULong(\"string(./topology[1]/@threads)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'threads' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->threads = (unsigned int) ul;\n\n        if (!def->sockets || !def->cores || !def->threads || !def->dies) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Invalid CPU topology\"));\n            goto cleanup;\n        }\n    }\n\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    if (n > 0) {\n        if (!def->model && def->mode == VIR_CPU_MODE_CUSTOM) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Non-empty feature list specified without \"\n                             \"CPU model\"));\n            goto cleanup;\n        }\n\n        if (VIR_RESIZE_N(def->features, def->nfeatures_max,\n                         def->nfeatures, n) < 0)\n            goto cleanup;\n\n        def->nfeatures = n;\n    }\n\n    for (i = 0; i < n; i++) {\n        char *name;\n        int policy; /* enum virDomainCPUFeaturePolicy */\n        size_t j;\n\n        if (def->type == VIR_CPU_TYPE_GUEST) {\n            char *strpolicy;\n\n            strpolicy = virXMLPropString(nodes[i], \"policy\");\n            if (strpolicy == NULL)\n                policy = VIR_CPU_FEATURE_REQUIRE;\n            else\n                policy = virCPUFeaturePolicyTypeFromString(strpolicy);\n            VIR_FREE(strpolicy);\n\n            if (policy < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid CPU feature policy\"));\n                goto cleanup;\n            }\n        } else {\n            policy = -1;\n        }\n\n        if (!(name = virXMLPropString(nodes[i], \"name\")) || *name == 0) {\n            VIR_FREE(name);\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Invalid CPU feature name\"));\n            goto cleanup;\n        }\n\n        for (j = 0; j < i; j++) {\n            if (STREQ(name, def->features[j].name)) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"CPU feature '%s' specified more than once\"),\n                               name);\n                VIR_FREE(name);\n                goto cleanup;\n            }\n        }\n\n        def->features[i].name = name;\n        def->features[i].policy = policy;\n    }\n\n    if (virXPathInt(\"count(./cache)\", ctxt, &n) < 0) {\n        goto cleanup;\n    } else if (n > 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"at most one CPU cache element may be specified\"));\n        goto cleanup;\n    } else if (n == 1) {\n        int level = -1;\n        char *strmode;\n        int mode;\n\n        if (virXPathBoolean(\"boolean(./cache[1]/@level)\", ctxt) == 1 &&\n            (virXPathInt(\"string(./cache[1]/@level)\", ctxt, &level) < 0 ||\n             level < 1 || level > 3)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"invalid CPU cache level, must be in range [1,3]\"));\n            goto cleanup;\n        }\n\n        if (!(strmode = virXPathString(\"string(./cache[1]/@mode)\", ctxt)) ||\n            (mode = virCPUCacheModeTypeFromString(strmode)) < 0) {\n            VIR_FREE(strmode);\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing or invalid CPU cache mode\"));\n            goto cleanup;\n        }\n        VIR_FREE(strmode);\n\n        if (VIR_ALLOC(def->cache) < 0)\n            goto cleanup;\n\n        def->cache->level = level;\n        def->cache->mode = mode;\n    }\n\n    *cpu = g_steal_pointer(&def);\n    ret = 0;\n\n cleanup:\n    ctxt->node = oldnode;\n    VIR_FREE(fallback);\n    VIR_FREE(vendor_id);\n    VIR_FREE(nodes);\n    VIR_FREE(tscScaling);\n    VIR_FREE(tsc);\n    virCPUDefFree(def);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLParseStringCtxt",
          "args": [
            "xml",
            "_(\"(CPU_definition)\")",
            "&ctxt"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"(CPU_definition)\""
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"missing CPU definition\")"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefParseXMLString(const char *xml,\n                        virCPUType type,\n                        virCPUDefPtr *cpu)\n{\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    int ret = -1;\n\n    if (!xml) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"missing CPU definition\"));\n        goto cleanup;\n    }\n\n    if (!(doc = virXMLParseStringCtxt(xml, _(\"(CPU_definition)\"), &ctxt)))\n        goto cleanup;\n\n    if (virCPUDefParseXML(ctxt, NULL, type, cpu) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    xmlFreeDoc(doc);\n    xmlXPathFreeContext(ctxt);\n    return ret;\n}"
  },
  {
    "function_name": "virCPUDefCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "269-285",
    "snippet": "virCPUDefPtr\nvirCPUDefCopy(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!(copy = virCPUDefCopyWithoutModel(cpu)))\n        return NULL;\n\n    if (virCPUDefCopyModel(copy, cpu, false) < 0)\n        goto error;\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "copy"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefCopyModel",
          "args": [
            "copy",
            "cpu",
            "false"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefCopyWithoutModel",
          "args": [
            "cpu"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefCopyWithoutModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "227-266",
          "snippet": "virCPUDefPtr\nvirCPUDefCopyWithoutModel(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!cpu)\n        return NULL;\n\n    copy = virCPUDefNew();\n    copy->type = cpu->type;\n    copy->mode = cpu->mode;\n    copy->match = cpu->match;\n    copy->check = cpu->check;\n    copy->fallback = cpu->fallback;\n    copy->sockets = cpu->sockets;\n    copy->dies = cpu->dies;\n    copy->cores = cpu->cores;\n    copy->threads = cpu->threads;\n    copy->arch = cpu->arch;\n\n    if (cpu->cache) {\n        if (VIR_ALLOC(copy->cache) < 0)\n            goto error;\n\n        *copy->cache = *cpu->cache;\n    }\n\n    if (cpu->tsc) {\n        if (VIR_ALLOC(copy->tsc) < 0)\n            goto error;\n\n        *copy->tsc = *cpu->tsc;\n    }\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUDefCopyWithoutModel(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!cpu)\n        return NULL;\n\n    copy = virCPUDefNew();\n    copy->type = cpu->type;\n    copy->mode = cpu->mode;\n    copy->match = cpu->match;\n    copy->check = cpu->check;\n    copy->fallback = cpu->fallback;\n    copy->sockets = cpu->sockets;\n    copy->dies = cpu->dies;\n    copy->cores = cpu->cores;\n    copy->threads = cpu->threads;\n    copy->arch = cpu->arch;\n\n    if (cpu->cache) {\n        if (VIR_ALLOC(copy->cache) < 0)\n            goto error;\n\n        *copy->cache = *cpu->cache;\n    }\n\n    if (cpu->tsc) {\n        if (VIR_ALLOC(copy->tsc) < 0)\n            goto error;\n\n        *copy->tsc = *cpu->tsc;\n    }\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUDefCopy(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!(copy = virCPUDefCopyWithoutModel(cpu)))\n        return NULL;\n\n    if (virCPUDefCopyModel(copy, cpu, false) < 0)\n        goto error;\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}"
  },
  {
    "function_name": "virCPUDefCopyWithoutModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "227-266",
    "snippet": "virCPUDefPtr\nvirCPUDefCopyWithoutModel(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!cpu)\n        return NULL;\n\n    copy = virCPUDefNew();\n    copy->type = cpu->type;\n    copy->mode = cpu->mode;\n    copy->match = cpu->match;\n    copy->check = cpu->check;\n    copy->fallback = cpu->fallback;\n    copy->sockets = cpu->sockets;\n    copy->dies = cpu->dies;\n    copy->cores = cpu->cores;\n    copy->threads = cpu->threads;\n    copy->arch = cpu->arch;\n\n    if (cpu->cache) {\n        if (VIR_ALLOC(copy->cache) < 0)\n            goto error;\n\n        *copy->cache = *cpu->cache;\n    }\n\n    if (cpu->tsc) {\n        if (VIR_ALLOC(copy->tsc) < 0)\n            goto error;\n\n        *copy->tsc = *cpu->tsc;\n    }\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "copy"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "copy->tsc"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "copy->cache"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefNew",
          "args": [],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "85-90",
          "snippet": "virCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUDefCopyWithoutModel(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!cpu)\n        return NULL;\n\n    copy = virCPUDefNew();\n    copy->type = cpu->type;\n    copy->mode = cpu->mode;\n    copy->match = cpu->match;\n    copy->check = cpu->check;\n    copy->fallback = cpu->fallback;\n    copy->sockets = cpu->sockets;\n    copy->dies = cpu->dies;\n    copy->cores = cpu->cores;\n    copy->threads = cpu->threads;\n    copy->arch = cpu->arch;\n\n    if (cpu->cache) {\n        if (VIR_ALLOC(copy->cache) < 0)\n            goto error;\n\n        *copy->cache = *cpu->cache;\n    }\n\n    if (cpu->tsc) {\n        if (VIR_ALLOC(copy->tsc) < 0)\n            goto error;\n\n        *copy->tsc = *cpu->tsc;\n    }\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}"
  },
  {
    "function_name": "virCPUDefStealModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "194-224",
    "snippet": "void\nvirCPUDefStealModel(virCPUDefPtr dst,\n                    virCPUDefPtr src,\n                    bool keepVendor)\n{\n    char *vendor = NULL;\n    char *vendor_id = NULL;\n\n    if (keepVendor) {\n        vendor = g_steal_pointer(&dst->vendor);\n        vendor_id = g_steal_pointer(&dst->vendor_id);\n    }\n\n    virCPUDefFreeModel(dst);\n\n    dst->model = g_steal_pointer(&src->model);\n    dst->features = g_steal_pointer(&src->features);\n    dst->microcodeVersion = src->microcodeVersion;\n    dst->nfeatures_max = src->nfeatures_max;\n    src->nfeatures_max = 0;\n    dst->nfeatures = src->nfeatures;\n    src->nfeatures = 0;\n\n    if (keepVendor) {\n        dst->vendor = vendor;\n        dst->vendor_id = vendor_id;\n    } else {\n        dst->vendor = g_steal_pointer(&src->vendor);\n        dst->vendor_id = g_steal_pointer(&src->vendor_id);\n    }\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&src->vendor_id"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&src->vendor"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&src->features"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&src->model"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefFreeModel",
          "args": [
            "dst"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&dst->vendor_id"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&dst->vendor"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefStealModel(virCPUDefPtr dst,\n                    virCPUDefPtr src,\n                    bool keepVendor)\n{\n    char *vendor = NULL;\n    char *vendor_id = NULL;\n\n    if (keepVendor) {\n        vendor = g_steal_pointer(&dst->vendor);\n        vendor_id = g_steal_pointer(&dst->vendor_id);\n    }\n\n    virCPUDefFreeModel(dst);\n\n    dst->model = g_steal_pointer(&src->model);\n    dst->features = g_steal_pointer(&src->features);\n    dst->microcodeVersion = src->microcodeVersion;\n    dst->nfeatures_max = src->nfeatures_max;\n    src->nfeatures_max = 0;\n    dst->nfeatures = src->nfeatures;\n    src->nfeatures = 0;\n\n    if (keepVendor) {\n        dst->vendor = vendor;\n        dst->vendor_id = vendor_id;\n    } else {\n        dst->vendor = g_steal_pointer(&src->vendor);\n        dst->vendor_id = g_steal_pointer(&src->vendor_id);\n    }\n}"
  },
  {
    "function_name": "virCPUDefCopyModelFilter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "144-184",
    "snippet": "int\nvirCPUDefCopyModelFilter(virCPUDefPtr dst,\n                         const virCPUDef *src,\n                         bool resetPolicy,\n                         virCPUDefFeatureFilter filter,\n                         void *opaque)\n{\n    size_t i;\n    size_t n;\n\n    if (VIR_ALLOC_N(dst->features, src->nfeatures) < 0)\n        return -1;\n\n    dst->model = g_strdup(src->model);\n    dst->vendor = g_strdup(src->vendor);\n    dst->vendor_id = g_strdup(src->vendor_id);\n    dst->microcodeVersion = src->microcodeVersion;\n    dst->nfeatures_max = src->nfeatures;\n    dst->nfeatures = 0;\n\n    for (i = 0; i < src->nfeatures; i++) {\n        if (filter && !filter(src->features[i].name, src->features[i].policy, opaque))\n            continue;\n\n        n = dst->nfeatures++;\n        if (dst->type != src->type && resetPolicy) {\n            if (dst->type == VIR_CPU_TYPE_HOST)\n                dst->features[n].policy = -1;\n            else if (src->features[i].policy == -1)\n                dst->features[n].policy = VIR_CPU_FEATURE_REQUIRE;\n            else\n                dst->features[n].policy = src->features[i].policy;\n        } else {\n            dst->features[n].policy = src->features[i].policy;\n        }\n\n        dst->features[n].name = g_strdup(src->features[i].name);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "src->features[i].name"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter",
          "args": [
            "src->features[i].name",
            "src->features[i].policy",
            "opaque"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "firewalld_dbus_filter_bridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "659-696",
          "snippet": "static DBusHandlerResult\nfirewalld_dbus_filter_bridge(DBusConnection *connection G_GNUC_UNUSED,\n                             DBusMessage *message,\n                             void *user_data)\n{\n    virNetworkDriverStatePtr driver = user_data;\n    bool reload = false;\n\n    if (dbus_message_is_signal(message,\n                               \"org.fedoraproject.FirewallD1\", \"Reloaded\")) {\n        reload = true;\n\n    } else if (dbus_message_is_signal(message,\n                                      DBUS_INTERFACE_DBUS, \"NameOwnerChanged\")) {\n\n        g_autofree char *name = NULL;\n        g_autofree char *old_owner = NULL;\n        g_autofree char *new_owner = NULL;\n\n        if (virDBusMessageDecode(message, \"sss\", &name, &old_owner, &new_owner) < 0) {\n            VIR_WARN(\"Failed to decode DBus NameOwnerChanged message\");\n            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n        }\n        /*\n         * if new_owner is empty, firewalld is shutting down. If it is\n         * non-empty, then it is starting\n         */\n        if (new_owner && *new_owner)\n            reload = true;\n    }\n\n    if (reload) {\n        VIR_DEBUG(\"Reload in bridge_driver because of firewalld.\");\n        networkReloadFirewallRules(driver, false);\n    }\n\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic DBusHandlerResult\nfirewalld_dbus_filter_bridge(DBusConnection *connection G_GNUC_UNUSED,\n                             DBusMessage *message,\n                             void *user_data)\n{\n    virNetworkDriverStatePtr driver = user_data;\n    bool reload = false;\n\n    if (dbus_message_is_signal(message,\n                               \"org.fedoraproject.FirewallD1\", \"Reloaded\")) {\n        reload = true;\n\n    } else if (dbus_message_is_signal(message,\n                                      DBUS_INTERFACE_DBUS, \"NameOwnerChanged\")) {\n\n        g_autofree char *name = NULL;\n        g_autofree char *old_owner = NULL;\n        g_autofree char *new_owner = NULL;\n\n        if (virDBusMessageDecode(message, \"sss\", &name, &old_owner, &new_owner) < 0) {\n            VIR_WARN(\"Failed to decode DBus NameOwnerChanged message\");\n            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n        }\n        /*\n         * if new_owner is empty, firewalld is shutting down. If it is\n         * non-empty, then it is starting\n         */\n        if (new_owner && *new_owner)\n            reload = true;\n    }\n\n    if (reload) {\n        VIR_DEBUG(\"Reload in bridge_driver because of firewalld.\");\n        networkReloadFirewallRules(driver, false);\n    }\n\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "dst->features",
            "src->nfeatures"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefCopyModelFilter(virCPUDefPtr dst,\n                         const virCPUDef *src,\n                         bool resetPolicy,\n                         virCPUDefFeatureFilter filter,\n                         void *opaque)\n{\n    size_t i;\n    size_t n;\n\n    if (VIR_ALLOC_N(dst->features, src->nfeatures) < 0)\n        return -1;\n\n    dst->model = g_strdup(src->model);\n    dst->vendor = g_strdup(src->vendor);\n    dst->vendor_id = g_strdup(src->vendor_id);\n    dst->microcodeVersion = src->microcodeVersion;\n    dst->nfeatures_max = src->nfeatures;\n    dst->nfeatures = 0;\n\n    for (i = 0; i < src->nfeatures; i++) {\n        if (filter && !filter(src->features[i].name, src->features[i].policy, opaque))\n            continue;\n\n        n = dst->nfeatures++;\n        if (dst->type != src->type && resetPolicy) {\n            if (dst->type == VIR_CPU_TYPE_HOST)\n                dst->features[n].policy = -1;\n            else if (src->features[i].policy == -1)\n                dst->features[n].policy = VIR_CPU_FEATURE_REQUIRE;\n            else\n                dst->features[n].policy = src->features[i].policy;\n        } else {\n            dst->features[n].policy = src->features[i].policy;\n        }\n\n        dst->features[n].name = g_strdup(src->features[i].name);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "135-141",
    "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefCopyModelFilter",
          "args": [
            "dst",
            "src",
            "resetPolicy",
            "NULL",
            "NULL"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefCopyModelFilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "144-184",
          "snippet": "int\nvirCPUDefCopyModelFilter(virCPUDefPtr dst,\n                         const virCPUDef *src,\n                         bool resetPolicy,\n                         virCPUDefFeatureFilter filter,\n                         void *opaque)\n{\n    size_t i;\n    size_t n;\n\n    if (VIR_ALLOC_N(dst->features, src->nfeatures) < 0)\n        return -1;\n\n    dst->model = g_strdup(src->model);\n    dst->vendor = g_strdup(src->vendor);\n    dst->vendor_id = g_strdup(src->vendor_id);\n    dst->microcodeVersion = src->microcodeVersion;\n    dst->nfeatures_max = src->nfeatures;\n    dst->nfeatures = 0;\n\n    for (i = 0; i < src->nfeatures; i++) {\n        if (filter && !filter(src->features[i].name, src->features[i].policy, opaque))\n            continue;\n\n        n = dst->nfeatures++;\n        if (dst->type != src->type && resetPolicy) {\n            if (dst->type == VIR_CPU_TYPE_HOST)\n                dst->features[n].policy = -1;\n            else if (src->features[i].policy == -1)\n                dst->features[n].policy = VIR_CPU_FEATURE_REQUIRE;\n            else\n                dst->features[n].policy = src->features[i].policy;\n        } else {\n            dst->features[n].policy = src->features[i].policy;\n        }\n\n        dst->features[n].name = g_strdup(src->features[i].name);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefCopyModelFilter(virCPUDefPtr dst,\n                         const virCPUDef *src,\n                         bool resetPolicy,\n                         virCPUDefFeatureFilter filter,\n                         void *opaque)\n{\n    size_t i;\n    size_t n;\n\n    if (VIR_ALLOC_N(dst->features, src->nfeatures) < 0)\n        return -1;\n\n    dst->model = g_strdup(src->model);\n    dst->vendor = g_strdup(src->vendor);\n    dst->vendor_id = g_strdup(src->vendor_id);\n    dst->microcodeVersion = src->microcodeVersion;\n    dst->nfeatures_max = src->nfeatures;\n    dst->nfeatures = 0;\n\n    for (i = 0; i < src->nfeatures; i++) {\n        if (filter && !filter(src->features[i].name, src->features[i].policy, opaque))\n            continue;\n\n        n = dst->nfeatures++;\n        if (dst->type != src->type && resetPolicy) {\n            if (dst->type == VIR_CPU_TYPE_HOST)\n                dst->features[n].policy = -1;\n            else if (src->features[i].policy == -1)\n                dst->features[n].policy = VIR_CPU_FEATURE_REQUIRE;\n            else\n                dst->features[n].policy = src->features[i].policy;\n        } else {\n            dst->features[n].policy = src->features[i].policy;\n        }\n\n        dst->features[n].name = g_strdup(src->features[i].name);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefCopyModel",
          "args": [
            "virCPUDefPtrdst",
            "constvirCPUDef *src",
            "boolresetPolicy"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATTRIBUTE_NONNULL",
          "args": [
            "2"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
  },
  {
    "function_name": "virCPUDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "120-132",
    "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->tsc"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->cache"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefFreeModel",
          "args": [
            "def"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_atomic_int_dec_and_test",
          "args": [
            "&def->refs"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
  },
  {
    "function_name": "virCPUDefRef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "114-118",
    "snippet": "void\nvirCPUDefRef(virCPUDefPtr def)\n{\n    g_atomic_int_inc(&def->refs);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_atomic_int_inc",
          "args": [
            "&def->refs"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefRef(virCPUDefPtr def)\n{\n    g_atomic_int_inc(&def->refs);\n}"
  },
  {
    "function_name": "virCPUDefFreeFeatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "92-102",
    "snippet": "void\nvirCPUDefFreeFeatures(virCPUDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nfeatures; i++)\n        VIR_FREE(def->features[i].name);\n    VIR_FREE(def->features);\n\n    def->nfeatures = def->nfeatures_max = 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->features"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->features[i].name"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFreeFeatures(virCPUDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nfeatures; i++)\n        VIR_FREE(def->features[i].name);\n    VIR_FREE(def->features);\n\n    def->nfeatures = def->nfeatures_max = 0;\n}"
  },
  {
    "function_name": "virCPUDefNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
    "lines": "85-90",
    "snippet": "virCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virCPUDef",
            "1"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}"
  }
]