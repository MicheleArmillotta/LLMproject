[
  {
    "function_name": "virLockManagerSanlockInquire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
    "lines": "1136-1176",
    "snippet": "static int virLockManagerSanlockInquire(virLockManagerPtr lock,\n                                        char **state,\n                                        unsigned int flags)\n{\n    virLockManagerSanlockPrivatePtr priv = lock->privateData;\n    int rv, res_count;\n\n    virCheckFlags(0, -1);\n\n    if (!state) {\n        virReportError(VIR_ERR_INVALID_ARG, __FUNCTION__);\n        return -1;\n    }\n\n    VIR_DEBUG(\"pid=%d\", priv->vm_pid);\n\n    if (!priv->registered) {\n        VIR_DEBUG(\"Process not registered, skipping inquiry\");\n        VIR_FREE(*state);\n        return 0;\n    }\n\n    if ((rv = sanlock_inquire(-1, priv->vm_pid, 0, &res_count, state)) < 0) {\n        char *err;\n        if (virLockManagerSanlockError(rv, &err)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to inquire lock: %s\"),\n                           NULLSTR(err));\n            VIR_FREE(err);\n        } else {\n            virReportSystemError(-rv, \"%s\",\n                                 _(\"Failed to inquire lock\"));\n        }\n        return -1;\n    }\n\n    if (STREQ_NULLABLE(*state, \"\"))\n        VIR_FREE(*state);\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"lock_driver.h\"",
      "#include <sanlock_admin.h>",
      "#include <sanlock_resource.h>",
      "#include <sanlock.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdint.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*state"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "*state",
            "\"\""
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-rv",
            "\"%s\"",
            "_(\"Failed to inquire lock\")"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to inquire lock\""
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "err"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to inquire lock: %s\")",
            "NULLSTR(err)"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "err"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockError",
          "args": [
            "rv",
            "&err"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanlock_inquire",
          "args": [
            "-1",
            "priv->vm_pid",
            "0",
            "&res_count",
            "state"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*state"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Process not registered, skipping inquiry\""
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"pid=%d\"",
            "priv->vm_pid"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "__FUNCTION__"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic int virLockManagerSanlockInquire(virLockManagerPtr lock,\n                                        char **state,\n                                        unsigned int flags)\n{\n    virLockManagerSanlockPrivatePtr priv = lock->privateData;\n    int rv, res_count;\n\n    virCheckFlags(0, -1);\n\n    if (!state) {\n        virReportError(VIR_ERR_INVALID_ARG, __FUNCTION__);\n        return -1;\n    }\n\n    VIR_DEBUG(\"pid=%d\", priv->vm_pid);\n\n    if (!priv->registered) {\n        VIR_DEBUG(\"Process not registered, skipping inquiry\");\n        VIR_FREE(*state);\n        return 0;\n    }\n\n    if ((rv = sanlock_inquire(-1, priv->vm_pid, 0, &res_count, state)) < 0) {\n        char *err;\n        if (virLockManagerSanlockError(rv, &err)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to inquire lock: %s\"),\n                           NULLSTR(err));\n            VIR_FREE(err);\n        } else {\n            virReportSystemError(-rv, \"%s\",\n                                 _(\"Failed to inquire lock\"));\n        }\n        return -1;\n    }\n\n    if (STREQ_NULLABLE(*state, \"\"))\n        VIR_FREE(*state);\n\n    return 0;\n}"
  },
  {
    "function_name": "virLockManagerSanlockRelease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
    "lines": "1084-1134",
    "snippet": "static int virLockManagerSanlockRelease(virLockManagerPtr lock,\n                                        char **state,\n                                        unsigned int flags)\n{\n    virLockManagerSanlockPrivatePtr priv = lock->privateData;\n    int res_count = priv->res_count;\n    int rv;\n\n    virCheckFlags(0, -1);\n\n    if (!priv->registered) {\n        VIR_DEBUG(\"Process not registered, skipping release\");\n        return 0;\n    }\n\n    if (state) {\n        if ((rv = sanlock_inquire(-1, priv->vm_pid, 0, &res_count, state)) < 0) {\n            char *err = NULL;\n            if (virLockManagerSanlockError(rv, &err)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to inquire lock: %s\"),\n                               NULLSTR(err));\n                VIR_FREE(err);\n            } else {\n                virReportSystemError(-rv, \"%s\",\n                                     _(\"Failed to inquire lock\"));\n            }\n            return -1;\n        }\n\n        if (STREQ_NULLABLE(*state, \"\"))\n            VIR_FREE(*state);\n    }\n\n    if ((rv = sanlock_release(-1, priv->vm_pid, 0, res_count,\n                              priv->res_args)) < 0) {\n        char *err = NULL;\n        if (virLockManagerSanlockError(rv, &err)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to release lock: %s\"),\n                           NULLSTR(err));\n            VIR_FREE(err);\n        } else {\n            virReportSystemError(-rv, \"%s\",\n                                 _(\"Failed to release lock\"));\n        }\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"lock_driver.h\"",
      "#include <sanlock_admin.h>",
      "#include <sanlock_resource.h>",
      "#include <sanlock.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdint.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-rv",
            "\"%s\"",
            "_(\"Failed to release lock\")"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to release lock\""
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "err"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to release lock: %s\")",
            "NULLSTR(err)"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "err"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockError",
          "args": [
            "rv",
            "&err"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanlock_release",
          "args": [
            "-1",
            "priv->vm_pid",
            "0",
            "res_count",
            "priv->res_args"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*state"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "*state",
            "\"\""
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-rv",
            "\"%s\"",
            "_(\"Failed to inquire lock\")"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "err"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to inquire lock: %s\")",
            "NULLSTR(err)"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "err"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockError",
          "args": [
            "rv",
            "&err"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanlock_inquire",
          "args": [
            "-1",
            "priv->vm_pid",
            "0",
            "&res_count",
            "state"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Process not registered, skipping release\""
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic int virLockManagerSanlockRelease(virLockManagerPtr lock,\n                                        char **state,\n                                        unsigned int flags)\n{\n    virLockManagerSanlockPrivatePtr priv = lock->privateData;\n    int res_count = priv->res_count;\n    int rv;\n\n    virCheckFlags(0, -1);\n\n    if (!priv->registered) {\n        VIR_DEBUG(\"Process not registered, skipping release\");\n        return 0;\n    }\n\n    if (state) {\n        if ((rv = sanlock_inquire(-1, priv->vm_pid, 0, &res_count, state)) < 0) {\n            char *err = NULL;\n            if (virLockManagerSanlockError(rv, &err)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to inquire lock: %s\"),\n                               NULLSTR(err));\n                VIR_FREE(err);\n            } else {\n                virReportSystemError(-rv, \"%s\",\n                                     _(\"Failed to inquire lock\"));\n            }\n            return -1;\n        }\n\n        if (STREQ_NULLABLE(*state, \"\"))\n            VIR_FREE(*state);\n    }\n\n    if ((rv = sanlock_release(-1, priv->vm_pid, 0, res_count,\n                              priv->res_args)) < 0) {\n        char *err = NULL;\n        if (virLockManagerSanlockError(rv, &err)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to release lock: %s\"),\n                           NULLSTR(err));\n            VIR_FREE(err);\n        } else {\n            virReportSystemError(-rv, \"%s\",\n                                 _(\"Failed to release lock\"));\n        }\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virLockManagerSanlockAcquire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
    "lines": "916-1081",
    "snippet": "static int virLockManagerSanlockAcquire(virLockManagerPtr lock,\n                                        const char *state,\n                                        unsigned int flags,\n                                        virDomainLockFailureAction action,\n                                        int *fd)\n{\n    virLockManagerSanlockDriverPtr driver = sanlockDriver;\n    virLockManagerSanlockPrivatePtr priv = lock->privateData;\n    struct sanlk_options *opt = NULL;\n    struct sanlk_resource **res_args;\n    int res_count;\n    bool res_free = false;\n    int sock = -1;\n    int rv;\n    size_t i;\n\n    virCheckFlags(VIR_LOCK_MANAGER_ACQUIRE_RESTRICT |\n                  VIR_LOCK_MANAGER_ACQUIRE_REGISTER_ONLY, -1);\n\n    if (priv->res_count == 0 &&\n        priv->hasRWDisks &&\n        driver->requireLeaseForDisks) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Read/write, exclusive access, disks were present, but no leases specified\"));\n        return -1;\n    }\n\n    /* We only initialize 'sock' if we are in the real\n     * child process and we need it to be inherited\n     *\n     * If sock == -1, then sanlock auto-open/closes a\n     * temporary sock\n     */\n    if (priv->vm_pid == getpid()) {\n        VIR_DEBUG(\"Register sanlock %d\", flags);\n        if ((sock = sanlock_register()) < 0) {\n            char *err = NULL;\n            if (virLockManagerSanlockError(sock, &err)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to open socket to sanlock daemon: %s\"),\n                               NULLSTR(err));\n                VIR_FREE(err);\n            } else {\n                virReportSystemError(-sock, \"%s\",\n                                     _(\"Failed to open socket to sanlock daemon\"));\n            }\n            goto error;\n        }\n\n        /* Mark the pid as registered */\n        priv->registered = true;\n\n        if (action != VIR_DOMAIN_LOCK_FAILURE_DEFAULT) {\n            char uuidstr[VIR_UUID_STRING_BUFLEN];\n            virUUIDFormat(priv->vm_uuid, uuidstr);\n            if (virLockManagerSanlockRegisterKillscript(sock, priv->vm_uri,\n                                                        uuidstr, action) < 0)\n                goto error;\n        }\n    } else if (!priv->registered) {\n        VIR_DEBUG(\"Process not registered, not acquiring lock\");\n        return 0;\n    }\n\n    if (VIR_ALLOC(opt) < 0)\n        goto error;\n\n    /* sanlock doesn't use owner_name for anything, so it's safe to take just\n     * the first SANLK_NAME_LEN - 1 characters from vm_name */\n    ignore_value(virStrncpy(opt->owner_name, priv->vm_name,\n                            MIN(strlen(priv->vm_name), SANLK_NAME_LEN - 1),\n                            SANLK_NAME_LEN));\n\n    if (state && STRNEQ(state, \"\")) {\n        if ((rv = sanlock_state_to_args((char *)state,\n                                        &res_count,\n                                        &res_args)) < 0) {\n            char *err = NULL;\n            if (virLockManagerSanlockError(rv, &err)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to parse lock state %s: %s\"),\n                               state, NULLSTR(err));\n                VIR_FREE(err);\n            } else {\n                virReportSystemError(-rv,\n                                     _(\"Unable to parse lock state %s\"),\n                                     state);\n            }\n            goto error;\n        }\n        res_free = true;\n    } else {\n        res_args = priv->res_args;\n        res_count = priv->res_count;\n    }\n\n    if (!(flags & VIR_LOCK_MANAGER_ACQUIRE_REGISTER_ONLY)) {\n        VIR_DEBUG(\"Acquiring object %u\", priv->res_count);\n        if ((rv = sanlock_acquire(sock, priv->vm_pid, 0,\n                                  priv->res_count, priv->res_args,\n                                  opt)) < 0) {\n            char *err = NULL;\n            if (virLockManagerSanlockError(rv, &err)) {\n                virReportError(VIR_ERR_RESOURCE_BUSY,\n                               _(\"Failed to acquire lock: %s\"),\n                               NULLSTR(err));\n                VIR_FREE(err);\n            } else {\n                virReportSystemError(-rv, \"%s\",\n                                     _(\"Failed to acquire lock\"));\n            }\n            goto error;\n        }\n    }\n\n    VIR_FREE(opt);\n\n    /*\n     * We are *intentionally* \"leaking\" sock file descriptor\n     * because we want it to be inherited by QEMU. When the\n     * sock FD finally closes upon QEMU exit (or crash) then\n     * sanlock will notice EOF and release the lock\n     */\n    if (sock != -1 &&\n        virSetInherit(sock, true) < 0)\n        goto error;\n\n    if (flags & VIR_LOCK_MANAGER_ACQUIRE_RESTRICT) {\n        if ((rv = sanlock_restrict(sock, SANLK_RESTRICT_ALL)) < 0) {\n            char *err = NULL;\n            if (virLockManagerSanlockError(rv, &err)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to restrict process: %s\"),\n                               NULLSTR(err));\n                VIR_FREE(err);\n            } else {\n                virReportSystemError(-rv, \"%s\",\n                                     _(\"Failed to restrict process\"));\n            }\n            goto error;\n        }\n    }\n\n    VIR_DEBUG(\"Acquire completed fd=%d\", sock);\n\n    if (res_free) {\n        for (i = 0; i < res_count; i++)\n            VIR_FREE(res_args[i]);\n        VIR_FREE(res_args);\n    }\n\n    if (fd)\n        *fd = sock;\n\n    return 0;\n\n error:\n    if (res_free) {\n        for (i = 0; i < res_count; i++)\n            VIR_FREE(res_args[i]);\n        VIR_FREE(res_args);\n    }\n    VIR_FREE(opt);\n    VIR_FORCE_CLOSE(sock);\n    return -1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"lock_driver.h\"",
      "#include <sanlock_admin.h>",
      "#include <sanlock_resource.h>",
      "#include <sanlock.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdint.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virLockManagerSanlockDriverPtr sanlockDriver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "sock"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "opt"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "res_args"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "res_args[i]"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "res_args"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "res_args[i]"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Acquire completed fd=%d\"",
            "sock"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-rv",
            "\"%s\"",
            "_(\"Failed to restrict process\")"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to restrict process\""
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "err"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to restrict process: %s\")",
            "NULLSTR(err)"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "err"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockError",
          "args": [
            "rv",
            "&err"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanlock_restrict",
          "args": [
            "sock",
            "SANLK_RESTRICT_ALL"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetInherit",
          "args": [
            "sock",
            "true"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "virSetInherit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "104-111",
          "snippet": "int virSetInherit(int fd G_GNUC_UNUSED, bool inherit G_GNUC_UNUSED)\n{\n    /* FIXME: Currently creating child processes is not supported on\n     * Win32, so there is no point in failing calls that are only relevant\n     * when creating child processes. So just pretend that we changed the\n     * inheritance property of the given fd as requested. */\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetInherit(int fd G_GNUC_UNUSED, bool inherit G_GNUC_UNUSED)\n{\n    /* FIXME: Currently creating child processes is not supported on\n     * Win32, so there is no point in failing calls that are only relevant\n     * when creating child processes. So just pretend that we changed the\n     * inheritance property of the given fd as requested. */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "opt"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-rv",
            "\"%s\"",
            "_(\"Failed to acquire lock\")"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "err"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RESOURCE_BUSY",
            "_(\"Failed to acquire lock: %s\")",
            "NULLSTR(err)"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "err"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockError",
          "args": [
            "rv",
            "&err"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanlock_acquire",
          "args": [
            "sock",
            "priv->vm_pid",
            "0",
            "priv->res_count",
            "priv->res_args",
            "opt"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Acquiring object %u\"",
            "priv->res_count"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-rv",
            "_(\"Unable to parse lock state %s\")",
            "state"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "err"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to parse lock state %s: %s\")",
            "state",
            "NULLSTR(err)"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "err"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockError",
          "args": [
            "rv",
            "&err"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanlock_state_to_args",
          "args": [
            "(char *)state",
            "&res_count",
            "&res_args"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "state",
            "\"\""
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virStrncpy(opt->owner_name, priv->vm_name,\n                            MIN(strlen(priv->vm_name), SANLK_NAME_LEN - 1),\n                            SANLK_NAME_LEN)"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrncpy",
          "args": [
            "opt->owner_name",
            "priv->vm_name",
            "MIN(strlen(priv->vm_name), SANLK_NAME_LEN - 1)",
            "SANLK_NAME_LEN"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "virStrncpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "746-765",
          "snippet": "int\nvirStrncpy(char *dest, const char *src, size_t n, size_t destbytes)\n{\n    size_t src_len = strlen(src);\n\n    /* As a special case, -1 means \"copy the entire string\".\n     *\n     * This is to avoid calling strlen() twice, once in the virStrcpy()\n     * wrapper and once here for bound checking purposes. */\n    if (n == -1)\n        n = src_len;\n\n    if (n > src_len || n > (destbytes - 1))\n        return -1;\n\n    memcpy(dest, src, n);\n    dest[n] = '\\0';\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrncpy(char *dest, const char *src, size_t n, size_t destbytes)\n{\n    size_t src_len = strlen(src);\n\n    /* As a special case, -1 means \"copy the entire string\".\n     *\n     * This is to avoid calling strlen() twice, once in the virStrcpy()\n     * wrapper and once here for bound checking purposes. */\n    if (n == -1)\n        n = src_len;\n\n    if (n > src_len || n > (destbytes - 1))\n        return -1;\n\n    memcpy(dest, src, n);\n    dest[n] = '\\0';\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "strlen(priv->vm_name)",
            "SANLK_NAME_LEN - 1"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "priv->vm_name"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "opt"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Process not registered, not acquiring lock\""
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockRegisterKillscript",
          "args": [
            "sock",
            "priv->vm_uri",
            "uuidstr",
            "action"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerSanlockRegisterKillscript",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "904-913",
          "snippet": "static int\nvirLockManagerSanlockRegisterKillscript(int sock G_GNUC_UNUSED,\n                                        const char *vmuri G_GNUC_UNUSED,\n                                        const char *uuidstr G_GNUC_UNUSED,\n                                        virDomainLockFailureAction action G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                   _(\"sanlock is too old to support lock failure action\"));\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic int\nvirLockManagerSanlockRegisterKillscript(int sock G_GNUC_UNUSED,\n                                        const char *vmuri G_GNUC_UNUSED,\n                                        const char *uuidstr G_GNUC_UNUSED,\n                                        virDomainLockFailureAction action G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                   _(\"sanlock is too old to support lock failure action\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "priv->vm_uuid",
            "uuidstr"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-sock",
            "\"%s\"",
            "_(\"Failed to open socket to sanlock daemon\")"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "err"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to open socket to sanlock daemon: %s\")",
            "NULLSTR(err)"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "err"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockError",
          "args": [
            "sock",
            "&err"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanlock_register",
          "args": [],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Register sanlock %d\"",
            "flags"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Read/write, exclusive access, disks were present, but no leases specified\")"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_LOCK_MANAGER_ACQUIRE_RESTRICT |\n                  VIR_LOCK_MANAGER_ACQUIRE_REGISTER_ONLY",
            "-1"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic virLockManagerSanlockDriverPtr sanlockDriver;\n\nstatic int virLockManagerSanlockAcquire(virLockManagerPtr lock,\n                                        const char *state,\n                                        unsigned int flags,\n                                        virDomainLockFailureAction action,\n                                        int *fd)\n{\n    virLockManagerSanlockDriverPtr driver = sanlockDriver;\n    virLockManagerSanlockPrivatePtr priv = lock->privateData;\n    struct sanlk_options *opt = NULL;\n    struct sanlk_resource **res_args;\n    int res_count;\n    bool res_free = false;\n    int sock = -1;\n    int rv;\n    size_t i;\n\n    virCheckFlags(VIR_LOCK_MANAGER_ACQUIRE_RESTRICT |\n                  VIR_LOCK_MANAGER_ACQUIRE_REGISTER_ONLY, -1);\n\n    if (priv->res_count == 0 &&\n        priv->hasRWDisks &&\n        driver->requireLeaseForDisks) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Read/write, exclusive access, disks were present, but no leases specified\"));\n        return -1;\n    }\n\n    /* We only initialize 'sock' if we are in the real\n     * child process and we need it to be inherited\n     *\n     * If sock == -1, then sanlock auto-open/closes a\n     * temporary sock\n     */\n    if (priv->vm_pid == getpid()) {\n        VIR_DEBUG(\"Register sanlock %d\", flags);\n        if ((sock = sanlock_register()) < 0) {\n            char *err = NULL;\n            if (virLockManagerSanlockError(sock, &err)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to open socket to sanlock daemon: %s\"),\n                               NULLSTR(err));\n                VIR_FREE(err);\n            } else {\n                virReportSystemError(-sock, \"%s\",\n                                     _(\"Failed to open socket to sanlock daemon\"));\n            }\n            goto error;\n        }\n\n        /* Mark the pid as registered */\n        priv->registered = true;\n\n        if (action != VIR_DOMAIN_LOCK_FAILURE_DEFAULT) {\n            char uuidstr[VIR_UUID_STRING_BUFLEN];\n            virUUIDFormat(priv->vm_uuid, uuidstr);\n            if (virLockManagerSanlockRegisterKillscript(sock, priv->vm_uri,\n                                                        uuidstr, action) < 0)\n                goto error;\n        }\n    } else if (!priv->registered) {\n        VIR_DEBUG(\"Process not registered, not acquiring lock\");\n        return 0;\n    }\n\n    if (VIR_ALLOC(opt) < 0)\n        goto error;\n\n    /* sanlock doesn't use owner_name for anything, so it's safe to take just\n     * the first SANLK_NAME_LEN - 1 characters from vm_name */\n    ignore_value(virStrncpy(opt->owner_name, priv->vm_name,\n                            MIN(strlen(priv->vm_name), SANLK_NAME_LEN - 1),\n                            SANLK_NAME_LEN));\n\n    if (state && STRNEQ(state, \"\")) {\n        if ((rv = sanlock_state_to_args((char *)state,\n                                        &res_count,\n                                        &res_args)) < 0) {\n            char *err = NULL;\n            if (virLockManagerSanlockError(rv, &err)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to parse lock state %s: %s\"),\n                               state, NULLSTR(err));\n                VIR_FREE(err);\n            } else {\n                virReportSystemError(-rv,\n                                     _(\"Unable to parse lock state %s\"),\n                                     state);\n            }\n            goto error;\n        }\n        res_free = true;\n    } else {\n        res_args = priv->res_args;\n        res_count = priv->res_count;\n    }\n\n    if (!(flags & VIR_LOCK_MANAGER_ACQUIRE_REGISTER_ONLY)) {\n        VIR_DEBUG(\"Acquiring object %u\", priv->res_count);\n        if ((rv = sanlock_acquire(sock, priv->vm_pid, 0,\n                                  priv->res_count, priv->res_args,\n                                  opt)) < 0) {\n            char *err = NULL;\n            if (virLockManagerSanlockError(rv, &err)) {\n                virReportError(VIR_ERR_RESOURCE_BUSY,\n                               _(\"Failed to acquire lock: %s\"),\n                               NULLSTR(err));\n                VIR_FREE(err);\n            } else {\n                virReportSystemError(-rv, \"%s\",\n                                     _(\"Failed to acquire lock\"));\n            }\n            goto error;\n        }\n    }\n\n    VIR_FREE(opt);\n\n    /*\n     * We are *intentionally* \"leaking\" sock file descriptor\n     * because we want it to be inherited by QEMU. When the\n     * sock FD finally closes upon QEMU exit (or crash) then\n     * sanlock will notice EOF and release the lock\n     */\n    if (sock != -1 &&\n        virSetInherit(sock, true) < 0)\n        goto error;\n\n    if (flags & VIR_LOCK_MANAGER_ACQUIRE_RESTRICT) {\n        if ((rv = sanlock_restrict(sock, SANLK_RESTRICT_ALL)) < 0) {\n            char *err = NULL;\n            if (virLockManagerSanlockError(rv, &err)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to restrict process: %s\"),\n                               NULLSTR(err));\n                VIR_FREE(err);\n            } else {\n                virReportSystemError(-rv, \"%s\",\n                                     _(\"Failed to restrict process\"));\n            }\n            goto error;\n        }\n    }\n\n    VIR_DEBUG(\"Acquire completed fd=%d\", sock);\n\n    if (res_free) {\n        for (i = 0; i < res_count; i++)\n            VIR_FREE(res_args[i]);\n        VIR_FREE(res_args);\n    }\n\n    if (fd)\n        *fd = sock;\n\n    return 0;\n\n error:\n    if (res_free) {\n        for (i = 0; i < res_count; i++)\n            VIR_FREE(res_args[i]);\n        VIR_FREE(res_args);\n    }\n    VIR_FREE(opt);\n    VIR_FORCE_CLOSE(sock);\n    return -1;\n}"
  },
  {
    "function_name": "virLockManagerSanlockRegisterKillscript",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
    "lines": "904-913",
    "snippet": "static int\nvirLockManagerSanlockRegisterKillscript(int sock G_GNUC_UNUSED,\n                                        const char *vmuri G_GNUC_UNUSED,\n                                        const char *uuidstr G_GNUC_UNUSED,\n                                        virDomainLockFailureAction action G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                   _(\"sanlock is too old to support lock failure action\"));\n    return -1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"lock_driver.h\"",
      "#include <sanlock_admin.h>",
      "#include <sanlock_resource.h>",
      "#include <sanlock.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdint.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"sanlock is too old to support lock failure action\")"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"sanlock is too old to support lock failure action\""
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic int\nvirLockManagerSanlockRegisterKillscript(int sock G_GNUC_UNUSED,\n                                        const char *vmuri G_GNUC_UNUSED,\n                                        const char *uuidstr G_GNUC_UNUSED,\n                                        virDomainLockFailureAction action G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                   _(\"sanlock is too old to support lock failure action\"));\n    return -1;\n}"
  },
  {
    "function_name": "virLockManagerSanlockRegisterKillscript",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
    "lines": "822-902",
    "snippet": "static int\nvirLockManagerSanlockRegisterKillscript(int sock,\n                                        const char *vmuri,\n                                        const char *uuidstr,\n                                        virDomainLockFailureAction action)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *path;\n    char *args = NULL;\n    int ret = -1;\n    int rv;\n\n    switch (action) {\n    case VIR_DOMAIN_LOCK_FAILURE_DEFAULT:\n        return 0;\n\n    case VIR_DOMAIN_LOCK_FAILURE_POWEROFF:\n    case VIR_DOMAIN_LOCK_FAILURE_PAUSE:\n        break;\n\n    case VIR_DOMAIN_LOCK_FAILURE_RESTART:\n    case VIR_DOMAIN_LOCK_FAILURE_IGNORE:\n    case VIR_DOMAIN_LOCK_FAILURE_LAST:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Failure action %s is not supported by sanlock\"),\n                       virDomainLockFailureTypeToString(action));\n        goto cleanup;\n    }\n\n    virBufferEscape(&buf, '\\\\', \"\\\\ \", \"%s\", vmuri);\n    virBufferAddLit(&buf, \" \");\n    virBufferEscape(&buf, '\\\\', \"\\\\ \", \"%s\", uuidstr);\n    virBufferAddLit(&buf, \" \");\n    virBufferEscape(&buf, '\\\\', \"\\\\ \", \"%s\",\n                    virDomainLockFailureTypeToString(action));\n\n    /* Unfortunately, sanlock_killpath() does not use const for either\n     * path or args even though it will just copy them into its own\n     * buffers.\n     */\n    path = (char *) VIR_LOCK_MANAGER_SANLOCK_KILLPATH;\n    args = virBufferContentAndReset(&buf);\n\n    VIR_DEBUG(\"Register sanlock killpath: %s %s\", path, args);\n\n    /* sanlock_killpath() would just crop the strings */\n    if (strlen(path) >= SANLK_HELPER_PATH_LEN) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Sanlock helper path is longer than %d: '%s'\"),\n                       SANLK_HELPER_PATH_LEN - 1, path);\n        goto cleanup;\n    }\n    if (strlen(args) >= SANLK_HELPER_ARGS_LEN) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Sanlock helper arguments are longer than %d:\"\n                         \" '%s'\"),\n                       SANLK_HELPER_ARGS_LEN - 1, args);\n        goto cleanup;\n    }\n\n    if ((rv = sanlock_killpath(sock, 0, path, args)) < 0) {\n        char *err = NULL;\n        if (virLockManagerSanlockError(rv, &err)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to register lock failure action: %s\"),\n                           NULLSTR(err));\n            VIR_FREE(err);\n        } else {\n            virReportSystemError(-rv, \"%s\",\n                                 _(\"Failed to register lock failure\"\n                                   \" action\"));\n        }\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(args);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"lock_driver.h\"",
      "#include <sanlock_admin.h>",
      "#include <sanlock_resource.h>",
      "#include <sanlock.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdint.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define VIR_LOCK_MANAGER_SANLOCK_KILLPATH LIBEXECDIR \"/libvirt_sanlock_helper\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "args"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-rv",
            "\"%s\"",
            "_(\"Failed to register lock failure\"\n                                   \" action\")"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to register lock failure\"\n                                   \" action\""
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "err"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to register lock failure action: %s\")",
            "NULLSTR(err)"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "err"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockError",
          "args": [
            "rv",
            "&err"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanlock_killpath",
          "args": [
            "sock",
            "0",
            "path",
            "args"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Sanlock helper arguments are longer than %d:\"\n                         \" '%s'\")",
            "SANLK_HELPER_ARGS_LEN - 1",
            "args"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "args"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Sanlock helper path is longer than %d: '%s'\")",
            "SANLK_HELPER_PATH_LEN - 1",
            "path"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Register sanlock killpath: %s %s\"",
            "path",
            "args"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscape",
          "args": [
            "&buf",
            "'\\\\'",
            "\"\\\\ \"",
            "\"%s\"",
            "virDomainLockFailureTypeToString(action)"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "491-522",
          "snippet": "void\nvirBufferEscape(virBufferPtr buf, char escape, const char *toescape,\n                const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, toescape) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 2);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (strchr(toescape, *cur))\n            *out++ = escape;\n        *out++ = *cur;\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscape(virBufferPtr buf, char escape, const char *toescape,\n                const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, toescape) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 2);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (strchr(toescape, *cur))\n            *out++ = escape;\n        *out++ = *cur;\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainLockFailureTypeToString",
          "args": [
            "action"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\" \""
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\" \""
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Failure action %s is not supported by sanlock\")",
            "virDomainLockFailureTypeToString(action)"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainLockFailureTypeToString",
          "args": [
            "action"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\n#define VIR_LOCK_MANAGER_SANLOCK_KILLPATH LIBEXECDIR \"/libvirt_sanlock_helper\"\n\nstatic int\nvirLockManagerSanlockRegisterKillscript(int sock,\n                                        const char *vmuri,\n                                        const char *uuidstr,\n                                        virDomainLockFailureAction action)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *path;\n    char *args = NULL;\n    int ret = -1;\n    int rv;\n\n    switch (action) {\n    case VIR_DOMAIN_LOCK_FAILURE_DEFAULT:\n        return 0;\n\n    case VIR_DOMAIN_LOCK_FAILURE_POWEROFF:\n    case VIR_DOMAIN_LOCK_FAILURE_PAUSE:\n        break;\n\n    case VIR_DOMAIN_LOCK_FAILURE_RESTART:\n    case VIR_DOMAIN_LOCK_FAILURE_IGNORE:\n    case VIR_DOMAIN_LOCK_FAILURE_LAST:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Failure action %s is not supported by sanlock\"),\n                       virDomainLockFailureTypeToString(action));\n        goto cleanup;\n    }\n\n    virBufferEscape(&buf, '\\\\', \"\\\\ \", \"%s\", vmuri);\n    virBufferAddLit(&buf, \" \");\n    virBufferEscape(&buf, '\\\\', \"\\\\ \", \"%s\", uuidstr);\n    virBufferAddLit(&buf, \" \");\n    virBufferEscape(&buf, '\\\\', \"\\\\ \", \"%s\",\n                    virDomainLockFailureTypeToString(action));\n\n    /* Unfortunately, sanlock_killpath() does not use const for either\n     * path or args even though it will just copy them into its own\n     * buffers.\n     */\n    path = (char *) VIR_LOCK_MANAGER_SANLOCK_KILLPATH;\n    args = virBufferContentAndReset(&buf);\n\n    VIR_DEBUG(\"Register sanlock killpath: %s %s\", path, args);\n\n    /* sanlock_killpath() would just crop the strings */\n    if (strlen(path) >= SANLK_HELPER_PATH_LEN) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Sanlock helper path is longer than %d: '%s'\"),\n                       SANLK_HELPER_PATH_LEN - 1, path);\n        goto cleanup;\n    }\n    if (strlen(args) >= SANLK_HELPER_ARGS_LEN) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Sanlock helper arguments are longer than %d:\"\n                         \" '%s'\"),\n                       SANLK_HELPER_ARGS_LEN - 1, args);\n        goto cleanup;\n    }\n\n    if ((rv = sanlock_killpath(sock, 0, path, args)) < 0) {\n        char *err = NULL;\n        if (virLockManagerSanlockError(rv, &err)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to register lock failure action: %s\"),\n                           NULLSTR(err));\n            VIR_FREE(err);\n        } else {\n            virReportSystemError(-rv, \"%s\",\n                                 _(\"Failed to register lock failure\"\n                                   \" action\"));\n        }\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(args);\n    return ret;\n}"
  },
  {
    "function_name": "virLockManagerSanlockAddResource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
    "lines": "763-819",
    "snippet": "static int virLockManagerSanlockAddResource(virLockManagerPtr lock,\n                                            unsigned int type,\n                                            const char *name,\n                                            size_t nparams,\n                                            virLockManagerParamPtr params,\n                                            unsigned int flags)\n{\n    virLockManagerSanlockDriverPtr driver = sanlockDriver;\n    virLockManagerSanlockPrivatePtr priv = lock->privateData;\n\n    virCheckFlags(VIR_LOCK_MANAGER_RESOURCE_READONLY |\n                  VIR_LOCK_MANAGER_RESOURCE_SHARED, -1);\n\n    if (priv->res_count == SANLK_MAX_RESOURCES) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many resources %d for object\"),\n                       SANLK_MAX_RESOURCES);\n        return -1;\n    }\n\n    /* Treat R/O resources as a no-op lock request */\n    if (flags & VIR_LOCK_MANAGER_RESOURCE_READONLY)\n        return 0;\n\n    switch (type) {\n    case VIR_LOCK_MANAGER_RESOURCE_TYPE_DISK:\n        if (driver->autoDiskLease) {\n            if (virLockManagerSanlockAddDisk(driver, lock, name, nparams, params,\n                                             !!(flags & VIR_LOCK_MANAGER_RESOURCE_SHARED)) < 0)\n                return -1;\n\n            if (virLockManagerSanlockCreateLease(driver,\n                                                 priv->res_args[priv->res_count-1]) < 0)\n                return -1;\n        } else {\n            if (!(flags & (VIR_LOCK_MANAGER_RESOURCE_SHARED |\n                           VIR_LOCK_MANAGER_RESOURCE_READONLY)))\n                priv->hasRWDisks = true;\n            /* Ignore disk resources without error */\n        }\n        break;\n\n    case VIR_LOCK_MANAGER_RESOURCE_TYPE_LEASE:\n        if (virLockManagerSanlockAddLease(lock, name, nparams, params,\n                                          !!(flags & VIR_LOCK_MANAGER_RESOURCE_SHARED)) < 0)\n            return -1;\n        break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown lock manager object type %d for domain lock object\"),\n                       type);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"lock_driver.h\"",
      "#include <sanlock_admin.h>",
      "#include <sanlock_resource.h>",
      "#include <sanlock.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdint.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virLockManagerSanlockDriverPtr sanlockDriver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown lock manager object type %d for domain lock object\")",
            "type"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown lock manager object type %d for domain lock object\""
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockAddLease",
          "args": [
            "lock",
            "name",
            "nparams",
            "params",
            "!!(flags & VIR_LOCK_MANAGER_RESOURCE_SHARED)"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerSanlockAddLease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "552-604",
          "snippet": "static int virLockManagerSanlockAddLease(virLockManagerPtr lock,\n                                         const char *name,\n                                         size_t nparams,\n                                         virLockManagerParamPtr params,\n                                         bool shared)\n{\n    virLockManagerSanlockPrivatePtr priv = lock->privateData;\n    int ret = -1;\n    struct sanlk_resource *res = NULL;\n    size_t i;\n\n    if (VIR_ALLOC_VAR(res, struct sanlk_disk, 1) < 0)\n        goto cleanup;\n\n    res->flags = shared ? SANLK_RES_SHARED : 0;\n    res->num_disks = 1;\n    if (virStrcpy(res->name, name, SANLK_NAME_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resource name '%s' exceeds %d characters\"),\n                       name, SANLK_NAME_LEN);\n        goto cleanup;\n    }\n\n    for (i = 0; i < nparams; i++) {\n        if (STREQ(params[i].key, \"path\")) {\n            if (virStrcpy(res->disks[0].path, params[i].value.str, SANLK_PATH_LEN) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Lease path '%s' exceeds %d characters\"),\n                               params[i].value.str, SANLK_PATH_LEN);\n                goto cleanup;\n            }\n        } else if (STREQ(params[i].key, \"offset\")) {\n            res->disks[0].offset = params[i].value.ul;\n        } else if (STREQ(params[i].key, \"lockspace\")) {\n            if (virStrcpy(res->lockspace_name, params[i].value.str, SANLK_NAME_LEN) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Resource lockspace '%s' exceeds %d characters\"),\n                               params[i].value.str, SANLK_NAME_LEN);\n                goto cleanup;\n            }\n        }\n    }\n\n    priv->res_args[priv->res_count] = res;\n    priv->res_count++;\n\n    ret = 0;\n\n cleanup:\n    if (ret == -1)\n        VIR_FREE(res);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic int virLockManagerSanlockAddLease(virLockManagerPtr lock,\n                                         const char *name,\n                                         size_t nparams,\n                                         virLockManagerParamPtr params,\n                                         bool shared)\n{\n    virLockManagerSanlockPrivatePtr priv = lock->privateData;\n    int ret = -1;\n    struct sanlk_resource *res = NULL;\n    size_t i;\n\n    if (VIR_ALLOC_VAR(res, struct sanlk_disk, 1) < 0)\n        goto cleanup;\n\n    res->flags = shared ? SANLK_RES_SHARED : 0;\n    res->num_disks = 1;\n    if (virStrcpy(res->name, name, SANLK_NAME_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resource name '%s' exceeds %d characters\"),\n                       name, SANLK_NAME_LEN);\n        goto cleanup;\n    }\n\n    for (i = 0; i < nparams; i++) {\n        if (STREQ(params[i].key, \"path\")) {\n            if (virStrcpy(res->disks[0].path, params[i].value.str, SANLK_PATH_LEN) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Lease path '%s' exceeds %d characters\"),\n                               params[i].value.str, SANLK_PATH_LEN);\n                goto cleanup;\n            }\n        } else if (STREQ(params[i].key, \"offset\")) {\n            res->disks[0].offset = params[i].value.ul;\n        } else if (STREQ(params[i].key, \"lockspace\")) {\n            if (virStrcpy(res->lockspace_name, params[i].value.str, SANLK_NAME_LEN) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Resource lockspace '%s' exceeds %d characters\"),\n                               params[i].value.str, SANLK_NAME_LEN);\n                goto cleanup;\n            }\n        }\n    }\n\n    priv->res_args[priv->res_count] = res;\n    priv->res_count++;\n\n    ret = 0;\n\n cleanup:\n    if (ret == -1)\n        VIR_FREE(res);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockCreateLease",
          "args": [
            "driver",
            "priv->res_args[priv->res_count-1]"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerSanlockCreateLease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "674-760",
          "snippet": "static int\nvirLockManagerSanlockCreateLease(virLockManagerSanlockDriverPtr driver,\n                                 struct sanlk_resource *res)\n{\n    int fd = -1;\n    struct stat st;\n    int rv;\n\n    if (stat(res->disks[0].path, &st) < 0) {\n        VIR_DEBUG(\"Lockspace %s does not yet exist\", res->disks[0].path);\n        if ((fd = open(res->disks[0].path, O_WRONLY|O_CREAT|O_EXCL, 0600)) < 0) {\n            if (errno != EEXIST) {\n                virReportSystemError(errno,\n                                     _(\"Unable to create lockspace %s\"),\n                                     res->disks[0].path);\n                return -1;\n            }\n            VIR_DEBUG(\"Someone else just created lockspace %s\", res->disks[0].path);\n        } else {\n            /* chown() the path to make sure sanlock can access it */\n            if ((driver->user != (uid_t) -1 || driver->group != (gid_t) -1) &&\n                (fchown(fd, driver->user, driver->group) < 0)) {\n                virReportSystemError(errno,\n                                     _(\"cannot chown '%s' to (%u, %u)\"),\n                                     res->disks[0].path,\n                                     (unsigned int) driver->user,\n                                     (unsigned int) driver->group);\n                goto error_unlink;\n            }\n\n            if ((rv = sanlock_align(&res->disks[0])) < 0) {\n                char *err = NULL;\n                if (virLockManagerSanlockError(rv, &err)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to query sector size %s: %s\"),\n                                   res->disks[0].path, NULLSTR(err));\n                    VIR_FREE(err);\n                } else {\n                    virReportSystemError(-rv,\n                                         _(\"Unable to query sector size %s\"),\n                                         res->disks[0].path);\n                }\n                goto error_unlink;\n            }\n\n            /*\n             * Pre allocate enough data for 1 block of leases at preferred alignment\n             */\n            if (safezero(fd, 0, rv) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Unable to allocate lease %s\"),\n                                     res->disks[0].path);\n                goto error_unlink;\n            }\n\n            if (VIR_CLOSE(fd) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Unable to save lease %s\"),\n                                     res->disks[0].path);\n                goto error_unlink;\n            }\n\n            if ((rv = sanlock_init(NULL, res, 0, 0)) < 0) {\n                char *err = NULL;\n                if (virLockManagerSanlockError(rv, &err)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to initialize lease %s: %s\"),\n                                   res->disks[0].path, NULLSTR(err));\n                    VIR_FREE(err);\n                } else {\n                    virReportSystemError(-rv,\n                                         _(\"Unable to initialize lease %s\"),\n                                         res->disks[0].path);\n                }\n                goto error_unlink;\n            }\n            VIR_DEBUG(\"Lease %s has been initialized\", res->disks[0].path);\n        }\n    }\n\n    return 0;\n\n error_unlink:\n    unlink(res->disks[0].path);\n    VIR_FORCE_CLOSE(fd);\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic int\nvirLockManagerSanlockCreateLease(virLockManagerSanlockDriverPtr driver,\n                                 struct sanlk_resource *res)\n{\n    int fd = -1;\n    struct stat st;\n    int rv;\n\n    if (stat(res->disks[0].path, &st) < 0) {\n        VIR_DEBUG(\"Lockspace %s does not yet exist\", res->disks[0].path);\n        if ((fd = open(res->disks[0].path, O_WRONLY|O_CREAT|O_EXCL, 0600)) < 0) {\n            if (errno != EEXIST) {\n                virReportSystemError(errno,\n                                     _(\"Unable to create lockspace %s\"),\n                                     res->disks[0].path);\n                return -1;\n            }\n            VIR_DEBUG(\"Someone else just created lockspace %s\", res->disks[0].path);\n        } else {\n            /* chown() the path to make sure sanlock can access it */\n            if ((driver->user != (uid_t) -1 || driver->group != (gid_t) -1) &&\n                (fchown(fd, driver->user, driver->group) < 0)) {\n                virReportSystemError(errno,\n                                     _(\"cannot chown '%s' to (%u, %u)\"),\n                                     res->disks[0].path,\n                                     (unsigned int) driver->user,\n                                     (unsigned int) driver->group);\n                goto error_unlink;\n            }\n\n            if ((rv = sanlock_align(&res->disks[0])) < 0) {\n                char *err = NULL;\n                if (virLockManagerSanlockError(rv, &err)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to query sector size %s: %s\"),\n                                   res->disks[0].path, NULLSTR(err));\n                    VIR_FREE(err);\n                } else {\n                    virReportSystemError(-rv,\n                                         _(\"Unable to query sector size %s\"),\n                                         res->disks[0].path);\n                }\n                goto error_unlink;\n            }\n\n            /*\n             * Pre allocate enough data for 1 block of leases at preferred alignment\n             */\n            if (safezero(fd, 0, rv) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Unable to allocate lease %s\"),\n                                     res->disks[0].path);\n                goto error_unlink;\n            }\n\n            if (VIR_CLOSE(fd) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Unable to save lease %s\"),\n                                     res->disks[0].path);\n                goto error_unlink;\n            }\n\n            if ((rv = sanlock_init(NULL, res, 0, 0)) < 0) {\n                char *err = NULL;\n                if (virLockManagerSanlockError(rv, &err)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to initialize lease %s: %s\"),\n                                   res->disks[0].path, NULLSTR(err));\n                    VIR_FREE(err);\n                } else {\n                    virReportSystemError(-rv,\n                                         _(\"Unable to initialize lease %s\"),\n                                         res->disks[0].path);\n                }\n                goto error_unlink;\n            }\n            VIR_DEBUG(\"Lease %s has been initialized\", res->disks[0].path);\n        }\n    }\n\n    return 0;\n\n error_unlink:\n    unlink(res->disks[0].path);\n    VIR_FORCE_CLOSE(fd);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockAddDisk",
          "args": [
            "driver",
            "lock",
            "name",
            "nparams",
            "params",
            "!!(flags & VIR_LOCK_MANAGER_RESOURCE_SHARED)"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerSanlockAddDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "609-671",
          "snippet": "static int\nvirLockManagerSanlockAddDisk(virLockManagerSanlockDriverPtr driver,\n                             virLockManagerPtr lock,\n                             const char *name,\n                             size_t nparams,\n                             virLockManagerParamPtr params G_GNUC_UNUSED,\n                             bool shared)\n{\n    virLockManagerSanlockPrivatePtr priv = lock->privateData;\n    int ret = -1;\n    struct sanlk_resource *res = NULL;\n    char *path = NULL;\n    char *hash = NULL;\n\n    if (nparams) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unexpected lock parameters for disk resource\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC_VAR(res, struct sanlk_disk, 1) < 0)\n        goto cleanup;\n\n    res->flags = shared ? SANLK_RES_SHARED : 0;\n    res->num_disks = 1;\n    if (virCryptoHashString(VIR_CRYPTO_HASH_MD5, name, &hash) < 0)\n        goto cleanup;\n    if (virStrcpy(res->name, hash, SANLK_NAME_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"MD5 hash '%s' unexpectedly larger than %d characters\"),\n                       hash, (SANLK_NAME_LEN - 1));\n        goto cleanup;\n    }\n\n    path = g_strdup_printf(\"%s/%s\", driver->autoDiskLeasePath, res->name);\n    if (virStrcpy(res->disks[0].path, path, SANLK_PATH_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lease path '%s' exceeds %d characters\"),\n                       path, SANLK_PATH_LEN);\n        goto cleanup;\n    }\n\n    if (virStrcpy(res->lockspace_name,\n                  VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE,\n                  SANLK_NAME_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resource lockspace '%s' exceeds %d characters\"),\n                       VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE, SANLK_NAME_LEN);\n        goto cleanup;\n    }\n\n    priv->res_args[priv->res_count] = res;\n    priv->res_count++;\n\n    ret = 0;\n\n cleanup:\n    if (ret == -1)\n        VIR_FREE(res);\n    VIR_FREE(path);\n    VIR_FREE(hash);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE \"__LIBVIRT__DISKS__\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\n#define VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE \"__LIBVIRT__DISKS__\"\n\nstatic int\nvirLockManagerSanlockAddDisk(virLockManagerSanlockDriverPtr driver,\n                             virLockManagerPtr lock,\n                             const char *name,\n                             size_t nparams,\n                             virLockManagerParamPtr params G_GNUC_UNUSED,\n                             bool shared)\n{\n    virLockManagerSanlockPrivatePtr priv = lock->privateData;\n    int ret = -1;\n    struct sanlk_resource *res = NULL;\n    char *path = NULL;\n    char *hash = NULL;\n\n    if (nparams) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unexpected lock parameters for disk resource\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC_VAR(res, struct sanlk_disk, 1) < 0)\n        goto cleanup;\n\n    res->flags = shared ? SANLK_RES_SHARED : 0;\n    res->num_disks = 1;\n    if (virCryptoHashString(VIR_CRYPTO_HASH_MD5, name, &hash) < 0)\n        goto cleanup;\n    if (virStrcpy(res->name, hash, SANLK_NAME_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"MD5 hash '%s' unexpectedly larger than %d characters\"),\n                       hash, (SANLK_NAME_LEN - 1));\n        goto cleanup;\n    }\n\n    path = g_strdup_printf(\"%s/%s\", driver->autoDiskLeasePath, res->name);\n    if (virStrcpy(res->disks[0].path, path, SANLK_PATH_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lease path '%s' exceeds %d characters\"),\n                       path, SANLK_PATH_LEN);\n        goto cleanup;\n    }\n\n    if (virStrcpy(res->lockspace_name,\n                  VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE,\n                  SANLK_NAME_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resource lockspace '%s' exceeds %d characters\"),\n                       VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE, SANLK_NAME_LEN);\n        goto cleanup;\n    }\n\n    priv->res_args[priv->res_count] = res;\n    priv->res_count++;\n\n    ret = 0;\n\n cleanup:\n    if (ret == -1)\n        VIR_FREE(res);\n    VIR_FREE(path);\n    VIR_FREE(hash);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Too many resources %d for object\")",
            "SANLK_MAX_RESOURCES"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_LOCK_MANAGER_RESOURCE_READONLY |\n                  VIR_LOCK_MANAGER_RESOURCE_SHARED",
            "-1"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic virLockManagerSanlockDriverPtr sanlockDriver;\n\nstatic int virLockManagerSanlockAddResource(virLockManagerPtr lock,\n                                            unsigned int type,\n                                            const char *name,\n                                            size_t nparams,\n                                            virLockManagerParamPtr params,\n                                            unsigned int flags)\n{\n    virLockManagerSanlockDriverPtr driver = sanlockDriver;\n    virLockManagerSanlockPrivatePtr priv = lock->privateData;\n\n    virCheckFlags(VIR_LOCK_MANAGER_RESOURCE_READONLY |\n                  VIR_LOCK_MANAGER_RESOURCE_SHARED, -1);\n\n    if (priv->res_count == SANLK_MAX_RESOURCES) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many resources %d for object\"),\n                       SANLK_MAX_RESOURCES);\n        return -1;\n    }\n\n    /* Treat R/O resources as a no-op lock request */\n    if (flags & VIR_LOCK_MANAGER_RESOURCE_READONLY)\n        return 0;\n\n    switch (type) {\n    case VIR_LOCK_MANAGER_RESOURCE_TYPE_DISK:\n        if (driver->autoDiskLease) {\n            if (virLockManagerSanlockAddDisk(driver, lock, name, nparams, params,\n                                             !!(flags & VIR_LOCK_MANAGER_RESOURCE_SHARED)) < 0)\n                return -1;\n\n            if (virLockManagerSanlockCreateLease(driver,\n                                                 priv->res_args[priv->res_count-1]) < 0)\n                return -1;\n        } else {\n            if (!(flags & (VIR_LOCK_MANAGER_RESOURCE_SHARED |\n                           VIR_LOCK_MANAGER_RESOURCE_READONLY)))\n                priv->hasRWDisks = true;\n            /* Ignore disk resources without error */\n        }\n        break;\n\n    case VIR_LOCK_MANAGER_RESOURCE_TYPE_LEASE:\n        if (virLockManagerSanlockAddLease(lock, name, nparams, params,\n                                          !!(flags & VIR_LOCK_MANAGER_RESOURCE_SHARED)) < 0)\n            return -1;\n        break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown lock manager object type %d for domain lock object\"),\n                       type);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virLockManagerSanlockCreateLease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
    "lines": "674-760",
    "snippet": "static int\nvirLockManagerSanlockCreateLease(virLockManagerSanlockDriverPtr driver,\n                                 struct sanlk_resource *res)\n{\n    int fd = -1;\n    struct stat st;\n    int rv;\n\n    if (stat(res->disks[0].path, &st) < 0) {\n        VIR_DEBUG(\"Lockspace %s does not yet exist\", res->disks[0].path);\n        if ((fd = open(res->disks[0].path, O_WRONLY|O_CREAT|O_EXCL, 0600)) < 0) {\n            if (errno != EEXIST) {\n                virReportSystemError(errno,\n                                     _(\"Unable to create lockspace %s\"),\n                                     res->disks[0].path);\n                return -1;\n            }\n            VIR_DEBUG(\"Someone else just created lockspace %s\", res->disks[0].path);\n        } else {\n            /* chown() the path to make sure sanlock can access it */\n            if ((driver->user != (uid_t) -1 || driver->group != (gid_t) -1) &&\n                (fchown(fd, driver->user, driver->group) < 0)) {\n                virReportSystemError(errno,\n                                     _(\"cannot chown '%s' to (%u, %u)\"),\n                                     res->disks[0].path,\n                                     (unsigned int) driver->user,\n                                     (unsigned int) driver->group);\n                goto error_unlink;\n            }\n\n            if ((rv = sanlock_align(&res->disks[0])) < 0) {\n                char *err = NULL;\n                if (virLockManagerSanlockError(rv, &err)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to query sector size %s: %s\"),\n                                   res->disks[0].path, NULLSTR(err));\n                    VIR_FREE(err);\n                } else {\n                    virReportSystemError(-rv,\n                                         _(\"Unable to query sector size %s\"),\n                                         res->disks[0].path);\n                }\n                goto error_unlink;\n            }\n\n            /*\n             * Pre allocate enough data for 1 block of leases at preferred alignment\n             */\n            if (safezero(fd, 0, rv) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Unable to allocate lease %s\"),\n                                     res->disks[0].path);\n                goto error_unlink;\n            }\n\n            if (VIR_CLOSE(fd) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Unable to save lease %s\"),\n                                     res->disks[0].path);\n                goto error_unlink;\n            }\n\n            if ((rv = sanlock_init(NULL, res, 0, 0)) < 0) {\n                char *err = NULL;\n                if (virLockManagerSanlockError(rv, &err)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to initialize lease %s: %s\"),\n                                   res->disks[0].path, NULLSTR(err));\n                    VIR_FREE(err);\n                } else {\n                    virReportSystemError(-rv,\n                                         _(\"Unable to initialize lease %s\"),\n                                         res->disks[0].path);\n                }\n                goto error_unlink;\n            }\n            VIR_DEBUG(\"Lease %s has been initialized\", res->disks[0].path);\n        }\n    }\n\n    return 0;\n\n error_unlink:\n    unlink(res->disks[0].path);\n    VIR_FORCE_CLOSE(fd);\n    return -1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"lock_driver.h\"",
      "#include <sanlock_admin.h>",
      "#include <sanlock_resource.h>",
      "#include <sanlock.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdint.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "res->disks[0].path"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Lease %s has been initialized\"",
            "res->disks[0].path"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-rv",
            "_(\"Unable to initialize lease %s\")",
            "res->disks[0].path"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to initialize lease %s\""
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "err"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to initialize lease %s: %s\")",
            "res->disks[0].path",
            "NULLSTR(err)"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "err"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockError",
          "args": [
            "rv",
            "&err"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanlock_init",
          "args": [
            "NULL",
            "res",
            "0",
            "0"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to save lease %s\")",
            "res->disks[0].path"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "fd"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to allocate lease %s\")",
            "res->disks[0].path"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safezero",
          "args": [
            "fd",
            "0",
            "rv"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "safezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1229-1244",
          "snippet": "int safezero(int fd, off_t offset, off_t len)\n{\n    int ret;\n\n    ret = safezero_posix_fallocate(fd, offset, len);\n    if (ret != -2)\n        return ret;\n\n    if (safezero_sys_fallocate(fd, offset, len) == 0)\n        return 0;\n\n    ret = safezero_mmap(fd, offset, len);\n    if (ret != -2)\n        return ret;\n    return safezero_slow(fd, offset, len);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint safezero(int fd, off_t offset, off_t len)\n{\n    int ret;\n\n    ret = safezero_posix_fallocate(fd, offset, len);\n    if (ret != -2)\n        return ret;\n\n    if (safezero_sys_fallocate(fd, offset, len) == 0)\n        return 0;\n\n    ret = safezero_mmap(fd, offset, len);\n    if (ret != -2)\n        return ret;\n    return safezero_slow(fd, offset, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-rv",
            "_(\"Unable to query sector size %s\")",
            "res->disks[0].path"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "err"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to query sector size %s: %s\")",
            "res->disks[0].path",
            "NULLSTR(err)"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "err"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockError",
          "args": [
            "rv",
            "&err"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanlock_align",
          "args": [
            "&res->disks[0]"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot chown '%s' to (%u, %u)\")",
            "res->disks[0].path",
            "(unsigned int) driver->user",
            "(unsigned int) driver->group"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchown",
          "args": [
            "fd",
            "driver->user",
            "driver->group"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Someone else just created lockspace %s\"",
            "res->disks[0].path"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to create lockspace %s\")",
            "res->disks[0].path"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "res->disks[0].path",
            "O_WRONLY|O_CREAT|O_EXCL",
            "0600"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockReopenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "3308-3323",
          "snippet": "int\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Lockspace %s does not yet exist\"",
            "res->disks[0].path"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "res->disks[0].path",
            "&st"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "profile_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_apparmor.c",
          "lines": "70-108",
          "snippet": "static int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}",
          "includes": [
            "#include \"virmdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viruuid.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"internal.h\"",
            "#include <wait.h>",
            "#include <unistd.h>",
            "#include <sys/apparmor.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virmdev.h\"\n#include \"virscsi.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virscsivhost.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viruuid.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"security_apparmor.h\"\n#include \"internal.h\"\n#include <wait.h>\n#include <unistd.h>\n#include <sys/apparmor.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic int\nvirLockManagerSanlockCreateLease(virLockManagerSanlockDriverPtr driver,\n                                 struct sanlk_resource *res)\n{\n    int fd = -1;\n    struct stat st;\n    int rv;\n\n    if (stat(res->disks[0].path, &st) < 0) {\n        VIR_DEBUG(\"Lockspace %s does not yet exist\", res->disks[0].path);\n        if ((fd = open(res->disks[0].path, O_WRONLY|O_CREAT|O_EXCL, 0600)) < 0) {\n            if (errno != EEXIST) {\n                virReportSystemError(errno,\n                                     _(\"Unable to create lockspace %s\"),\n                                     res->disks[0].path);\n                return -1;\n            }\n            VIR_DEBUG(\"Someone else just created lockspace %s\", res->disks[0].path);\n        } else {\n            /* chown() the path to make sure sanlock can access it */\n            if ((driver->user != (uid_t) -1 || driver->group != (gid_t) -1) &&\n                (fchown(fd, driver->user, driver->group) < 0)) {\n                virReportSystemError(errno,\n                                     _(\"cannot chown '%s' to (%u, %u)\"),\n                                     res->disks[0].path,\n                                     (unsigned int) driver->user,\n                                     (unsigned int) driver->group);\n                goto error_unlink;\n            }\n\n            if ((rv = sanlock_align(&res->disks[0])) < 0) {\n                char *err = NULL;\n                if (virLockManagerSanlockError(rv, &err)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to query sector size %s: %s\"),\n                                   res->disks[0].path, NULLSTR(err));\n                    VIR_FREE(err);\n                } else {\n                    virReportSystemError(-rv,\n                                         _(\"Unable to query sector size %s\"),\n                                         res->disks[0].path);\n                }\n                goto error_unlink;\n            }\n\n            /*\n             * Pre allocate enough data for 1 block of leases at preferred alignment\n             */\n            if (safezero(fd, 0, rv) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Unable to allocate lease %s\"),\n                                     res->disks[0].path);\n                goto error_unlink;\n            }\n\n            if (VIR_CLOSE(fd) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Unable to save lease %s\"),\n                                     res->disks[0].path);\n                goto error_unlink;\n            }\n\n            if ((rv = sanlock_init(NULL, res, 0, 0)) < 0) {\n                char *err = NULL;\n                if (virLockManagerSanlockError(rv, &err)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to initialize lease %s: %s\"),\n                                   res->disks[0].path, NULLSTR(err));\n                    VIR_FREE(err);\n                } else {\n                    virReportSystemError(-rv,\n                                         _(\"Unable to initialize lease %s\"),\n                                         res->disks[0].path);\n                }\n                goto error_unlink;\n            }\n            VIR_DEBUG(\"Lease %s has been initialized\", res->disks[0].path);\n        }\n    }\n\n    return 0;\n\n error_unlink:\n    unlink(res->disks[0].path);\n    VIR_FORCE_CLOSE(fd);\n    return -1;\n}"
  },
  {
    "function_name": "virLockManagerSanlockAddDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
    "lines": "609-671",
    "snippet": "static int\nvirLockManagerSanlockAddDisk(virLockManagerSanlockDriverPtr driver,\n                             virLockManagerPtr lock,\n                             const char *name,\n                             size_t nparams,\n                             virLockManagerParamPtr params G_GNUC_UNUSED,\n                             bool shared)\n{\n    virLockManagerSanlockPrivatePtr priv = lock->privateData;\n    int ret = -1;\n    struct sanlk_resource *res = NULL;\n    char *path = NULL;\n    char *hash = NULL;\n\n    if (nparams) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unexpected lock parameters for disk resource\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC_VAR(res, struct sanlk_disk, 1) < 0)\n        goto cleanup;\n\n    res->flags = shared ? SANLK_RES_SHARED : 0;\n    res->num_disks = 1;\n    if (virCryptoHashString(VIR_CRYPTO_HASH_MD5, name, &hash) < 0)\n        goto cleanup;\n    if (virStrcpy(res->name, hash, SANLK_NAME_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"MD5 hash '%s' unexpectedly larger than %d characters\"),\n                       hash, (SANLK_NAME_LEN - 1));\n        goto cleanup;\n    }\n\n    path = g_strdup_printf(\"%s/%s\", driver->autoDiskLeasePath, res->name);\n    if (virStrcpy(res->disks[0].path, path, SANLK_PATH_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lease path '%s' exceeds %d characters\"),\n                       path, SANLK_PATH_LEN);\n        goto cleanup;\n    }\n\n    if (virStrcpy(res->lockspace_name,\n                  VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE,\n                  SANLK_NAME_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resource lockspace '%s' exceeds %d characters\"),\n                       VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE, SANLK_NAME_LEN);\n        goto cleanup;\n    }\n\n    priv->res_args[priv->res_count] = res;\n    priv->res_count++;\n\n    ret = 0;\n\n cleanup:\n    if (ret == -1)\n        VIR_FREE(res);\n    VIR_FREE(path);\n    VIR_FREE(hash);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"lock_driver.h\"",
      "#include <sanlock_admin.h>",
      "#include <sanlock_resource.h>",
      "#include <sanlock.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdint.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE \"__LIBVIRT__DISKS__\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "hash"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "res"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Resource lockspace '%s' exceeds %d characters\")",
            "VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE",
            "SANLK_NAME_LEN"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Resource lockspace '%s' exceeds %d characters\""
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virStrcpy",
          "args": [
            "res->lockspace_name",
            "VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE",
            "SANLK_NAME_LEN"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "virStrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "780-784",
          "snippet": "int\nvirStrcpy(char *dest, const char *src, size_t destbytes)\n{\n    return virStrncpy(dest, src, -1, destbytes);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrcpy(char *dest, const char *src, size_t destbytes)\n{\n    return virStrncpy(dest, src, -1, destbytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Lease path '%s' exceeds %d characters\")",
            "path",
            "SANLK_PATH_LEN"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s\"",
            "driver->autoDiskLeasePath",
            "res->name"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"MD5 hash '%s' unexpectedly larger than %d characters\")",
            "hash",
            "(SANLK_NAME_LEN - 1)"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCryptoHashString",
          "args": [
            "VIR_CRYPTO_HASH_MD5",
            "name",
            "&hash"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "virCryptoHashString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
          "lines": "76-100",
          "snippet": "int\nvirCryptoHashString(virCryptoHash hash,\n                    const char *input,\n                    char **output)\n{\n    unsigned char buf[VIR_CRYPTO_LARGEST_DIGEST_SIZE];\n    ssize_t rc;\n    size_t hashstrlen;\n    size_t i;\n\n    if ((rc = virCryptoHashBuf(hash, input, buf)) < 0)\n        return -1;\n\n    hashstrlen = (rc * 2) + 1;\n\n    if (VIR_ALLOC_N(*output, hashstrlen) < 0)\n        return -1;\n\n    for (i = 0; i < rc; i++) {\n        (*output)[i * 2] = hex[(buf[i] >> 4) & 0xf];\n        (*output)[(i * 2) + 1] = hex[buf[i] & 0xf];\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"virrandom.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_CRYPTO_LARGEST_DIGEST_SIZE VIR_CRYPTO_HASH_SIZE_SHA256"
          ],
          "globals_used": [
            "static const char hex[] = \"0123456789abcdef\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\n#define VIR_CRYPTO_LARGEST_DIGEST_SIZE VIR_CRYPTO_HASH_SIZE_SHA256\n\nstatic const char hex[] = \"0123456789abcdef\";\n\nint\nvirCryptoHashString(virCryptoHash hash,\n                    const char *input,\n                    char **output)\n{\n    unsigned char buf[VIR_CRYPTO_LARGEST_DIGEST_SIZE];\n    ssize_t rc;\n    size_t hashstrlen;\n    size_t i;\n\n    if ((rc = virCryptoHashBuf(hash, input, buf)) < 0)\n        return -1;\n\n    hashstrlen = (rc * 2) + 1;\n\n    if (VIR_ALLOC_N(*output, hashstrlen) < 0)\n        return -1;\n\n    for (i = 0; i < rc; i++) {\n        (*output)[i * 2] = hex[(buf[i] >> 4) & 0xf];\n        (*output)[(i * 2) + 1] = hex[buf[i] & 0xf];\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_VAR",
          "args": [
            "res",
            "structsanlk_disk",
            "1"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unexpected lock parameters for disk resource\")"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\n#define VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE \"__LIBVIRT__DISKS__\"\n\nstatic int\nvirLockManagerSanlockAddDisk(virLockManagerSanlockDriverPtr driver,\n                             virLockManagerPtr lock,\n                             const char *name,\n                             size_t nparams,\n                             virLockManagerParamPtr params G_GNUC_UNUSED,\n                             bool shared)\n{\n    virLockManagerSanlockPrivatePtr priv = lock->privateData;\n    int ret = -1;\n    struct sanlk_resource *res = NULL;\n    char *path = NULL;\n    char *hash = NULL;\n\n    if (nparams) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unexpected lock parameters for disk resource\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC_VAR(res, struct sanlk_disk, 1) < 0)\n        goto cleanup;\n\n    res->flags = shared ? SANLK_RES_SHARED : 0;\n    res->num_disks = 1;\n    if (virCryptoHashString(VIR_CRYPTO_HASH_MD5, name, &hash) < 0)\n        goto cleanup;\n    if (virStrcpy(res->name, hash, SANLK_NAME_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"MD5 hash '%s' unexpectedly larger than %d characters\"),\n                       hash, (SANLK_NAME_LEN - 1));\n        goto cleanup;\n    }\n\n    path = g_strdup_printf(\"%s/%s\", driver->autoDiskLeasePath, res->name);\n    if (virStrcpy(res->disks[0].path, path, SANLK_PATH_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lease path '%s' exceeds %d characters\"),\n                       path, SANLK_PATH_LEN);\n        goto cleanup;\n    }\n\n    if (virStrcpy(res->lockspace_name,\n                  VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE,\n                  SANLK_NAME_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resource lockspace '%s' exceeds %d characters\"),\n                       VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE, SANLK_NAME_LEN);\n        goto cleanup;\n    }\n\n    priv->res_args[priv->res_count] = res;\n    priv->res_count++;\n\n    ret = 0;\n\n cleanup:\n    if (ret == -1)\n        VIR_FREE(res);\n    VIR_FREE(path);\n    VIR_FREE(hash);\n    return ret;\n}"
  },
  {
    "function_name": "virLockManagerSanlockAddLease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
    "lines": "552-604",
    "snippet": "static int virLockManagerSanlockAddLease(virLockManagerPtr lock,\n                                         const char *name,\n                                         size_t nparams,\n                                         virLockManagerParamPtr params,\n                                         bool shared)\n{\n    virLockManagerSanlockPrivatePtr priv = lock->privateData;\n    int ret = -1;\n    struct sanlk_resource *res = NULL;\n    size_t i;\n\n    if (VIR_ALLOC_VAR(res, struct sanlk_disk, 1) < 0)\n        goto cleanup;\n\n    res->flags = shared ? SANLK_RES_SHARED : 0;\n    res->num_disks = 1;\n    if (virStrcpy(res->name, name, SANLK_NAME_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resource name '%s' exceeds %d characters\"),\n                       name, SANLK_NAME_LEN);\n        goto cleanup;\n    }\n\n    for (i = 0; i < nparams; i++) {\n        if (STREQ(params[i].key, \"path\")) {\n            if (virStrcpy(res->disks[0].path, params[i].value.str, SANLK_PATH_LEN) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Lease path '%s' exceeds %d characters\"),\n                               params[i].value.str, SANLK_PATH_LEN);\n                goto cleanup;\n            }\n        } else if (STREQ(params[i].key, \"offset\")) {\n            res->disks[0].offset = params[i].value.ul;\n        } else if (STREQ(params[i].key, \"lockspace\")) {\n            if (virStrcpy(res->lockspace_name, params[i].value.str, SANLK_NAME_LEN) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Resource lockspace '%s' exceeds %d characters\"),\n                               params[i].value.str, SANLK_NAME_LEN);\n                goto cleanup;\n            }\n        }\n    }\n\n    priv->res_args[priv->res_count] = res;\n    priv->res_count++;\n\n    ret = 0;\n\n cleanup:\n    if (ret == -1)\n        VIR_FREE(res);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"lock_driver.h\"",
      "#include <sanlock_admin.h>",
      "#include <sanlock_resource.h>",
      "#include <sanlock.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdint.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "res"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Resource lockspace '%s' exceeds %d characters\")",
            "params[i].value.str",
            "SANLK_NAME_LEN"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Resource lockspace '%s' exceeds %d characters\""
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virStrcpy",
          "args": [
            "res->lockspace_name",
            "params[i].value.str",
            "SANLK_NAME_LEN"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "virStrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "780-784",
          "snippet": "int\nvirStrcpy(char *dest, const char *src, size_t destbytes)\n{\n    return virStrncpy(dest, src, -1, destbytes);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrcpy(char *dest, const char *src, size_t destbytes)\n{\n    return virStrncpy(dest, src, -1, destbytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "params[i].key",
            "\"lockspace\""
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "params[i].key",
            "\"offset\""
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Lease path '%s' exceeds %d characters\")",
            "params[i].value.str",
            "SANLK_PATH_LEN"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "params[i].key",
            "\"path\""
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Resource name '%s' exceeds %d characters\")",
            "name",
            "SANLK_NAME_LEN"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_VAR",
          "args": [
            "res",
            "structsanlk_disk",
            "1"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic int virLockManagerSanlockAddLease(virLockManagerPtr lock,\n                                         const char *name,\n                                         size_t nparams,\n                                         virLockManagerParamPtr params,\n                                         bool shared)\n{\n    virLockManagerSanlockPrivatePtr priv = lock->privateData;\n    int ret = -1;\n    struct sanlk_resource *res = NULL;\n    size_t i;\n\n    if (VIR_ALLOC_VAR(res, struct sanlk_disk, 1) < 0)\n        goto cleanup;\n\n    res->flags = shared ? SANLK_RES_SHARED : 0;\n    res->num_disks = 1;\n    if (virStrcpy(res->name, name, SANLK_NAME_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Resource name '%s' exceeds %d characters\"),\n                       name, SANLK_NAME_LEN);\n        goto cleanup;\n    }\n\n    for (i = 0; i < nparams; i++) {\n        if (STREQ(params[i].key, \"path\")) {\n            if (virStrcpy(res->disks[0].path, params[i].value.str, SANLK_PATH_LEN) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Lease path '%s' exceeds %d characters\"),\n                               params[i].value.str, SANLK_PATH_LEN);\n                goto cleanup;\n            }\n        } else if (STREQ(params[i].key, \"offset\")) {\n            res->disks[0].offset = params[i].value.ul;\n        } else if (STREQ(params[i].key, \"lockspace\")) {\n            if (virStrcpy(res->lockspace_name, params[i].value.str, SANLK_NAME_LEN) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Resource lockspace '%s' exceeds %d characters\"),\n                               params[i].value.str, SANLK_NAME_LEN);\n                goto cleanup;\n            }\n        }\n    }\n\n    priv->res_args[priv->res_count] = res;\n    priv->res_count++;\n\n    ret = 0;\n\n cleanup:\n    if (ret == -1)\n        VIR_FREE(res);\n    return ret;\n}"
  },
  {
    "function_name": "virLockManagerSanlockFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
    "lines": "536-549",
    "snippet": "static void virLockManagerSanlockFree(virLockManagerPtr lock)\n{\n    virLockManagerSanlockPrivatePtr priv = lock->privateData;\n    size_t i;\n\n    if (!priv)\n        return;\n\n    VIR_FREE(priv->vm_name);\n    for (i = 0; i < priv->res_count; i++)\n        VIR_FREE(priv->res_args[i]);\n    VIR_FREE(priv);\n    lock->privateData = NULL;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"lock_driver.h\"",
      "#include <sanlock_admin.h>",
      "#include <sanlock_resource.h>",
      "#include <sanlock.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdint.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->res_args[i]"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->vm_name"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic void virLockManagerSanlockFree(virLockManagerPtr lock)\n{\n    virLockManagerSanlockPrivatePtr priv = lock->privateData;\n    size_t i;\n\n    if (!priv)\n        return;\n\n    VIR_FREE(priv->vm_name);\n    for (i = 0; i < priv->res_count; i++)\n        VIR_FREE(priv->res_args[i]);\n    VIR_FREE(priv);\n    lock->privateData = NULL;\n}"
  },
  {
    "function_name": "virLockManagerSanlockNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
    "lines": "473-534",
    "snippet": "static int virLockManagerSanlockNew(virLockManagerPtr lock,\n                                    unsigned int type,\n                                    size_t nparams,\n                                    virLockManagerParamPtr params,\n                                    unsigned int flags)\n{\n    virLockManagerParamPtr param;\n    virLockManagerSanlockPrivatePtr priv;\n    size_t i;\n    int resCount = 0;\n\n    virCheckFlags(VIR_LOCK_MANAGER_NEW_STARTED, -1);\n\n    if (!sanlockDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Sanlock plugin is not initialized\"));\n        return -1;\n    }\n\n    if (type != VIR_LOCK_MANAGER_OBJECT_TYPE_DOMAIN) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unsupported object type %d\"), type);\n        return -1;\n    }\n\n    if (VIR_ALLOC(priv) < 0)\n        return -1;\n\n    priv->flags = flags;\n\n    for (i = 0; i < nparams; i++) {\n        param = &params[i];\n\n        if (STREQ(param->key, \"uuid\")) {\n            memcpy(priv->vm_uuid, param->value.uuid, 16);\n        } else if (STREQ(param->key, \"name\")) {\n            priv->vm_name = g_strdup(param->value.str);\n        } else if (STREQ(param->key, \"pid\")) {\n            priv->vm_pid = param->value.iv;\n        } else if (STREQ(param->key, \"id\")) {\n            priv->vm_id = param->value.ui;\n        } else if (STREQ(param->key, \"uri\")) {\n            priv->vm_uri = param->value.cstr;\n        }\n    }\n\n    /* Sanlock needs process registration, but the only way how to probe\n     * whether a process has been registered is to inquire the lock.  If\n     * sanlock_inquire() returns -ESRCH, then it is not registered, but\n     * if it returns any other error (rv < 0), then we cannot fail due\n     * to back-compat.  So this whole call is non-fatal, because it's\n     * called from all over the place (it will usually fail).  It merely\n     * updates privateData.\n     * If the process has just been started, we are pretty sure it is not\n     * registered. */\n    if (!(flags & VIR_LOCK_MANAGER_NEW_STARTED) &&\n        sanlock_inquire(-1, priv->vm_pid, 0, &resCount, NULL) >= 0)\n        priv->registered = true;\n\n    lock->privateData = priv;\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"lock_driver.h\"",
      "#include <sanlock_admin.h>",
      "#include <sanlock_resource.h>",
      "#include <sanlock.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdint.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virLockManagerSanlockDriverPtr sanlockDriver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sanlock_inquire",
          "args": [
            "-1",
            "priv->vm_pid",
            "0",
            "&resCount",
            "NULL"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "param->key",
            "\"uri\""
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "param->key",
            "\"id\""
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "param->key",
            "\"pid\""
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "param->value.str"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "param->key",
            "\"name\""
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "priv->vm_uuid",
            "param->value.uuid",
            "16"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "param->key",
            "\"uuid\""
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "priv"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unsupported object type %d\")",
            "type"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported object type %d\""
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Sanlock plugin is not initialized\")"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_LOCK_MANAGER_NEW_STARTED",
            "-1"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic virLockManagerSanlockDriverPtr sanlockDriver;\n\nstatic int virLockManagerSanlockNew(virLockManagerPtr lock,\n                                    unsigned int type,\n                                    size_t nparams,\n                                    virLockManagerParamPtr params,\n                                    unsigned int flags)\n{\n    virLockManagerParamPtr param;\n    virLockManagerSanlockPrivatePtr priv;\n    size_t i;\n    int resCount = 0;\n\n    virCheckFlags(VIR_LOCK_MANAGER_NEW_STARTED, -1);\n\n    if (!sanlockDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Sanlock plugin is not initialized\"));\n        return -1;\n    }\n\n    if (type != VIR_LOCK_MANAGER_OBJECT_TYPE_DOMAIN) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unsupported object type %d\"), type);\n        return -1;\n    }\n\n    if (VIR_ALLOC(priv) < 0)\n        return -1;\n\n    priv->flags = flags;\n\n    for (i = 0; i < nparams; i++) {\n        param = &params[i];\n\n        if (STREQ(param->key, \"uuid\")) {\n            memcpy(priv->vm_uuid, param->value.uuid, 16);\n        } else if (STREQ(param->key, \"name\")) {\n            priv->vm_name = g_strdup(param->value.str);\n        } else if (STREQ(param->key, \"pid\")) {\n            priv->vm_pid = param->value.iv;\n        } else if (STREQ(param->key, \"id\")) {\n            priv->vm_id = param->value.ui;\n        } else if (STREQ(param->key, \"uri\")) {\n            priv->vm_uri = param->value.cstr;\n        }\n    }\n\n    /* Sanlock needs process registration, but the only way how to probe\n     * whether a process has been registered is to inquire the lock.  If\n     * sanlock_inquire() returns -ESRCH, then it is not registered, but\n     * if it returns any other error (rv < 0), then we cannot fail due\n     * to back-compat.  So this whole call is non-fatal, because it's\n     * called from all over the place (it will usually fail).  It merely\n     * updates privateData.\n     * If the process has just been started, we are pretty sure it is not\n     * registered. */\n    if (!(flags & VIR_LOCK_MANAGER_NEW_STARTED) &&\n        sanlock_inquire(-1, priv->vm_pid, 0, &resCount, NULL) >= 0)\n        priv->registered = true;\n\n    lock->privateData = priv;\n    return 0;\n}"
  },
  {
    "function_name": "virLockManagerSanlockDeinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
    "lines": "461-470",
    "snippet": "static int virLockManagerSanlockDeinit(void)\n{\n    if (!sanlockDriver)\n        return 0;\n\n    VIR_FREE(sanlockDriver->autoDiskLeasePath);\n    VIR_FREE(sanlockDriver);\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"lock_driver.h\"",
      "#include <sanlock_admin.h>",
      "#include <sanlock_resource.h>",
      "#include <sanlock.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdint.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virLockManagerSanlockDriverPtr sanlockDriver;",
      "static int virLockManagerSanlockDeinit(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sanlockDriver"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sanlockDriver->autoDiskLeasePath"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic virLockManagerSanlockDriverPtr sanlockDriver;\nstatic int virLockManagerSanlockDeinit(void);\n\nstatic int virLockManagerSanlockDeinit(void)\n{\n    if (!sanlockDriver)\n        return 0;\n\n    VIR_FREE(sanlockDriver->autoDiskLeasePath);\n    VIR_FREE(sanlockDriver);\n\n    return 0;\n}"
  },
  {
    "function_name": "virLockManagerSanlockInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
    "lines": "414-459",
    "snippet": "static int virLockManagerSanlockInit(unsigned int version,\n                                     const char *configFile,\n                                     unsigned int flags)\n{\n    virLockManagerSanlockDriverPtr driver;\n\n    VIR_DEBUG(\"version=%u configFile=%s flags=0x%x\",\n              version, NULLSTR(configFile), flags);\n    virCheckFlags(0, -1);\n\n    if (sanlockDriver)\n        return 0;\n\n    if (VIR_ALLOC(sanlockDriver) < 0)\n        return -1;\n\n    driver = sanlockDriver;\n\n    driver->requireLeaseForDisks = true;\n    driver->hostID = 0;\n    driver->autoDiskLease = false;\n    driver->io_timeout = 0;\n    driver->user = (uid_t) -1;\n    driver->group = (gid_t) -1;\n    driver->autoDiskLeasePath = g_strdup(LOCALSTATEDIR \"/lib/libvirt/sanlock\");\n\n    if (virLockManagerSanlockLoadConfig(driver, configFile) < 0)\n        goto error;\n\n    if (driver->autoDiskLease && !driver->hostID) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Automatic disk lease mode enabled, but no host ID is set\"));\n        goto error;\n    }\n\n    if (driver->autoDiskLease) {\n        if (virLockManagerSanlockSetupLockspace(driver) < -1)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    virLockManagerSanlockDeinit();\n    return -1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"lock_driver.h\"",
      "#include <sanlock_admin.h>",
      "#include <sanlock_resource.h>",
      "#include <sanlock.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdint.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virLockManagerSanlockDriverPtr sanlockDriver;",
      "static int virLockManagerSanlockDeinit(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLockManagerSanlockDeinit",
          "args": [],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerSanlockDeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "461-470",
          "snippet": "static int virLockManagerSanlockDeinit(void)\n{\n    if (!sanlockDriver)\n        return 0;\n\n    VIR_FREE(sanlockDriver->autoDiskLeasePath);\n    VIR_FREE(sanlockDriver);\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLockManagerSanlockDriverPtr sanlockDriver;",
            "static int virLockManagerSanlockDeinit(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic virLockManagerSanlockDriverPtr sanlockDriver;\nstatic int virLockManagerSanlockDeinit(void);\n\nstatic int virLockManagerSanlockDeinit(void)\n{\n    if (!sanlockDriver)\n        return 0;\n\n    VIR_FREE(sanlockDriver->autoDiskLeasePath);\n    VIR_FREE(sanlockDriver);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockSetupLockspace",
          "args": [
            "driver"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerSanlockSetupLockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "203-410",
          "snippet": "static int\nvirLockManagerSanlockSetupLockspace(virLockManagerSanlockDriverPtr driver)\n{\n    int fd = -1;\n    struct stat st;\n    int rv;\n    struct sanlk_lockspace ls;\n    char *path = NULL;\n    char *dir = NULL;\n    int retries = LOCKSPACE_RETRIES;\n\n    path = g_strdup_printf(\"%s/%s\", driver->autoDiskLeasePath,\n                           VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE);\n\n    if (virStrcpyStatic(ls.name,\n                        VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lockspace path '%s' exceeded %d characters\"),\n                       VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE,\n                       SANLK_PATH_LEN);\n        goto error;\n    }\n    ls.host_id = 0; /* Doesn't matter for initialization */\n    ls.flags = 0;\n    if (virStrcpy(ls.host_id_disk.path, path, SANLK_PATH_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lockspace path '%s' exceeded %d characters\"),\n                       path, SANLK_PATH_LEN);\n        goto error;\n    }\n    ls.host_id_disk.offset = 0;\n\n    /* Stage 1: Ensure the lockspace file exists on disk, has\n     * space allocated for it and is initialized with lease\n     */\n    if (stat(path, &st) < 0) {\n        int perms = 0600;\n        VIR_DEBUG(\"Lockspace %s does not yet exist\", path);\n\n        dir = g_path_get_dirname(path);\n        if (stat(dir, &st) < 0 || !S_ISDIR(st.st_mode)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to create lockspace %s: parent directory\"\n                             \" does not exist or is not a directory\"),\n                           path);\n            goto error;\n        }\n\n        if (driver->group != (gid_t) -1)\n            perms |= 0060;\n\n        if ((fd = open(path, O_WRONLY|O_CREAT|O_EXCL, perms)) < 0) {\n            if (errno != EEXIST) {\n                virReportSystemError(errno,\n                                     _(\"Unable to create lockspace %s\"),\n                                     path);\n                goto error;\n            }\n            VIR_DEBUG(\"Someone else just created lockspace %s\", path);\n        } else {\n            /* chown() the path to make sure sanlock can access it */\n            if ((driver->user != (uid_t) -1 || driver->group != (gid_t) -1) &&\n                (fchown(fd, driver->user, driver->group) < 0)) {\n                virReportSystemError(errno,\n                                     _(\"cannot chown '%s' to (%u, %u)\"),\n                                     path,\n                                     (unsigned int) driver->user,\n                                     (unsigned int) driver->group);\n                goto error_unlink;\n            }\n\n            if ((rv = sanlock_align(&ls.host_id_disk)) < 0) {\n                char *err = NULL;\n                if (virLockManagerSanlockError(rv, &err)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to query sector size %s: %s\"),\n                                   path, NULLSTR(err));\n                    VIR_FREE(err);\n                } else {\n                    virReportSystemError(-rv,\n                                         _(\"Unable to query sector size %s\"),\n                                         path);\n                }\n                goto error_unlink;\n            }\n\n            /*\n             * Pre allocate enough data for 1 block of leases at preferred alignment\n             */\n            if (safezero(fd, 0, rv) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Unable to allocate lockspace %s\"),\n                                     path);\n                goto error_unlink;\n            }\n\n            if (VIR_CLOSE(fd) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Unable to save lockspace %s\"),\n                                     path);\n                goto error_unlink;\n            }\n\n            if ((rv = virLockManagerSanlockInitLockspace(driver, &ls)) < 0) {\n                char *err = NULL;\n                if (virLockManagerSanlockError(rv, &err)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to initialize lockspace %s: %s\"),\n                                   path, NULLSTR(err));\n                    VIR_FREE(err);\n                } else {\n                    virReportSystemError(-rv,\n                                         _(\"Unable to initialize lockspace %s\"),\n                                         path);\n                }\n                goto error_unlink;\n            }\n            VIR_DEBUG(\"Lockspace %s has been initialized\", path);\n        }\n    } else if (S_ISREG(st.st_mode)) {\n        /* okay, the lease file exists. Check the permissions */\n        if (((driver->user != (uid_t) -1 && driver->user != st.st_uid) ||\n             (driver->group != (gid_t) -1 && driver->group != st.st_gid)) &&\n            (chown(path, driver->user, driver->group) < 0)) {\n            virReportSystemError(errno,\n                                 _(\"cannot chown '%s' to (%u, %u)\"),\n                                 path,\n                                 (unsigned int) driver->user,\n                                 (unsigned int) driver->group);\n            goto error;\n        }\n\n        if ((driver->group != (gid_t) -1 && (st.st_mode & 0060) != 0060) &&\n            chmod(path, 0660) < 0) {\n            virReportSystemError(errno,\n                                 _(\"cannot chmod '%s' to 0660\"),\n                                 path);\n            goto error;\n        }\n    }\n\n    ls.host_id = driver->hostID;\n    /* Stage 2: Try to register the lockspace with the daemon.  If the lockspace\n     * is already registered, we should get EEXIST back in which case we can\n     * just carry on with life. If EINPROGRESS is returned, we have two options:\n     * either call a sanlock API that blocks us until lockspace changes state,\n     * or we can fallback to polling.\n     */\n retry:\n#ifdef HAVE_SANLOCK_IO_TIMEOUT\n    rv = sanlock_add_lockspace_timeout(&ls, 0, driver->io_timeout);\n#else\n    if (driver->io_timeout) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unable to use io_timeout with this version of sanlock\"));\n        goto error;\n    }\n    rv = sanlock_add_lockspace(&ls, 0);\n#endif\n    if (rv < 0) {\n        if (-rv == EINPROGRESS && --retries) {\n#ifdef HAVE_SANLOCK_INQ_LOCKSPACE\n            /* we have this function which blocks until lockspace change the\n             * state. It returns 0 if lockspace has been added, -ENOENT if it\n             * hasn't. */\n            VIR_DEBUG(\"Inquiring lockspace\");\n            if (sanlock_inq_lockspace(&ls, SANLK_INQ_WAIT) < 0)\n                VIR_DEBUG(\"Unable to inquire lockspace\");\n#else\n            /* fall back to polling */\n            VIR_DEBUG(\"Sleeping for %dms\", LOCKSPACE_SLEEP);\n            g_usleep(LOCKSPACE_SLEEP * 1000);\n#endif\n            VIR_DEBUG(\"Retrying to add lockspace (left %d)\", retries);\n            goto retry;\n        }\n        if (-rv != EEXIST) {\n            char *err = NULL;\n            if (virLockManagerSanlockError(rv, &err)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to add lockspace %s: %s\"),\n                               path, NULLSTR(err));\n                VIR_FREE(err);\n            } else {\n                virReportSystemError(-rv,\n                                     _(\"Unable to add lockspace %s\"),\n                                     path);\n            }\n            goto error;\n        } else {\n            VIR_DEBUG(\"Lockspace %s is already registered\", path);\n        }\n    } else {\n        VIR_DEBUG(\"Lockspace %s has been registered\", path);\n    }\n\n    VIR_FREE(path);\n    VIR_FREE(dir);\n    return 0;\n\n error_unlink:\n    unlink(path);\n error:\n    VIR_FORCE_CLOSE(fd);\n    VIR_FREE(path);\n    VIR_FREE(dir);\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LOCKSPACE_RETRIES 10",
            "#define LOCKSPACE_SLEEP 100",
            "#define VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE \"__LIBVIRT__DISKS__\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\n#define LOCKSPACE_RETRIES 10\n#define LOCKSPACE_SLEEP 100\n#define VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE \"__LIBVIRT__DISKS__\"\n\nstatic int\nvirLockManagerSanlockSetupLockspace(virLockManagerSanlockDriverPtr driver)\n{\n    int fd = -1;\n    struct stat st;\n    int rv;\n    struct sanlk_lockspace ls;\n    char *path = NULL;\n    char *dir = NULL;\n    int retries = LOCKSPACE_RETRIES;\n\n    path = g_strdup_printf(\"%s/%s\", driver->autoDiskLeasePath,\n                           VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE);\n\n    if (virStrcpyStatic(ls.name,\n                        VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lockspace path '%s' exceeded %d characters\"),\n                       VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE,\n                       SANLK_PATH_LEN);\n        goto error;\n    }\n    ls.host_id = 0; /* Doesn't matter for initialization */\n    ls.flags = 0;\n    if (virStrcpy(ls.host_id_disk.path, path, SANLK_PATH_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lockspace path '%s' exceeded %d characters\"),\n                       path, SANLK_PATH_LEN);\n        goto error;\n    }\n    ls.host_id_disk.offset = 0;\n\n    /* Stage 1: Ensure the lockspace file exists on disk, has\n     * space allocated for it and is initialized with lease\n     */\n    if (stat(path, &st) < 0) {\n        int perms = 0600;\n        VIR_DEBUG(\"Lockspace %s does not yet exist\", path);\n\n        dir = g_path_get_dirname(path);\n        if (stat(dir, &st) < 0 || !S_ISDIR(st.st_mode)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to create lockspace %s: parent directory\"\n                             \" does not exist or is not a directory\"),\n                           path);\n            goto error;\n        }\n\n        if (driver->group != (gid_t) -1)\n            perms |= 0060;\n\n        if ((fd = open(path, O_WRONLY|O_CREAT|O_EXCL, perms)) < 0) {\n            if (errno != EEXIST) {\n                virReportSystemError(errno,\n                                     _(\"Unable to create lockspace %s\"),\n                                     path);\n                goto error;\n            }\n            VIR_DEBUG(\"Someone else just created lockspace %s\", path);\n        } else {\n            /* chown() the path to make sure sanlock can access it */\n            if ((driver->user != (uid_t) -1 || driver->group != (gid_t) -1) &&\n                (fchown(fd, driver->user, driver->group) < 0)) {\n                virReportSystemError(errno,\n                                     _(\"cannot chown '%s' to (%u, %u)\"),\n                                     path,\n                                     (unsigned int) driver->user,\n                                     (unsigned int) driver->group);\n                goto error_unlink;\n            }\n\n            if ((rv = sanlock_align(&ls.host_id_disk)) < 0) {\n                char *err = NULL;\n                if (virLockManagerSanlockError(rv, &err)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to query sector size %s: %s\"),\n                                   path, NULLSTR(err));\n                    VIR_FREE(err);\n                } else {\n                    virReportSystemError(-rv,\n                                         _(\"Unable to query sector size %s\"),\n                                         path);\n                }\n                goto error_unlink;\n            }\n\n            /*\n             * Pre allocate enough data for 1 block of leases at preferred alignment\n             */\n            if (safezero(fd, 0, rv) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Unable to allocate lockspace %s\"),\n                                     path);\n                goto error_unlink;\n            }\n\n            if (VIR_CLOSE(fd) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Unable to save lockspace %s\"),\n                                     path);\n                goto error_unlink;\n            }\n\n            if ((rv = virLockManagerSanlockInitLockspace(driver, &ls)) < 0) {\n                char *err = NULL;\n                if (virLockManagerSanlockError(rv, &err)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to initialize lockspace %s: %s\"),\n                                   path, NULLSTR(err));\n                    VIR_FREE(err);\n                } else {\n                    virReportSystemError(-rv,\n                                         _(\"Unable to initialize lockspace %s\"),\n                                         path);\n                }\n                goto error_unlink;\n            }\n            VIR_DEBUG(\"Lockspace %s has been initialized\", path);\n        }\n    } else if (S_ISREG(st.st_mode)) {\n        /* okay, the lease file exists. Check the permissions */\n        if (((driver->user != (uid_t) -1 && driver->user != st.st_uid) ||\n             (driver->group != (gid_t) -1 && driver->group != st.st_gid)) &&\n            (chown(path, driver->user, driver->group) < 0)) {\n            virReportSystemError(errno,\n                                 _(\"cannot chown '%s' to (%u, %u)\"),\n                                 path,\n                                 (unsigned int) driver->user,\n                                 (unsigned int) driver->group);\n            goto error;\n        }\n\n        if ((driver->group != (gid_t) -1 && (st.st_mode & 0060) != 0060) &&\n            chmod(path, 0660) < 0) {\n            virReportSystemError(errno,\n                                 _(\"cannot chmod '%s' to 0660\"),\n                                 path);\n            goto error;\n        }\n    }\n\n    ls.host_id = driver->hostID;\n    /* Stage 2: Try to register the lockspace with the daemon.  If the lockspace\n     * is already registered, we should get EEXIST back in which case we can\n     * just carry on with life. If EINPROGRESS is returned, we have two options:\n     * either call a sanlock API that blocks us until lockspace changes state,\n     * or we can fallback to polling.\n     */\n retry:\n#ifdef HAVE_SANLOCK_IO_TIMEOUT\n    rv = sanlock_add_lockspace_timeout(&ls, 0, driver->io_timeout);\n#else\n    if (driver->io_timeout) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unable to use io_timeout with this version of sanlock\"));\n        goto error;\n    }\n    rv = sanlock_add_lockspace(&ls, 0);\n#endif\n    if (rv < 0) {\n        if (-rv == EINPROGRESS && --retries) {\n#ifdef HAVE_SANLOCK_INQ_LOCKSPACE\n            /* we have this function which blocks until lockspace change the\n             * state. It returns 0 if lockspace has been added, -ENOENT if it\n             * hasn't. */\n            VIR_DEBUG(\"Inquiring lockspace\");\n            if (sanlock_inq_lockspace(&ls, SANLK_INQ_WAIT) < 0)\n                VIR_DEBUG(\"Unable to inquire lockspace\");\n#else\n            /* fall back to polling */\n            VIR_DEBUG(\"Sleeping for %dms\", LOCKSPACE_SLEEP);\n            g_usleep(LOCKSPACE_SLEEP * 1000);\n#endif\n            VIR_DEBUG(\"Retrying to add lockspace (left %d)\", retries);\n            goto retry;\n        }\n        if (-rv != EEXIST) {\n            char *err = NULL;\n            if (virLockManagerSanlockError(rv, &err)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to add lockspace %s: %s\"),\n                               path, NULLSTR(err));\n                VIR_FREE(err);\n            } else {\n                virReportSystemError(-rv,\n                                     _(\"Unable to add lockspace %s\"),\n                                     path);\n            }\n            goto error;\n        } else {\n            VIR_DEBUG(\"Lockspace %s is already registered\", path);\n        }\n    } else {\n        VIR_DEBUG(\"Lockspace %s has been registered\", path);\n    }\n\n    VIR_FREE(path);\n    VIR_FREE(dir);\n    return 0;\n\n error_unlink:\n    unlink(path);\n error:\n    VIR_FORCE_CLOSE(fd);\n    VIR_FREE(path);\n    VIR_FREE(dir);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Automatic disk lease mode enabled, but no host ID is set\")"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Automatic disk lease mode enabled, but no host ID is set\""
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockLoadConfig",
          "args": [
            "driver",
            "configFile"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerSanlockLoadConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "118-173",
          "snippet": "static int\nvirLockManagerSanlockLoadConfig(virLockManagerSanlockDriverPtr driver,\n                                const char *configFile)\n{\n    g_autoptr(virConf) conf = NULL;\n    int ret = -1;\n    char *user = NULL;\n    char *group = NULL;\n\n    if (access(configFile, R_OK) == -1) {\n        if (errno != ENOENT) {\n            virReportSystemError(errno,\n                                 _(\"Unable to access config file %s\"),\n                                 configFile);\n            return -1;\n        }\n        return 0;\n    }\n\n    if (!(conf = virConfReadFile(configFile, 0)))\n        return -1;\n\n    if (virConfGetValueBool(conf, \"auto_disk_leases\", &driver->autoDiskLease) < 0)\n        goto cleanup;\n\n    if (virConfGetValueString(conf, \"disk_lease_dir\", &driver->autoDiskLeasePath) < 0)\n        goto cleanup;\n\n    if (virConfGetValueUInt(conf, \"host_id\", &driver->hostID) < 0)\n        goto cleanup;\n\n    driver->requireLeaseForDisks = !driver->autoDiskLease;\n    if (virConfGetValueBool(conf, \"require_lease_for_disks\", &driver->requireLeaseForDisks) < 0)\n        goto cleanup;\n\n    if (virConfGetValueUInt(conf, \"io_timeout\", &driver->io_timeout) < 0)\n        goto cleanup;\n\n    if (virConfGetValueString(conf, \"user\", &user) < 0)\n        goto cleanup;\n    if (user &&\n        virGetUserID(user, &driver->user) < 0)\n        goto cleanup;\n\n    if (virConfGetValueString(conf, \"group\", &group) < 0)\n        goto cleanup;\n    if (group &&\n        virGetGroupID(group, &driver->group) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(user);\n    VIR_FREE(group);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic int\nvirLockManagerSanlockLoadConfig(virLockManagerSanlockDriverPtr driver,\n                                const char *configFile)\n{\n    g_autoptr(virConf) conf = NULL;\n    int ret = -1;\n    char *user = NULL;\n    char *group = NULL;\n\n    if (access(configFile, R_OK) == -1) {\n        if (errno != ENOENT) {\n            virReportSystemError(errno,\n                                 _(\"Unable to access config file %s\"),\n                                 configFile);\n            return -1;\n        }\n        return 0;\n    }\n\n    if (!(conf = virConfReadFile(configFile, 0)))\n        return -1;\n\n    if (virConfGetValueBool(conf, \"auto_disk_leases\", &driver->autoDiskLease) < 0)\n        goto cleanup;\n\n    if (virConfGetValueString(conf, \"disk_lease_dir\", &driver->autoDiskLeasePath) < 0)\n        goto cleanup;\n\n    if (virConfGetValueUInt(conf, \"host_id\", &driver->hostID) < 0)\n        goto cleanup;\n\n    driver->requireLeaseForDisks = !driver->autoDiskLease;\n    if (virConfGetValueBool(conf, \"require_lease_for_disks\", &driver->requireLeaseForDisks) < 0)\n        goto cleanup;\n\n    if (virConfGetValueUInt(conf, \"io_timeout\", &driver->io_timeout) < 0)\n        goto cleanup;\n\n    if (virConfGetValueString(conf, \"user\", &user) < 0)\n        goto cleanup;\n    if (user &&\n        virGetUserID(user, &driver->user) < 0)\n        goto cleanup;\n\n    if (virConfGetValueString(conf, \"group\", &group) < 0)\n        goto cleanup;\n    if (group &&\n        virGetGroupID(group, &driver->group) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(user);\n    VIR_FREE(group);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "LOCALSTATEDIR \"/lib/libvirt/sanlock\""
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "sanlockDriver"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"version=%u configFile=%s flags=0x%x\"",
            "version",
            "NULLSTR(configFile)",
            "flags"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "configFile"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic virLockManagerSanlockDriverPtr sanlockDriver;\nstatic int virLockManagerSanlockDeinit(void);\n\nstatic int virLockManagerSanlockInit(unsigned int version,\n                                     const char *configFile,\n                                     unsigned int flags)\n{\n    virLockManagerSanlockDriverPtr driver;\n\n    VIR_DEBUG(\"version=%u configFile=%s flags=0x%x\",\n              version, NULLSTR(configFile), flags);\n    virCheckFlags(0, -1);\n\n    if (sanlockDriver)\n        return 0;\n\n    if (VIR_ALLOC(sanlockDriver) < 0)\n        return -1;\n\n    driver = sanlockDriver;\n\n    driver->requireLeaseForDisks = true;\n    driver->hostID = 0;\n    driver->autoDiskLease = false;\n    driver->io_timeout = 0;\n    driver->user = (uid_t) -1;\n    driver->group = (gid_t) -1;\n    driver->autoDiskLeasePath = g_strdup(LOCALSTATEDIR \"/lib/libvirt/sanlock\");\n\n    if (virLockManagerSanlockLoadConfig(driver, configFile) < 0)\n        goto error;\n\n    if (driver->autoDiskLease && !driver->hostID) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Automatic disk lease mode enabled, but no host ID is set\"));\n        goto error;\n    }\n\n    if (driver->autoDiskLease) {\n        if (virLockManagerSanlockSetupLockspace(driver) < -1)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    virLockManagerSanlockDeinit();\n    return -1;\n}"
  },
  {
    "function_name": "virLockManagerSanlockSetupLockspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
    "lines": "203-410",
    "snippet": "static int\nvirLockManagerSanlockSetupLockspace(virLockManagerSanlockDriverPtr driver)\n{\n    int fd = -1;\n    struct stat st;\n    int rv;\n    struct sanlk_lockspace ls;\n    char *path = NULL;\n    char *dir = NULL;\n    int retries = LOCKSPACE_RETRIES;\n\n    path = g_strdup_printf(\"%s/%s\", driver->autoDiskLeasePath,\n                           VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE);\n\n    if (virStrcpyStatic(ls.name,\n                        VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lockspace path '%s' exceeded %d characters\"),\n                       VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE,\n                       SANLK_PATH_LEN);\n        goto error;\n    }\n    ls.host_id = 0; /* Doesn't matter for initialization */\n    ls.flags = 0;\n    if (virStrcpy(ls.host_id_disk.path, path, SANLK_PATH_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lockspace path '%s' exceeded %d characters\"),\n                       path, SANLK_PATH_LEN);\n        goto error;\n    }\n    ls.host_id_disk.offset = 0;\n\n    /* Stage 1: Ensure the lockspace file exists on disk, has\n     * space allocated for it and is initialized with lease\n     */\n    if (stat(path, &st) < 0) {\n        int perms = 0600;\n        VIR_DEBUG(\"Lockspace %s does not yet exist\", path);\n\n        dir = g_path_get_dirname(path);\n        if (stat(dir, &st) < 0 || !S_ISDIR(st.st_mode)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to create lockspace %s: parent directory\"\n                             \" does not exist or is not a directory\"),\n                           path);\n            goto error;\n        }\n\n        if (driver->group != (gid_t) -1)\n            perms |= 0060;\n\n        if ((fd = open(path, O_WRONLY|O_CREAT|O_EXCL, perms)) < 0) {\n            if (errno != EEXIST) {\n                virReportSystemError(errno,\n                                     _(\"Unable to create lockspace %s\"),\n                                     path);\n                goto error;\n            }\n            VIR_DEBUG(\"Someone else just created lockspace %s\", path);\n        } else {\n            /* chown() the path to make sure sanlock can access it */\n            if ((driver->user != (uid_t) -1 || driver->group != (gid_t) -1) &&\n                (fchown(fd, driver->user, driver->group) < 0)) {\n                virReportSystemError(errno,\n                                     _(\"cannot chown '%s' to (%u, %u)\"),\n                                     path,\n                                     (unsigned int) driver->user,\n                                     (unsigned int) driver->group);\n                goto error_unlink;\n            }\n\n            if ((rv = sanlock_align(&ls.host_id_disk)) < 0) {\n                char *err = NULL;\n                if (virLockManagerSanlockError(rv, &err)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to query sector size %s: %s\"),\n                                   path, NULLSTR(err));\n                    VIR_FREE(err);\n                } else {\n                    virReportSystemError(-rv,\n                                         _(\"Unable to query sector size %s\"),\n                                         path);\n                }\n                goto error_unlink;\n            }\n\n            /*\n             * Pre allocate enough data for 1 block of leases at preferred alignment\n             */\n            if (safezero(fd, 0, rv) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Unable to allocate lockspace %s\"),\n                                     path);\n                goto error_unlink;\n            }\n\n            if (VIR_CLOSE(fd) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Unable to save lockspace %s\"),\n                                     path);\n                goto error_unlink;\n            }\n\n            if ((rv = virLockManagerSanlockInitLockspace(driver, &ls)) < 0) {\n                char *err = NULL;\n                if (virLockManagerSanlockError(rv, &err)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to initialize lockspace %s: %s\"),\n                                   path, NULLSTR(err));\n                    VIR_FREE(err);\n                } else {\n                    virReportSystemError(-rv,\n                                         _(\"Unable to initialize lockspace %s\"),\n                                         path);\n                }\n                goto error_unlink;\n            }\n            VIR_DEBUG(\"Lockspace %s has been initialized\", path);\n        }\n    } else if (S_ISREG(st.st_mode)) {\n        /* okay, the lease file exists. Check the permissions */\n        if (((driver->user != (uid_t) -1 && driver->user != st.st_uid) ||\n             (driver->group != (gid_t) -1 && driver->group != st.st_gid)) &&\n            (chown(path, driver->user, driver->group) < 0)) {\n            virReportSystemError(errno,\n                                 _(\"cannot chown '%s' to (%u, %u)\"),\n                                 path,\n                                 (unsigned int) driver->user,\n                                 (unsigned int) driver->group);\n            goto error;\n        }\n\n        if ((driver->group != (gid_t) -1 && (st.st_mode & 0060) != 0060) &&\n            chmod(path, 0660) < 0) {\n            virReportSystemError(errno,\n                                 _(\"cannot chmod '%s' to 0660\"),\n                                 path);\n            goto error;\n        }\n    }\n\n    ls.host_id = driver->hostID;\n    /* Stage 2: Try to register the lockspace with the daemon.  If the lockspace\n     * is already registered, we should get EEXIST back in which case we can\n     * just carry on with life. If EINPROGRESS is returned, we have two options:\n     * either call a sanlock API that blocks us until lockspace changes state,\n     * or we can fallback to polling.\n     */\n retry:\n#ifdef HAVE_SANLOCK_IO_TIMEOUT\n    rv = sanlock_add_lockspace_timeout(&ls, 0, driver->io_timeout);\n#else\n    if (driver->io_timeout) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unable to use io_timeout with this version of sanlock\"));\n        goto error;\n    }\n    rv = sanlock_add_lockspace(&ls, 0);\n#endif\n    if (rv < 0) {\n        if (-rv == EINPROGRESS && --retries) {\n#ifdef HAVE_SANLOCK_INQ_LOCKSPACE\n            /* we have this function which blocks until lockspace change the\n             * state. It returns 0 if lockspace has been added, -ENOENT if it\n             * hasn't. */\n            VIR_DEBUG(\"Inquiring lockspace\");\n            if (sanlock_inq_lockspace(&ls, SANLK_INQ_WAIT) < 0)\n                VIR_DEBUG(\"Unable to inquire lockspace\");\n#else\n            /* fall back to polling */\n            VIR_DEBUG(\"Sleeping for %dms\", LOCKSPACE_SLEEP);\n            g_usleep(LOCKSPACE_SLEEP * 1000);\n#endif\n            VIR_DEBUG(\"Retrying to add lockspace (left %d)\", retries);\n            goto retry;\n        }\n        if (-rv != EEXIST) {\n            char *err = NULL;\n            if (virLockManagerSanlockError(rv, &err)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to add lockspace %s: %s\"),\n                               path, NULLSTR(err));\n                VIR_FREE(err);\n            } else {\n                virReportSystemError(-rv,\n                                     _(\"Unable to add lockspace %s\"),\n                                     path);\n            }\n            goto error;\n        } else {\n            VIR_DEBUG(\"Lockspace %s is already registered\", path);\n        }\n    } else {\n        VIR_DEBUG(\"Lockspace %s has been registered\", path);\n    }\n\n    VIR_FREE(path);\n    VIR_FREE(dir);\n    return 0;\n\n error_unlink:\n    unlink(path);\n error:\n    VIR_FORCE_CLOSE(fd);\n    VIR_FREE(path);\n    VIR_FREE(dir);\n    return -1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"lock_driver.h\"",
      "#include <sanlock_admin.h>",
      "#include <sanlock_resource.h>",
      "#include <sanlock.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdint.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define LOCKSPACE_RETRIES 10",
      "#define LOCKSPACE_SLEEP 100",
      "#define VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE \"__LIBVIRT__DISKS__\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dir"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "path"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dir"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Lockspace %s has been registered\"",
            "path"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Lockspace %s is already registered\"",
            "path"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-rv",
            "_(\"Unable to add lockspace %s\")",
            "path"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to add lockspace %s\""
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "err"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to add lockspace %s: %s\")",
            "path",
            "NULLSTR(err)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "err"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockError",
          "args": [
            "rv",
            "&err"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Retrying to add lockspace (left %d)\"",
            "retries"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "LOCKSPACE_SLEEP * 1000"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Sleeping for %dms\"",
            "LOCKSPACE_SLEEP"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Unable to inquire lockspace\""
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanlock_inq_lockspace",
          "args": [
            "&ls",
            "SANLK_INQ_WAIT"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Inquiring lockspace\""
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanlock_add_lockspace",
          "args": [
            "&ls",
            "0"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unable to use io_timeout with this version of sanlock\")"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanlock_add_lockspace_timeout",
          "args": [
            "&ls",
            "0",
            "driver->io_timeout"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot chmod '%s' to 0660\")",
            "path"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "path",
            "0660"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot chown '%s' to (%u, %u)\")",
            "path",
            "(unsigned int) driver->user",
            "(unsigned int) driver->group"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "path",
            "driver->user",
            "driver->group"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Lockspace %s has been initialized\"",
            "path"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-rv",
            "_(\"Unable to initialize lockspace %s\")",
            "path"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "err"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to initialize lockspace %s: %s\")",
            "path",
            "NULLSTR(err)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "err"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockError",
          "args": [
            "rv",
            "&err"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockInitLockspace",
          "args": [
            "driver",
            "&ls"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerSanlockInitLockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "175-196",
          "snippet": "static int\nvirLockManagerSanlockInitLockspace(virLockManagerSanlockDriverPtr driver,\n                                   struct sanlk_lockspace *ls)\n{\n    int ret;\n\n#ifdef HAVE_SANLOCK_IO_TIMEOUT\n    const int max_hosts = 0; /* defaults used in sanlock_init() implementation */\n    const unsigned int lockspaceFlags = 0;\n\n    ret = sanlock_write_lockspace(ls, max_hosts, lockspaceFlags, driver->io_timeout);\n#else\n    if (driver->io_timeout) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unable to use io_timeout with this version of sanlock\"));\n        return -ENOTSUP;\n    }\n\n    ret = sanlock_init(ls, NULL, 0, 0);\n#endif\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic int\nvirLockManagerSanlockInitLockspace(virLockManagerSanlockDriverPtr driver,\n                                   struct sanlk_lockspace *ls)\n{\n    int ret;\n\n#ifdef HAVE_SANLOCK_IO_TIMEOUT\n    const int max_hosts = 0; /* defaults used in sanlock_init() implementation */\n    const unsigned int lockspaceFlags = 0;\n\n    ret = sanlock_write_lockspace(ls, max_hosts, lockspaceFlags, driver->io_timeout);\n#else\n    if (driver->io_timeout) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unable to use io_timeout with this version of sanlock\"));\n        return -ENOTSUP;\n    }\n\n    ret = sanlock_init(ls, NULL, 0, 0);\n#endif\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to save lockspace %s\")",
            "path"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "fd"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to allocate lockspace %s\")",
            "path"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safezero",
          "args": [
            "fd",
            "0",
            "rv"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "safezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1229-1244",
          "snippet": "int safezero(int fd, off_t offset, off_t len)\n{\n    int ret;\n\n    ret = safezero_posix_fallocate(fd, offset, len);\n    if (ret != -2)\n        return ret;\n\n    if (safezero_sys_fallocate(fd, offset, len) == 0)\n        return 0;\n\n    ret = safezero_mmap(fd, offset, len);\n    if (ret != -2)\n        return ret;\n    return safezero_slow(fd, offset, len);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint safezero(int fd, off_t offset, off_t len)\n{\n    int ret;\n\n    ret = safezero_posix_fallocate(fd, offset, len);\n    if (ret != -2)\n        return ret;\n\n    if (safezero_sys_fallocate(fd, offset, len) == 0)\n        return 0;\n\n    ret = safezero_mmap(fd, offset, len);\n    if (ret != -2)\n        return ret;\n    return safezero_slow(fd, offset, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-rv",
            "_(\"Unable to query sector size %s\")",
            "path"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "err"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to query sector size %s: %s\")",
            "path",
            "NULLSTR(err)"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "err"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerSanlockError",
          "args": [
            "rv",
            "&err"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanlock_align",
          "args": [
            "&ls.host_id_disk"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot chown '%s' to (%u, %u)\")",
            "path",
            "(unsigned int) driver->user",
            "(unsigned int) driver->group"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchown",
          "args": [
            "fd",
            "driver->user",
            "driver->group"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Someone else just created lockspace %s\"",
            "path"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to create lockspace %s\")",
            "path"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_WRONLY|O_CREAT|O_EXCL",
            "perms"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockReopenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "3308-3323",
          "snippet": "int\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to create lockspace %s: parent directory\"\n                             \" does not exist or is not a directory\")",
            "path"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dir",
            "&st"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "profile_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_apparmor.c",
          "lines": "70-108",
          "snippet": "static int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}",
          "includes": [
            "#include \"virmdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viruuid.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"internal.h\"",
            "#include <wait.h>",
            "#include <unistd.h>",
            "#include <sys/apparmor.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virmdev.h\"\n#include \"virscsi.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virscsivhost.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viruuid.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"security_apparmor.h\"\n#include \"internal.h\"\n#include <wait.h>\n#include <unistd.h>\n#include <sys/apparmor.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_path_get_dirname",
          "args": [
            "path"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Lockspace %s does not yet exist\"",
            "path"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Lockspace path '%s' exceeded %d characters\")",
            "path",
            "SANLK_PATH_LEN"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpy",
          "args": [
            "ls.host_id_disk.path",
            "path",
            "SANLK_PATH_LEN"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "virStrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "780-784",
          "snippet": "int\nvirStrcpy(char *dest, const char *src, size_t destbytes)\n{\n    return virStrncpy(dest, src, -1, destbytes);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrcpy(char *dest, const char *src, size_t destbytes)\n{\n    return virStrncpy(dest, src, -1, destbytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Lockspace path '%s' exceeded %d characters\")",
            "VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE",
            "SANLK_PATH_LEN"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "ls.name",
            "VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s\"",
            "driver->autoDiskLeasePath",
            "VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\n#define LOCKSPACE_RETRIES 10\n#define LOCKSPACE_SLEEP 100\n#define VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE \"__LIBVIRT__DISKS__\"\n\nstatic int\nvirLockManagerSanlockSetupLockspace(virLockManagerSanlockDriverPtr driver)\n{\n    int fd = -1;\n    struct stat st;\n    int rv;\n    struct sanlk_lockspace ls;\n    char *path = NULL;\n    char *dir = NULL;\n    int retries = LOCKSPACE_RETRIES;\n\n    path = g_strdup_printf(\"%s/%s\", driver->autoDiskLeasePath,\n                           VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE);\n\n    if (virStrcpyStatic(ls.name,\n                        VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lockspace path '%s' exceeded %d characters\"),\n                       VIR_LOCK_MANAGER_SANLOCK_AUTO_DISK_LOCKSPACE,\n                       SANLK_PATH_LEN);\n        goto error;\n    }\n    ls.host_id = 0; /* Doesn't matter for initialization */\n    ls.flags = 0;\n    if (virStrcpy(ls.host_id_disk.path, path, SANLK_PATH_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Lockspace path '%s' exceeded %d characters\"),\n                       path, SANLK_PATH_LEN);\n        goto error;\n    }\n    ls.host_id_disk.offset = 0;\n\n    /* Stage 1: Ensure the lockspace file exists on disk, has\n     * space allocated for it and is initialized with lease\n     */\n    if (stat(path, &st) < 0) {\n        int perms = 0600;\n        VIR_DEBUG(\"Lockspace %s does not yet exist\", path);\n\n        dir = g_path_get_dirname(path);\n        if (stat(dir, &st) < 0 || !S_ISDIR(st.st_mode)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to create lockspace %s: parent directory\"\n                             \" does not exist or is not a directory\"),\n                           path);\n            goto error;\n        }\n\n        if (driver->group != (gid_t) -1)\n            perms |= 0060;\n\n        if ((fd = open(path, O_WRONLY|O_CREAT|O_EXCL, perms)) < 0) {\n            if (errno != EEXIST) {\n                virReportSystemError(errno,\n                                     _(\"Unable to create lockspace %s\"),\n                                     path);\n                goto error;\n            }\n            VIR_DEBUG(\"Someone else just created lockspace %s\", path);\n        } else {\n            /* chown() the path to make sure sanlock can access it */\n            if ((driver->user != (uid_t) -1 || driver->group != (gid_t) -1) &&\n                (fchown(fd, driver->user, driver->group) < 0)) {\n                virReportSystemError(errno,\n                                     _(\"cannot chown '%s' to (%u, %u)\"),\n                                     path,\n                                     (unsigned int) driver->user,\n                                     (unsigned int) driver->group);\n                goto error_unlink;\n            }\n\n            if ((rv = sanlock_align(&ls.host_id_disk)) < 0) {\n                char *err = NULL;\n                if (virLockManagerSanlockError(rv, &err)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to query sector size %s: %s\"),\n                                   path, NULLSTR(err));\n                    VIR_FREE(err);\n                } else {\n                    virReportSystemError(-rv,\n                                         _(\"Unable to query sector size %s\"),\n                                         path);\n                }\n                goto error_unlink;\n            }\n\n            /*\n             * Pre allocate enough data for 1 block of leases at preferred alignment\n             */\n            if (safezero(fd, 0, rv) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Unable to allocate lockspace %s\"),\n                                     path);\n                goto error_unlink;\n            }\n\n            if (VIR_CLOSE(fd) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Unable to save lockspace %s\"),\n                                     path);\n                goto error_unlink;\n            }\n\n            if ((rv = virLockManagerSanlockInitLockspace(driver, &ls)) < 0) {\n                char *err = NULL;\n                if (virLockManagerSanlockError(rv, &err)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to initialize lockspace %s: %s\"),\n                                   path, NULLSTR(err));\n                    VIR_FREE(err);\n                } else {\n                    virReportSystemError(-rv,\n                                         _(\"Unable to initialize lockspace %s\"),\n                                         path);\n                }\n                goto error_unlink;\n            }\n            VIR_DEBUG(\"Lockspace %s has been initialized\", path);\n        }\n    } else if (S_ISREG(st.st_mode)) {\n        /* okay, the lease file exists. Check the permissions */\n        if (((driver->user != (uid_t) -1 && driver->user != st.st_uid) ||\n             (driver->group != (gid_t) -1 && driver->group != st.st_gid)) &&\n            (chown(path, driver->user, driver->group) < 0)) {\n            virReportSystemError(errno,\n                                 _(\"cannot chown '%s' to (%u, %u)\"),\n                                 path,\n                                 (unsigned int) driver->user,\n                                 (unsigned int) driver->group);\n            goto error;\n        }\n\n        if ((driver->group != (gid_t) -1 && (st.st_mode & 0060) != 0060) &&\n            chmod(path, 0660) < 0) {\n            virReportSystemError(errno,\n                                 _(\"cannot chmod '%s' to 0660\"),\n                                 path);\n            goto error;\n        }\n    }\n\n    ls.host_id = driver->hostID;\n    /* Stage 2: Try to register the lockspace with the daemon.  If the lockspace\n     * is already registered, we should get EEXIST back in which case we can\n     * just carry on with life. If EINPROGRESS is returned, we have two options:\n     * either call a sanlock API that blocks us until lockspace changes state,\n     * or we can fallback to polling.\n     */\n retry:\n#ifdef HAVE_SANLOCK_IO_TIMEOUT\n    rv = sanlock_add_lockspace_timeout(&ls, 0, driver->io_timeout);\n#else\n    if (driver->io_timeout) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unable to use io_timeout with this version of sanlock\"));\n        goto error;\n    }\n    rv = sanlock_add_lockspace(&ls, 0);\n#endif\n    if (rv < 0) {\n        if (-rv == EINPROGRESS && --retries) {\n#ifdef HAVE_SANLOCK_INQ_LOCKSPACE\n            /* we have this function which blocks until lockspace change the\n             * state. It returns 0 if lockspace has been added, -ENOENT if it\n             * hasn't. */\n            VIR_DEBUG(\"Inquiring lockspace\");\n            if (sanlock_inq_lockspace(&ls, SANLK_INQ_WAIT) < 0)\n                VIR_DEBUG(\"Unable to inquire lockspace\");\n#else\n            /* fall back to polling */\n            VIR_DEBUG(\"Sleeping for %dms\", LOCKSPACE_SLEEP);\n            g_usleep(LOCKSPACE_SLEEP * 1000);\n#endif\n            VIR_DEBUG(\"Retrying to add lockspace (left %d)\", retries);\n            goto retry;\n        }\n        if (-rv != EEXIST) {\n            char *err = NULL;\n            if (virLockManagerSanlockError(rv, &err)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to add lockspace %s: %s\"),\n                               path, NULLSTR(err));\n                VIR_FREE(err);\n            } else {\n                virReportSystemError(-rv,\n                                     _(\"Unable to add lockspace %s\"),\n                                     path);\n            }\n            goto error;\n        } else {\n            VIR_DEBUG(\"Lockspace %s is already registered\", path);\n        }\n    } else {\n        VIR_DEBUG(\"Lockspace %s has been registered\", path);\n    }\n\n    VIR_FREE(path);\n    VIR_FREE(dir);\n    return 0;\n\n error_unlink:\n    unlink(path);\n error:\n    VIR_FORCE_CLOSE(fd);\n    VIR_FREE(path);\n    VIR_FREE(dir);\n    return -1;\n}"
  },
  {
    "function_name": "virLockManagerSanlockInitLockspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
    "lines": "175-196",
    "snippet": "static int\nvirLockManagerSanlockInitLockspace(virLockManagerSanlockDriverPtr driver,\n                                   struct sanlk_lockspace *ls)\n{\n    int ret;\n\n#ifdef HAVE_SANLOCK_IO_TIMEOUT\n    const int max_hosts = 0; /* defaults used in sanlock_init() implementation */\n    const unsigned int lockspaceFlags = 0;\n\n    ret = sanlock_write_lockspace(ls, max_hosts, lockspaceFlags, driver->io_timeout);\n#else\n    if (driver->io_timeout) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unable to use io_timeout with this version of sanlock\"));\n        return -ENOTSUP;\n    }\n\n    ret = sanlock_init(ls, NULL, 0, 0);\n#endif\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"lock_driver.h\"",
      "#include <sanlock_admin.h>",
      "#include <sanlock_resource.h>",
      "#include <sanlock.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdint.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sanlock_init",
          "args": [
            "ls",
            "NULL",
            "0",
            "0"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unable to use io_timeout with this version of sanlock\")"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to use io_timeout with this version of sanlock\""
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "sanlock_write_lockspace",
          "args": [
            "ls",
            "max_hosts",
            "lockspaceFlags",
            "driver->io_timeout"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic int\nvirLockManagerSanlockInitLockspace(virLockManagerSanlockDriverPtr driver,\n                                   struct sanlk_lockspace *ls)\n{\n    int ret;\n\n#ifdef HAVE_SANLOCK_IO_TIMEOUT\n    const int max_hosts = 0; /* defaults used in sanlock_init() implementation */\n    const unsigned int lockspaceFlags = 0;\n\n    ret = sanlock_write_lockspace(ls, max_hosts, lockspaceFlags, driver->io_timeout);\n#else\n    if (driver->io_timeout) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unable to use io_timeout with this version of sanlock\"));\n        return -ENOTSUP;\n    }\n\n    ret = sanlock_init(ls, NULL, 0, 0);\n#endif\n    return ret;\n}"
  },
  {
    "function_name": "virLockManagerSanlockLoadConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
    "lines": "118-173",
    "snippet": "static int\nvirLockManagerSanlockLoadConfig(virLockManagerSanlockDriverPtr driver,\n                                const char *configFile)\n{\n    g_autoptr(virConf) conf = NULL;\n    int ret = -1;\n    char *user = NULL;\n    char *group = NULL;\n\n    if (access(configFile, R_OK) == -1) {\n        if (errno != ENOENT) {\n            virReportSystemError(errno,\n                                 _(\"Unable to access config file %s\"),\n                                 configFile);\n            return -1;\n        }\n        return 0;\n    }\n\n    if (!(conf = virConfReadFile(configFile, 0)))\n        return -1;\n\n    if (virConfGetValueBool(conf, \"auto_disk_leases\", &driver->autoDiskLease) < 0)\n        goto cleanup;\n\n    if (virConfGetValueString(conf, \"disk_lease_dir\", &driver->autoDiskLeasePath) < 0)\n        goto cleanup;\n\n    if (virConfGetValueUInt(conf, \"host_id\", &driver->hostID) < 0)\n        goto cleanup;\n\n    driver->requireLeaseForDisks = !driver->autoDiskLease;\n    if (virConfGetValueBool(conf, \"require_lease_for_disks\", &driver->requireLeaseForDisks) < 0)\n        goto cleanup;\n\n    if (virConfGetValueUInt(conf, \"io_timeout\", &driver->io_timeout) < 0)\n        goto cleanup;\n\n    if (virConfGetValueString(conf, \"user\", &user) < 0)\n        goto cleanup;\n    if (user &&\n        virGetUserID(user, &driver->user) < 0)\n        goto cleanup;\n\n    if (virConfGetValueString(conf, \"group\", &group) < 0)\n        goto cleanup;\n    if (group &&\n        virGetGroupID(group, &driver->group) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(user);\n    VIR_FREE(group);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"lock_driver.h\"",
      "#include <sanlock_admin.h>",
      "#include <sanlock_resource.h>",
      "#include <sanlock.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdint.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "group"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "user"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetGroupID",
          "args": [
            "group",
            "&driver->group"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "virGetGroupID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1138-1145",
          "snippet": "int virGetGroupID(const char *name G_GNUC_UNUSED,\n                  gid_t *gid G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virGetGroupID is not available\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virGetGroupID(const char *name G_GNUC_UNUSED,\n                  gid_t *gid G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virGetGroupID is not available\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValueString",
          "args": [
            "conf",
            "\"group\"",
            "&group"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "875-898",
          "snippet": "int virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetUserID",
          "args": [
            "user",
            "&driver->user"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1128-1135",
          "snippet": "int virGetUserID(const char *name G_GNUC_UNUSED,\n                 uid_t *uid G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virGetUserID is not available\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virGetUserID(const char *name G_GNUC_UNUSED,\n                 uid_t *uid G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virGetUserID is not available\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValueUInt",
          "args": [
            "conf",
            "\"io_timeout\"",
            "&driver->io_timeout"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueUInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1099-1128",
          "snippet": "int virConfGetValueUInt(virConfPtr conf,\n                        const char *setting,\n                        unsigned int *value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value uint %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_ULLONG) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected an unsigned integer for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    if (((unsigned long long)cval->l) > UINT_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: value for '%s' parameter must be in range 0:%u\"),\n                       conf->filename, setting, UINT_MAX);\n        return -1;\n    }\n\n    *value = (unsigned int)cval->l;\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueUInt(virConfPtr conf,\n                        const char *setting,\n                        unsigned int *value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value uint %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_ULLONG) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected an unsigned integer for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    if (((unsigned long long)cval->l) > UINT_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: value for '%s' parameter must be in range 0:%u\"),\n                       conf->filename, setting, UINT_MAX);\n        return -1;\n    }\n\n    *value = (unsigned int)cval->l;\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValueBool",
          "args": [
            "conf",
            "\"require_lease_for_disks\"",
            "&driver->requireLeaseForDisks"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueBool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1002-1031",
          "snippet": "int virConfGetValueBool(virConfPtr conf,\n                        const char *setting,\n                        bool *value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value bool %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_ULLONG) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a bool for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    if (((unsigned long long)cval->l) > 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: value for '%s' parameter must be 0 or 1\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    *value = cval->l == 1;\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueBool(virConfPtr conf,\n                        const char *setting,\n                        bool *value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value bool %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_ULLONG) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a bool for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    if (((unsigned long long)cval->l) > 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: value for '%s' parameter must be 0 or 1\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    *value = cval->l == 1;\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfReadFile",
          "args": [
            "configFile",
            "0"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "virConfReadFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "730-752",
          "snippet": "virConfPtr\nvirConfReadFile(const char *filename, unsigned int flags)\n{\n    char *content;\n    int len;\n    virConfPtr conf;\n\n    VIR_DEBUG(\"filename=%s\", NULLSTR(filename));\n\n    if (filename == NULL) {\n        virConfError(NULL, VIR_ERR_INVALID_ARG, __FUNCTION__);\n        return NULL;\n    }\n\n    if ((len = virFileReadAll(filename, MAX_CONFIG_FILE_SIZE, &content)) < 0)\n        return NULL;\n\n    conf = virConfParse(filename, content, len, flags);\n\n    VIR_FREE(content);\n\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_CONFIG_FILE_SIZE (1024*1024*10)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\n#define MAX_CONFIG_FILE_SIZE (1024*1024*10)\n\nvirConfPtr\nvirConfReadFile(const char *filename, unsigned int flags)\n{\n    char *content;\n    int len;\n    virConfPtr conf;\n\n    VIR_DEBUG(\"filename=%s\", NULLSTR(filename));\n\n    if (filename == NULL) {\n        virConfError(NULL, VIR_ERR_INVALID_ARG, __FUNCTION__);\n        return NULL;\n    }\n\n    if ((len = virFileReadAll(filename, MAX_CONFIG_FILE_SIZE, &content)) < 0)\n        return NULL;\n\n    conf = virConfParse(filename, content, len, flags);\n\n    VIR_FREE(content);\n\n    return conf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to access config file %s\")",
            "configFile"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to access config file %s\""
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "configFile",
            "R_OK"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic int\nvirLockManagerSanlockLoadConfig(virLockManagerSanlockDriverPtr driver,\n                                const char *configFile)\n{\n    g_autoptr(virConf) conf = NULL;\n    int ret = -1;\n    char *user = NULL;\n    char *group = NULL;\n\n    if (access(configFile, R_OK) == -1) {\n        if (errno != ENOENT) {\n            virReportSystemError(errno,\n                                 _(\"Unable to access config file %s\"),\n                                 configFile);\n            return -1;\n        }\n        return 0;\n    }\n\n    if (!(conf = virConfReadFile(configFile, 0)))\n        return -1;\n\n    if (virConfGetValueBool(conf, \"auto_disk_leases\", &driver->autoDiskLease) < 0)\n        goto cleanup;\n\n    if (virConfGetValueString(conf, \"disk_lease_dir\", &driver->autoDiskLeasePath) < 0)\n        goto cleanup;\n\n    if (virConfGetValueUInt(conf, \"host_id\", &driver->hostID) < 0)\n        goto cleanup;\n\n    driver->requireLeaseForDisks = !driver->autoDiskLease;\n    if (virConfGetValueBool(conf, \"require_lease_for_disks\", &driver->requireLeaseForDisks) < 0)\n        goto cleanup;\n\n    if (virConfGetValueUInt(conf, \"io_timeout\", &driver->io_timeout) < 0)\n        goto cleanup;\n\n    if (virConfGetValueString(conf, \"user\", &user) < 0)\n        goto cleanup;\n    if (user &&\n        virGetUserID(user, &driver->user) < 0)\n        goto cleanup;\n\n    if (virConfGetValueString(conf, \"group\", &group) < 0)\n        goto cleanup;\n    if (group &&\n        virGetGroupID(group, &driver->group) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(user);\n    VIR_FREE(group);\n    return ret;\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
    "lines": "97-111",
    "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"lock_driver.h\"",
      "#include <sanlock_admin.h>",
      "#include <sanlock_resource.h>",
      "#include <sanlock.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdint.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "_(\"sanlock error %d\")",
            "err"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"sanlock error %d\""
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sanlock_strerror",
          "args": [
            "err"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
  }
]