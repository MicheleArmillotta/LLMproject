[
  {
    "function_name": "adminDispatchConnectGetLoggingFilters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "494-523",
    "snippet": "static int\nadminDispatchConnectGetLoggingFilters(virNetServerPtr server G_GNUC_UNUSED,\n                                      virNetServerClientPtr client G_GNUC_UNUSED,\n                                      virNetMessagePtr msg G_GNUC_UNUSED,\n                                      virNetMessageErrorPtr rerr,\n                                      admin_connect_get_logging_filters_args *args,\n                                      admin_connect_get_logging_filters_ret *ret)\n{\n    char *filters = NULL;\n    int nfilters = 0;\n\n    if ((nfilters = adminConnectGetLoggingFilters(&filters, args->flags)) < 0) {\n        virNetMessageSaveError(rerr);\n        return -1;\n    }\n\n    if (nfilters == 0) {\n        ret->filters = NULL;\n    } else {\n        char **ret_filters = NULL;\n        if (VIR_ALLOC(ret_filters) < 0)\n            return -1;\n\n        *ret_filters = filters;\n        ret->filters = ret_filters;\n    }\n    ret->nfilters = nfilters;\n\n    return 0;\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ret_filters"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "adminConnectGetLoggingFilters",
          "args": [
            "&filters",
            "args->flags"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "adminConnectGetLoggingFilters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
          "lines": "437-450",
          "snippet": "static int\nadminConnectGetLoggingFilters(char **filters, unsigned int flags)\n{\n    char *tmp = NULL;\n    int ret = 0;\n\n    virCheckFlags(0, -1);\n\n    if ((ret = virLogGetNbFilters()) > 0 && !(tmp = virLogGetFilters()))\n        return -1;\n\n    *filters = tmp;\n    return ret;\n}",
          "includes": [
            "#include \"admin_server_dispatch_stubs.h\"",
            "#include \"virutil.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"admin_server.h\"",
            "#include \"admin_server_dispatch.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nadminConnectGetLoggingFilters(char **filters, unsigned int flags)\n{\n    char *tmp = NULL;\n    int ret = 0;\n\n    virCheckFlags(0, -1);\n\n    if ((ret = virLogGetNbFilters()) > 0 && !(tmp = virLogGetFilters()))\n        return -1;\n\n    *filters = tmp;\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nadminDispatchConnectGetLoggingFilters(virNetServerPtr server G_GNUC_UNUSED,\n                                      virNetServerClientPtr client G_GNUC_UNUSED,\n                                      virNetMessagePtr msg G_GNUC_UNUSED,\n                                      virNetMessageErrorPtr rerr,\n                                      admin_connect_get_logging_filters_args *args,\n                                      admin_connect_get_logging_filters_ret *ret)\n{\n    char *filters = NULL;\n    int nfilters = 0;\n\n    if ((nfilters = adminConnectGetLoggingFilters(&filters, args->flags)) < 0) {\n        virNetMessageSaveError(rerr);\n        return -1;\n    }\n\n    if (nfilters == 0) {\n        ret->filters = NULL;\n    } else {\n        char **ret_filters = NULL;\n        if (VIR_ALLOC(ret_filters) < 0)\n            return -1;\n\n        *ret_filters = filters;\n        ret->filters = ret_filters;\n    }\n    ret->nfilters = nfilters;\n\n    return 0;\n}"
  },
  {
    "function_name": "adminDispatchConnectGetLoggingOutputs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "472-492",
    "snippet": "static int\nadminDispatchConnectGetLoggingOutputs(virNetServerPtr server G_GNUC_UNUSED,\n                                      virNetServerClientPtr client G_GNUC_UNUSED,\n                                      virNetMessagePtr msg G_GNUC_UNUSED,\n                                      virNetMessageErrorPtr rerr,\n                                      admin_connect_get_logging_outputs_args *args,\n                                      admin_connect_get_logging_outputs_ret *ret)\n{\n    char *outputs = NULL;\n    int noutputs = 0;\n\n    if ((noutputs = adminConnectGetLoggingOutputs(&outputs, args->flags)) < 0) {\n        virNetMessageSaveError(rerr);\n        return -1;\n    }\n\n    ret->outputs = g_steal_pointer(&outputs);\n    ret->noutputs = noutputs;\n\n    return 0;\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&outputs"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "adminConnectGetLoggingOutputs",
          "args": [
            "&outputs",
            "args->flags"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "adminConnectGetLoggingOutputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
          "lines": "422-434",
          "snippet": "static int\nadminConnectGetLoggingOutputs(char **outputs, unsigned int flags)\n{\n    char *tmp = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (!(tmp = virLogGetOutputs()))\n        return -1;\n\n    *outputs = tmp;\n    return virLogGetNbOutputs();\n}",
          "includes": [
            "#include \"admin_server_dispatch_stubs.h\"",
            "#include \"virutil.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"admin_server.h\"",
            "#include \"admin_server_dispatch.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nadminConnectGetLoggingOutputs(char **outputs, unsigned int flags)\n{\n    char *tmp = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (!(tmp = virLogGetOutputs()))\n        return -1;\n\n    *outputs = tmp;\n    return virLogGetNbOutputs();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nadminDispatchConnectGetLoggingOutputs(virNetServerPtr server G_GNUC_UNUSED,\n                                      virNetServerClientPtr client G_GNUC_UNUSED,\n                                      virNetMessagePtr msg G_GNUC_UNUSED,\n                                      virNetMessageErrorPtr rerr,\n                                      admin_connect_get_logging_outputs_args *args,\n                                      admin_connect_get_logging_outputs_ret *ret)\n{\n    char *outputs = NULL;\n    int noutputs = 0;\n\n    if ((noutputs = adminConnectGetLoggingOutputs(&outputs, args->flags)) < 0) {\n        virNetMessageSaveError(rerr);\n        return -1;\n    }\n\n    ret->outputs = g_steal_pointer(&outputs);\n    ret->noutputs = noutputs;\n\n    return 0;\n}"
  },
  {
    "function_name": "adminConnectSetLoggingFilters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "462-470",
    "snippet": "static int\nadminConnectSetLoggingFilters(virNetDaemonPtr dmn G_GNUC_UNUSED,\n                              const char *filters,\n                              unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n    return virLogSetFilters(filters);\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLogSetFilters",
          "args": [
            "filters"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "virLogSetFilters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1790-1811",
          "snippet": "int\nvirLogSetFilters(const char *src)\n{\n    int ret = -1;\n    int nfilters = 0;\n    virLogFilterPtr *filters = NULL;\n\n    if (virLogInitialize() < 0)\n        return -1;\n\n    if (src && (nfilters = virLogParseFilters(src, &filters)) < 0)\n        goto cleanup;\n\n    if (virLogDefineFilters(filters, nfilters) < 0)\n        goto cleanup;\n\n    filters = NULL;\n    ret = 0;\n cleanup:\n    virLogFilterListFree(filters, nfilters);\n    return ret;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirLogSetFilters(const char *src)\n{\n    int ret = -1;\n    int nfilters = 0;\n    virLogFilterPtr *filters = NULL;\n\n    if (virLogInitialize() < 0)\n        return -1;\n\n    if (src && (nfilters = virLogParseFilters(src, &filters)) < 0)\n        goto cleanup;\n\n    if (virLogDefineFilters(filters, nfilters) < 0)\n        goto cleanup;\n\n    filters = NULL;\n    ret = 0;\n cleanup:\n    virLogFilterListFree(filters, nfilters);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nadminConnectSetLoggingFilters(virNetDaemonPtr dmn G_GNUC_UNUSED,\n                              const char *filters,\n                              unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n    return virLogSetFilters(filters);\n}"
  },
  {
    "function_name": "adminConnectSetLoggingOutputs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "452-460",
    "snippet": "static int\nadminConnectSetLoggingOutputs(virNetDaemonPtr dmn G_GNUC_UNUSED,\n                              const char *outputs,\n                              unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n    return virLogSetOutputs(outputs);\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLogSetOutputs",
          "args": [
            "outputs"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "virLogSetOutputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1747-1779",
          "snippet": "int\nvirLogSetOutputs(const char *src)\n{\n    int ret = -1;\n    int noutputs = 0;\n    const char *outputstr = virLogDefaultOutput;\n    virLogOutputPtr *outputs = NULL;\n\n    if (virLogInitialize() < 0)\n        return -1;\n\n    if (src && *src)\n        outputstr = src;\n\n    /* This can only happen during daemon init when the default output is not\n     * determined yet. It's safe to do, since it's the only place setting the\n     * default output.\n     */\n    if (!outputstr)\n        return 0;\n\n    if ((noutputs = virLogParseOutputs(outputstr, &outputs)) < 0)\n        goto cleanup;\n\n    if (virLogDefineOutputs(outputs, noutputs) < 0)\n        goto cleanup;\n\n    outputs = NULL;\n    ret = 0;\n cleanup:\n    virLogOutputListFree(outputs, noutputs);\n    return ret;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *virLogDefaultOutput;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *virLogDefaultOutput;\n\nint\nvirLogSetOutputs(const char *src)\n{\n    int ret = -1;\n    int noutputs = 0;\n    const char *outputstr = virLogDefaultOutput;\n    virLogOutputPtr *outputs = NULL;\n\n    if (virLogInitialize() < 0)\n        return -1;\n\n    if (src && *src)\n        outputstr = src;\n\n    /* This can only happen during daemon init when the default output is not\n     * determined yet. It's safe to do, since it's the only place setting the\n     * default output.\n     */\n    if (!outputstr)\n        return 0;\n\n    if ((noutputs = virLogParseOutputs(outputstr, &outputs)) < 0)\n        goto cleanup;\n\n    if (virLogDefineOutputs(outputs, noutputs) < 0)\n        goto cleanup;\n\n    outputs = NULL;\n    ret = 0;\n cleanup:\n    virLogOutputListFree(outputs, noutputs);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nadminConnectSetLoggingOutputs(virNetDaemonPtr dmn G_GNUC_UNUSED,\n                              const char *outputs,\n                              unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n    return virLogSetOutputs(outputs);\n}"
  },
  {
    "function_name": "adminConnectGetLoggingFilters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "437-450",
    "snippet": "static int\nadminConnectGetLoggingFilters(char **filters, unsigned int flags)\n{\n    char *tmp = NULL;\n    int ret = 0;\n\n    virCheckFlags(0, -1);\n\n    if ((ret = virLogGetNbFilters()) > 0 && !(tmp = virLogGetFilters()))\n        return -1;\n\n    *filters = tmp;\n    return ret;\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLogGetFilters",
          "args": [],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "virLogGetFilters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1077-1094",
          "snippet": "char *\nvirLogGetFilters(void)\n{\n    size_t i;\n    virBuffer filterbuf = VIR_BUFFER_INITIALIZER;\n\n    virLogLock();\n    for (i = 0; i < virLogNbFilters; i++) {\n        const char *sep = \":\";\n        virBufferAsprintf(&filterbuf, \"%d%s%s \",\n                          virLogFilters[i]->priority,\n                          sep,\n                          virLogFilters[i]->match);\n    }\n    virLogUnlock();\n\n    return virBufferContentAndReset(&filterbuf);\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLogFilterPtr *virLogFilters;",
            "static size_t virLogNbFilters;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic virLogFilterPtr *virLogFilters;\nstatic size_t virLogNbFilters;\n\nchar *\nvirLogGetFilters(void)\n{\n    size_t i;\n    virBuffer filterbuf = VIR_BUFFER_INITIALIZER;\n\n    virLogLock();\n    for (i = 0; i < virLogNbFilters; i++) {\n        const char *sep = \":\";\n        virBufferAsprintf(&filterbuf, \"%d%s%s \",\n                          virLogFilters[i]->priority,\n                          sep,\n                          virLogFilters[i]->match);\n    }\n    virLogUnlock();\n\n    return virBufferContentAndReset(&filterbuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogGetNbFilters",
          "args": [],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "virLogGetNbFilters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1151-1155",
          "snippet": "int\nvirLogGetNbFilters(void)\n{\n    return virLogNbFilters;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t virLogNbFilters;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic size_t virLogNbFilters;\n\nint\nvirLogGetNbFilters(void)\n{\n    return virLogNbFilters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nadminConnectGetLoggingFilters(char **filters, unsigned int flags)\n{\n    char *tmp = NULL;\n    int ret = 0;\n\n    virCheckFlags(0, -1);\n\n    if ((ret = virLogGetNbFilters()) > 0 && !(tmp = virLogGetFilters()))\n        return -1;\n\n    *filters = tmp;\n    return ret;\n}"
  },
  {
    "function_name": "adminConnectGetLoggingOutputs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "422-434",
    "snippet": "static int\nadminConnectGetLoggingOutputs(char **outputs, unsigned int flags)\n{\n    char *tmp = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (!(tmp = virLogGetOutputs()))\n        return -1;\n\n    *outputs = tmp;\n    return virLogGetNbOutputs();\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLogGetNbOutputs",
          "args": [],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "virLogGetNbOutputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1163-1167",
          "snippet": "int\nvirLogGetNbOutputs(void)\n{\n    return virLogNbOutputs;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t virLogNbOutputs;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic size_t virLogNbOutputs;\n\nint\nvirLogGetNbOutputs(void)\n{\n    return virLogNbOutputs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogGetOutputs",
          "args": [],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "virLogGetOutputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1104-1143",
          "snippet": "char *\nvirLogGetOutputs(void)\n{\n    size_t i;\n    virBuffer outputbuf = VIR_BUFFER_INITIALIZER;\n\n    virLogLock();\n    for (i = 0; i < virLogNbOutputs; i++) {\n        virLogDestination dest = virLogOutputs[i]->dest;\n        if (i)\n            virBufferAddChar(&outputbuf, ' ');\n        switch (dest) {\n            case VIR_LOG_TO_SYSLOG:\n            case VIR_LOG_TO_FILE:\n                virBufferAsprintf(&outputbuf, \"%d:%s:%s\",\n                                  virLogOutputs[i]->priority,\n                                  virLogDestinationTypeToString(dest),\n                                  virLogOutputs[i]->name);\n                break;\n            case VIR_LOG_TO_STDERR:\n            case VIR_LOG_TO_JOURNALD:\n                virBufferAsprintf(&outputbuf, \"%d:%s\",\n                                  virLogOutputs[i]->priority,\n                                  virLogDestinationTypeToString(dest));\n                break;\n            case VIR_LOG_TO_OUTPUT_LAST:\n            default:\n                virReportEnumRangeError(virLogDestination, dest);\n                goto error;\n        }\n    }\n\n    virLogUnlock();\n    return virBufferContentAndReset(&outputbuf);\n\n error:\n    virLogUnlock();\n    virBufferFreeAndReset(&outputbuf);\n    return NULL;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLogOutputPtr *virLogOutputs;",
            "static size_t virLogNbOutputs;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic virLogOutputPtr *virLogOutputs;\nstatic size_t virLogNbOutputs;\n\nchar *\nvirLogGetOutputs(void)\n{\n    size_t i;\n    virBuffer outputbuf = VIR_BUFFER_INITIALIZER;\n\n    virLogLock();\n    for (i = 0; i < virLogNbOutputs; i++) {\n        virLogDestination dest = virLogOutputs[i]->dest;\n        if (i)\n            virBufferAddChar(&outputbuf, ' ');\n        switch (dest) {\n            case VIR_LOG_TO_SYSLOG:\n            case VIR_LOG_TO_FILE:\n                virBufferAsprintf(&outputbuf, \"%d:%s:%s\",\n                                  virLogOutputs[i]->priority,\n                                  virLogDestinationTypeToString(dest),\n                                  virLogOutputs[i]->name);\n                break;\n            case VIR_LOG_TO_STDERR:\n            case VIR_LOG_TO_JOURNALD:\n                virBufferAsprintf(&outputbuf, \"%d:%s\",\n                                  virLogOutputs[i]->priority,\n                                  virLogDestinationTypeToString(dest));\n                break;\n            case VIR_LOG_TO_OUTPUT_LAST:\n            default:\n                virReportEnumRangeError(virLogDestination, dest);\n                goto error;\n        }\n    }\n\n    virLogUnlock();\n    return virBufferContentAndReset(&outputbuf);\n\n error:\n    virLogUnlock();\n    virBufferFreeAndReset(&outputbuf);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nadminConnectGetLoggingOutputs(char **outputs, unsigned int flags)\n{\n    char *tmp = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (!(tmp = virLogGetOutputs()))\n        return -1;\n\n    *outputs = tmp;\n    return virLogGetNbOutputs();\n}"
  },
  {
    "function_name": "adminDispatchServerSetClientLimits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "383-419",
    "snippet": "static int\nadminDispatchServerSetClientLimits(virNetServerPtr server G_GNUC_UNUSED,\n                                   virNetServerClientPtr client,\n                                   virNetMessagePtr msg G_GNUC_UNUSED,\n                                   virNetMessageErrorPtr rerr G_GNUC_UNUSED,\n                                   admin_server_set_client_limits_args *args)\n{\n    int rv = -1;\n    virNetServerPtr srv = NULL;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    struct daemonAdmClientPrivate *priv =\n        virNetServerClientGetPrivateData(client);\n\n    if (!(srv = virNetDaemonGetServer(priv->dmn, args->srv.name))) {\n        virReportError(VIR_ERR_NO_SERVER,\n                       _(\"no server with matching name '%s' found\"),\n                       args->srv.name);\n        goto cleanup;\n    }\n\n    if (virTypedParamsDeserialize((virTypedParameterRemotePtr) args->params.params_val,\n        args->params.params_len,\n        ADMIN_SERVER_CLIENT_LIMITS_MAX, &params, &nparams) < 0)\n        goto cleanup;\n\n    if (adminServerSetClientLimits(srv, params, nparams, args->flags) < 0)\n        goto cleanup;\n\n    rv = 0;\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virTypedParamsFree(params, nparams);\n    virObjectUnref(srv);\n    return rv;\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "srv"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsFree",
          "args": [
            "params",
            "nparams"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam-public.c",
          "lines": "878-884",
          "snippet": "void\nvirTypedParamsFree(virTypedParameterPtr params,\n                   int nparams)\n{\n    virTypedParamsClear(params, nparams);\n    VIR_FREE(params);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtypedparam.h\"\n#include <config.h>\n\nvoid\nvirTypedParamsFree(virTypedParameterPtr params,\n                   int nparams)\n{\n    virTypedParamsClear(params, nparams);\n    VIR_FREE(params);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "adminServerSetClientLimits",
          "args": [
            "srv",
            "params",
            "nparams",
            "args->flags"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "adminServerSetClientLimits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server.c",
          "lines": "336-369",
          "snippet": "int\nadminServerSetClientLimits(virNetServerPtr srv,\n                           virTypedParameterPtr params,\n                           int nparams,\n                           unsigned int flags)\n{\n    long long int maxClients = -1;\n    long long int maxClientsUnauth = -1;\n    virTypedParameterPtr param = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (virTypedParamsValidate(params, nparams,\n                               VIR_SERVER_CLIENTS_MAX,\n                               VIR_TYPED_PARAM_UINT,\n                               VIR_SERVER_CLIENTS_UNAUTH_MAX,\n                               VIR_TYPED_PARAM_UINT,\n                               NULL) < 0)\n        return -1;\n\n    if ((param = virTypedParamsGet(params, nparams,\n                                   VIR_SERVER_CLIENTS_MAX)))\n        maxClients = param->value.ui;\n\n    if ((param = virTypedParamsGet(params, nparams,\n                                   VIR_SERVER_CLIENTS_UNAUTH_MAX)))\n        maxClientsUnauth = param->value.ui;\n\n    if (virNetServerSetClientLimits(srv, maxClients,\n                                    maxClientsUnauth) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virstring.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virlog.h\"",
            "#include \"viridentity.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"admin_server.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virthreadpool.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"viridentity.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include <config.h>\n\nint\nadminServerSetClientLimits(virNetServerPtr srv,\n                           virTypedParameterPtr params,\n                           int nparams,\n                           unsigned int flags)\n{\n    long long int maxClients = -1;\n    long long int maxClientsUnauth = -1;\n    virTypedParameterPtr param = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (virTypedParamsValidate(params, nparams,\n                               VIR_SERVER_CLIENTS_MAX,\n                               VIR_TYPED_PARAM_UINT,\n                               VIR_SERVER_CLIENTS_UNAUTH_MAX,\n                               VIR_TYPED_PARAM_UINT,\n                               NULL) < 0)\n        return -1;\n\n    if ((param = virTypedParamsGet(params, nparams,\n                                   VIR_SERVER_CLIENTS_MAX)))\n        maxClients = param->value.ui;\n\n    if ((param = virTypedParamsGet(params, nparams,\n                                   VIR_SERVER_CLIENTS_UNAUTH_MAX)))\n        maxClientsUnauth = param->value.ui;\n\n    if (virNetServerSetClientLimits(srv, maxClients,\n                                    maxClientsUnauth) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsDeserialize",
          "args": [
            "(virTypedParameterRemotePtr) args->params.params_val",
            "args->params.params_len",
            "ADMIN_SERVER_CLIENT_LIMITS_MAX",
            "&params",
            "&nparams"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsDeserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "527-621",
          "snippet": "int\nvirTypedParamsDeserialize(virTypedParameterRemotePtr remote_params,\n                          unsigned int remote_params_len,\n                          int limit,\n                          virTypedParameterPtr *params,\n                          int *nparams)\n{\n    size_t i = 0;\n    int rv = -1;\n    bool userAllocated = *params != NULL;\n\n    if (limit && remote_params_len > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%u' for limit '%d'\"),\n                       remote_params_len, limit);\n        goto cleanup;\n    }\n\n    if (userAllocated) {\n        /* Check the length of the returned list carefully. */\n        if (remote_params_len > *nparams) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"too many parameters '%u' for nparams '%d'\"),\n                           remote_params_len, *nparams);\n            goto cleanup;\n        }\n    } else {\n        if (VIR_ALLOC_N(*params, remote_params_len) < 0)\n            goto cleanup;\n    }\n    *nparams = remote_params_len;\n\n    /* Deserialize the result. */\n    for (i = 0; i < remote_params_len; ++i) {\n        virTypedParameterPtr param = *params + i;\n        virTypedParameterRemotePtr remote_param = remote_params + i;\n\n        if (virStrcpyStatic(param->field,\n                            remote_param->field) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"parameter %s too big for destination\"),\n                           remote_param->field);\n            goto cleanup;\n        }\n\n        param->type = remote_param->value.type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            param->value.i =\n                remote_param->value.remote_typed_param_value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            param->value.ui =\n                remote_param->value.remote_typed_param_value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            param->value.l =\n                remote_param->value.remote_typed_param_value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            param->value.ul =\n                remote_param->value.remote_typed_param_value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            param->value.d =\n                remote_param->value.remote_typed_param_value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            param->value.b =\n                remote_param->value.remote_typed_param_value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            param->value.s = g_strdup(remote_param->value.remote_typed_param_value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n    }\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0) {\n        if (userAllocated) {\n            virTypedParamsClear(*params, i);\n        } else {\n            virTypedParamsFree(*params, i);\n            *params = NULL;\n            *nparams = 0;\n        }\n    }\n    return rv;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsDeserialize(virTypedParameterRemotePtr remote_params,\n                          unsigned int remote_params_len,\n                          int limit,\n                          virTypedParameterPtr *params,\n                          int *nparams)\n{\n    size_t i = 0;\n    int rv = -1;\n    bool userAllocated = *params != NULL;\n\n    if (limit && remote_params_len > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%u' for limit '%d'\"),\n                       remote_params_len, limit);\n        goto cleanup;\n    }\n\n    if (userAllocated) {\n        /* Check the length of the returned list carefully. */\n        if (remote_params_len > *nparams) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"too many parameters '%u' for nparams '%d'\"),\n                           remote_params_len, *nparams);\n            goto cleanup;\n        }\n    } else {\n        if (VIR_ALLOC_N(*params, remote_params_len) < 0)\n            goto cleanup;\n    }\n    *nparams = remote_params_len;\n\n    /* Deserialize the result. */\n    for (i = 0; i < remote_params_len; ++i) {\n        virTypedParameterPtr param = *params + i;\n        virTypedParameterRemotePtr remote_param = remote_params + i;\n\n        if (virStrcpyStatic(param->field,\n                            remote_param->field) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"parameter %s too big for destination\"),\n                           remote_param->field);\n            goto cleanup;\n        }\n\n        param->type = remote_param->value.type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            param->value.i =\n                remote_param->value.remote_typed_param_value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            param->value.ui =\n                remote_param->value.remote_typed_param_value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            param->value.l =\n                remote_param->value.remote_typed_param_value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            param->value.ul =\n                remote_param->value.remote_typed_param_value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            param->value.d =\n                remote_param->value.remote_typed_param_value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            param->value.b =\n                remote_param->value.remote_typed_param_value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            param->value.s = g_strdup(remote_param->value.remote_typed_param_value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n    }\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0) {\n        if (userAllocated) {\n            virTypedParamsClear(*params, i);\n        } else {\n            virTypedParamsFree(*params, i);\n            *params = NULL;\n            *nparams = 0;\n        }\n    }\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SERVER",
            "_(\"no server with matching name '%s' found\")",
            "args->srv.name"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no server with matching name '%s' found\""
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonGetServer",
          "args": [
            "priv->dmn",
            "args->srv.name"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonGetServers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "240-264",
          "snippet": "ssize_t\nvirNetDaemonGetServers(virNetDaemonPtr dmn,\n                       virNetServerPtr **servers)\n{\n    struct collectData data = { servers, 0 };\n    ssize_t ret = -1;\n\n    *servers = NULL;\n\n    virObjectLock(dmn);\n\n    if (virHashForEach(dmn->servers, collectServers, &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get all servers from daemon\"));\n        goto cleanup;\n    }\n\n    ret = data.nservers;\n\n cleanup:\n    if (ret < 0)\n        virObjectListFreeCount(*servers, data.nservers);\n    virObjectUnlock(dmn);\n    return ret;\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nssize_t\nvirNetDaemonGetServers(virNetDaemonPtr dmn,\n                       virNetServerPtr **servers)\n{\n    struct collectData data = { servers, 0 };\n    ssize_t ret = -1;\n\n    *servers = NULL;\n\n    virObjectLock(dmn);\n\n    if (virHashForEach(dmn->servers, collectServers, &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get all servers from daemon\"));\n        goto cleanup;\n    }\n\n    ret = data.nservers;\n\n cleanup:\n    if (ret < 0)\n        virObjectListFreeCount(*servers, data.nservers);\n    virObjectUnlock(dmn);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nadminDispatchServerSetClientLimits(virNetServerPtr server G_GNUC_UNUSED,\n                                   virNetServerClientPtr client,\n                                   virNetMessagePtr msg G_GNUC_UNUSED,\n                                   virNetMessageErrorPtr rerr G_GNUC_UNUSED,\n                                   admin_server_set_client_limits_args *args)\n{\n    int rv = -1;\n    virNetServerPtr srv = NULL;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    struct daemonAdmClientPrivate *priv =\n        virNetServerClientGetPrivateData(client);\n\n    if (!(srv = virNetDaemonGetServer(priv->dmn, args->srv.name))) {\n        virReportError(VIR_ERR_NO_SERVER,\n                       _(\"no server with matching name '%s' found\"),\n                       args->srv.name);\n        goto cleanup;\n    }\n\n    if (virTypedParamsDeserialize((virTypedParameterRemotePtr) args->params.params_val,\n        args->params.params_len,\n        ADMIN_SERVER_CLIENT_LIMITS_MAX, &params, &nparams) < 0)\n        goto cleanup;\n\n    if (adminServerSetClientLimits(srv, params, nparams, args->flags) < 0)\n        goto cleanup;\n\n    rv = 0;\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n    virTypedParamsFree(params, nparams);\n    virObjectUnref(srv);\n    return rv;\n}"
  },
  {
    "function_name": "adminDispatchServerGetClientLimits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "346-381",
    "snippet": "static int\nadminDispatchServerGetClientLimits(virNetServerPtr server G_GNUC_UNUSED,\n                                   virNetServerClientPtr client,\n                                   virNetMessagePtr msg G_GNUC_UNUSED,\n                                   virNetMessageErrorPtr rerr G_GNUC_UNUSED,\n                                   admin_server_get_client_limits_args *args,\n                                   admin_server_get_client_limits_ret *ret)\n{\n    int rv = -1;\n    virNetServerPtr srv = NULL;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    struct daemonAdmClientPrivate *priv =\n        virNetServerClientGetPrivateData(client);\n\n    if (!(srv = virNetDaemonGetServer(priv->dmn, args->srv.name)))\n        goto cleanup;\n\n    if (adminServerGetClientLimits(srv, &params, &nparams, args->flags) < 0)\n        goto cleanup;\n\n    if (virTypedParamsSerialize(params, nparams,\n                                ADMIN_SERVER_CLIENT_LIMITS_MAX,\n                                (virTypedParameterRemotePtr *) &ret->params.params_val,\n                                &ret->params.params_len, 0) < 0)\n        goto cleanup;\n\n    rv = 0;\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n\n    virTypedParamsFree(params, nparams);\n    virObjectUnref(srv);\n    return rv;\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "srv"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsFree",
          "args": [
            "params",
            "nparams"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam-public.c",
          "lines": "878-884",
          "snippet": "void\nvirTypedParamsFree(virTypedParameterPtr params,\n                   int nparams)\n{\n    virTypedParamsClear(params, nparams);\n    VIR_FREE(params);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtypedparam.h\"\n#include <config.h>\n\nvoid\nvirTypedParamsFree(virTypedParameterPtr params,\n                   int nparams)\n{\n    virTypedParamsClear(params, nparams);\n    VIR_FREE(params);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsSerialize",
          "args": [
            "params",
            "nparams",
            "ADMIN_SERVER_CLIENT_LIMITS_MAX",
            "(virTypedParameterRemotePtr *) &ret->params.params_val",
            "&ret->params.params_len",
            "0"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsSerialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "644-723",
          "snippet": "int\nvirTypedParamsSerialize(virTypedParameterPtr params,\n                        int nparams,\n                        int limit,\n                        virTypedParameterRemotePtr *remote_params_val,\n                        unsigned int *remote_params_len,\n                        unsigned int flags)\n{\n    size_t i;\n    size_t j;\n    int rv = -1;\n    virTypedParameterRemotePtr params_val = NULL;\n    int params_len = nparams;\n\n    if (nparams > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%d' for limit '%d'\"),\n                       nparams, limit);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(params_val, nparams) < 0)\n        goto cleanup;\n\n    for (i = 0, j = 0; i < nparams; ++i) {\n        virTypedParameterPtr param = params + i;\n        virTypedParameterRemotePtr val = params_val + j;\n        /* NOTE: Following snippet is relevant to server only, because\n         * virDomainGetCPUStats can return a sparse array; also, we can't pass\n         * back strings to older clients. */\n        if (!param->type ||\n            (!(flags & VIR_TYPED_PARAM_STRING_OKAY) &&\n             param->type == VIR_TYPED_PARAM_STRING)) {\n            --params_len;\n            continue;\n        }\n\n        /* This will be either freed by virNetServerDispatchCall or call(),\n         * depending on the calling side, i.e. server or client */\n        val->field = g_strdup(param->field);\n        val->value.type = param->type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            val->value.remote_typed_param_value.i = param->value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            val->value.remote_typed_param_value.ui = param->value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            val->value.remote_typed_param_value.l = param->value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            val->value.remote_typed_param_value.ul = param->value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            val->value.remote_typed_param_value.d = param->value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            val->value.remote_typed_param_value.b = param->value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            val->value.remote_typed_param_value.s = g_strdup(param->value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n        j++;\n    }\n\n    *remote_params_val = params_val;\n    *remote_params_len = params_len;\n    params_val = NULL;\n    rv = 0;\n\n cleanup:\n    virTypedParamsRemoteFree(params_val, nparams);\n    return rv;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsSerialize(virTypedParameterPtr params,\n                        int nparams,\n                        int limit,\n                        virTypedParameterRemotePtr *remote_params_val,\n                        unsigned int *remote_params_len,\n                        unsigned int flags)\n{\n    size_t i;\n    size_t j;\n    int rv = -1;\n    virTypedParameterRemotePtr params_val = NULL;\n    int params_len = nparams;\n\n    if (nparams > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%d' for limit '%d'\"),\n                       nparams, limit);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(params_val, nparams) < 0)\n        goto cleanup;\n\n    for (i = 0, j = 0; i < nparams; ++i) {\n        virTypedParameterPtr param = params + i;\n        virTypedParameterRemotePtr val = params_val + j;\n        /* NOTE: Following snippet is relevant to server only, because\n         * virDomainGetCPUStats can return a sparse array; also, we can't pass\n         * back strings to older clients. */\n        if (!param->type ||\n            (!(flags & VIR_TYPED_PARAM_STRING_OKAY) &&\n             param->type == VIR_TYPED_PARAM_STRING)) {\n            --params_len;\n            continue;\n        }\n\n        /* This will be either freed by virNetServerDispatchCall or call(),\n         * depending on the calling side, i.e. server or client */\n        val->field = g_strdup(param->field);\n        val->value.type = param->type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            val->value.remote_typed_param_value.i = param->value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            val->value.remote_typed_param_value.ui = param->value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            val->value.remote_typed_param_value.l = param->value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            val->value.remote_typed_param_value.ul = param->value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            val->value.remote_typed_param_value.d = param->value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            val->value.remote_typed_param_value.b = param->value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            val->value.remote_typed_param_value.s = g_strdup(param->value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n        j++;\n    }\n\n    *remote_params_val = params_val;\n    *remote_params_len = params_len;\n    params_val = NULL;\n    rv = 0;\n\n cleanup:\n    virTypedParamsRemoteFree(params_val, nparams);\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "adminServerGetClientLimits",
          "args": [
            "srv",
            "&params",
            "&nparams",
            "args->flags"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "adminServerGetClientLimits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server.c",
          "lines": "301-334",
          "snippet": "int\nadminServerGetClientLimits(virNetServerPtr srv,\n                           virTypedParameterPtr *params,\n                           int *nparams,\n                           unsigned int flags)\n{\n    g_autoptr(virTypedParamList) paramlist = g_new0(virTypedParamList, 1);\n\n    virCheckFlags(0, -1);\n\n    if (virTypedParamListAddUInt(paramlist,\n                                 virNetServerGetMaxClients(srv),\n                                 \"%s\", VIR_SERVER_CLIENTS_MAX) < 0)\n        return -1;\n\n    if (virTypedParamListAddUInt(paramlist,\n                                 virNetServerGetCurrentClients(srv),\n                                 \"%s\", VIR_SERVER_CLIENTS_CURRENT) < 0)\n        return -1;\n\n    if (virTypedParamListAddUInt(paramlist,\n                                 virNetServerGetMaxUnauthClients(srv),\n                                 \"%s\", VIR_SERVER_CLIENTS_UNAUTH_MAX) < 0)\n        return -1;\n\n    if (virTypedParamListAddUInt(paramlist,\n                                 virNetServerGetCurrentUnauthClients(srv),\n                                 \"%s\", VIR_SERVER_CLIENTS_UNAUTH_CURRENT) < 0)\n        return -1;\n\n    *nparams = virTypedParamListStealParams(paramlist, params);\n\n    return 0;\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virstring.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virlog.h\"",
            "#include \"viridentity.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"admin_server.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virthreadpool.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"viridentity.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include <config.h>\n\nint\nadminServerGetClientLimits(virNetServerPtr srv,\n                           virTypedParameterPtr *params,\n                           int *nparams,\n                           unsigned int flags)\n{\n    g_autoptr(virTypedParamList) paramlist = g_new0(virTypedParamList, 1);\n\n    virCheckFlags(0, -1);\n\n    if (virTypedParamListAddUInt(paramlist,\n                                 virNetServerGetMaxClients(srv),\n                                 \"%s\", VIR_SERVER_CLIENTS_MAX) < 0)\n        return -1;\n\n    if (virTypedParamListAddUInt(paramlist,\n                                 virNetServerGetCurrentClients(srv),\n                                 \"%s\", VIR_SERVER_CLIENTS_CURRENT) < 0)\n        return -1;\n\n    if (virTypedParamListAddUInt(paramlist,\n                                 virNetServerGetMaxUnauthClients(srv),\n                                 \"%s\", VIR_SERVER_CLIENTS_UNAUTH_MAX) < 0)\n        return -1;\n\n    if (virTypedParamListAddUInt(paramlist,\n                                 virNetServerGetCurrentUnauthClients(srv),\n                                 \"%s\", VIR_SERVER_CLIENTS_UNAUTH_CURRENT) < 0)\n        return -1;\n\n    *nparams = virTypedParamListStealParams(paramlist, params);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonGetServer",
          "args": [
            "priv->dmn",
            "args->srv.name"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonGetServers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "240-264",
          "snippet": "ssize_t\nvirNetDaemonGetServers(virNetDaemonPtr dmn,\n                       virNetServerPtr **servers)\n{\n    struct collectData data = { servers, 0 };\n    ssize_t ret = -1;\n\n    *servers = NULL;\n\n    virObjectLock(dmn);\n\n    if (virHashForEach(dmn->servers, collectServers, &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get all servers from daemon\"));\n        goto cleanup;\n    }\n\n    ret = data.nservers;\n\n cleanup:\n    if (ret < 0)\n        virObjectListFreeCount(*servers, data.nservers);\n    virObjectUnlock(dmn);\n    return ret;\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nssize_t\nvirNetDaemonGetServers(virNetDaemonPtr dmn,\n                       virNetServerPtr **servers)\n{\n    struct collectData data = { servers, 0 };\n    ssize_t ret = -1;\n\n    *servers = NULL;\n\n    virObjectLock(dmn);\n\n    if (virHashForEach(dmn->servers, collectServers, &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get all servers from daemon\"));\n        goto cleanup;\n    }\n\n    ret = data.nservers;\n\n cleanup:\n    if (ret < 0)\n        virObjectListFreeCount(*servers, data.nservers);\n    virObjectUnlock(dmn);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nadminDispatchServerGetClientLimits(virNetServerPtr server G_GNUC_UNUSED,\n                                   virNetServerClientPtr client,\n                                   virNetMessagePtr msg G_GNUC_UNUSED,\n                                   virNetMessageErrorPtr rerr G_GNUC_UNUSED,\n                                   admin_server_get_client_limits_args *args,\n                                   admin_server_get_client_limits_ret *ret)\n{\n    int rv = -1;\n    virNetServerPtr srv = NULL;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    struct daemonAdmClientPrivate *priv =\n        virNetServerClientGetPrivateData(client);\n\n    if (!(srv = virNetDaemonGetServer(priv->dmn, args->srv.name)))\n        goto cleanup;\n\n    if (adminServerGetClientLimits(srv, &params, &nparams, args->flags) < 0)\n        goto cleanup;\n\n    if (virTypedParamsSerialize(params, nparams,\n                                ADMIN_SERVER_CLIENT_LIMITS_MAX,\n                                (virTypedParameterRemotePtr *) &ret->params.params_val,\n                                &ret->params.params_len, 0) < 0)\n        goto cleanup;\n\n    rv = 0;\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n\n    virTypedParamsFree(params, nparams);\n    virObjectUnref(srv);\n    return rv;\n}"
  },
  {
    "function_name": "adminDispatchClientGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "294-344",
    "snippet": "static int\nadminDispatchClientGetInfo(virNetServerPtr server G_GNUC_UNUSED,\n                           virNetServerClientPtr client,\n                           virNetMessagePtr msg G_GNUC_UNUSED,\n                           virNetMessageErrorPtr rerr,\n                           struct admin_client_get_info_args *args,\n                           struct admin_client_get_info_ret *ret)\n{\n    int rv = -1;\n    virNetServerPtr srv = NULL;\n    virNetServerClientPtr clnt = NULL;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    struct daemonAdmClientPrivate *priv =\n        virNetServerClientGetPrivateData(client);\n\n    if (!(srv = virNetDaemonGetServer(priv->dmn, args->clnt.srv.name))) {\n        virReportError(VIR_ERR_NO_SERVER,\n                       _(\"no server with matching name '%s' found\"),\n                       args->clnt.srv.name);\n        goto cleanup;\n    }\n\n    if (!(clnt = virNetServerGetClient(srv, args->clnt.id))) {\n        virReportError(VIR_ERR_NO_CLIENT,\n                       _(\"no client with matching id '%llu' found\"),\n                       (unsigned long long) args->clnt.id);\n        goto cleanup;\n    }\n\n    if (adminClientGetInfo(clnt, &params, &nparams, args->flags) < 0)\n        goto cleanup;\n\n    if (virTypedParamsSerialize(params, nparams,\n                                ADMIN_CLIENT_INFO_PARAMETERS_MAX,\n                                (virTypedParameterRemotePtr *) &ret->params.params_val,\n                                &ret->params.params_len,\n                                VIR_TYPED_PARAM_STRING_OKAY) < 0)\n        goto cleanup;\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n\n    virTypedParamsFree(params, nparams);\n    virObjectUnref(clnt);\n    virObjectUnref(srv);\n    return rv;\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "srv"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsFree",
          "args": [
            "params",
            "nparams"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam-public.c",
          "lines": "878-884",
          "snippet": "void\nvirTypedParamsFree(virTypedParameterPtr params,\n                   int nparams)\n{\n    virTypedParamsClear(params, nparams);\n    VIR_FREE(params);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtypedparam.h\"\n#include <config.h>\n\nvoid\nvirTypedParamsFree(virTypedParameterPtr params,\n                   int nparams)\n{\n    virTypedParamsClear(params, nparams);\n    VIR_FREE(params);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsSerialize",
          "args": [
            "params",
            "nparams",
            "ADMIN_CLIENT_INFO_PARAMETERS_MAX",
            "(virTypedParameterRemotePtr *) &ret->params.params_val",
            "&ret->params.params_len",
            "VIR_TYPED_PARAM_STRING_OKAY"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsSerialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "644-723",
          "snippet": "int\nvirTypedParamsSerialize(virTypedParameterPtr params,\n                        int nparams,\n                        int limit,\n                        virTypedParameterRemotePtr *remote_params_val,\n                        unsigned int *remote_params_len,\n                        unsigned int flags)\n{\n    size_t i;\n    size_t j;\n    int rv = -1;\n    virTypedParameterRemotePtr params_val = NULL;\n    int params_len = nparams;\n\n    if (nparams > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%d' for limit '%d'\"),\n                       nparams, limit);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(params_val, nparams) < 0)\n        goto cleanup;\n\n    for (i = 0, j = 0; i < nparams; ++i) {\n        virTypedParameterPtr param = params + i;\n        virTypedParameterRemotePtr val = params_val + j;\n        /* NOTE: Following snippet is relevant to server only, because\n         * virDomainGetCPUStats can return a sparse array; also, we can't pass\n         * back strings to older clients. */\n        if (!param->type ||\n            (!(flags & VIR_TYPED_PARAM_STRING_OKAY) &&\n             param->type == VIR_TYPED_PARAM_STRING)) {\n            --params_len;\n            continue;\n        }\n\n        /* This will be either freed by virNetServerDispatchCall or call(),\n         * depending on the calling side, i.e. server or client */\n        val->field = g_strdup(param->field);\n        val->value.type = param->type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            val->value.remote_typed_param_value.i = param->value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            val->value.remote_typed_param_value.ui = param->value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            val->value.remote_typed_param_value.l = param->value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            val->value.remote_typed_param_value.ul = param->value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            val->value.remote_typed_param_value.d = param->value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            val->value.remote_typed_param_value.b = param->value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            val->value.remote_typed_param_value.s = g_strdup(param->value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n        j++;\n    }\n\n    *remote_params_val = params_val;\n    *remote_params_len = params_len;\n    params_val = NULL;\n    rv = 0;\n\n cleanup:\n    virTypedParamsRemoteFree(params_val, nparams);\n    return rv;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsSerialize(virTypedParameterPtr params,\n                        int nparams,\n                        int limit,\n                        virTypedParameterRemotePtr *remote_params_val,\n                        unsigned int *remote_params_len,\n                        unsigned int flags)\n{\n    size_t i;\n    size_t j;\n    int rv = -1;\n    virTypedParameterRemotePtr params_val = NULL;\n    int params_len = nparams;\n\n    if (nparams > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%d' for limit '%d'\"),\n                       nparams, limit);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(params_val, nparams) < 0)\n        goto cleanup;\n\n    for (i = 0, j = 0; i < nparams; ++i) {\n        virTypedParameterPtr param = params + i;\n        virTypedParameterRemotePtr val = params_val + j;\n        /* NOTE: Following snippet is relevant to server only, because\n         * virDomainGetCPUStats can return a sparse array; also, we can't pass\n         * back strings to older clients. */\n        if (!param->type ||\n            (!(flags & VIR_TYPED_PARAM_STRING_OKAY) &&\n             param->type == VIR_TYPED_PARAM_STRING)) {\n            --params_len;\n            continue;\n        }\n\n        /* This will be either freed by virNetServerDispatchCall or call(),\n         * depending on the calling side, i.e. server or client */\n        val->field = g_strdup(param->field);\n        val->value.type = param->type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            val->value.remote_typed_param_value.i = param->value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            val->value.remote_typed_param_value.ui = param->value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            val->value.remote_typed_param_value.l = param->value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            val->value.remote_typed_param_value.ul = param->value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            val->value.remote_typed_param_value.d = param->value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            val->value.remote_typed_param_value.b = param->value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            val->value.remote_typed_param_value.s = g_strdup(param->value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n        j++;\n    }\n\n    *remote_params_val = params_val;\n    *remote_params_len = params_len;\n    params_val = NULL;\n    rv = 0;\n\n cleanup:\n    virTypedParamsRemoteFree(params_val, nparams);\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "adminClientGetInfo",
          "args": [
            "clnt",
            "&params",
            "&nparams",
            "args->flags"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "adminClientGetInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server.c",
          "lines": "200-290",
          "snippet": "int\nadminClientGetInfo(virNetServerClientPtr client,\n                   virTypedParameterPtr *params,\n                   int *nparams,\n                   unsigned int flags)\n{\n    bool readonly;\n    g_autofree char *sock_addr = NULL;\n    const char *attr = NULL;\n    g_autoptr(virTypedParamList) paramlist = g_new0(virTypedParamList, 1);\n    g_autoptr(virIdentity) identity = NULL;\n    int rc;\n\n    virCheckFlags(0, -1);\n\n    if (virNetServerClientGetInfo(client, &readonly,\n                                  &sock_addr, &identity) < 0)\n        return -1;\n\n    if (virTypedParamListAddBoolean(paramlist, readonly,\n                                    \"%s\", VIR_CLIENT_INFO_READONLY) < 0)\n        return -1;\n\n    if ((rc = virIdentityGetSASLUserName(identity, &attr)) < 0)\n        return -1;\n    if (rc == 1 &&\n        virTypedParamListAddString(paramlist, attr,\n                                   \"%s\", VIR_CLIENT_INFO_SASL_USER_NAME) < 0)\n        return -1;\n\n    if (!virNetServerClientIsLocal(client)) {\n        if (virTypedParamListAddString(paramlist, sock_addr,\n                                       \"%s\", VIR_CLIENT_INFO_SOCKET_ADDR) < 0)\n            return -1;\n\n        if ((rc = virIdentityGetX509DName(identity, &attr)) < 0)\n            return -1;\n        if (rc == 1 &&\n            virTypedParamListAddString(paramlist, attr,\n                                       \"%s\", VIR_CLIENT_INFO_X509_DISTINGUISHED_NAME) < 0)\n            return -1;\n    } else {\n        pid_t pid;\n        uid_t uid;\n        gid_t gid;\n        if ((rc = virIdentityGetUNIXUserID(identity, &uid)) < 0)\n            return -1;\n        if (rc == 1 &&\n            virTypedParamListAddInt(paramlist, uid,\n                                    \"%s\", VIR_CLIENT_INFO_UNIX_USER_ID) < 0)\n            return -1;\n\n        if ((rc = virIdentityGetUserName(identity, &attr)) < 0)\n            return -1;\n        if (rc == 1 &&\n            virTypedParamListAddString(paramlist, attr,\n                                       \"%s\", VIR_CLIENT_INFO_UNIX_USER_NAME) < 0)\n            return -1;\n\n        if ((rc = virIdentityGetUNIXGroupID(identity, &gid)) < 0)\n            return -1;\n        if (rc == 1 &&\n            virTypedParamListAddInt(paramlist, gid,\n                                    \"%s\", VIR_CLIENT_INFO_UNIX_GROUP_ID) < 0)\n            return -1;\n\n        if ((rc = virIdentityGetGroupName(identity, &attr)) < 0)\n            return -1;\n        if (rc == 1 &&\n            virTypedParamListAddString(paramlist, attr,\n                                       \"%s\", VIR_CLIENT_INFO_UNIX_GROUP_NAME) < 0)\n            return -1;\n\n        if ((rc = virIdentityGetProcessID(identity, &pid)) < 0)\n            return -1;\n        if (rc == 1 &&\n            virTypedParamListAddInt(paramlist, pid,\n                                    \"%s\", VIR_CLIENT_INFO_UNIX_PROCESS_ID) < 0)\n            return -1;\n    }\n\n    if ((rc = virIdentityGetSELinuxContext(identity, &attr)) < 0)\n        return -1;\n    if (rc == 1 &&\n        virTypedParamListAddString(paramlist, attr,\n                                   \"%s\", VIR_CLIENT_INFO_SELINUX_CONTEXT) < 0)\n        return -1;\n\n    *nparams = virTypedParamListStealParams(paramlist, params);\n    return 0;\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virstring.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virlog.h\"",
            "#include \"viridentity.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"admin_server.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virthreadpool.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"viridentity.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include <config.h>\n\nint\nadminClientGetInfo(virNetServerClientPtr client,\n                   virTypedParameterPtr *params,\n                   int *nparams,\n                   unsigned int flags)\n{\n    bool readonly;\n    g_autofree char *sock_addr = NULL;\n    const char *attr = NULL;\n    g_autoptr(virTypedParamList) paramlist = g_new0(virTypedParamList, 1);\n    g_autoptr(virIdentity) identity = NULL;\n    int rc;\n\n    virCheckFlags(0, -1);\n\n    if (virNetServerClientGetInfo(client, &readonly,\n                                  &sock_addr, &identity) < 0)\n        return -1;\n\n    if (virTypedParamListAddBoolean(paramlist, readonly,\n                                    \"%s\", VIR_CLIENT_INFO_READONLY) < 0)\n        return -1;\n\n    if ((rc = virIdentityGetSASLUserName(identity, &attr)) < 0)\n        return -1;\n    if (rc == 1 &&\n        virTypedParamListAddString(paramlist, attr,\n                                   \"%s\", VIR_CLIENT_INFO_SASL_USER_NAME) < 0)\n        return -1;\n\n    if (!virNetServerClientIsLocal(client)) {\n        if (virTypedParamListAddString(paramlist, sock_addr,\n                                       \"%s\", VIR_CLIENT_INFO_SOCKET_ADDR) < 0)\n            return -1;\n\n        if ((rc = virIdentityGetX509DName(identity, &attr)) < 0)\n            return -1;\n        if (rc == 1 &&\n            virTypedParamListAddString(paramlist, attr,\n                                       \"%s\", VIR_CLIENT_INFO_X509_DISTINGUISHED_NAME) < 0)\n            return -1;\n    } else {\n        pid_t pid;\n        uid_t uid;\n        gid_t gid;\n        if ((rc = virIdentityGetUNIXUserID(identity, &uid)) < 0)\n            return -1;\n        if (rc == 1 &&\n            virTypedParamListAddInt(paramlist, uid,\n                                    \"%s\", VIR_CLIENT_INFO_UNIX_USER_ID) < 0)\n            return -1;\n\n        if ((rc = virIdentityGetUserName(identity, &attr)) < 0)\n            return -1;\n        if (rc == 1 &&\n            virTypedParamListAddString(paramlist, attr,\n                                       \"%s\", VIR_CLIENT_INFO_UNIX_USER_NAME) < 0)\n            return -1;\n\n        if ((rc = virIdentityGetUNIXGroupID(identity, &gid)) < 0)\n            return -1;\n        if (rc == 1 &&\n            virTypedParamListAddInt(paramlist, gid,\n                                    \"%s\", VIR_CLIENT_INFO_UNIX_GROUP_ID) < 0)\n            return -1;\n\n        if ((rc = virIdentityGetGroupName(identity, &attr)) < 0)\n            return -1;\n        if (rc == 1 &&\n            virTypedParamListAddString(paramlist, attr,\n                                       \"%s\", VIR_CLIENT_INFO_UNIX_GROUP_NAME) < 0)\n            return -1;\n\n        if ((rc = virIdentityGetProcessID(identity, &pid)) < 0)\n            return -1;\n        if (rc == 1 &&\n            virTypedParamListAddInt(paramlist, pid,\n                                    \"%s\", VIR_CLIENT_INFO_UNIX_PROCESS_ID) < 0)\n            return -1;\n    }\n\n    if ((rc = virIdentityGetSELinuxContext(identity, &attr)) < 0)\n        return -1;\n    if (rc == 1 &&\n        virTypedParamListAddString(paramlist, attr,\n                                   \"%s\", VIR_CLIENT_INFO_SELINUX_CONTEXT) < 0)\n        return -1;\n\n    *nparams = virTypedParamListStealParams(paramlist, params);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_CLIENT",
            "_(\"no client with matching id '%llu' found\")",
            "(unsigned long long) args->clnt.id"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no client with matching id '%llu' found\""
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerGetClient",
          "args": [
            "srv",
            "args->clnt.id"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerGetClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "1151-1172",
          "snippet": "virNetServerClientPtr\nvirNetServerGetClient(virNetServerPtr srv,\n                      unsigned long long id)\n{\n    size_t i;\n    virNetServerClientPtr ret = NULL;\n\n    virObjectLock(srv);\n\n    for (i = 0; i < srv->nclients; i++) {\n        virNetServerClientPtr client = srv->clients[i];\n        if (virNetServerClientGetID(client) == id)\n            ret = virObjectRef(client);\n    }\n\n    virObjectUnlock(srv);\n\n    if (!ret)\n        virReportError(VIR_ERR_NO_CLIENT,\n                       _(\"No client with matching ID '%llu'\"), id);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nvirNetServerClientPtr\nvirNetServerGetClient(virNetServerPtr srv,\n                      unsigned long long id)\n{\n    size_t i;\n    virNetServerClientPtr ret = NULL;\n\n    virObjectLock(srv);\n\n    for (i = 0; i < srv->nclients; i++) {\n        virNetServerClientPtr client = srv->clients[i];\n        if (virNetServerClientGetID(client) == id)\n            ret = virObjectRef(client);\n    }\n\n    virObjectUnlock(srv);\n\n    if (!ret)\n        virReportError(VIR_ERR_NO_CLIENT,\n                       _(\"No client with matching ID '%llu'\"), id);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SERVER",
            "_(\"no server with matching name '%s' found\")",
            "args->clnt.srv.name"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDaemonGetServer",
          "args": [
            "priv->dmn",
            "args->clnt.srv.name"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonGetServers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "240-264",
          "snippet": "ssize_t\nvirNetDaemonGetServers(virNetDaemonPtr dmn,\n                       virNetServerPtr **servers)\n{\n    struct collectData data = { servers, 0 };\n    ssize_t ret = -1;\n\n    *servers = NULL;\n\n    virObjectLock(dmn);\n\n    if (virHashForEach(dmn->servers, collectServers, &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get all servers from daemon\"));\n        goto cleanup;\n    }\n\n    ret = data.nservers;\n\n cleanup:\n    if (ret < 0)\n        virObjectListFreeCount(*servers, data.nservers);\n    virObjectUnlock(dmn);\n    return ret;\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nssize_t\nvirNetDaemonGetServers(virNetDaemonPtr dmn,\n                       virNetServerPtr **servers)\n{\n    struct collectData data = { servers, 0 };\n    ssize_t ret = -1;\n\n    *servers = NULL;\n\n    virObjectLock(dmn);\n\n    if (virHashForEach(dmn->servers, collectServers, &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get all servers from daemon\"));\n        goto cleanup;\n    }\n\n    ret = data.nservers;\n\n cleanup:\n    if (ret < 0)\n        virObjectListFreeCount(*servers, data.nservers);\n    virObjectUnlock(dmn);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nadminDispatchClientGetInfo(virNetServerPtr server G_GNUC_UNUSED,\n                           virNetServerClientPtr client,\n                           virNetMessagePtr msg G_GNUC_UNUSED,\n                           virNetMessageErrorPtr rerr,\n                           struct admin_client_get_info_args *args,\n                           struct admin_client_get_info_ret *ret)\n{\n    int rv = -1;\n    virNetServerPtr srv = NULL;\n    virNetServerClientPtr clnt = NULL;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    struct daemonAdmClientPrivate *priv =\n        virNetServerClientGetPrivateData(client);\n\n    if (!(srv = virNetDaemonGetServer(priv->dmn, args->clnt.srv.name))) {\n        virReportError(VIR_ERR_NO_SERVER,\n                       _(\"no server with matching name '%s' found\"),\n                       args->clnt.srv.name);\n        goto cleanup;\n    }\n\n    if (!(clnt = virNetServerGetClient(srv, args->clnt.id))) {\n        virReportError(VIR_ERR_NO_CLIENT,\n                       _(\"no client with matching id '%llu' found\"),\n                       (unsigned long long) args->clnt.id);\n        goto cleanup;\n    }\n\n    if (adminClientGetInfo(clnt, &params, &nparams, args->flags) < 0)\n        goto cleanup;\n\n    if (virTypedParamsSerialize(params, nparams,\n                                ADMIN_CLIENT_INFO_PARAMETERS_MAX,\n                                (virTypedParameterRemotePtr *) &ret->params.params_val,\n                                &ret->params.params_len,\n                                VIR_TYPED_PARAM_STRING_OKAY) < 0)\n        goto cleanup;\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n\n    virTypedParamsFree(params, nparams);\n    virObjectUnref(clnt);\n    virObjectUnref(srv);\n    return rv;\n}"
  },
  {
    "function_name": "adminDispatchServerSetThreadpoolParameters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "251-292",
    "snippet": "static int\nadminDispatchServerSetThreadpoolParameters(virNetServerPtr server G_GNUC_UNUSED,\n                                           virNetServerClientPtr client,\n                                           virNetMessagePtr msg G_GNUC_UNUSED,\n                                           virNetMessageErrorPtr rerr,\n                                           struct admin_server_set_threadpool_parameters_args *args)\n{\n    int rv = -1;\n    virNetServerPtr srv = NULL;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    struct daemonAdmClientPrivate *priv =\n        virNetServerClientGetPrivateData(client);\n\n    if (!(srv = virNetDaemonGetServer(priv->dmn, args->srv.name))) {\n        virReportError(VIR_ERR_NO_SERVER,\n                       _(\"no server with matching name '%s' found\"),\n                       args->srv.name);\n        goto cleanup;\n    }\n\n    if (virTypedParamsDeserialize((virTypedParameterRemotePtr) args->params.params_val,\n                                  args->params.params_len,\n                                  ADMIN_SERVER_THREADPOOL_PARAMETERS_MAX,\n                                  &params,\n                                  &nparams) < 0)\n        goto cleanup;\n\n\n    if (adminServerSetThreadPoolParameters(srv, params,\n                                           nparams, args->flags) < 0)\n        goto cleanup;\n\n    rv = 0;\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n\n    virTypedParamsFree(params, nparams);\n    virObjectUnref(srv);\n    return rv;\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "srv"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsFree",
          "args": [
            "params",
            "nparams"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam-public.c",
          "lines": "878-884",
          "snippet": "void\nvirTypedParamsFree(virTypedParameterPtr params,\n                   int nparams)\n{\n    virTypedParamsClear(params, nparams);\n    VIR_FREE(params);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtypedparam.h\"\n#include <config.h>\n\nvoid\nvirTypedParamsFree(virTypedParameterPtr params,\n                   int nparams)\n{\n    virTypedParamsClear(params, nparams);\n    VIR_FREE(params);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "adminServerSetThreadPoolParameters",
          "args": [
            "srv",
            "params",
            "nparams",
            "args->flags"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "adminServerSetThreadPoolParameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server.c",
          "lines": "126-166",
          "snippet": "int\nadminServerSetThreadPoolParameters(virNetServerPtr srv,\n                                   virTypedParameterPtr params,\n                                   int nparams,\n                                   unsigned int flags)\n{\n    long long int minWorkers = -1;\n    long long int maxWorkers = -1;\n    long long int prioWorkers = -1;\n    virTypedParameterPtr param = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (virTypedParamsValidate(params, nparams,\n                               VIR_THREADPOOL_WORKERS_MIN,\n                               VIR_TYPED_PARAM_UINT,\n                               VIR_THREADPOOL_WORKERS_MAX,\n                               VIR_TYPED_PARAM_UINT,\n                               VIR_THREADPOOL_WORKERS_PRIORITY,\n                               VIR_TYPED_PARAM_UINT,\n                               NULL) < 0)\n        return -1;\n\n    if ((param = virTypedParamsGet(params, nparams,\n                                   VIR_THREADPOOL_WORKERS_MIN)))\n        minWorkers = param->value.ui;\n\n    if ((param = virTypedParamsGet(params, nparams,\n                                   VIR_THREADPOOL_WORKERS_MAX)))\n        maxWorkers = param->value.ui;\n\n    if ((param = virTypedParamsGet(params, nparams,\n                                   VIR_THREADPOOL_WORKERS_PRIORITY)))\n        prioWorkers = param->value.ui;\n\n    if (virNetServerSetThreadPoolParameters(srv, minWorkers,\n                                            maxWorkers, prioWorkers) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virstring.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virlog.h\"",
            "#include \"viridentity.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"admin_server.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virthreadpool.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"viridentity.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include <config.h>\n\nint\nadminServerSetThreadPoolParameters(virNetServerPtr srv,\n                                   virTypedParameterPtr params,\n                                   int nparams,\n                                   unsigned int flags)\n{\n    long long int minWorkers = -1;\n    long long int maxWorkers = -1;\n    long long int prioWorkers = -1;\n    virTypedParameterPtr param = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (virTypedParamsValidate(params, nparams,\n                               VIR_THREADPOOL_WORKERS_MIN,\n                               VIR_TYPED_PARAM_UINT,\n                               VIR_THREADPOOL_WORKERS_MAX,\n                               VIR_TYPED_PARAM_UINT,\n                               VIR_THREADPOOL_WORKERS_PRIORITY,\n                               VIR_TYPED_PARAM_UINT,\n                               NULL) < 0)\n        return -1;\n\n    if ((param = virTypedParamsGet(params, nparams,\n                                   VIR_THREADPOOL_WORKERS_MIN)))\n        minWorkers = param->value.ui;\n\n    if ((param = virTypedParamsGet(params, nparams,\n                                   VIR_THREADPOOL_WORKERS_MAX)))\n        maxWorkers = param->value.ui;\n\n    if ((param = virTypedParamsGet(params, nparams,\n                                   VIR_THREADPOOL_WORKERS_PRIORITY)))\n        prioWorkers = param->value.ui;\n\n    if (virNetServerSetThreadPoolParameters(srv, minWorkers,\n                                            maxWorkers, prioWorkers) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsDeserialize",
          "args": [
            "(virTypedParameterRemotePtr) args->params.params_val",
            "args->params.params_len",
            "ADMIN_SERVER_THREADPOOL_PARAMETERS_MAX",
            "&params",
            "&nparams"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsDeserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "527-621",
          "snippet": "int\nvirTypedParamsDeserialize(virTypedParameterRemotePtr remote_params,\n                          unsigned int remote_params_len,\n                          int limit,\n                          virTypedParameterPtr *params,\n                          int *nparams)\n{\n    size_t i = 0;\n    int rv = -1;\n    bool userAllocated = *params != NULL;\n\n    if (limit && remote_params_len > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%u' for limit '%d'\"),\n                       remote_params_len, limit);\n        goto cleanup;\n    }\n\n    if (userAllocated) {\n        /* Check the length of the returned list carefully. */\n        if (remote_params_len > *nparams) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"too many parameters '%u' for nparams '%d'\"),\n                           remote_params_len, *nparams);\n            goto cleanup;\n        }\n    } else {\n        if (VIR_ALLOC_N(*params, remote_params_len) < 0)\n            goto cleanup;\n    }\n    *nparams = remote_params_len;\n\n    /* Deserialize the result. */\n    for (i = 0; i < remote_params_len; ++i) {\n        virTypedParameterPtr param = *params + i;\n        virTypedParameterRemotePtr remote_param = remote_params + i;\n\n        if (virStrcpyStatic(param->field,\n                            remote_param->field) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"parameter %s too big for destination\"),\n                           remote_param->field);\n            goto cleanup;\n        }\n\n        param->type = remote_param->value.type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            param->value.i =\n                remote_param->value.remote_typed_param_value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            param->value.ui =\n                remote_param->value.remote_typed_param_value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            param->value.l =\n                remote_param->value.remote_typed_param_value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            param->value.ul =\n                remote_param->value.remote_typed_param_value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            param->value.d =\n                remote_param->value.remote_typed_param_value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            param->value.b =\n                remote_param->value.remote_typed_param_value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            param->value.s = g_strdup(remote_param->value.remote_typed_param_value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n    }\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0) {\n        if (userAllocated) {\n            virTypedParamsClear(*params, i);\n        } else {\n            virTypedParamsFree(*params, i);\n            *params = NULL;\n            *nparams = 0;\n        }\n    }\n    return rv;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsDeserialize(virTypedParameterRemotePtr remote_params,\n                          unsigned int remote_params_len,\n                          int limit,\n                          virTypedParameterPtr *params,\n                          int *nparams)\n{\n    size_t i = 0;\n    int rv = -1;\n    bool userAllocated = *params != NULL;\n\n    if (limit && remote_params_len > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%u' for limit '%d'\"),\n                       remote_params_len, limit);\n        goto cleanup;\n    }\n\n    if (userAllocated) {\n        /* Check the length of the returned list carefully. */\n        if (remote_params_len > *nparams) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"too many parameters '%u' for nparams '%d'\"),\n                           remote_params_len, *nparams);\n            goto cleanup;\n        }\n    } else {\n        if (VIR_ALLOC_N(*params, remote_params_len) < 0)\n            goto cleanup;\n    }\n    *nparams = remote_params_len;\n\n    /* Deserialize the result. */\n    for (i = 0; i < remote_params_len; ++i) {\n        virTypedParameterPtr param = *params + i;\n        virTypedParameterRemotePtr remote_param = remote_params + i;\n\n        if (virStrcpyStatic(param->field,\n                            remote_param->field) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"parameter %s too big for destination\"),\n                           remote_param->field);\n            goto cleanup;\n        }\n\n        param->type = remote_param->value.type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            param->value.i =\n                remote_param->value.remote_typed_param_value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            param->value.ui =\n                remote_param->value.remote_typed_param_value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            param->value.l =\n                remote_param->value.remote_typed_param_value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            param->value.ul =\n                remote_param->value.remote_typed_param_value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            param->value.d =\n                remote_param->value.remote_typed_param_value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            param->value.b =\n                remote_param->value.remote_typed_param_value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            param->value.s = g_strdup(remote_param->value.remote_typed_param_value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n    }\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0) {\n        if (userAllocated) {\n            virTypedParamsClear(*params, i);\n        } else {\n            virTypedParamsFree(*params, i);\n            *params = NULL;\n            *nparams = 0;\n        }\n    }\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SERVER",
            "_(\"no server with matching name '%s' found\")",
            "args->srv.name"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no server with matching name '%s' found\""
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonGetServer",
          "args": [
            "priv->dmn",
            "args->srv.name"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonGetServers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "240-264",
          "snippet": "ssize_t\nvirNetDaemonGetServers(virNetDaemonPtr dmn,\n                       virNetServerPtr **servers)\n{\n    struct collectData data = { servers, 0 };\n    ssize_t ret = -1;\n\n    *servers = NULL;\n\n    virObjectLock(dmn);\n\n    if (virHashForEach(dmn->servers, collectServers, &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get all servers from daemon\"));\n        goto cleanup;\n    }\n\n    ret = data.nservers;\n\n cleanup:\n    if (ret < 0)\n        virObjectListFreeCount(*servers, data.nservers);\n    virObjectUnlock(dmn);\n    return ret;\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nssize_t\nvirNetDaemonGetServers(virNetDaemonPtr dmn,\n                       virNetServerPtr **servers)\n{\n    struct collectData data = { servers, 0 };\n    ssize_t ret = -1;\n\n    *servers = NULL;\n\n    virObjectLock(dmn);\n\n    if (virHashForEach(dmn->servers, collectServers, &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get all servers from daemon\"));\n        goto cleanup;\n    }\n\n    ret = data.nservers;\n\n cleanup:\n    if (ret < 0)\n        virObjectListFreeCount(*servers, data.nservers);\n    virObjectUnlock(dmn);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nadminDispatchServerSetThreadpoolParameters(virNetServerPtr server G_GNUC_UNUSED,\n                                           virNetServerClientPtr client,\n                                           virNetMessagePtr msg G_GNUC_UNUSED,\n                                           virNetMessageErrorPtr rerr,\n                                           struct admin_server_set_threadpool_parameters_args *args)\n{\n    int rv = -1;\n    virNetServerPtr srv = NULL;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    struct daemonAdmClientPrivate *priv =\n        virNetServerClientGetPrivateData(client);\n\n    if (!(srv = virNetDaemonGetServer(priv->dmn, args->srv.name))) {\n        virReportError(VIR_ERR_NO_SERVER,\n                       _(\"no server with matching name '%s' found\"),\n                       args->srv.name);\n        goto cleanup;\n    }\n\n    if (virTypedParamsDeserialize((virTypedParameterRemotePtr) args->params.params_val,\n                                  args->params.params_len,\n                                  ADMIN_SERVER_THREADPOOL_PARAMETERS_MAX,\n                                  &params,\n                                  &nparams) < 0)\n        goto cleanup;\n\n\n    if (adminServerSetThreadPoolParameters(srv, params,\n                                           nparams, args->flags) < 0)\n        goto cleanup;\n\n    rv = 0;\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n\n    virTypedParamsFree(params, nparams);\n    virObjectUnref(srv);\n    return rv;\n}"
  },
  {
    "function_name": "adminDispatchServerGetThreadpoolParameters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "213-249",
    "snippet": "static int\nadminDispatchServerGetThreadpoolParameters(virNetServerPtr server G_GNUC_UNUSED,\n                                           virNetServerClientPtr client,\n                                           virNetMessagePtr msg G_GNUC_UNUSED,\n                                           virNetMessageErrorPtr rerr,\n                                           struct admin_server_get_threadpool_parameters_args *args,\n                                           struct admin_server_get_threadpool_parameters_ret *ret)\n{\n    int rv = -1;\n    virNetServerPtr srv = NULL;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    struct daemonAdmClientPrivate *priv =\n        virNetServerClientGetPrivateData(client);\n\n    if (!(srv = virNetDaemonGetServer(priv->dmn, args->srv.name)))\n        goto cleanup;\n\n    if (adminServerGetThreadPoolParameters(srv, &params, &nparams,\n                                           args->flags) < 0)\n        goto cleanup;\n\n    if (virTypedParamsSerialize(params, nparams,\n                                ADMIN_SERVER_THREADPOOL_PARAMETERS_MAX,\n                                (virTypedParameterRemotePtr *) &ret->params.params_val,\n                                &ret->params.params_len, 0) < 0)\n        goto cleanup;\n\n    rv = 0;\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n\n    virTypedParamsFree(params, nparams);\n    virObjectUnref(srv);\n    return rv;\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "srv"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsFree",
          "args": [
            "params",
            "nparams"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam-public.c",
          "lines": "878-884",
          "snippet": "void\nvirTypedParamsFree(virTypedParameterPtr params,\n                   int nparams)\n{\n    virTypedParamsClear(params, nparams);\n    VIR_FREE(params);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtypedparam.h\"\n#include <config.h>\n\nvoid\nvirTypedParamsFree(virTypedParameterPtr params,\n                   int nparams)\n{\n    virTypedParamsClear(params, nparams);\n    VIR_FREE(params);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsSerialize",
          "args": [
            "params",
            "nparams",
            "ADMIN_SERVER_THREADPOOL_PARAMETERS_MAX",
            "(virTypedParameterRemotePtr *) &ret->params.params_val",
            "&ret->params.params_len",
            "0"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsSerialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "644-723",
          "snippet": "int\nvirTypedParamsSerialize(virTypedParameterPtr params,\n                        int nparams,\n                        int limit,\n                        virTypedParameterRemotePtr *remote_params_val,\n                        unsigned int *remote_params_len,\n                        unsigned int flags)\n{\n    size_t i;\n    size_t j;\n    int rv = -1;\n    virTypedParameterRemotePtr params_val = NULL;\n    int params_len = nparams;\n\n    if (nparams > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%d' for limit '%d'\"),\n                       nparams, limit);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(params_val, nparams) < 0)\n        goto cleanup;\n\n    for (i = 0, j = 0; i < nparams; ++i) {\n        virTypedParameterPtr param = params + i;\n        virTypedParameterRemotePtr val = params_val + j;\n        /* NOTE: Following snippet is relevant to server only, because\n         * virDomainGetCPUStats can return a sparse array; also, we can't pass\n         * back strings to older clients. */\n        if (!param->type ||\n            (!(flags & VIR_TYPED_PARAM_STRING_OKAY) &&\n             param->type == VIR_TYPED_PARAM_STRING)) {\n            --params_len;\n            continue;\n        }\n\n        /* This will be either freed by virNetServerDispatchCall or call(),\n         * depending on the calling side, i.e. server or client */\n        val->field = g_strdup(param->field);\n        val->value.type = param->type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            val->value.remote_typed_param_value.i = param->value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            val->value.remote_typed_param_value.ui = param->value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            val->value.remote_typed_param_value.l = param->value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            val->value.remote_typed_param_value.ul = param->value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            val->value.remote_typed_param_value.d = param->value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            val->value.remote_typed_param_value.b = param->value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            val->value.remote_typed_param_value.s = g_strdup(param->value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n        j++;\n    }\n\n    *remote_params_val = params_val;\n    *remote_params_len = params_len;\n    params_val = NULL;\n    rv = 0;\n\n cleanup:\n    virTypedParamsRemoteFree(params_val, nparams);\n    return rv;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsSerialize(virTypedParameterPtr params,\n                        int nparams,\n                        int limit,\n                        virTypedParameterRemotePtr *remote_params_val,\n                        unsigned int *remote_params_len,\n                        unsigned int flags)\n{\n    size_t i;\n    size_t j;\n    int rv = -1;\n    virTypedParameterRemotePtr params_val = NULL;\n    int params_len = nparams;\n\n    if (nparams > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%d' for limit '%d'\"),\n                       nparams, limit);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(params_val, nparams) < 0)\n        goto cleanup;\n\n    for (i = 0, j = 0; i < nparams; ++i) {\n        virTypedParameterPtr param = params + i;\n        virTypedParameterRemotePtr val = params_val + j;\n        /* NOTE: Following snippet is relevant to server only, because\n         * virDomainGetCPUStats can return a sparse array; also, we can't pass\n         * back strings to older clients. */\n        if (!param->type ||\n            (!(flags & VIR_TYPED_PARAM_STRING_OKAY) &&\n             param->type == VIR_TYPED_PARAM_STRING)) {\n            --params_len;\n            continue;\n        }\n\n        /* This will be either freed by virNetServerDispatchCall or call(),\n         * depending on the calling side, i.e. server or client */\n        val->field = g_strdup(param->field);\n        val->value.type = param->type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            val->value.remote_typed_param_value.i = param->value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            val->value.remote_typed_param_value.ui = param->value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            val->value.remote_typed_param_value.l = param->value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            val->value.remote_typed_param_value.ul = param->value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            val->value.remote_typed_param_value.d = param->value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            val->value.remote_typed_param_value.b = param->value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            val->value.remote_typed_param_value.s = g_strdup(param->value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n        j++;\n    }\n\n    *remote_params_val = params_val;\n    *remote_params_len = params_len;\n    params_val = NULL;\n    rv = 0;\n\n cleanup:\n    virTypedParamsRemoteFree(params_val, nparams);\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "adminServerGetThreadPoolParameters",
          "args": [
            "srv",
            "&params",
            "&nparams",
            "args->flags"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "adminServerGetThreadPoolParameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server.c",
          "lines": "72-124",
          "snippet": "int\nadminServerGetThreadPoolParameters(virNetServerPtr srv,\n                                   virTypedParameterPtr *params,\n                                   int *nparams,\n                                   unsigned int flags)\n{\n    size_t minWorkers;\n    size_t maxWorkers;\n    size_t nWorkers;\n    size_t freeWorkers;\n    size_t nPrioWorkers;\n    size_t jobQueueDepth;\n    g_autoptr(virTypedParamList) paramlist = g_new0(virTypedParamList, 1);\n\n    virCheckFlags(0, -1);\n\n    if (virNetServerGetThreadPoolParameters(srv, &minWorkers, &maxWorkers,\n                                            &nWorkers, &freeWorkers,\n                                            &nPrioWorkers,\n                                            &jobQueueDepth) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to retrieve threadpool parameters\"));\n        return -1;\n    }\n\n    if (virTypedParamListAddUInt(paramlist, minWorkers,\n                                 \"%s\", VIR_THREADPOOL_WORKERS_MIN) < 0)\n        return -1;\n\n    if (virTypedParamListAddUInt(paramlist, maxWorkers,\n                                 \"%s\", VIR_THREADPOOL_WORKERS_MAX) < 0)\n        return -1;\n\n    if (virTypedParamListAddUInt(paramlist, nWorkers,\n                                 \"%s\", VIR_THREADPOOL_WORKERS_CURRENT) < 0)\n        return -1;\n\n    if (virTypedParamListAddUInt(paramlist, freeWorkers,\n                                 \"%s\", VIR_THREADPOOL_WORKERS_FREE) < 0)\n        return -1;\n\n    if (virTypedParamListAddUInt(paramlist, nPrioWorkers,\n                                 \"%s\", VIR_THREADPOOL_WORKERS_PRIORITY) < 0)\n        return -1;\n\n    if (virTypedParamListAddUInt(paramlist, jobQueueDepth,\n                                 \"%s\", VIR_THREADPOOL_JOB_QUEUE_DEPTH) < 0)\n        return -1;\n\n    *nparams = virTypedParamListStealParams(paramlist, params);\n\n    return 0;\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virstring.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virlog.h\"",
            "#include \"viridentity.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"admin_server.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virthreadpool.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"viridentity.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include <config.h>\n\nint\nadminServerGetThreadPoolParameters(virNetServerPtr srv,\n                                   virTypedParameterPtr *params,\n                                   int *nparams,\n                                   unsigned int flags)\n{\n    size_t minWorkers;\n    size_t maxWorkers;\n    size_t nWorkers;\n    size_t freeWorkers;\n    size_t nPrioWorkers;\n    size_t jobQueueDepth;\n    g_autoptr(virTypedParamList) paramlist = g_new0(virTypedParamList, 1);\n\n    virCheckFlags(0, -1);\n\n    if (virNetServerGetThreadPoolParameters(srv, &minWorkers, &maxWorkers,\n                                            &nWorkers, &freeWorkers,\n                                            &nPrioWorkers,\n                                            &jobQueueDepth) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to retrieve threadpool parameters\"));\n        return -1;\n    }\n\n    if (virTypedParamListAddUInt(paramlist, minWorkers,\n                                 \"%s\", VIR_THREADPOOL_WORKERS_MIN) < 0)\n        return -1;\n\n    if (virTypedParamListAddUInt(paramlist, maxWorkers,\n                                 \"%s\", VIR_THREADPOOL_WORKERS_MAX) < 0)\n        return -1;\n\n    if (virTypedParamListAddUInt(paramlist, nWorkers,\n                                 \"%s\", VIR_THREADPOOL_WORKERS_CURRENT) < 0)\n        return -1;\n\n    if (virTypedParamListAddUInt(paramlist, freeWorkers,\n                                 \"%s\", VIR_THREADPOOL_WORKERS_FREE) < 0)\n        return -1;\n\n    if (virTypedParamListAddUInt(paramlist, nPrioWorkers,\n                                 \"%s\", VIR_THREADPOOL_WORKERS_PRIORITY) < 0)\n        return -1;\n\n    if (virTypedParamListAddUInt(paramlist, jobQueueDepth,\n                                 \"%s\", VIR_THREADPOOL_JOB_QUEUE_DEPTH) < 0)\n        return -1;\n\n    *nparams = virTypedParamListStealParams(paramlist, params);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonGetServer",
          "args": [
            "priv->dmn",
            "args->srv.name"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonGetServers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "240-264",
          "snippet": "ssize_t\nvirNetDaemonGetServers(virNetDaemonPtr dmn,\n                       virNetServerPtr **servers)\n{\n    struct collectData data = { servers, 0 };\n    ssize_t ret = -1;\n\n    *servers = NULL;\n\n    virObjectLock(dmn);\n\n    if (virHashForEach(dmn->servers, collectServers, &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get all servers from daemon\"));\n        goto cleanup;\n    }\n\n    ret = data.nservers;\n\n cleanup:\n    if (ret < 0)\n        virObjectListFreeCount(*servers, data.nservers);\n    virObjectUnlock(dmn);\n    return ret;\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nssize_t\nvirNetDaemonGetServers(virNetDaemonPtr dmn,\n                       virNetServerPtr **servers)\n{\n    struct collectData data = { servers, 0 };\n    ssize_t ret = -1;\n\n    *servers = NULL;\n\n    virObjectLock(dmn);\n\n    if (virHashForEach(dmn->servers, collectServers, &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get all servers from daemon\"));\n        goto cleanup;\n    }\n\n    ret = data.nservers;\n\n cleanup:\n    if (ret < 0)\n        virObjectListFreeCount(*servers, data.nservers);\n    virObjectUnlock(dmn);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nadminDispatchServerGetThreadpoolParameters(virNetServerPtr server G_GNUC_UNUSED,\n                                           virNetServerClientPtr client,\n                                           virNetMessagePtr msg G_GNUC_UNUSED,\n                                           virNetMessageErrorPtr rerr,\n                                           struct admin_server_get_threadpool_parameters_args *args,\n                                           struct admin_server_get_threadpool_parameters_ret *ret)\n{\n    int rv = -1;\n    virNetServerPtr srv = NULL;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    struct daemonAdmClientPrivate *priv =\n        virNetServerClientGetPrivateData(client);\n\n    if (!(srv = virNetDaemonGetServer(priv->dmn, args->srv.name)))\n        goto cleanup;\n\n    if (adminServerGetThreadPoolParameters(srv, &params, &nparams,\n                                           args->flags) < 0)\n        goto cleanup;\n\n    if (virTypedParamsSerialize(params, nparams,\n                                ADMIN_SERVER_THREADPOOL_PARAMETERS_MAX,\n                                (virTypedParameterRemotePtr *) &ret->params.params_val,\n                                &ret->params.params_len, 0) < 0)\n        goto cleanup;\n\n    rv = 0;\n cleanup:\n    if (rv < 0)\n        virNetMessageSaveError(rerr);\n\n    virTypedParamsFree(params, nparams);\n    virObjectUnref(srv);\n    return rv;\n}"
  },
  {
    "function_name": "adminGetConn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "204-211",
    "snippet": "static virNetDaemonPtr\nadminGetConn(virNetServerClientPtr client)\n{\n    struct daemonAdmClientPrivate *priv =\n        virNetServerClientGetPrivateData(client);\n\n    return priv->dmn;\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virNetDaemonPtr\nadminGetConn(virNetServerClientPtr client)\n{\n    struct daemonAdmClientPrivate *priv =\n        virNetServerClientGetPrivateData(client);\n\n    return priv->dmn;\n}"
  },
  {
    "function_name": "adminConnectGetLibVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "195-202",
    "snippet": "static int\nadminConnectGetLibVersion(virNetDaemonPtr dmn G_GNUC_UNUSED,\n                          unsigned long long *libVer)\n{\n    if (libVer)\n        *libVer = LIBVIR_VERSION_NUMBER;\n    return 0;\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nadminConnectGetLibVersion(virNetDaemonPtr dmn G_GNUC_UNUSED,\n                          unsigned long long *libVer)\n{\n    if (libVer)\n        *libVer = LIBVIR_VERSION_NUMBER;\n    return 0;\n}"
  },
  {
    "function_name": "adminDispatchConnectClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "185-193",
    "snippet": "static int\nadminDispatchConnectClose(virNetServerPtr server G_GNUC_UNUSED,\n                          virNetServerClientPtr client,\n                          virNetMessagePtr msg G_GNUC_UNUSED,\n                          virNetMessageErrorPtr rerr G_GNUC_UNUSED)\n{\n    virNetServerClientDelayedClose(client);\n    return 0;\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerClientDelayedClose",
          "args": [
            "client"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientDelayedClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1076-1081",
          "snippet": "void virNetServerClientDelayedClose(virNetServerClientPtr client)\n{\n    virObjectLock(client);\n    client->delayedClose = true;\n    virObjectUnlock(client);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid virNetServerClientDelayedClose(virNetServerClientPtr client)\n{\n    virObjectLock(client);\n    client->delayedClose = true;\n    virObjectUnlock(client);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nadminDispatchConnectClose(virNetServerPtr server G_GNUC_UNUSED,\n                          virNetServerClientPtr client,\n                          virNetMessagePtr msg G_GNUC_UNUSED,\n                          virNetMessageErrorPtr rerr G_GNUC_UNUSED)\n{\n    virNetServerClientDelayedClose(client);\n    return 0;\n}"
  },
  {
    "function_name": "adminDispatchConnectOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "159-183",
    "snippet": "static int\nadminDispatchConnectOpen(virNetServerPtr server G_GNUC_UNUSED,\n                         virNetServerClientPtr client,\n                         virNetMessagePtr msg G_GNUC_UNUSED,\n                         virNetMessageErrorPtr rerr,\n                         struct admin_connect_open_args *args)\n{\n    unsigned int flags;\n    struct daemonAdmClientPrivate *priv =\n        virNetServerClientGetPrivateData(client);\n    int ret = -1;\n\n    VIR_DEBUG(\"priv=%p dmn=%p\", priv, priv->dmn);\n    virMutexLock(&priv->lock);\n\n    flags = args->flags;\n    virCheckFlagsGoto(0, cleanup);\n\n    ret = 0;\n cleanup:\n    if (ret < 0)\n        virNetMessageSaveError(rerr);\n    virMutexUnlock(&priv->lock);\n    return ret;\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&priv->lock"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlagsGoto",
          "args": [
            "0",
            "cleanup"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&priv->lock"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"priv=%p dmn=%p\"",
            "priv",
            "priv->dmn"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nadminDispatchConnectOpen(virNetServerPtr server G_GNUC_UNUSED,\n                         virNetServerClientPtr client,\n                         virNetMessagePtr msg G_GNUC_UNUSED,\n                         virNetMessageErrorPtr rerr,\n                         struct admin_connect_open_args *args)\n{\n    unsigned int flags;\n    struct daemonAdmClientPrivate *priv =\n        virNetServerClientGetPrivateData(client);\n    int ret = -1;\n\n    VIR_DEBUG(\"priv=%p dmn=%p\", priv, priv->dmn);\n    virMutexLock(&priv->lock);\n\n    flags = args->flags;\n    virCheckFlagsGoto(0, cleanup);\n\n    ret = 0;\n cleanup:\n    if (ret < 0)\n        virNetMessageSaveError(rerr);\n    virMutexUnlock(&priv->lock);\n    return ret;\n}"
  },
  {
    "function_name": "make_nonnull_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "149-156",
    "snippet": "static void\nmake_nonnull_client(admin_nonnull_client *clt_dst,\n                    virNetServerClientPtr clt_src)\n{\n    clt_dst->id = virNetServerClientGetID(clt_src);\n    clt_dst->timestamp = virNetServerClientGetTimestamp(clt_src);\n    clt_dst->transport = virNetServerClientGetTransport(clt_src);\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerClientGetTransport",
          "args": [
            "clt_src"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetTransport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1632-1650",
          "snippet": "int\nvirNetServerClientGetTransport(virNetServerClientPtr client)\n{\n    int ret = -1;\n\n    virObjectLock(client);\n\n    if (client->sock && virNetSocketIsLocal(client->sock))\n        ret = VIR_CLIENT_TRANS_UNIX;\n    else\n        ret = VIR_CLIENT_TRANS_TCP;\n\n    if (client->tls)\n        ret = VIR_CLIENT_TRANS_TLS;\n\n    virObjectUnlock(client);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nint\nvirNetServerClientGetTransport(virNetServerClientPtr client)\n{\n    int ret = -1;\n\n    virObjectLock(client);\n\n    if (client->sock && virNetSocketIsLocal(client->sock))\n        ret = VIR_CLIENT_TRANS_UNIX;\n    else\n        ret = VIR_CLIENT_TRANS_TCP;\n\n    if (client->tls)\n        ret = VIR_CLIENT_TRANS_TLS;\n\n    virObjectUnlock(client);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetTimestamp",
          "args": [
            "clt_src"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "685-688",
          "snippet": "long long virNetServerClientGetTimestamp(virNetServerClientPtr client)\n{\n    return client->conn_time;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nlong long virNetServerClientGetTimestamp(virNetServerClientPtr client)\n{\n    return client->conn_time;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetID",
          "args": [
            "clt_src"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "680-683",
          "snippet": "unsigned long long virNetServerClientGetID(virNetServerClientPtr client)\n{\n    return client->id;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nunsigned long long virNetServerClientGetID(virNetServerClientPtr client)\n{\n    return client->id;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nmake_nonnull_client(admin_nonnull_client *clt_dst,\n                    virNetServerClientPtr clt_src)\n{\n    clt_dst->id = virNetServerClientGetID(clt_src);\n    clt_dst->timestamp = virNetServerClientGetTimestamp(clt_src);\n    clt_dst->transport = virNetServerClientGetTransport(clt_src);\n}"
  },
  {
    "function_name": "get_nonnull_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "143-147",
    "snippet": "static virNetServerClientPtr\nget_nonnull_client(virNetServerPtr srv, admin_nonnull_client clnt)\n{\n    return virNetServerGetClient(srv, clnt.id);\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerGetClient",
          "args": [
            "srv",
            "clnt.id"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerGetClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "1151-1172",
          "snippet": "virNetServerClientPtr\nvirNetServerGetClient(virNetServerPtr srv,\n                      unsigned long long id)\n{\n    size_t i;\n    virNetServerClientPtr ret = NULL;\n\n    virObjectLock(srv);\n\n    for (i = 0; i < srv->nclients; i++) {\n        virNetServerClientPtr client = srv->clients[i];\n        if (virNetServerClientGetID(client) == id)\n            ret = virObjectRef(client);\n    }\n\n    virObjectUnlock(srv);\n\n    if (!ret)\n        virReportError(VIR_ERR_NO_CLIENT,\n                       _(\"No client with matching ID '%llu'\"), id);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nvirNetServerClientPtr\nvirNetServerGetClient(virNetServerPtr srv,\n                      unsigned long long id)\n{\n    size_t i;\n    virNetServerClientPtr ret = NULL;\n\n    virObjectLock(srv);\n\n    for (i = 0; i < srv->nclients; i++) {\n        virNetServerClientPtr client = srv->clients[i];\n        if (virNetServerClientGetID(client) == id)\n            ret = virObjectRef(client);\n    }\n\n    virObjectUnlock(srv);\n\n    if (!ret)\n        virReportError(VIR_ERR_NO_CLIENT,\n                       _(\"No client with matching ID '%llu'\"), id);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virNetServerClientPtr\nget_nonnull_client(virNetServerPtr srv, admin_nonnull_client clnt)\n{\n    return virNetServerGetClient(srv, clnt.id);\n}"
  },
  {
    "function_name": "make_nonnull_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "136-141",
    "snippet": "static void\nmake_nonnull_server(admin_nonnull_server *srv_dst,\n                    virNetServerPtr srv_src)\n{\n    srv_dst->name = g_strdup(virNetServerGetName(srv_src));\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "virNetServerGetName(srv_src)"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerGetName",
          "args": [
            "srv_src"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerGetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "1013-1017",
          "snippet": "const char *\nvirNetServerGetName(virNetServerPtr srv)\n{\n    return srv->name;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nconst char *\nvirNetServerGetName(virNetServerPtr srv)\n{\n    return srv->name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nmake_nonnull_server(admin_nonnull_server *srv_dst,\n                    virNetServerPtr srv_src)\n{\n    srv_dst->name = g_strdup(virNetServerGetName(srv_src));\n}"
  },
  {
    "function_name": "get_nonnull_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "130-134",
    "snippet": "static virNetServerPtr\nget_nonnull_server(virNetDaemonPtr dmn, admin_nonnull_server srv)\n{\n    return virNetDaemonGetServer(dmn, srv.name);\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDaemonGetServer",
          "args": [
            "dmn",
            "srv.name"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonGetServers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "240-264",
          "snippet": "ssize_t\nvirNetDaemonGetServers(virNetDaemonPtr dmn,\n                       virNetServerPtr **servers)\n{\n    struct collectData data = { servers, 0 };\n    ssize_t ret = -1;\n\n    *servers = NULL;\n\n    virObjectLock(dmn);\n\n    if (virHashForEach(dmn->servers, collectServers, &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get all servers from daemon\"));\n        goto cleanup;\n    }\n\n    ret = data.nservers;\n\n cleanup:\n    if (ret < 0)\n        virObjectListFreeCount(*servers, data.nservers);\n    virObjectUnlock(dmn);\n    return ret;\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nssize_t\nvirNetDaemonGetServers(virNetDaemonPtr dmn,\n                       virNetServerPtr **servers)\n{\n    struct collectData data = { servers, 0 };\n    ssize_t ret = -1;\n\n    *servers = NULL;\n\n    virObjectLock(dmn);\n\n    if (virHashForEach(dmn->servers, collectServers, &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get all servers from daemon\"));\n        goto cleanup;\n    }\n\n    ret = data.nservers;\n\n cleanup:\n    if (ret < 0)\n        virObjectListFreeCount(*servers, data.nservers);\n    virObjectUnlock(dmn);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virNetServerPtr\nget_nonnull_server(virNetDaemonPtr dmn, admin_nonnull_server srv)\n{\n    return virNetDaemonGetServer(dmn, srv.name);\n}"
  },
  {
    "function_name": "remoteAdmClientPreExecRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "117-125",
    "snippet": "virJSONValuePtr remoteAdmClientPreExecRestart(virNetServerClientPtr client G_GNUC_UNUSED,\n                                              void *data G_GNUC_UNUSED)\n{\n    virJSONValuePtr object = virJSONValueNewObject();\n\n    /* No content to add at this time - just need empty object */\n\n    return object;\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueNewObject",
          "args": [],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "571-579",
          "snippet": "virJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirJSONValuePtr remoteAdmClientPreExecRestart(virNetServerClientPtr client G_GNUC_UNUSED,\n                                              void *data G_GNUC_UNUSED)\n{\n    virJSONValuePtr object = virJSONValueNewObject();\n\n    /* No content to add at this time - just need empty object */\n\n    return object;\n}"
  },
  {
    "function_name": "remoteAdmClientNewPostExecRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "110-115",
    "snippet": "void *remoteAdmClientNewPostExecRestart(virNetServerClientPtr client,\n                                        virJSONValuePtr object G_GNUC_UNUSED,\n                                        void *opaque)\n{\n    return remoteAdmClientNew(client, opaque);\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remoteAdmClientNew",
          "args": [
            "client",
            "opaque"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "remoteAdmClientNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
          "lines": "63-108",
          "snippet": "void *\nremoteAdmClientNew(virNetServerClientPtr client G_GNUC_UNUSED,\n                   void *opaque)\n{\n    struct daemonAdmClientPrivate *priv;\n    uid_t clientuid;\n    gid_t clientgid;\n    pid_t clientpid;\n    unsigned long long timestamp;\n\n    if (virNetServerClientGetUNIXIdentity(client,\n                                          &clientuid,\n                                          &clientgid,\n                                          &clientpid,\n                                          &timestamp) < 0)\n        return NULL;\n\n    VIR_DEBUG(\"New client pid %lld uid %lld\",\n              (long long)clientpid,\n              (long long)clientuid);\n\n    if (geteuid() != clientuid) {\n        virReportRestrictedError(_(\"Disallowing client %lld with uid %lld\"),\n                                 (long long)clientpid,\n                                 (long long)clientuid);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(priv) < 0)\n        return NULL;\n\n    if (virMutexInit(&priv->lock) < 0) {\n        VIR_FREE(priv);\n        virReportSystemError(errno, \"%s\", _(\"unable to init mutex\"));\n        return NULL;\n    }\n\n    /*\n     * We don't necessarily need to ref this object right now as there\n     * must be one ref being held throughout the life of the daemon,\n     * but let's just be safe for future.\n     */\n    priv->dmn = virObjectRef(opaque);\n\n    return priv;\n}",
          "includes": [
            "#include \"admin_server_dispatch_stubs.h\"",
            "#include \"virutil.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"admin_server.h\"",
            "#include \"admin_server_dispatch.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid *\nremoteAdmClientNew(virNetServerClientPtr client G_GNUC_UNUSED,\n                   void *opaque)\n{\n    struct daemonAdmClientPrivate *priv;\n    uid_t clientuid;\n    gid_t clientgid;\n    pid_t clientpid;\n    unsigned long long timestamp;\n\n    if (virNetServerClientGetUNIXIdentity(client,\n                                          &clientuid,\n                                          &clientgid,\n                                          &clientpid,\n                                          &timestamp) < 0)\n        return NULL;\n\n    VIR_DEBUG(\"New client pid %lld uid %lld\",\n              (long long)clientpid,\n              (long long)clientuid);\n\n    if (geteuid() != clientuid) {\n        virReportRestrictedError(_(\"Disallowing client %lld with uid %lld\"),\n                                 (long long)clientpid,\n                                 (long long)clientuid);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(priv) < 0)\n        return NULL;\n\n    if (virMutexInit(&priv->lock) < 0) {\n        VIR_FREE(priv);\n        virReportSystemError(errno, \"%s\", _(\"unable to init mutex\"));\n        return NULL;\n    }\n\n    /*\n     * We don't necessarily need to ref this object right now as there\n     * must be one ref being held throughout the life of the daemon,\n     * but let's just be safe for future.\n     */\n    priv->dmn = virObjectRef(opaque);\n\n    return priv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid *remoteAdmClientNewPostExecRestart(virNetServerClientPtr client,\n                                        virJSONValuePtr object G_GNUC_UNUSED,\n                                        void *opaque)\n{\n    return remoteAdmClientNew(client, opaque);\n}"
  },
  {
    "function_name": "remoteAdmClientNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "63-108",
    "snippet": "void *\nremoteAdmClientNew(virNetServerClientPtr client G_GNUC_UNUSED,\n                   void *opaque)\n{\n    struct daemonAdmClientPrivate *priv;\n    uid_t clientuid;\n    gid_t clientgid;\n    pid_t clientpid;\n    unsigned long long timestamp;\n\n    if (virNetServerClientGetUNIXIdentity(client,\n                                          &clientuid,\n                                          &clientgid,\n                                          &clientpid,\n                                          &timestamp) < 0)\n        return NULL;\n\n    VIR_DEBUG(\"New client pid %lld uid %lld\",\n              (long long)clientpid,\n              (long long)clientuid);\n\n    if (geteuid() != clientuid) {\n        virReportRestrictedError(_(\"Disallowing client %lld with uid %lld\"),\n                                 (long long)clientpid,\n                                 (long long)clientuid);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(priv) < 0)\n        return NULL;\n\n    if (virMutexInit(&priv->lock) < 0) {\n        VIR_FREE(priv);\n        virReportSystemError(errno, \"%s\", _(\"unable to init mutex\"));\n        return NULL;\n    }\n\n    /*\n     * We don't necessarily need to ref this object right now as there\n     * must be one ref being held throughout the life of the daemon,\n     * but let's just be safe for future.\n     */\n    priv->dmn = virObjectRef(opaque);\n\n    return priv;\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "opaque"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"unable to init mutex\")"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to init mutex\""
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexInit",
          "args": [
            "&priv->lock"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexInitRecursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "61-74",
          "snippet": "int virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "priv"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportRestrictedError",
          "args": [
            "_(\"Disallowing client %lld with uid %lld\")",
            "(long long)clientpid",
            "(long long)clientuid"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"New client pid %lld uid %lld\"",
            "(long long)clientpid",
            "(long long)clientuid"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetUNIXIdentity",
          "args": [
            "client",
            "&clientuid",
            "&clientgid",
            "&clientpid",
            "&timestamp"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetUNIXIdentity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "741-753",
          "snippet": "int virNetServerClientGetUNIXIdentity(virNetServerClientPtr client,\n                                      uid_t *uid, gid_t *gid, pid_t *pid,\n                                      unsigned long long *timestamp)\n{\n    int ret = -1;\n    virObjectLock(client);\n    if (client->sock)\n        ret = virNetSocketGetUNIXIdentity(client->sock,\n                                          uid, gid, pid,\n                                          timestamp);\n    virObjectUnlock(client);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nint virNetServerClientGetUNIXIdentity(virNetServerClientPtr client,\n                                      uid_t *uid, gid_t *gid, pid_t *pid,\n                                      unsigned long long *timestamp)\n{\n    int ret = -1;\n    virObjectLock(client);\n    if (client->sock)\n        ret = virNetSocketGetUNIXIdentity(client->sock,\n                                          uid, gid, pid,\n                                          timestamp);\n    virObjectUnlock(client);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid *\nremoteAdmClientNew(virNetServerClientPtr client G_GNUC_UNUSED,\n                   void *opaque)\n{\n    struct daemonAdmClientPrivate *priv;\n    uid_t clientuid;\n    gid_t clientgid;\n    pid_t clientpid;\n    unsigned long long timestamp;\n\n    if (virNetServerClientGetUNIXIdentity(client,\n                                          &clientuid,\n                                          &clientgid,\n                                          &clientpid,\n                                          &timestamp) < 0)\n        return NULL;\n\n    VIR_DEBUG(\"New client pid %lld uid %lld\",\n              (long long)clientpid,\n              (long long)clientuid);\n\n    if (geteuid() != clientuid) {\n        virReportRestrictedError(_(\"Disallowing client %lld with uid %lld\"),\n                                 (long long)clientpid,\n                                 (long long)clientuid);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(priv) < 0)\n        return NULL;\n\n    if (virMutexInit(&priv->lock) < 0) {\n        VIR_FREE(priv);\n        virReportSystemError(errno, \"%s\", _(\"unable to init mutex\"));\n        return NULL;\n    }\n\n    /*\n     * We don't necessarily need to ref this object right now as there\n     * must be one ref being held throughout the life of the daemon,\n     * but let's just be safe for future.\n     */\n    priv->dmn = virObjectRef(opaque);\n\n    return priv;\n}"
  },
  {
    "function_name": "remoteAdmClientFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_server_dispatch.c",
    "lines": "53-61",
    "snippet": "void\nremoteAdmClientFree(void *data)\n{\n    struct daemonAdmClientPrivate *priv = data;\n\n    virMutexDestroy(&priv->lock);\n    virObjectUnref(priv->dmn);\n    VIR_FREE(priv);\n}",
    "includes": [
      "#include \"admin_server_dispatch_stubs.h\"",
      "#include \"virutil.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virthreadjob.h\"",
      "#include \"virstring.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"admin_server.h\"",
      "#include \"admin_server_dispatch.h\"",
      "#include \"libvirt_internal.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "priv->dmn"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexDestroy",
          "args": [
            "&priv->lock"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "76-79",
          "snippet": "void virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_server_dispatch_stubs.h\"\n#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"admin_server.h\"\n#include \"admin_server_dispatch.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nremoteAdmClientFree(void *data)\n{\n    struct daemonAdmClientPrivate *priv = data;\n\n    virMutexDestroy(&priv->lock);\n    virObjectUnref(priv->dmn);\n    VIR_FREE(priv);\n}"
  }
]