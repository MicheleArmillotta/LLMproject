[
  {
    "function_name": "virNWFilterRuleIsProtocolEthernet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "3143-3149",
    "snippet": "bool\nvirNWFilterRuleIsProtocolEthernet(virNWFilterRuleDefPtr rule)\n{\n    if (rule->prtclType <= VIR_NWFILTER_RULE_PROTOCOL_IPV6)\n        return true;\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirNWFilterRuleIsProtocolEthernet(virNWFilterRuleDefPtr rule)\n{\n    if (rule->prtclType <= VIR_NWFILTER_RULE_PROTOCOL_IPV6)\n        return true;\n    return false;\n}"
  },
  {
    "function_name": "virNWFilterRuleIsProtocolIPv6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "3133-3140",
    "snippet": "bool\nvirNWFilterRuleIsProtocolIPv6(virNWFilterRuleDefPtr rule)\n{\n    if (rule->prtclType >= VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6 &&\n        rule->prtclType <= VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6)\n        return true;\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirNWFilterRuleIsProtocolIPv6(virNWFilterRuleDefPtr rule)\n{\n    if (rule->prtclType >= VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6 &&\n        rule->prtclType <= VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6)\n        return true;\n    return false;\n}"
  },
  {
    "function_name": "virNWFilterRuleIsProtocolIPv4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "3123-3130",
    "snippet": "bool\nvirNWFilterRuleIsProtocolIPv4(virNWFilterRuleDefPtr rule)\n{\n    if (rule->prtclType >= VIR_NWFILTER_RULE_PROTOCOL_TCP &&\n        rule->prtclType <= VIR_NWFILTER_RULE_PROTOCOL_ALL)\n        return true;\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirNWFilterRuleIsProtocolIPv4(virNWFilterRuleDefPtr rule)\n{\n    if (rule->prtclType >= VIR_NWFILTER_RULE_PROTOCOL_TCP &&\n        rule->prtclType <= VIR_NWFILTER_RULE_PROTOCOL_ALL)\n        return true;\n    return false;\n}"
  },
  {
    "function_name": "virNWFilterTriggerRebuild",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "3114-3120",
    "snippet": "int\nvirNWFilterTriggerRebuild(void)\n{\n    if (rebuildCallback)\n        return rebuildCallback(rebuildOpaque);\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNWFilterTriggerRebuildCallback rebuildCallback;",
      "static void *rebuildOpaque;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rebuildCallback",
          "args": [
            "rebuildOpaque"
          ],
          "line": 3118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNWFilterTriggerRebuildCallback rebuildCallback;\nstatic void *rebuildOpaque;\n\nint\nvirNWFilterTriggerRebuild(void)\n{\n    if (rebuildCallback)\n        return rebuildCallback(rebuildOpaque);\n    return 0;\n}"
  },
  {
    "function_name": "virNWFilterConfLayerShutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "3100-3111",
    "snippet": "void\nvirNWFilterConfLayerShutdown(void)\n{\n    if (!initialized)\n        return;\n\n    virRWLockDestroy(&updateLock);\n\n    initialized = false;\n    rebuildCallback = NULL;\n    rebuildOpaque = NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virRWLock updateLock;",
      "static bool initialized;",
      "static virNWFilterTriggerRebuildCallback rebuildCallback;",
      "static void *rebuildOpaque;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virRWLockDestroy",
          "args": [
            "&updateLock"
          ],
          "line": 3106
        },
        "resolved": true,
        "details": {
          "function_name": "virRWLockDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "103-106",
          "snippet": "void virRWLockDestroy(virRWLockPtr m)\n{\n    pthread_rwlock_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virRWLockDestroy(virRWLockPtr m)\n{\n    pthread_rwlock_destroy(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virRWLock updateLock;\nstatic bool initialized;\nstatic virNWFilterTriggerRebuildCallback rebuildCallback;\nstatic void *rebuildOpaque;\n\nvoid\nvirNWFilterConfLayerShutdown(void)\n{\n    if (!initialized)\n        return;\n\n    virRWLockDestroy(&updateLock);\n\n    initialized = false;\n    rebuildCallback = NULL;\n    rebuildOpaque = NULL;\n}"
  },
  {
    "function_name": "virNWFilterConfLayerInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "3081-3097",
    "snippet": "int\nvirNWFilterConfLayerInit(virNWFilterTriggerRebuildCallback cb,\n                         void *opaque)\n{\n    if (initialized)\n        return -1;\n\n    rebuildCallback = cb;\n    rebuildOpaque = opaque;\n\n    initialized = true;\n\n    if (virRWLockInit(&updateLock) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virRWLock updateLock;",
      "static bool initialized;",
      "static virNWFilterTriggerRebuildCallback rebuildCallback;",
      "static void *rebuildOpaque;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virRWLockInit",
          "args": [
            "&updateLock"
          ],
          "line": 3093
        },
        "resolved": true,
        "details": {
          "function_name": "virRWLockInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "92-101",
          "snippet": "int virRWLockInit(virRWLockPtr m)\n{\n    int ret;\n    ret = pthread_rwlock_init(&m->lock, NULL);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virRWLockInit(virRWLockPtr m)\n{\n    int ret;\n    ret = pthread_rwlock_init(&m->lock, NULL);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virRWLock updateLock;\nstatic bool initialized;\nstatic virNWFilterTriggerRebuildCallback rebuildCallback;\nstatic void *rebuildOpaque;\n\nint\nvirNWFilterConfLayerInit(virNWFilterTriggerRebuildCallback cb,\n                         void *opaque)\n{\n    if (initialized)\n        return -1;\n\n    rebuildCallback = cb;\n    rebuildOpaque = opaque;\n\n    initialized = true;\n\n    if (virRWLockInit(&updateLock) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virNWFilterDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "3044-3076",
    "snippet": "char *\nvirNWFilterDefFormat(const virNWFilterDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char uuid[VIR_UUID_STRING_BUFLEN];\n    size_t i;\n\n    virBufferAsprintf(&buf, \"<filter name='%s' chain='%s'\",\n                      def->name,\n                      def->chainsuffix);\n    if (def->chainPriority != 0)\n        virBufferAsprintf(&buf, \" priority='%d'\",\n                          def->chainPriority);\n    virBufferAddLit(&buf, \">\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    virUUIDFormat(def->uuid, uuid);\n    virBufferAsprintf(&buf, \"<uuid>%s</uuid>\\n\", uuid);\n\n    for (i = 0; i < def->nentries; i++) {\n        if (virNWFilterEntryFormat(&buf, def->filterEntries[i]) < 0)\n            goto err_exit;\n    }\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</filter>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n err_exit:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 3074
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 3071
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"</filter>\\n\""
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "&buf",
            "-2"
          ],
          "line": 3068
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterEntryFormat",
          "args": [
            "&buf",
            "def->filterEntries[i]"
          ],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterEntryFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "3033-3041",
          "snippet": "static int\nvirNWFilterEntryFormat(virBufferPtr buf,\n                       virNWFilterEntryPtr entry)\n{\n    if (entry->rule)\n        return virNWFilterRuleDefFormat(buf, entry->rule);\n    return virNWFilterFormatParamAttributes(buf, entry->include->params,\n                                            entry->include->filterref);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirNWFilterEntryFormat(virBufferPtr buf,\n                       virNWFilterEntryPtr entry)\n{\n    if (entry->rule)\n        return virNWFilterRuleDefFormat(buf, entry->rule);\n    return virNWFilterFormatParamAttributes(buf, entry->include->params,\n                                            entry->include->filterref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"<uuid>%s</uuid>\\n\"",
            "uuid"
          ],
          "line": 3061
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "def->uuid",
            "uuid"
          ],
          "line": 3060
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\">\\n\""
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirNWFilterDefFormat(const virNWFilterDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char uuid[VIR_UUID_STRING_BUFLEN];\n    size_t i;\n\n    virBufferAsprintf(&buf, \"<filter name='%s' chain='%s'\",\n                      def->name,\n                      def->chainsuffix);\n    if (def->chainPriority != 0)\n        virBufferAsprintf(&buf, \" priority='%d'\",\n                          def->chainPriority);\n    virBufferAddLit(&buf, \">\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    virUUIDFormat(def->uuid, uuid);\n    virBufferAsprintf(&buf, \"<uuid>%s</uuid>\\n\", uuid);\n\n    for (i = 0; i < def->nentries; i++) {\n        if (virNWFilterEntryFormat(&buf, def->filterEntries[i]) < 0)\n            goto err_exit;\n    }\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</filter>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n err_exit:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
  },
  {
    "function_name": "virNWFilterEntryFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "3033-3041",
    "snippet": "static int\nvirNWFilterEntryFormat(virBufferPtr buf,\n                       virNWFilterEntryPtr entry)\n{\n    if (entry->rule)\n        return virNWFilterRuleDefFormat(buf, entry->rule);\n    return virNWFilterFormatParamAttributes(buf, entry->include->params,\n                                            entry->include->filterref);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNWFilterFormatParamAttributes",
          "args": [
            "buf",
            "entry->include->params",
            "entry->include->filterref"
          ],
          "line": 3039
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterFormatParamAttributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_params.c",
          "lines": "783-830",
          "snippet": "int\nvirNWFilterFormatParamAttributes(virBufferPtr buf,\n                                 virHashTablePtr table,\n                                 const char *filterref)\n{\n    virHashKeyValuePairPtr items;\n    size_t i, j;\n    int card, numKeys;\n\n    numKeys = virHashSize(table);\n\n    if (numKeys < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing filter parameter table\"));\n        return -1;\n    }\n\n    items = virHashGetItems(table,\n                            virNWFilterFormatParameterNameSorter);\n    if (!items)\n        return -1;\n\n    virBufferAsprintf(buf, \"<filterref filter='%s'\", filterref);\n    if (numKeys) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < numKeys; i++) {\n            const virNWFilterVarValue *value = items[i].value;\n\n            card = virNWFilterVarValueGetCardinality(value);\n\n            for (j = 0; j < card; j++)\n                virBufferAsprintf(buf,\n                                  \"<parameter name='%s' value='%s'/>\\n\",\n                                  (const char *)items[i].key,\n                                  virNWFilterVarValueGetNthValue(value, j));\n\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</filterref>\\n\");\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    VIR_FREE(items);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool isValidVarValue(const char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic bool isValidVarValue(const char *value);\n\nint\nvirNWFilterFormatParamAttributes(virBufferPtr buf,\n                                 virHashTablePtr table,\n                                 const char *filterref)\n{\n    virHashKeyValuePairPtr items;\n    size_t i, j;\n    int card, numKeys;\n\n    numKeys = virHashSize(table);\n\n    if (numKeys < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing filter parameter table\"));\n        return -1;\n    }\n\n    items = virHashGetItems(table,\n                            virNWFilterFormatParameterNameSorter);\n    if (!items)\n        return -1;\n\n    virBufferAsprintf(buf, \"<filterref filter='%s'\", filterref);\n    if (numKeys) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < numKeys; i++) {\n            const virNWFilterVarValue *value = items[i].value;\n\n            card = virNWFilterVarValueGetCardinality(value);\n\n            for (j = 0; j < card; j++)\n                virBufferAsprintf(buf,\n                                  \"<parameter name='%s' value='%s'/>\\n\",\n                                  (const char *)items[i].key,\n                                  virNWFilterVarValueGetNthValue(value, j));\n\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</filterref>\\n\");\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    VIR_FREE(items);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleDefFormat",
          "args": [
            "buf",
            "entry->rule"
          ],
          "line": 3038
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRuleDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "2993-3030",
          "snippet": "static int\nvirNWFilterRuleDefFormat(virBufferPtr buf,\n                         virNWFilterRuleDefPtr def)\n{\n    size_t i;\n    bool subelement = false;\n\n    virBufferAsprintf(buf, \"<rule action='%s' direction='%s' priority='%d'\",\n                      virNWFilterRuleActionTypeToString(def->action),\n                      virNWFilterRuleDirectionTypeToString(def->tt),\n                      def->priority);\n\n    if ((def->flags & RULE_FLAG_NO_STATEMATCH))\n        virBufferAddLit(buf, \" statematch='false'\");\n\n    virBufferAdjustIndent(buf, 2);\n    i = 0;\n    while (virAttr[i].id) {\n        if (virAttr[i].prtclType == def->prtclType) {\n            if (!subelement)\n                virBufferAddLit(buf, \">\\n\");\n            virNWFilterRuleDefDetailsFormat(buf,\n                                            virAttr[i].id,\n                                            virAttr[i].att,\n                                            def);\n            subelement = true;\n            break;\n        }\n        i++;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    if (subelement)\n        virBufferAddLit(buf, \"</rule>\\n\");\n    else\n        virBufferAddLit(buf, \"/>\\n\");\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const virAttributes virAttr[] = {\n    PROTOCOL_ENTRY(\"arp\",     arpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ARP),\n    PROTOCOL_ENTRY(\"rarp\",    arpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_RARP),\n    PROTOCOL_ENTRY(\"mac\",     macAttributes,     VIR_NWFILTER_RULE_PROTOCOL_MAC),\n    PROTOCOL_ENTRY(\"vlan\",    vlanAttributes,    VIR_NWFILTER_RULE_PROTOCOL_VLAN),\n    PROTOCOL_ENTRY(\"stp\",     stpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_STP),\n    PROTOCOL_ENTRY(\"ip\",      ipAttributes,      VIR_NWFILTER_RULE_PROTOCOL_IP),\n    PROTOCOL_ENTRY(\"ipv6\",    ipv6Attributes,    VIR_NWFILTER_RULE_PROTOCOL_IPV6),\n    PROTOCOL_ENTRY(\"tcp\",     tcpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_TCP),\n    PROTOCOL_ENTRY(\"udp\",     udpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_UDP),\n    PROTOCOL_ENTRY(\"udplite\", udpliteAttributes, VIR_NWFILTER_RULE_PROTOCOL_UDPLITE),\n    PROTOCOL_ENTRY(\"esp\",     espAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ESP),\n    PROTOCOL_ENTRY(\"ah\",      ahAttributes,      VIR_NWFILTER_RULE_PROTOCOL_AH),\n    PROTOCOL_ENTRY(\"sctp\",    sctpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_SCTP),\n    PROTOCOL_ENTRY(\"icmp\",    icmpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_ICMP),\n    PROTOCOL_ENTRY(\"all\",     allAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ALL),\n    PROTOCOL_ENTRY(\"igmp\",    igmpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_IGMP),\n    PROTOCOL_ENTRY(\"tcp-ipv6\",     tcpipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6),\n    PROTOCOL_ENTRY(\"udp-ipv6\",     udpipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6),\n    PROTOCOL_ENTRY(\"udplite-ipv6\", udpliteipv6Attributes, VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6),\n    PROTOCOL_ENTRY(\"esp-ipv6\",     espipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6),\n    PROTOCOL_ENTRY(\"ah-ipv6\",      ahipv6Attributes,      VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6),\n    PROTOCOL_ENTRY(\"sctp-ipv6\",    sctpipv6Attributes,    VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6),\n    PROTOCOL_ENTRY(\"icmpv6\",       icmpv6Attributes,      VIR_NWFILTER_RULE_PROTOCOL_ICMPV6),\n    PROTOCOL_ENTRY(\"all-ipv6\",     allipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6),\n    PROTOCOL_ENTRY_LAST\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const virAttributes virAttr[] = {\n    PROTOCOL_ENTRY(\"arp\",     arpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ARP),\n    PROTOCOL_ENTRY(\"rarp\",    arpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_RARP),\n    PROTOCOL_ENTRY(\"mac\",     macAttributes,     VIR_NWFILTER_RULE_PROTOCOL_MAC),\n    PROTOCOL_ENTRY(\"vlan\",    vlanAttributes,    VIR_NWFILTER_RULE_PROTOCOL_VLAN),\n    PROTOCOL_ENTRY(\"stp\",     stpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_STP),\n    PROTOCOL_ENTRY(\"ip\",      ipAttributes,      VIR_NWFILTER_RULE_PROTOCOL_IP),\n    PROTOCOL_ENTRY(\"ipv6\",    ipv6Attributes,    VIR_NWFILTER_RULE_PROTOCOL_IPV6),\n    PROTOCOL_ENTRY(\"tcp\",     tcpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_TCP),\n    PROTOCOL_ENTRY(\"udp\",     udpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_UDP),\n    PROTOCOL_ENTRY(\"udplite\", udpliteAttributes, VIR_NWFILTER_RULE_PROTOCOL_UDPLITE),\n    PROTOCOL_ENTRY(\"esp\",     espAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ESP),\n    PROTOCOL_ENTRY(\"ah\",      ahAttributes,      VIR_NWFILTER_RULE_PROTOCOL_AH),\n    PROTOCOL_ENTRY(\"sctp\",    sctpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_SCTP),\n    PROTOCOL_ENTRY(\"icmp\",    icmpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_ICMP),\n    PROTOCOL_ENTRY(\"all\",     allAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ALL),\n    PROTOCOL_ENTRY(\"igmp\",    igmpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_IGMP),\n    PROTOCOL_ENTRY(\"tcp-ipv6\",     tcpipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6),\n    PROTOCOL_ENTRY(\"udp-ipv6\",     udpipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6),\n    PROTOCOL_ENTRY(\"udplite-ipv6\", udpliteipv6Attributes, VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6),\n    PROTOCOL_ENTRY(\"esp-ipv6\",     espipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6),\n    PROTOCOL_ENTRY(\"ah-ipv6\",      ahipv6Attributes,      VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6),\n    PROTOCOL_ENTRY(\"sctp-ipv6\",    sctpipv6Attributes,    VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6),\n    PROTOCOL_ENTRY(\"icmpv6\",       icmpv6Attributes,      VIR_NWFILTER_RULE_PROTOCOL_ICMPV6),\n    PROTOCOL_ENTRY(\"all-ipv6\",     allipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6),\n    PROTOCOL_ENTRY_LAST\n};\n\nstatic int\nvirNWFilterRuleDefFormat(virBufferPtr buf,\n                         virNWFilterRuleDefPtr def)\n{\n    size_t i;\n    bool subelement = false;\n\n    virBufferAsprintf(buf, \"<rule action='%s' direction='%s' priority='%d'\",\n                      virNWFilterRuleActionTypeToString(def->action),\n                      virNWFilterRuleDirectionTypeToString(def->tt),\n                      def->priority);\n\n    if ((def->flags & RULE_FLAG_NO_STATEMATCH))\n        virBufferAddLit(buf, \" statematch='false'\");\n\n    virBufferAdjustIndent(buf, 2);\n    i = 0;\n    while (virAttr[i].id) {\n        if (virAttr[i].prtclType == def->prtclType) {\n            if (!subelement)\n                virBufferAddLit(buf, \">\\n\");\n            virNWFilterRuleDefDetailsFormat(buf,\n                                            virAttr[i].id,\n                                            virAttr[i].att,\n                                            def);\n            subelement = true;\n            break;\n        }\n        i++;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    if (subelement)\n        virBufferAddLit(buf, \"</rule>\\n\");\n    else\n        virBufferAddLit(buf, \"/>\\n\");\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirNWFilterEntryFormat(virBufferPtr buf,\n                       virNWFilterEntryPtr entry)\n{\n    if (entry->rule)\n        return virNWFilterRuleDefFormat(buf, entry->rule);\n    return virNWFilterFormatParamAttributes(buf, entry->include->params,\n                                            entry->include->filterref);\n}"
  },
  {
    "function_name": "virNWFilterRuleDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "2993-3030",
    "snippet": "static int\nvirNWFilterRuleDefFormat(virBufferPtr buf,\n                         virNWFilterRuleDefPtr def)\n{\n    size_t i;\n    bool subelement = false;\n\n    virBufferAsprintf(buf, \"<rule action='%s' direction='%s' priority='%d'\",\n                      virNWFilterRuleActionTypeToString(def->action),\n                      virNWFilterRuleDirectionTypeToString(def->tt),\n                      def->priority);\n\n    if ((def->flags & RULE_FLAG_NO_STATEMATCH))\n        virBufferAddLit(buf, \" statematch='false'\");\n\n    virBufferAdjustIndent(buf, 2);\n    i = 0;\n    while (virAttr[i].id) {\n        if (virAttr[i].prtclType == def->prtclType) {\n            if (!subelement)\n                virBufferAddLit(buf, \">\\n\");\n            virNWFilterRuleDefDetailsFormat(buf,\n                                            virAttr[i].id,\n                                            virAttr[i].att,\n                                            def);\n            subelement = true;\n            break;\n        }\n        i++;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    if (subelement)\n        virBufferAddLit(buf, \"</rule>\\n\");\n    else\n        virBufferAddLit(buf, \"/>\\n\");\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const virAttributes virAttr[] = {\n    PROTOCOL_ENTRY(\"arp\",     arpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ARP),\n    PROTOCOL_ENTRY(\"rarp\",    arpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_RARP),\n    PROTOCOL_ENTRY(\"mac\",     macAttributes,     VIR_NWFILTER_RULE_PROTOCOL_MAC),\n    PROTOCOL_ENTRY(\"vlan\",    vlanAttributes,    VIR_NWFILTER_RULE_PROTOCOL_VLAN),\n    PROTOCOL_ENTRY(\"stp\",     stpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_STP),\n    PROTOCOL_ENTRY(\"ip\",      ipAttributes,      VIR_NWFILTER_RULE_PROTOCOL_IP),\n    PROTOCOL_ENTRY(\"ipv6\",    ipv6Attributes,    VIR_NWFILTER_RULE_PROTOCOL_IPV6),\n    PROTOCOL_ENTRY(\"tcp\",     tcpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_TCP),\n    PROTOCOL_ENTRY(\"udp\",     udpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_UDP),\n    PROTOCOL_ENTRY(\"udplite\", udpliteAttributes, VIR_NWFILTER_RULE_PROTOCOL_UDPLITE),\n    PROTOCOL_ENTRY(\"esp\",     espAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ESP),\n    PROTOCOL_ENTRY(\"ah\",      ahAttributes,      VIR_NWFILTER_RULE_PROTOCOL_AH),\n    PROTOCOL_ENTRY(\"sctp\",    sctpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_SCTP),\n    PROTOCOL_ENTRY(\"icmp\",    icmpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_ICMP),\n    PROTOCOL_ENTRY(\"all\",     allAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ALL),\n    PROTOCOL_ENTRY(\"igmp\",    igmpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_IGMP),\n    PROTOCOL_ENTRY(\"tcp-ipv6\",     tcpipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6),\n    PROTOCOL_ENTRY(\"udp-ipv6\",     udpipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6),\n    PROTOCOL_ENTRY(\"udplite-ipv6\", udpliteipv6Attributes, VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6),\n    PROTOCOL_ENTRY(\"esp-ipv6\",     espipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6),\n    PROTOCOL_ENTRY(\"ah-ipv6\",      ahipv6Attributes,      VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6),\n    PROTOCOL_ENTRY(\"sctp-ipv6\",    sctpipv6Attributes,    VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6),\n    PROTOCOL_ENTRY(\"icmpv6\",       icmpv6Attributes,      VIR_NWFILTER_RULE_PROTOCOL_ICMPV6),\n    PROTOCOL_ENTRY(\"all-ipv6\",     allipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6),\n    PROTOCOL_ENTRY_LAST\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</rule>\\n\""
          ],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 3024
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleDefDetailsFormat",
          "args": [
            "buf",
            "virAttr[i].id",
            "virAttr[i].att",
            "def"
          ],
          "line": 3014
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRuleDefDetailsFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "2849-2990",
          "snippet": "static void\nvirNWFilterRuleDefDetailsFormat(virBufferPtr buf,\n                                const char *type,\n                                const virXMLAttr2Struct *att,\n                                virNWFilterRuleDefPtr def)\n{\n    size_t i = 0, j;\n    bool typeShown = false;\n    bool neverShown = true;\n    bool asHex;\n    enum match {\n        MATCH_NONE = 0,\n        MATCH_YES,\n        MATCH_NO\n    } matchShown = MATCH_NONE;\n    nwItemDesc *item;\n\n    while (att[i].name) {\n        VIR_WARNINGS_NO_CAST_ALIGN\n        item = (nwItemDesc *)((char *)def + att[i].dataIdx);\n        VIR_WARNINGS_RESET\n        virNWFilterEntryItemFlags flags = item->flags;\n        if ((flags & NWFILTER_ENTRY_ITEM_FLAG_EXISTS)) {\n            if (!typeShown) {\n                virBufferAsprintf(buf, \"<%s\", type);\n                typeShown = true;\n                neverShown = false;\n            }\n\n            if ((flags & NWFILTER_ENTRY_ITEM_FLAG_IS_NEG)) {\n                if (matchShown == MATCH_NONE) {\n                    virBufferAddLit(buf, \" match='no'\");\n                    matchShown = MATCH_NO;\n                } else if (matchShown == MATCH_YES) {\n                    virBufferAddLit(buf, \"/>\\n\");\n                    typeShown = 0;\n                    matchShown = MATCH_NONE;\n                    continue;\n                }\n            } else {\n                if (matchShown == MATCH_NO) {\n                    virBufferAddLit(buf, \"/>\\n\");\n                    typeShown = 0;\n                    matchShown = MATCH_NONE;\n                    continue;\n                }\n                matchShown = MATCH_YES;\n            }\n\n            virBufferAsprintf(buf, \" %s='\",\n                              att[i].name);\n            if (att[i].formatter && !(flags & NWFILTER_ENTRY_ITEM_FLAG_HAS_VAR)) {\n               if (!att[i].formatter(buf, def, item)) {\n                  virReportError(VIR_ERR_INTERNAL_ERROR,\n                                 _(\"formatter for %s %s reported error\"),\n                                 type,\n                                 att[i].name);\n                   return;\n               }\n            } else if ((flags & NWFILTER_ENTRY_ITEM_FLAG_HAS_VAR)) {\n                virBufferAddChar(buf, '$');\n                virNWFilterVarAccessPrint(item->varAccess, buf);\n            } else {\n               asHex = false;\n\n               switch (item->datatype) {\n\n               case DATATYPE_UINT8_HEX:\n                   asHex = true;\n                   G_GNUC_FALLTHROUGH;\n               case DATATYPE_IPMASK:\n               case DATATYPE_IPV6MASK:\n                   /* display all masks in CIDR format */\n               case DATATYPE_UINT8:\n                   virBufferAsprintf(buf, asHex ? \"0x%x\" : \"%d\",\n                                     item->u.u8);\n               break;\n\n               case DATATYPE_UINT16_HEX:\n                   asHex = true;\n                   G_GNUC_FALLTHROUGH;\n               case DATATYPE_UINT16:\n                   virBufferAsprintf(buf, asHex ? \"0x%x\" : \"%d\",\n                                     item->u.u16);\n               break;\n\n               case DATATYPE_UINT32_HEX:\n                   asHex = true;\n                   G_GNUC_FALLTHROUGH;\n               case DATATYPE_UINT32:\n                   virBufferAsprintf(buf, asHex ? \"0x%x\" : \"%u\",\n                                     item->u.u32);\n               break;\n\n               case DATATYPE_IPADDR:\n               case DATATYPE_IPV6ADDR:\n                   virNWIPAddressFormat(buf,\n                                        &item->u.ipaddr);\n               break;\n\n               case DATATYPE_MACMASK:\n               case DATATYPE_MACADDR:\n                   for (j = 0; j < 6; j++)\n                       virBufferAsprintf(buf, \"%02x%s\",\n                                         item->u.macaddr.addr[j],\n                                         (j < 5) ? \":\" : \"\");\n               break;\n\n               case DATATYPE_STRINGCOPY:\n                   virBufferEscapeString(buf, \"%s\", item->u.string);\n               break;\n\n               case DATATYPE_BOOLEAN:\n                   if (item->u.boolean)\n                       virBufferAddLit(buf, \"true\");\n                   else\n                       virBufferAddLit(buf, \"false\");\n               break;\n\n               case DATATYPE_IPSETNAME:\n               case DATATYPE_IPSETFLAGS:\n               case DATATYPE_STRING:\n               case DATATYPE_LAST:\n               default:\n                   virBufferAsprintf(buf,\n                                     \"UNSUPPORTED DATATYPE 0x%02x\\n\",\n                                     att[i].datatype);\n               }\n            }\n            virBufferAddLit(buf, \"'\");\n        }\n        i++;\n    }\n    if (typeShown)\n       virBufferAddLit(buf, \"/>\\n\");\n\n    if (neverShown)\n       virBufferAsprintf(buf,\n                         \"<%s/>\\n\", type);\n\n    return;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirNWFilterRuleDefDetailsFormat(virBufferPtr buf,\n                                const char *type,\n                                const virXMLAttr2Struct *att,\n                                virNWFilterRuleDefPtr def)\n{\n    size_t i = 0, j;\n    bool typeShown = false;\n    bool neverShown = true;\n    bool asHex;\n    enum match {\n        MATCH_NONE = 0,\n        MATCH_YES,\n        MATCH_NO\n    } matchShown = MATCH_NONE;\n    nwItemDesc *item;\n\n    while (att[i].name) {\n        VIR_WARNINGS_NO_CAST_ALIGN\n        item = (nwItemDesc *)((char *)def + att[i].dataIdx);\n        VIR_WARNINGS_RESET\n        virNWFilterEntryItemFlags flags = item->flags;\n        if ((flags & NWFILTER_ENTRY_ITEM_FLAG_EXISTS)) {\n            if (!typeShown) {\n                virBufferAsprintf(buf, \"<%s\", type);\n                typeShown = true;\n                neverShown = false;\n            }\n\n            if ((flags & NWFILTER_ENTRY_ITEM_FLAG_IS_NEG)) {\n                if (matchShown == MATCH_NONE) {\n                    virBufferAddLit(buf, \" match='no'\");\n                    matchShown = MATCH_NO;\n                } else if (matchShown == MATCH_YES) {\n                    virBufferAddLit(buf, \"/>\\n\");\n                    typeShown = 0;\n                    matchShown = MATCH_NONE;\n                    continue;\n                }\n            } else {\n                if (matchShown == MATCH_NO) {\n                    virBufferAddLit(buf, \"/>\\n\");\n                    typeShown = 0;\n                    matchShown = MATCH_NONE;\n                    continue;\n                }\n                matchShown = MATCH_YES;\n            }\n\n            virBufferAsprintf(buf, \" %s='\",\n                              att[i].name);\n            if (att[i].formatter && !(flags & NWFILTER_ENTRY_ITEM_FLAG_HAS_VAR)) {\n               if (!att[i].formatter(buf, def, item)) {\n                  virReportError(VIR_ERR_INTERNAL_ERROR,\n                                 _(\"formatter for %s %s reported error\"),\n                                 type,\n                                 att[i].name);\n                   return;\n               }\n            } else if ((flags & NWFILTER_ENTRY_ITEM_FLAG_HAS_VAR)) {\n                virBufferAddChar(buf, '$');\n                virNWFilterVarAccessPrint(item->varAccess, buf);\n            } else {\n               asHex = false;\n\n               switch (item->datatype) {\n\n               case DATATYPE_UINT8_HEX:\n                   asHex = true;\n                   G_GNUC_FALLTHROUGH;\n               case DATATYPE_IPMASK:\n               case DATATYPE_IPV6MASK:\n                   /* display all masks in CIDR format */\n               case DATATYPE_UINT8:\n                   virBufferAsprintf(buf, asHex ? \"0x%x\" : \"%d\",\n                                     item->u.u8);\n               break;\n\n               case DATATYPE_UINT16_HEX:\n                   asHex = true;\n                   G_GNUC_FALLTHROUGH;\n               case DATATYPE_UINT16:\n                   virBufferAsprintf(buf, asHex ? \"0x%x\" : \"%d\",\n                                     item->u.u16);\n               break;\n\n               case DATATYPE_UINT32_HEX:\n                   asHex = true;\n                   G_GNUC_FALLTHROUGH;\n               case DATATYPE_UINT32:\n                   virBufferAsprintf(buf, asHex ? \"0x%x\" : \"%u\",\n                                     item->u.u32);\n               break;\n\n               case DATATYPE_IPADDR:\n               case DATATYPE_IPV6ADDR:\n                   virNWIPAddressFormat(buf,\n                                        &item->u.ipaddr);\n               break;\n\n               case DATATYPE_MACMASK:\n               case DATATYPE_MACADDR:\n                   for (j = 0; j < 6; j++)\n                       virBufferAsprintf(buf, \"%02x%s\",\n                                         item->u.macaddr.addr[j],\n                                         (j < 5) ? \":\" : \"\");\n               break;\n\n               case DATATYPE_STRINGCOPY:\n                   virBufferEscapeString(buf, \"%s\", item->u.string);\n               break;\n\n               case DATATYPE_BOOLEAN:\n                   if (item->u.boolean)\n                       virBufferAddLit(buf, \"true\");\n                   else\n                       virBufferAddLit(buf, \"false\");\n               break;\n\n               case DATATYPE_IPSETNAME:\n               case DATATYPE_IPSETFLAGS:\n               case DATATYPE_STRING:\n               case DATATYPE_LAST:\n               default:\n                   virBufferAsprintf(buf,\n                                     \"UNSUPPORTED DATATYPE 0x%02x\\n\",\n                                     att[i].datatype);\n               }\n            }\n            virBufferAddLit(buf, \"'\");\n        }\n        i++;\n    }\n    if (typeShown)\n       virBufferAddLit(buf, \"/>\\n\");\n\n    if (neverShown)\n       virBufferAsprintf(buf,\n                         \"<%s/>\\n\", type);\n\n    return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\">\\n\""
          ],
          "line": 3013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" statematch='false'\""
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<rule action='%s' direction='%s' priority='%d'\"",
            "virNWFilterRuleActionTypeToString(def->action)",
            "virNWFilterRuleDirectionTypeToString(def->tt)",
            "def->priority"
          ],
          "line": 3000
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleDirectionTypeToString",
          "args": [
            "def->tt"
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleActionTypeToString",
          "args": [
            "def->action"
          ],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const virAttributes virAttr[] = {\n    PROTOCOL_ENTRY(\"arp\",     arpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ARP),\n    PROTOCOL_ENTRY(\"rarp\",    arpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_RARP),\n    PROTOCOL_ENTRY(\"mac\",     macAttributes,     VIR_NWFILTER_RULE_PROTOCOL_MAC),\n    PROTOCOL_ENTRY(\"vlan\",    vlanAttributes,    VIR_NWFILTER_RULE_PROTOCOL_VLAN),\n    PROTOCOL_ENTRY(\"stp\",     stpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_STP),\n    PROTOCOL_ENTRY(\"ip\",      ipAttributes,      VIR_NWFILTER_RULE_PROTOCOL_IP),\n    PROTOCOL_ENTRY(\"ipv6\",    ipv6Attributes,    VIR_NWFILTER_RULE_PROTOCOL_IPV6),\n    PROTOCOL_ENTRY(\"tcp\",     tcpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_TCP),\n    PROTOCOL_ENTRY(\"udp\",     udpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_UDP),\n    PROTOCOL_ENTRY(\"udplite\", udpliteAttributes, VIR_NWFILTER_RULE_PROTOCOL_UDPLITE),\n    PROTOCOL_ENTRY(\"esp\",     espAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ESP),\n    PROTOCOL_ENTRY(\"ah\",      ahAttributes,      VIR_NWFILTER_RULE_PROTOCOL_AH),\n    PROTOCOL_ENTRY(\"sctp\",    sctpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_SCTP),\n    PROTOCOL_ENTRY(\"icmp\",    icmpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_ICMP),\n    PROTOCOL_ENTRY(\"all\",     allAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ALL),\n    PROTOCOL_ENTRY(\"igmp\",    igmpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_IGMP),\n    PROTOCOL_ENTRY(\"tcp-ipv6\",     tcpipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6),\n    PROTOCOL_ENTRY(\"udp-ipv6\",     udpipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6),\n    PROTOCOL_ENTRY(\"udplite-ipv6\", udpliteipv6Attributes, VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6),\n    PROTOCOL_ENTRY(\"esp-ipv6\",     espipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6),\n    PROTOCOL_ENTRY(\"ah-ipv6\",      ahipv6Attributes,      VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6),\n    PROTOCOL_ENTRY(\"sctp-ipv6\",    sctpipv6Attributes,    VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6),\n    PROTOCOL_ENTRY(\"icmpv6\",       icmpv6Attributes,      VIR_NWFILTER_RULE_PROTOCOL_ICMPV6),\n    PROTOCOL_ENTRY(\"all-ipv6\",     allipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6),\n    PROTOCOL_ENTRY_LAST\n};\n\nstatic int\nvirNWFilterRuleDefFormat(virBufferPtr buf,\n                         virNWFilterRuleDefPtr def)\n{\n    size_t i;\n    bool subelement = false;\n\n    virBufferAsprintf(buf, \"<rule action='%s' direction='%s' priority='%d'\",\n                      virNWFilterRuleActionTypeToString(def->action),\n                      virNWFilterRuleDirectionTypeToString(def->tt),\n                      def->priority);\n\n    if ((def->flags & RULE_FLAG_NO_STATEMATCH))\n        virBufferAddLit(buf, \" statematch='false'\");\n\n    virBufferAdjustIndent(buf, 2);\n    i = 0;\n    while (virAttr[i].id) {\n        if (virAttr[i].prtclType == def->prtclType) {\n            if (!subelement)\n                virBufferAddLit(buf, \">\\n\");\n            virNWFilterRuleDefDetailsFormat(buf,\n                                            virAttr[i].id,\n                                            virAttr[i].att,\n                                            def);\n            subelement = true;\n            break;\n        }\n        i++;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    if (subelement)\n        virBufferAddLit(buf, \"</rule>\\n\");\n    else\n        virBufferAddLit(buf, \"/>\\n\");\n    return 0;\n}"
  },
  {
    "function_name": "virNWFilterRuleDefDetailsFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "2849-2990",
    "snippet": "static void\nvirNWFilterRuleDefDetailsFormat(virBufferPtr buf,\n                                const char *type,\n                                const virXMLAttr2Struct *att,\n                                virNWFilterRuleDefPtr def)\n{\n    size_t i = 0, j;\n    bool typeShown = false;\n    bool neverShown = true;\n    bool asHex;\n    enum match {\n        MATCH_NONE = 0,\n        MATCH_YES,\n        MATCH_NO\n    } matchShown = MATCH_NONE;\n    nwItemDesc *item;\n\n    while (att[i].name) {\n        VIR_WARNINGS_NO_CAST_ALIGN\n        item = (nwItemDesc *)((char *)def + att[i].dataIdx);\n        VIR_WARNINGS_RESET\n        virNWFilterEntryItemFlags flags = item->flags;\n        if ((flags & NWFILTER_ENTRY_ITEM_FLAG_EXISTS)) {\n            if (!typeShown) {\n                virBufferAsprintf(buf, \"<%s\", type);\n                typeShown = true;\n                neverShown = false;\n            }\n\n            if ((flags & NWFILTER_ENTRY_ITEM_FLAG_IS_NEG)) {\n                if (matchShown == MATCH_NONE) {\n                    virBufferAddLit(buf, \" match='no'\");\n                    matchShown = MATCH_NO;\n                } else if (matchShown == MATCH_YES) {\n                    virBufferAddLit(buf, \"/>\\n\");\n                    typeShown = 0;\n                    matchShown = MATCH_NONE;\n                    continue;\n                }\n            } else {\n                if (matchShown == MATCH_NO) {\n                    virBufferAddLit(buf, \"/>\\n\");\n                    typeShown = 0;\n                    matchShown = MATCH_NONE;\n                    continue;\n                }\n                matchShown = MATCH_YES;\n            }\n\n            virBufferAsprintf(buf, \" %s='\",\n                              att[i].name);\n            if (att[i].formatter && !(flags & NWFILTER_ENTRY_ITEM_FLAG_HAS_VAR)) {\n               if (!att[i].formatter(buf, def, item)) {\n                  virReportError(VIR_ERR_INTERNAL_ERROR,\n                                 _(\"formatter for %s %s reported error\"),\n                                 type,\n                                 att[i].name);\n                   return;\n               }\n            } else if ((flags & NWFILTER_ENTRY_ITEM_FLAG_HAS_VAR)) {\n                virBufferAddChar(buf, '$');\n                virNWFilterVarAccessPrint(item->varAccess, buf);\n            } else {\n               asHex = false;\n\n               switch (item->datatype) {\n\n               case DATATYPE_UINT8_HEX:\n                   asHex = true;\n                   G_GNUC_FALLTHROUGH;\n               case DATATYPE_IPMASK:\n               case DATATYPE_IPV6MASK:\n                   /* display all masks in CIDR format */\n               case DATATYPE_UINT8:\n                   virBufferAsprintf(buf, asHex ? \"0x%x\" : \"%d\",\n                                     item->u.u8);\n               break;\n\n               case DATATYPE_UINT16_HEX:\n                   asHex = true;\n                   G_GNUC_FALLTHROUGH;\n               case DATATYPE_UINT16:\n                   virBufferAsprintf(buf, asHex ? \"0x%x\" : \"%d\",\n                                     item->u.u16);\n               break;\n\n               case DATATYPE_UINT32_HEX:\n                   asHex = true;\n                   G_GNUC_FALLTHROUGH;\n               case DATATYPE_UINT32:\n                   virBufferAsprintf(buf, asHex ? \"0x%x\" : \"%u\",\n                                     item->u.u32);\n               break;\n\n               case DATATYPE_IPADDR:\n               case DATATYPE_IPV6ADDR:\n                   virNWIPAddressFormat(buf,\n                                        &item->u.ipaddr);\n               break;\n\n               case DATATYPE_MACMASK:\n               case DATATYPE_MACADDR:\n                   for (j = 0; j < 6; j++)\n                       virBufferAsprintf(buf, \"%02x%s\",\n                                         item->u.macaddr.addr[j],\n                                         (j < 5) ? \":\" : \"\");\n               break;\n\n               case DATATYPE_STRINGCOPY:\n                   virBufferEscapeString(buf, \"%s\", item->u.string);\n               break;\n\n               case DATATYPE_BOOLEAN:\n                   if (item->u.boolean)\n                       virBufferAddLit(buf, \"true\");\n                   else\n                       virBufferAddLit(buf, \"false\");\n               break;\n\n               case DATATYPE_IPSETNAME:\n               case DATATYPE_IPSETFLAGS:\n               case DATATYPE_STRING:\n               case DATATYPE_LAST:\n               default:\n                   virBufferAsprintf(buf,\n                                     \"UNSUPPORTED DATATYPE 0x%02x\\n\",\n                                     att[i].datatype);\n               }\n            }\n            virBufferAddLit(buf, \"'\");\n        }\n        i++;\n    }\n    if (typeShown)\n       virBufferAddLit(buf, \"/>\\n\");\n\n    if (neverShown)\n       virBufferAsprintf(buf,\n                         \"<%s/>\\n\", type);\n\n    return;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<%s/>\\n\"",
            "type"
          ],
          "line": 2986
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"'\""
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"false\""
          ],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"true\""
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"%s\"",
            "item->u.string"
          ],
          "line": 2958
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWIPAddressFormat",
          "args": [
            "buf",
            "&item->u.ipaddr"
          ],
          "line": 2945
        },
        "resolved": true,
        "details": {
          "function_name": "virNWIPAddressFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "2836-2846",
          "snippet": "static void\nvirNWIPAddressFormat(virBufferPtr buf,\n                     virSocketAddrPtr ipaddr)\n{\n    char *output = virSocketAddrFormat(ipaddr);\n\n    if (output) {\n        virBufferAdd(buf, output, -1);\n        VIR_FREE(output);\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirNWIPAddressFormat(virBufferPtr buf,\n                     virSocketAddrPtr ipaddr)\n{\n    char *output = virSocketAddrFormat(ipaddr);\n\n    if (output) {\n        virBufferAdd(buf, output, -1);\n        VIR_FREE(output);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterVarAccessPrint",
          "args": [
            "item->varAccess",
            "buf"
          ],
          "line": 2910
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterVarAccessPrint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_params.c",
          "lines": "959-974",
          "snippet": "void\nvirNWFilterVarAccessPrint(virNWFilterVarAccessPtr vap, virBufferPtr buf)\n{\n    virBufferAdd(buf, vap->varName, -1);\n    switch (vap->accessType) {\n    case VIR_NWFILTER_VAR_ACCESS_ELEMENT:\n        virBufferAsprintf(buf, \"[%u]\", vap->u.index.idx);\n        break;\n    case VIR_NWFILTER_VAR_ACCESS_ITERATOR:\n        if (vap->u.iterId != 0)\n            virBufferAsprintf(buf, \"[@%u]\", vap->u.iterId);\n        break;\n    case VIR_NWFILTER_VAR_ACCESS_LAST:\n        break;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNWFilterVarAccessSetIntIterId(virNWFilterVarAccessPtr,\n                                             unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNWFilterVarAccessSetIntIterId(virNWFilterVarAccessPtr,\n                                             unsigned int);\n\nvoid\nvirNWFilterVarAccessPrint(virNWFilterVarAccessPtr vap, virBufferPtr buf)\n{\n    virBufferAdd(buf, vap->varName, -1);\n    switch (vap->accessType) {\n    case VIR_NWFILTER_VAR_ACCESS_ELEMENT:\n        virBufferAsprintf(buf, \"[%u]\", vap->u.index.idx);\n        break;\n    case VIR_NWFILTER_VAR_ACCESS_ITERATOR:\n        if (vap->u.iterId != 0)\n            virBufferAsprintf(buf, \"[@%u]\", vap->u.iterId);\n        break;\n    case VIR_NWFILTER_VAR_ACCESS_LAST:\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddChar",
          "args": [
            "buf",
            "'$'"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "206-210",
          "snippet": "void\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"formatter for %s %s reported error\")",
            "type",
            "att[i].name"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"formatter for %s %s reported error\""
          ],
          "line": 2903
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "att[i].formatter",
          "args": [
            "buf",
            "def",
            "item"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 2883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" match='no'\""
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirNWFilterRuleDefDetailsFormat(virBufferPtr buf,\n                                const char *type,\n                                const virXMLAttr2Struct *att,\n                                virNWFilterRuleDefPtr def)\n{\n    size_t i = 0, j;\n    bool typeShown = false;\n    bool neverShown = true;\n    bool asHex;\n    enum match {\n        MATCH_NONE = 0,\n        MATCH_YES,\n        MATCH_NO\n    } matchShown = MATCH_NONE;\n    nwItemDesc *item;\n\n    while (att[i].name) {\n        VIR_WARNINGS_NO_CAST_ALIGN\n        item = (nwItemDesc *)((char *)def + att[i].dataIdx);\n        VIR_WARNINGS_RESET\n        virNWFilterEntryItemFlags flags = item->flags;\n        if ((flags & NWFILTER_ENTRY_ITEM_FLAG_EXISTS)) {\n            if (!typeShown) {\n                virBufferAsprintf(buf, \"<%s\", type);\n                typeShown = true;\n                neverShown = false;\n            }\n\n            if ((flags & NWFILTER_ENTRY_ITEM_FLAG_IS_NEG)) {\n                if (matchShown == MATCH_NONE) {\n                    virBufferAddLit(buf, \" match='no'\");\n                    matchShown = MATCH_NO;\n                } else if (matchShown == MATCH_YES) {\n                    virBufferAddLit(buf, \"/>\\n\");\n                    typeShown = 0;\n                    matchShown = MATCH_NONE;\n                    continue;\n                }\n            } else {\n                if (matchShown == MATCH_NO) {\n                    virBufferAddLit(buf, \"/>\\n\");\n                    typeShown = 0;\n                    matchShown = MATCH_NONE;\n                    continue;\n                }\n                matchShown = MATCH_YES;\n            }\n\n            virBufferAsprintf(buf, \" %s='\",\n                              att[i].name);\n            if (att[i].formatter && !(flags & NWFILTER_ENTRY_ITEM_FLAG_HAS_VAR)) {\n               if (!att[i].formatter(buf, def, item)) {\n                  virReportError(VIR_ERR_INTERNAL_ERROR,\n                                 _(\"formatter for %s %s reported error\"),\n                                 type,\n                                 att[i].name);\n                   return;\n               }\n            } else if ((flags & NWFILTER_ENTRY_ITEM_FLAG_HAS_VAR)) {\n                virBufferAddChar(buf, '$');\n                virNWFilterVarAccessPrint(item->varAccess, buf);\n            } else {\n               asHex = false;\n\n               switch (item->datatype) {\n\n               case DATATYPE_UINT8_HEX:\n                   asHex = true;\n                   G_GNUC_FALLTHROUGH;\n               case DATATYPE_IPMASK:\n               case DATATYPE_IPV6MASK:\n                   /* display all masks in CIDR format */\n               case DATATYPE_UINT8:\n                   virBufferAsprintf(buf, asHex ? \"0x%x\" : \"%d\",\n                                     item->u.u8);\n               break;\n\n               case DATATYPE_UINT16_HEX:\n                   asHex = true;\n                   G_GNUC_FALLTHROUGH;\n               case DATATYPE_UINT16:\n                   virBufferAsprintf(buf, asHex ? \"0x%x\" : \"%d\",\n                                     item->u.u16);\n               break;\n\n               case DATATYPE_UINT32_HEX:\n                   asHex = true;\n                   G_GNUC_FALLTHROUGH;\n               case DATATYPE_UINT32:\n                   virBufferAsprintf(buf, asHex ? \"0x%x\" : \"%u\",\n                                     item->u.u32);\n               break;\n\n               case DATATYPE_IPADDR:\n               case DATATYPE_IPV6ADDR:\n                   virNWIPAddressFormat(buf,\n                                        &item->u.ipaddr);\n               break;\n\n               case DATATYPE_MACMASK:\n               case DATATYPE_MACADDR:\n                   for (j = 0; j < 6; j++)\n                       virBufferAsprintf(buf, \"%02x%s\",\n                                         item->u.macaddr.addr[j],\n                                         (j < 5) ? \":\" : \"\");\n               break;\n\n               case DATATYPE_STRINGCOPY:\n                   virBufferEscapeString(buf, \"%s\", item->u.string);\n               break;\n\n               case DATATYPE_BOOLEAN:\n                   if (item->u.boolean)\n                       virBufferAddLit(buf, \"true\");\n                   else\n                       virBufferAddLit(buf, \"false\");\n               break;\n\n               case DATATYPE_IPSETNAME:\n               case DATATYPE_IPSETFLAGS:\n               case DATATYPE_STRING:\n               case DATATYPE_LAST:\n               default:\n                   virBufferAsprintf(buf,\n                                     \"UNSUPPORTED DATATYPE 0x%02x\\n\",\n                                     att[i].datatype);\n               }\n            }\n            virBufferAddLit(buf, \"'\");\n        }\n        i++;\n    }\n    if (typeShown)\n       virBufferAddLit(buf, \"/>\\n\");\n\n    if (neverShown)\n       virBufferAsprintf(buf,\n                         \"<%s/>\\n\", type);\n\n    return;\n}"
  },
  {
    "function_name": "virNWIPAddressFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "2836-2846",
    "snippet": "static void\nvirNWIPAddressFormat(virBufferPtr buf,\n                     virSocketAddrPtr ipaddr)\n{\n    char *output = virSocketAddrFormat(ipaddr);\n\n    if (output) {\n        virBufferAdd(buf, output, -1);\n        VIR_FREE(output);\n    }\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "output"
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "buf",
            "output",
            "-1"
          ],
          "line": 2843
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "ipaddr"
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirNWIPAddressFormat(virBufferPtr buf,\n                     virSocketAddrPtr ipaddr)\n{\n    char *output = virSocketAddrFormat(ipaddr);\n\n    if (output) {\n        virBufferAdd(buf, output, -1);\n        VIR_FREE(output);\n    }\n}"
  },
  {
    "function_name": "virNWFilterDeleteDef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "2812-2833",
    "snippet": "int\nvirNWFilterDeleteDef(const char *configDir,\n                     virNWFilterDefPtr def)\n{\n    int ret = -1;\n    char *configFile = NULL;\n\n    if (!(configFile = virFileBuildPath(configDir, def->name, \".xml\")))\n        goto error;\n\n    if (unlink(configFile) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot remove config for %s\"),\n                       def->name);\n        goto error;\n    }\n\n    ret = 0;\n error:\n    VIR_FREE(configFile);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "configFile"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"cannot remove config for %s\")",
            "def->name"
          ],
          "line": 2823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot remove config for %s\""
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "configFile"
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileBuildPath",
          "args": [
            "configDir",
            "def->name",
            "\".xml\""
          ],
          "line": 2819
        },
        "resolved": true,
        "details": {
          "function_name": "virFileBuildPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3116-3128",
          "snippet": "char *\nvirFileBuildPath(const char *dir, const char *name, const char *ext)\n{\n    char *path;\n\n    if (ext == NULL) {\n        path = g_strdup_printf(\"%s/%s\", dir, name);\n    } else {\n        path = g_strdup_printf(\"%s/%s%s\", dir, name, ext);\n    }\n\n    return path;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFileBuildPath(const char *dir, const char *name, const char *ext)\n{\n    char *path;\n\n    if (ext == NULL) {\n        path = g_strdup_printf(\"%s/%s\", dir, name);\n    } else {\n        path = g_strdup_printf(\"%s/%s%s\", dir, name, ext);\n    }\n\n    return path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirNWFilterDeleteDef(const char *configDir,\n                     virNWFilterDefPtr def)\n{\n    int ret = -1;\n    char *configFile = NULL;\n\n    if (!(configFile = virFileBuildPath(configDir, def->name, \".xml\")))\n        goto error;\n\n    if (unlink(configFile) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot remove config for %s\"),\n                       def->name);\n        goto error;\n    }\n\n    ret = 0;\n error:\n    VIR_FREE(configFile);\n    return ret;\n}"
  },
  {
    "function_name": "virNWFilterSaveConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "2785-2809",
    "snippet": "int\nvirNWFilterSaveConfig(const char *configDir,\n                      virNWFilterDefPtr def)\n{\n    int ret = -1;\n    char *xml;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *configFile = NULL;\n\n    if (!(xml = virNWFilterDefFormat(def)))\n        goto cleanup;\n\n    if (!(configFile = virFileBuildPath(configDir, def->name, \".xml\")))\n        goto cleanup;\n\n    virUUIDFormat(def->uuid, uuidstr);\n    ret = virXMLSaveFile(configFile,\n                         virXMLPickShellSafeComment(def->name, uuidstr),\n                         \"nwfilter-edit\", xml);\n\n cleanup:\n    VIR_FREE(configFile);\n    VIR_FREE(xml);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 2807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "configFile"
          ],
          "line": 2806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLSaveFile",
          "args": [
            "configFile",
            "virXMLPickShellSafeComment(def->name, uuidstr)",
            "\"nwfilter-edit\"",
            "xml"
          ],
          "line": 2801
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLSaveFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "941-950",
          "snippet": "int\nvirXMLSaveFile(const char *path,\n               const char *warnName,\n               const char *warnCommand,\n               const char *xml)\n{\n    struct virXMLRewriteFileData data = { warnName, warnCommand, xml };\n\n    return virFileRewrite(path, S_IRUSR | S_IWUSR, virXMLRewriteFile, &data);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXMLSaveFile(const char *path,\n               const char *warnName,\n               const char *warnCommand,\n               const char *xml)\n{\n    struct virXMLRewriteFileData data = { warnName, warnCommand, xml };\n\n    return virFileRewrite(path, S_IRUSR | S_IWUSR, virXMLRewriteFile, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLPickShellSafeComment",
          "args": [
            "def->name",
            "uuidstr"
          ],
          "line": 2802
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPickShellSafeComment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "863-872",
          "snippet": "const char *virXMLPickShellSafeComment(const char *str1, const char *str2)\n{\n    if (str1 && !strpbrk(str1, \"\\r\\t\\n !\\\"#$&'()*;<>?[\\\\]^`{|}~\") &&\n        !strstr(str1, \"--\"))\n        return str1;\n    if (str2 && !strpbrk(str2, \"\\r\\t\\n !\\\"#$&'()*;<>?[\\\\]^`{|}~\") &&\n        !strstr(str2, \"--\"))\n        return str2;\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nconst char *virXMLPickShellSafeComment(const char *str1, const char *str2)\n{\n    if (str1 && !strpbrk(str1, \"\\r\\t\\n !\\\"#$&'()*;<>?[\\\\]^`{|}~\") &&\n        !strstr(str1, \"--\"))\n        return str1;\n    if (str2 && !strpbrk(str2, \"\\r\\t\\n !\\\"#$&'()*;<>?[\\\\]^`{|}~\") &&\n        !strstr(str2, \"--\"))\n        return str2;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "def->uuid",
            "uuidstr"
          ],
          "line": 2800
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileBuildPath",
          "args": [
            "configDir",
            "def->name",
            "\".xml\""
          ],
          "line": 2797
        },
        "resolved": true,
        "details": {
          "function_name": "virFileBuildPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3116-3128",
          "snippet": "char *\nvirFileBuildPath(const char *dir, const char *name, const char *ext)\n{\n    char *path;\n\n    if (ext == NULL) {\n        path = g_strdup_printf(\"%s/%s\", dir, name);\n    } else {\n        path = g_strdup_printf(\"%s/%s%s\", dir, name, ext);\n    }\n\n    return path;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFileBuildPath(const char *dir, const char *name, const char *ext)\n{\n    char *path;\n\n    if (ext == NULL) {\n        path = g_strdup_printf(\"%s/%s\", dir, name);\n    } else {\n        path = g_strdup_printf(\"%s/%s%s\", dir, name, ext);\n    }\n\n    return path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterDefFormat",
          "args": [
            "def"
          ],
          "line": 2794
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "3044-3076",
          "snippet": "char *\nvirNWFilterDefFormat(const virNWFilterDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char uuid[VIR_UUID_STRING_BUFLEN];\n    size_t i;\n\n    virBufferAsprintf(&buf, \"<filter name='%s' chain='%s'\",\n                      def->name,\n                      def->chainsuffix);\n    if (def->chainPriority != 0)\n        virBufferAsprintf(&buf, \" priority='%d'\",\n                          def->chainPriority);\n    virBufferAddLit(&buf, \">\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    virUUIDFormat(def->uuid, uuid);\n    virBufferAsprintf(&buf, \"<uuid>%s</uuid>\\n\", uuid);\n\n    for (i = 0; i < def->nentries; i++) {\n        if (virNWFilterEntryFormat(&buf, def->filterEntries[i]) < 0)\n            goto err_exit;\n    }\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</filter>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n err_exit:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirNWFilterDefFormat(const virNWFilterDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char uuid[VIR_UUID_STRING_BUFLEN];\n    size_t i;\n\n    virBufferAsprintf(&buf, \"<filter name='%s' chain='%s'\",\n                      def->name,\n                      def->chainsuffix);\n    if (def->chainPriority != 0)\n        virBufferAsprintf(&buf, \" priority='%d'\",\n                          def->chainPriority);\n    virBufferAddLit(&buf, \">\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    virUUIDFormat(def->uuid, uuid);\n    virBufferAsprintf(&buf, \"<uuid>%s</uuid>\\n\", uuid);\n\n    for (i = 0; i < def->nentries; i++) {\n        if (virNWFilterEntryFormat(&buf, def->filterEntries[i]) < 0)\n            goto err_exit;\n    }\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</filter>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n err_exit:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirNWFilterSaveConfig(const char *configDir,\n                      virNWFilterDefPtr def)\n{\n    int ret = -1;\n    char *xml;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *configFile = NULL;\n\n    if (!(xml = virNWFilterDefFormat(def)))\n        goto cleanup;\n\n    if (!(configFile = virFileBuildPath(configDir, def->name, \".xml\")))\n        goto cleanup;\n\n    virUUIDFormat(def->uuid, uuidstr);\n    ret = virXMLSaveFile(configFile,\n                         virXMLPickShellSafeComment(def->name, uuidstr),\n                         \"nwfilter-edit\", xml);\n\n cleanup:\n    VIR_FREE(configFile);\n    VIR_FREE(xml);\n    return ret;\n}"
  },
  {
    "function_name": "virNWFilterDefParseFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "2778-2782",
    "snippet": "virNWFilterDefPtr\nvirNWFilterDefParseFile(const char *filename)\n{\n    return virNWFilterDefParse(NULL, filename);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNWFilterDefParse",
          "args": [
            "NULL",
            "filename"
          ],
          "line": 2781
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterDefParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "2755-2768",
          "snippet": "static virNWFilterDefPtr\nvirNWFilterDefParse(const char *xmlStr,\n                    const char *filename)\n{\n    virNWFilterDefPtr def = NULL;\n    xmlDocPtr xml;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(nwfilter_definition)\")))) {\n        def = virNWFilterDefParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNWFilterDefPtr\nvirNWFilterDefParse(const char *xmlStr,\n                    const char *filename)\n{\n    virNWFilterDefPtr def = NULL;\n    xmlDocPtr xml;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(nwfilter_definition)\")))) {\n        def = virNWFilterDefParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirNWFilterDefPtr\nvirNWFilterDefParseFile(const char *filename)\n{\n    return virNWFilterDefParse(NULL, filename);\n}"
  },
  {
    "function_name": "virNWFilterDefParseString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "2771-2775",
    "snippet": "virNWFilterDefPtr\nvirNWFilterDefParseString(const char *xmlStr)\n{\n    return virNWFilterDefParse(xmlStr, NULL);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNWFilterDefParse",
          "args": [
            "xmlStr",
            "NULL"
          ],
          "line": 2774
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterDefParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "2755-2768",
          "snippet": "static virNWFilterDefPtr\nvirNWFilterDefParse(const char *xmlStr,\n                    const char *filename)\n{\n    virNWFilterDefPtr def = NULL;\n    xmlDocPtr xml;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(nwfilter_definition)\")))) {\n        def = virNWFilterDefParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNWFilterDefPtr\nvirNWFilterDefParse(const char *xmlStr,\n                    const char *filename)\n{\n    virNWFilterDefPtr def = NULL;\n    xmlDocPtr xml;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(nwfilter_definition)\")))) {\n        def = virNWFilterDefParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirNWFilterDefPtr\nvirNWFilterDefParseString(const char *xmlStr)\n{\n    return virNWFilterDefParse(xmlStr, NULL);\n}"
  },
  {
    "function_name": "virNWFilterDefParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "2755-2768",
    "snippet": "static virNWFilterDefPtr\nvirNWFilterDefParse(const char *xmlStr,\n                    const char *filename)\n{\n    virNWFilterDefPtr def = NULL;\n    xmlDocPtr xml;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(nwfilter_definition)\")))) {\n        def = virNWFilterDefParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "xml"
          ],
          "line": 2764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterDefParseNode",
          "args": [
            "xml",
            "xmlDocGetRootElement(xml)"
          ],
          "line": 2763
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterDefParseNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "2734-2752",
          "snippet": "virNWFilterDefPtr\nvirNWFilterDefParseNode(xmlDocPtr xml,\n                        xmlNodePtr root)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (STRNEQ((const char *)root->name, \"filter\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\",\n                       _(\"unknown root element for nw filter\"));\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virNWFilterDefParseXML(ctxt);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirNWFilterDefPtr\nvirNWFilterDefParseNode(xmlDocPtr xml,\n                        xmlNodePtr root)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (STRNEQ((const char *)root->name, \"filter\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\",\n                       _(\"unknown root element for nw filter\"));\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virNWFilterDefParseXML(ctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlDocGetRootElement",
          "args": [
            "xml"
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLParse",
          "args": [
            "filename",
            "xmlStr",
            "_(\"(nwfilter_definition)\")"
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"(nwfilter_definition)\""
          ],
          "line": 2762
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNWFilterDefPtr\nvirNWFilterDefParse(const char *xmlStr,\n                    const char *filename)\n{\n    virNWFilterDefPtr def = NULL;\n    xmlDocPtr xml;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(nwfilter_definition)\")))) {\n        def = virNWFilterDefParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}"
  },
  {
    "function_name": "virNWFilterDefParseNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "2734-2752",
    "snippet": "virNWFilterDefPtr\nvirNWFilterDefParseNode(xmlDocPtr xml,\n                        xmlNodePtr root)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (STRNEQ((const char *)root->name, \"filter\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\",\n                       _(\"unknown root element for nw filter\"));\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virNWFilterDefParseXML(ctxt);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNWFilterDefParseXML",
          "args": [
            "ctxt"
          ],
          "line": 2751
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "2607-2731",
          "snippet": "static virNWFilterDefPtr\nvirNWFilterDefParseXML(xmlXPathContextPtr ctxt)\n{\n    virNWFilterDefPtr ret;\n    xmlNodePtr curr = ctxt->node;\n    char *uuid = NULL;\n    char *chain = NULL;\n    char *chain_pri_s = NULL;\n    virNWFilterEntryPtr entry;\n    int chain_priority;\n    const char *name_prefix;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->name = virXPathString(\"string(./@name)\", ctxt);\n    if (!ret->name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"filter has no name\"));\n        goto cleanup;\n    }\n\n    chain_pri_s = virXPathString(\"string(./@priority)\", ctxt);\n    if (chain_pri_s) {\n        if (virStrToLong_i(chain_pri_s, NULL, 10, &chain_priority) < 0) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Could not parse chain priority '%s'\"),\n                           chain_pri_s);\n            goto cleanup;\n        }\n        if (chain_priority < NWFILTER_MIN_FILTER_PRIORITY ||\n            chain_priority > NWFILTER_MAX_FILTER_PRIORITY) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Priority '%d' is outside valid \"\n                             \"range of [%d,%d]\"),\n                           chain_priority,\n                           NWFILTER_MIN_FILTER_PRIORITY,\n                           NWFILTER_MAX_FILTER_PRIORITY);\n            goto cleanup;\n        }\n    }\n\n    chain = virXPathString(\"string(./@chain)\", ctxt);\n    if (chain) {\n        name_prefix = virNWFilterIsAllowedChain(chain);\n        if (name_prefix == NULL)\n            goto cleanup;\n        ret->chainsuffix = chain;\n\n        if (chain_pri_s) {\n            ret->chainPriority = chain_priority;\n        } else {\n            /* assign default priority if none can be found via lookup */\n            if (intMapGetByString(chain_priorities, name_prefix,\n                                  0, &ret->chainPriority) < 0) {\n                ret->chainPriority = (NWFILTER_MAX_FILTER_PRIORITY +\n                                      NWFILTER_MIN_FILTER_PRIORITY) / 2;\n            }\n        }\n        chain = NULL;\n    } else {\n        ret->chainsuffix = g_strdup(virNWFilterChainSuffixTypeToString(VIR_NWFILTER_CHAINSUFFIX_ROOT));\n    }\n\n    uuid = virXPathString(\"string(./uuid)\", ctxt);\n    ret->uuid_specified = (uuid != NULL);\n    if (uuid == NULL) {\n        if (virUUIDGenerate(ret->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"unable to generate uuid\"));\n            goto cleanup;\n        }\n    } else {\n        if (virUUIDParse(uuid, ret->uuid) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"malformed uuid element\"));\n            goto cleanup;\n        }\n        VIR_FREE(uuid);\n    }\n\n    curr = curr->children;\n\n    while (curr != NULL) {\n        if (curr->type == XML_ELEMENT_NODE) {\n            if (VIR_ALLOC(entry) < 0)\n                goto cleanup;\n\n            if (virXMLNodeNameEqual(curr, \"rule\")) {\n                if (!(entry->rule = virNWFilterRuleParse(curr))) {\n                    virNWFilterEntryFree(entry);\n                    goto cleanup;\n                }\n            } else if (virXMLNodeNameEqual(curr, \"filterref\")) {\n                if (!(entry->include = virNWFilterIncludeParse(curr))) {\n                    virNWFilterEntryFree(entry);\n                    goto cleanup;\n                }\n            }\n\n            if (entry->rule || entry->include) {\n                if (VIR_APPEND_ELEMENT_COPY(ret->filterEntries,\n                                            ret->nentries, entry) < 0) {\n                    virNWFilterEntryFree(entry);\n                    goto cleanup;\n                }\n            } else {\n                virNWFilterEntryFree(entry);\n            }\n        }\n        curr = curr->next;\n    }\n\n    VIR_FREE(chain);\n    VIR_FREE(chain_pri_s);\n\n    return ret;\n\n cleanup:\n    virNWFilterDefFree(ret);\n    VIR_FREE(chain);\n    VIR_FREE(uuid);\n    VIR_FREE(chain_pri_s);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct int_map chain_priorities[] = {\n    INTMAP_ENTRY(NWFILTER_ROOT_FILTER_PRI, \"root\"),\n    INTMAP_ENTRY(NWFILTER_MAC_FILTER_PRI,  \"mac\"),\n    INTMAP_ENTRY(NWFILTER_VLAN_FILTER_PRI, \"vlan\"),\n    INTMAP_ENTRY(NWFILTER_IPV4_FILTER_PRI, \"ipv4\"),\n    INTMAP_ENTRY(NWFILTER_IPV6_FILTER_PRI, \"ipv6\"),\n    INTMAP_ENTRY(NWFILTER_ARP_FILTER_PRI,  \"arp\"),\n    INTMAP_ENTRY(NWFILTER_RARP_FILTER_PRI, \"rarp\"),\n    INTMAP_ENTRY_LAST,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map chain_priorities[] = {\n    INTMAP_ENTRY(NWFILTER_ROOT_FILTER_PRI, \"root\"),\n    INTMAP_ENTRY(NWFILTER_MAC_FILTER_PRI,  \"mac\"),\n    INTMAP_ENTRY(NWFILTER_VLAN_FILTER_PRI, \"vlan\"),\n    INTMAP_ENTRY(NWFILTER_IPV4_FILTER_PRI, \"ipv4\"),\n    INTMAP_ENTRY(NWFILTER_IPV6_FILTER_PRI, \"ipv6\"),\n    INTMAP_ENTRY(NWFILTER_ARP_FILTER_PRI,  \"arp\"),\n    INTMAP_ENTRY(NWFILTER_RARP_FILTER_PRI, \"rarp\"),\n    INTMAP_ENTRY_LAST,\n};\n\nstatic virNWFilterDefPtr\nvirNWFilterDefParseXML(xmlXPathContextPtr ctxt)\n{\n    virNWFilterDefPtr ret;\n    xmlNodePtr curr = ctxt->node;\n    char *uuid = NULL;\n    char *chain = NULL;\n    char *chain_pri_s = NULL;\n    virNWFilterEntryPtr entry;\n    int chain_priority;\n    const char *name_prefix;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->name = virXPathString(\"string(./@name)\", ctxt);\n    if (!ret->name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"filter has no name\"));\n        goto cleanup;\n    }\n\n    chain_pri_s = virXPathString(\"string(./@priority)\", ctxt);\n    if (chain_pri_s) {\n        if (virStrToLong_i(chain_pri_s, NULL, 10, &chain_priority) < 0) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Could not parse chain priority '%s'\"),\n                           chain_pri_s);\n            goto cleanup;\n        }\n        if (chain_priority < NWFILTER_MIN_FILTER_PRIORITY ||\n            chain_priority > NWFILTER_MAX_FILTER_PRIORITY) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Priority '%d' is outside valid \"\n                             \"range of [%d,%d]\"),\n                           chain_priority,\n                           NWFILTER_MIN_FILTER_PRIORITY,\n                           NWFILTER_MAX_FILTER_PRIORITY);\n            goto cleanup;\n        }\n    }\n\n    chain = virXPathString(\"string(./@chain)\", ctxt);\n    if (chain) {\n        name_prefix = virNWFilterIsAllowedChain(chain);\n        if (name_prefix == NULL)\n            goto cleanup;\n        ret->chainsuffix = chain;\n\n        if (chain_pri_s) {\n            ret->chainPriority = chain_priority;\n        } else {\n            /* assign default priority if none can be found via lookup */\n            if (intMapGetByString(chain_priorities, name_prefix,\n                                  0, &ret->chainPriority) < 0) {\n                ret->chainPriority = (NWFILTER_MAX_FILTER_PRIORITY +\n                                      NWFILTER_MIN_FILTER_PRIORITY) / 2;\n            }\n        }\n        chain = NULL;\n    } else {\n        ret->chainsuffix = g_strdup(virNWFilterChainSuffixTypeToString(VIR_NWFILTER_CHAINSUFFIX_ROOT));\n    }\n\n    uuid = virXPathString(\"string(./uuid)\", ctxt);\n    ret->uuid_specified = (uuid != NULL);\n    if (uuid == NULL) {\n        if (virUUIDGenerate(ret->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"unable to generate uuid\"));\n            goto cleanup;\n        }\n    } else {\n        if (virUUIDParse(uuid, ret->uuid) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"malformed uuid element\"));\n            goto cleanup;\n        }\n        VIR_FREE(uuid);\n    }\n\n    curr = curr->children;\n\n    while (curr != NULL) {\n        if (curr->type == XML_ELEMENT_NODE) {\n            if (VIR_ALLOC(entry) < 0)\n                goto cleanup;\n\n            if (virXMLNodeNameEqual(curr, \"rule\")) {\n                if (!(entry->rule = virNWFilterRuleParse(curr))) {\n                    virNWFilterEntryFree(entry);\n                    goto cleanup;\n                }\n            } else if (virXMLNodeNameEqual(curr, \"filterref\")) {\n                if (!(entry->include = virNWFilterIncludeParse(curr))) {\n                    virNWFilterEntryFree(entry);\n                    goto cleanup;\n                }\n            }\n\n            if (entry->rule || entry->include) {\n                if (VIR_APPEND_ELEMENT_COPY(ret->filterEntries,\n                                            ret->nentries, entry) < 0) {\n                    virNWFilterEntryFree(entry);\n                    goto cleanup;\n                }\n            } else {\n                virNWFilterEntryFree(entry);\n            }\n        }\n        curr = curr->next;\n    }\n\n    VIR_FREE(chain);\n    VIR_FREE(chain_pri_s);\n\n    return ret;\n\n cleanup:\n    virNWFilterDefFree(ret);\n    VIR_FREE(chain);\n    VIR_FREE(uuid);\n    VIR_FREE(chain_pri_s);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLXPathContextNew",
          "args": [
            "xml"
          ],
          "line": 2747
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLXPathContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "48-59",
          "snippet": "xmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"unknown root element for nw filter\")"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown root element for nw filter\""
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "(const char *)root->name",
            "\"filter\""
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirNWFilterDefPtr\nvirNWFilterDefParseNode(xmlDocPtr xml,\n                        xmlNodePtr root)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (STRNEQ((const char *)root->name, \"filter\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\",\n                       _(\"unknown root element for nw filter\"));\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virNWFilterDefParseXML(ctxt);\n}"
  },
  {
    "function_name": "virNWFilterDefParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "2607-2731",
    "snippet": "static virNWFilterDefPtr\nvirNWFilterDefParseXML(xmlXPathContextPtr ctxt)\n{\n    virNWFilterDefPtr ret;\n    xmlNodePtr curr = ctxt->node;\n    char *uuid = NULL;\n    char *chain = NULL;\n    char *chain_pri_s = NULL;\n    virNWFilterEntryPtr entry;\n    int chain_priority;\n    const char *name_prefix;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->name = virXPathString(\"string(./@name)\", ctxt);\n    if (!ret->name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"filter has no name\"));\n        goto cleanup;\n    }\n\n    chain_pri_s = virXPathString(\"string(./@priority)\", ctxt);\n    if (chain_pri_s) {\n        if (virStrToLong_i(chain_pri_s, NULL, 10, &chain_priority) < 0) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Could not parse chain priority '%s'\"),\n                           chain_pri_s);\n            goto cleanup;\n        }\n        if (chain_priority < NWFILTER_MIN_FILTER_PRIORITY ||\n            chain_priority > NWFILTER_MAX_FILTER_PRIORITY) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Priority '%d' is outside valid \"\n                             \"range of [%d,%d]\"),\n                           chain_priority,\n                           NWFILTER_MIN_FILTER_PRIORITY,\n                           NWFILTER_MAX_FILTER_PRIORITY);\n            goto cleanup;\n        }\n    }\n\n    chain = virXPathString(\"string(./@chain)\", ctxt);\n    if (chain) {\n        name_prefix = virNWFilterIsAllowedChain(chain);\n        if (name_prefix == NULL)\n            goto cleanup;\n        ret->chainsuffix = chain;\n\n        if (chain_pri_s) {\n            ret->chainPriority = chain_priority;\n        } else {\n            /* assign default priority if none can be found via lookup */\n            if (intMapGetByString(chain_priorities, name_prefix,\n                                  0, &ret->chainPriority) < 0) {\n                ret->chainPriority = (NWFILTER_MAX_FILTER_PRIORITY +\n                                      NWFILTER_MIN_FILTER_PRIORITY) / 2;\n            }\n        }\n        chain = NULL;\n    } else {\n        ret->chainsuffix = g_strdup(virNWFilterChainSuffixTypeToString(VIR_NWFILTER_CHAINSUFFIX_ROOT));\n    }\n\n    uuid = virXPathString(\"string(./uuid)\", ctxt);\n    ret->uuid_specified = (uuid != NULL);\n    if (uuid == NULL) {\n        if (virUUIDGenerate(ret->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"unable to generate uuid\"));\n            goto cleanup;\n        }\n    } else {\n        if (virUUIDParse(uuid, ret->uuid) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"malformed uuid element\"));\n            goto cleanup;\n        }\n        VIR_FREE(uuid);\n    }\n\n    curr = curr->children;\n\n    while (curr != NULL) {\n        if (curr->type == XML_ELEMENT_NODE) {\n            if (VIR_ALLOC(entry) < 0)\n                goto cleanup;\n\n            if (virXMLNodeNameEqual(curr, \"rule\")) {\n                if (!(entry->rule = virNWFilterRuleParse(curr))) {\n                    virNWFilterEntryFree(entry);\n                    goto cleanup;\n                }\n            } else if (virXMLNodeNameEqual(curr, \"filterref\")) {\n                if (!(entry->include = virNWFilterIncludeParse(curr))) {\n                    virNWFilterEntryFree(entry);\n                    goto cleanup;\n                }\n            }\n\n            if (entry->rule || entry->include) {\n                if (VIR_APPEND_ELEMENT_COPY(ret->filterEntries,\n                                            ret->nentries, entry) < 0) {\n                    virNWFilterEntryFree(entry);\n                    goto cleanup;\n                }\n            } else {\n                virNWFilterEntryFree(entry);\n            }\n        }\n        curr = curr->next;\n    }\n\n    VIR_FREE(chain);\n    VIR_FREE(chain_pri_s);\n\n    return ret;\n\n cleanup:\n    virNWFilterDefFree(ret);\n    VIR_FREE(chain);\n    VIR_FREE(uuid);\n    VIR_FREE(chain_pri_s);\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct int_map chain_priorities[] = {\n    INTMAP_ENTRY(NWFILTER_ROOT_FILTER_PRI, \"root\"),\n    INTMAP_ENTRY(NWFILTER_MAC_FILTER_PRI,  \"mac\"),\n    INTMAP_ENTRY(NWFILTER_VLAN_FILTER_PRI, \"vlan\"),\n    INTMAP_ENTRY(NWFILTER_IPV4_FILTER_PRI, \"ipv4\"),\n    INTMAP_ENTRY(NWFILTER_IPV6_FILTER_PRI, \"ipv6\"),\n    INTMAP_ENTRY(NWFILTER_ARP_FILTER_PRI,  \"arp\"),\n    INTMAP_ENTRY(NWFILTER_RARP_FILTER_PRI, \"rarp\"),\n    INTMAP_ENTRY_LAST,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "chain_pri_s"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid"
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "chain"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterDefFree",
          "args": [
            "ret"
          ],
          "line": 2726
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "344-360",
          "snippet": "void\nvirNWFilterDefFree(virNWFilterDefPtr def)\n{\n    size_t i;\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n\n    for (i = 0; i < def->nentries; i++)\n        virNWFilterEntryFree(def->filterEntries[i]);\n\n    VIR_FREE(def->filterEntries);\n    VIR_FREE(def->chainsuffix);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirNWFilterDefFree(virNWFilterDefPtr def)\n{\n    size_t i;\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n\n    for (i = 0; i < def->nentries; i++)\n        virNWFilterEntryFree(def->filterEntries[i]);\n\n    VIR_FREE(def->filterEntries);\n    VIR_FREE(def->chainsuffix);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "chain_pri_s"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "chain"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterEntryFree",
          "args": [
            "entry"
          ],
          "line": 2714
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterEntryFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "332-341",
          "snippet": "static void\nvirNWFilterEntryFree(virNWFilterEntryPtr entry)\n{\n    if (!entry)\n        return;\n\n    virNWFilterRuleDefFree(entry->rule);\n    virNWFilterIncludeDefFree(entry->include);\n    VIR_FREE(entry);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirNWFilterEntryFree(virNWFilterEntryPtr entry)\n{\n    if (!entry)\n        return;\n\n    virNWFilterRuleDefFree(entry->rule);\n    virNWFilterIncludeDefFree(entry->include);\n    VIR_FREE(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT_COPY",
          "args": [
            "ret->filterEntries",
            "ret->nentries",
            "entry"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterIncludeParse",
          "args": [
            "curr"
          ],
          "line": 2701
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterIncludeParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "2067-2092",
          "snippet": "static virNWFilterIncludeDefPtr\nvirNWFilterIncludeParse(xmlNodePtr cur)\n{\n    virNWFilterIncludeDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->filterref = virXMLPropString(cur, \"filter\");\n    if (!ret->filterref) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"rule node requires action attribute\"));\n        goto err_exit;\n    }\n\n    ret->params = virNWFilterParseParamAttributes(cur);\n    if (!ret->params)\n        goto err_exit;\n\n    return ret;\n\n err_exit:\n    virNWFilterIncludeDefFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNWFilterIncludeDefPtr\nvirNWFilterIncludeParse(xmlNodePtr cur)\n{\n    virNWFilterIncludeDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->filterref = virXMLPropString(cur, \"filter\");\n    if (!ret->filterref) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"rule node requires action attribute\"));\n        goto err_exit;\n    }\n\n    ret->params = virNWFilterParseParamAttributes(cur);\n    if (!ret->params)\n        goto err_exit;\n\n    return ret;\n\n err_exit:\n    virNWFilterIncludeDefFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLNodeNameEqual",
          "args": [
            "curr",
            "\"filterref\""
          ],
          "line": 2700
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeNameEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1013-1018",
          "snippet": "bool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nbool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleParse",
          "args": [
            "curr"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRuleParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "2412-2529",
          "snippet": "static virNWFilterRuleDefPtr\nvirNWFilterRuleParse(xmlNodePtr node)\n{\n    char *action;\n    char *direction;\n    char *prio;\n    char *statematch;\n    bool found;\n    int found_i = 0;\n    int priority;\n\n    xmlNodePtr cur;\n    virNWFilterRuleDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    action     = virXMLPropString(node, \"action\");\n    direction  = virXMLPropString(node, \"direction\");\n    prio       = virXMLPropString(node, \"priority\");\n    statematch = virXMLPropString(node, \"statematch\");\n\n    if (!action) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"rule node requires action attribute\"));\n        goto err_exit;\n    }\n\n    if ((ret->action = virNWFilterRuleActionTypeFromString(action)) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       \"%s\",\n                       _(\"unknown rule action attribute value\"));\n        goto err_exit;\n    }\n\n    if (!direction) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"rule node requires direction attribute\"));\n        goto err_exit;\n    }\n\n    if ((ret->tt = virNWFilterRuleDirectionTypeFromString(direction)) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       \"%s\",\n                       _(\"unknown rule direction attribute value\"));\n        goto err_exit;\n    }\n\n    ret->priority = MAX_RULE_PRIORITY / 2;\n\n    if (prio) {\n        if (virStrToLong_i(prio, NULL, 10, &priority) >= 0) {\n            if (priority <= MAX_RULE_PRIORITY &&\n                priority >= MIN_RULE_PRIORITY)\n                ret->priority = priority;\n        }\n    }\n\n    if (statematch &&\n        (STREQ(statematch, \"0\") || STRCASEEQ(statematch, \"false\")))\n        ret->flags |= RULE_FLAG_NO_STATEMATCH;\n\n    cur = node->children;\n\n    found = false;\n\n    while (cur != NULL) {\n        if (cur->type == XML_ELEMENT_NODE) {\n            size_t i = 0;\n            while (1) {\n                if (found)\n                    i = found_i;\n\n                if (virXMLNodeNameEqual(cur, virAttr[i].id)) {\n\n                    found_i = i;\n                    found = true;\n                    ret->prtclType = virAttr[i].prtclType;\n\n                    if (virNWFilterRuleDetailsParse(cur,\n                                                    ret,\n                                                    virAttr[i].att) < 0) {\n                        goto err_exit;\n                    }\n                    if (virNWFilterRuleValidate(ret) < 0)\n                        goto err_exit;\n                    break;\n                }\n                if (!found) {\n                    i++;\n                    if (!virAttr[i].id)\n                        break;\n                } else {\n                   break;\n                }\n            }\n        }\n\n        cur = cur->next;\n    }\n\n    virNWFilterRuleDefFixup(ret);\n\n cleanup:\n    VIR_FREE(prio);\n    VIR_FREE(action);\n    VIR_FREE(direction);\n    VIR_FREE(statematch);\n\n    return ret;\n\n err_exit:\n    virNWFilterRuleDefFree(ret);\n    ret = NULL;\n    goto cleanup;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const virAttributes virAttr[] = {\n    PROTOCOL_ENTRY(\"arp\",     arpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ARP),\n    PROTOCOL_ENTRY(\"rarp\",    arpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_RARP),\n    PROTOCOL_ENTRY(\"mac\",     macAttributes,     VIR_NWFILTER_RULE_PROTOCOL_MAC),\n    PROTOCOL_ENTRY(\"vlan\",    vlanAttributes,    VIR_NWFILTER_RULE_PROTOCOL_VLAN),\n    PROTOCOL_ENTRY(\"stp\",     stpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_STP),\n    PROTOCOL_ENTRY(\"ip\",      ipAttributes,      VIR_NWFILTER_RULE_PROTOCOL_IP),\n    PROTOCOL_ENTRY(\"ipv6\",    ipv6Attributes,    VIR_NWFILTER_RULE_PROTOCOL_IPV6),\n    PROTOCOL_ENTRY(\"tcp\",     tcpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_TCP),\n    PROTOCOL_ENTRY(\"udp\",     udpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_UDP),\n    PROTOCOL_ENTRY(\"udplite\", udpliteAttributes, VIR_NWFILTER_RULE_PROTOCOL_UDPLITE),\n    PROTOCOL_ENTRY(\"esp\",     espAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ESP),\n    PROTOCOL_ENTRY(\"ah\",      ahAttributes,      VIR_NWFILTER_RULE_PROTOCOL_AH),\n    PROTOCOL_ENTRY(\"sctp\",    sctpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_SCTP),\n    PROTOCOL_ENTRY(\"icmp\",    icmpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_ICMP),\n    PROTOCOL_ENTRY(\"all\",     allAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ALL),\n    PROTOCOL_ENTRY(\"igmp\",    igmpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_IGMP),\n    PROTOCOL_ENTRY(\"tcp-ipv6\",     tcpipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6),\n    PROTOCOL_ENTRY(\"udp-ipv6\",     udpipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6),\n    PROTOCOL_ENTRY(\"udplite-ipv6\", udpliteipv6Attributes, VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6),\n    PROTOCOL_ENTRY(\"esp-ipv6\",     espipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6),\n    PROTOCOL_ENTRY(\"ah-ipv6\",      ahipv6Attributes,      VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6),\n    PROTOCOL_ENTRY(\"sctp-ipv6\",    sctpipv6Attributes,    VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6),\n    PROTOCOL_ENTRY(\"icmpv6\",       icmpv6Attributes,      VIR_NWFILTER_RULE_PROTOCOL_ICMPV6),\n    PROTOCOL_ENTRY(\"all-ipv6\",     allipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6),\n    PROTOCOL_ENTRY_LAST\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const virAttributes virAttr[] = {\n    PROTOCOL_ENTRY(\"arp\",     arpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ARP),\n    PROTOCOL_ENTRY(\"rarp\",    arpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_RARP),\n    PROTOCOL_ENTRY(\"mac\",     macAttributes,     VIR_NWFILTER_RULE_PROTOCOL_MAC),\n    PROTOCOL_ENTRY(\"vlan\",    vlanAttributes,    VIR_NWFILTER_RULE_PROTOCOL_VLAN),\n    PROTOCOL_ENTRY(\"stp\",     stpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_STP),\n    PROTOCOL_ENTRY(\"ip\",      ipAttributes,      VIR_NWFILTER_RULE_PROTOCOL_IP),\n    PROTOCOL_ENTRY(\"ipv6\",    ipv6Attributes,    VIR_NWFILTER_RULE_PROTOCOL_IPV6),\n    PROTOCOL_ENTRY(\"tcp\",     tcpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_TCP),\n    PROTOCOL_ENTRY(\"udp\",     udpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_UDP),\n    PROTOCOL_ENTRY(\"udplite\", udpliteAttributes, VIR_NWFILTER_RULE_PROTOCOL_UDPLITE),\n    PROTOCOL_ENTRY(\"esp\",     espAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ESP),\n    PROTOCOL_ENTRY(\"ah\",      ahAttributes,      VIR_NWFILTER_RULE_PROTOCOL_AH),\n    PROTOCOL_ENTRY(\"sctp\",    sctpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_SCTP),\n    PROTOCOL_ENTRY(\"icmp\",    icmpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_ICMP),\n    PROTOCOL_ENTRY(\"all\",     allAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ALL),\n    PROTOCOL_ENTRY(\"igmp\",    igmpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_IGMP),\n    PROTOCOL_ENTRY(\"tcp-ipv6\",     tcpipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6),\n    PROTOCOL_ENTRY(\"udp-ipv6\",     udpipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6),\n    PROTOCOL_ENTRY(\"udplite-ipv6\", udpliteipv6Attributes, VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6),\n    PROTOCOL_ENTRY(\"esp-ipv6\",     espipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6),\n    PROTOCOL_ENTRY(\"ah-ipv6\",      ahipv6Attributes,      VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6),\n    PROTOCOL_ENTRY(\"sctp-ipv6\",    sctpipv6Attributes,    VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6),\n    PROTOCOL_ENTRY(\"icmpv6\",       icmpv6Attributes,      VIR_NWFILTER_RULE_PROTOCOL_ICMPV6),\n    PROTOCOL_ENTRY(\"all-ipv6\",     allipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6),\n    PROTOCOL_ENTRY_LAST\n};\n\nstatic virNWFilterRuleDefPtr\nvirNWFilterRuleParse(xmlNodePtr node)\n{\n    char *action;\n    char *direction;\n    char *prio;\n    char *statematch;\n    bool found;\n    int found_i = 0;\n    int priority;\n\n    xmlNodePtr cur;\n    virNWFilterRuleDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    action     = virXMLPropString(node, \"action\");\n    direction  = virXMLPropString(node, \"direction\");\n    prio       = virXMLPropString(node, \"priority\");\n    statematch = virXMLPropString(node, \"statematch\");\n\n    if (!action) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"rule node requires action attribute\"));\n        goto err_exit;\n    }\n\n    if ((ret->action = virNWFilterRuleActionTypeFromString(action)) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       \"%s\",\n                       _(\"unknown rule action attribute value\"));\n        goto err_exit;\n    }\n\n    if (!direction) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"rule node requires direction attribute\"));\n        goto err_exit;\n    }\n\n    if ((ret->tt = virNWFilterRuleDirectionTypeFromString(direction)) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       \"%s\",\n                       _(\"unknown rule direction attribute value\"));\n        goto err_exit;\n    }\n\n    ret->priority = MAX_RULE_PRIORITY / 2;\n\n    if (prio) {\n        if (virStrToLong_i(prio, NULL, 10, &priority) >= 0) {\n            if (priority <= MAX_RULE_PRIORITY &&\n                priority >= MIN_RULE_PRIORITY)\n                ret->priority = priority;\n        }\n    }\n\n    if (statematch &&\n        (STREQ(statematch, \"0\") || STRCASEEQ(statematch, \"false\")))\n        ret->flags |= RULE_FLAG_NO_STATEMATCH;\n\n    cur = node->children;\n\n    found = false;\n\n    while (cur != NULL) {\n        if (cur->type == XML_ELEMENT_NODE) {\n            size_t i = 0;\n            while (1) {\n                if (found)\n                    i = found_i;\n\n                if (virXMLNodeNameEqual(cur, virAttr[i].id)) {\n\n                    found_i = i;\n                    found = true;\n                    ret->prtclType = virAttr[i].prtclType;\n\n                    if (virNWFilterRuleDetailsParse(cur,\n                                                    ret,\n                                                    virAttr[i].att) < 0) {\n                        goto err_exit;\n                    }\n                    if (virNWFilterRuleValidate(ret) < 0)\n                        goto err_exit;\n                    break;\n                }\n                if (!found) {\n                    i++;\n                    if (!virAttr[i].id)\n                        break;\n                } else {\n                   break;\n                }\n            }\n        }\n\n        cur = cur->next;\n    }\n\n    virNWFilterRuleDefFixup(ret);\n\n cleanup:\n    VIR_FREE(prio);\n    VIR_FREE(action);\n    VIR_FREE(direction);\n    VIR_FREE(statematch);\n\n    return ret;\n\n err_exit:\n    virNWFilterRuleDefFree(ret);\n    ret = NULL;\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "entry"
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"malformed uuid element\")"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"malformed uuid element\""
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "uuid",
            "ret->uuid"
          ],
          "line": 2680
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"unable to generate uuid\")"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDGenerate",
          "args": [
            "ret->uuid"
          ],
          "line": 2674
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDGenerate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "50-79",
          "snippet": "int\nvirUUIDGenerate(unsigned char *uuid)\n{\n    if (uuid == NULL)\n        return -1;\n\n    if (virRandomBytes(uuid, VIR_UUID_BUFLEN) < 0)\n        return -1;\n\n    /*\n     * Make UUID RFC 4122 compliant. Following form will be used:\n     *\n     * xxxxxxxx-xxxx-Axxx-Bxxx-xxxxxxxxxxxx\n     *\n     * where\n     * A is version defined in 4.1.3 of RFC\n     *  Msb0  Msb1  Msb2  Msb3   Version  Description\n     *   0     1     0     0        4     The randomly or pseudo-\n     *                                    randomly generated version\n     *                                    specified in this document.\n     *\n     * B is variant defined in 4.1.1 of RFC\n     *  Msb0  Msb1  Msb2  Description\n     *   1     0     x    The variant specified in this document.\n     */\n    uuid[6] = (uuid[6] & 0x0F) | (4 << 4);\n    uuid[8] = (uuid[8] & 0x3F) | (2 << 6);\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDGenerate(unsigned char *uuid)\n{\n    if (uuid == NULL)\n        return -1;\n\n    if (virRandomBytes(uuid, VIR_UUID_BUFLEN) < 0)\n        return -1;\n\n    /*\n     * Make UUID RFC 4122 compliant. Following form will be used:\n     *\n     * xxxxxxxx-xxxx-Axxx-Bxxx-xxxxxxxxxxxx\n     *\n     * where\n     * A is version defined in 4.1.3 of RFC\n     *  Msb0  Msb1  Msb2  Msb3   Version  Description\n     *   0     1     0     0        4     The randomly or pseudo-\n     *                                    randomly generated version\n     *                                    specified in this document.\n     *\n     * B is variant defined in 4.1.1 of RFC\n     *  Msb0  Msb1  Msb2  Description\n     *   1     0     x    The variant specified in this document.\n     */\n    uuid[6] = (uuid[6] & 0x0F) | (4 << 4);\n    uuid[8] = (uuid[8] & 0x3F) | (2 << 6);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./uuid)\"",
            "ctxt"
          ],
          "line": 2671
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "virNWFilterChainSuffixTypeToString(VIR_NWFILTER_CHAINSUFFIX_ROOT)"
          ],
          "line": 2668
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterChainSuffixTypeToString",
          "args": [
            "VIR_NWFILTER_CHAINSUFFIX_ROOT"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intMapGetByString",
          "args": [
            "chain_priorities",
            "name_prefix",
            "0",
            "&ret->chainPriority"
          ],
          "line": 2660
        },
        "resolved": true,
        "details": {
          "function_name": "intMapGetByString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "280-298",
          "snippet": "static int\nintMapGetByString(const struct int_map *intmap,\n                  const char *str,\n                  int casecmp,\n                  int32_t *result)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if ((casecmp && STRCASEEQ(intmap[i].val, str)) ||\n            STREQ(intmap[i].val, str)) {\n            *result = intmap[i].attr;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nintMapGetByString(const struct int_map *intmap,\n                  const char *str,\n                  int casecmp,\n                  int32_t *result)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if ((casecmp && STRCASEEQ(intmap[i].val, str)) ||\n            STREQ(intmap[i].val, str)) {\n            *result = intmap[i].attr;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterIsAllowedChain",
          "args": [
            "chain"
          ],
          "line": 2651
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterIsAllowedChain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "2558-2604",
          "snippet": "static const char *\nvirNWFilterIsAllowedChain(const char *chainname)\n{\n    virNWFilterChainSuffixType i;\n    const char *name;\n    char *msg;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool printed = false;\n\n    if (!virNWFilterIsValidChainName(chainname))\n        return NULL;\n\n    for (i = 0; i < VIR_NWFILTER_CHAINSUFFIX_LAST; i++) {\n        name = virNWFilterChainSuffixTypeToString(i);\n        if (i == VIR_NWFILTER_CHAINSUFFIX_ROOT) {\n            /* allow 'root' as a complete name but not as a prefix */\n            if (STREQ(chainname, name))\n                return name;\n            if (STRPREFIX(chainname, name))\n                return NULL;\n        }\n        if (STRPREFIX(chainname, name))\n            return name;\n    }\n\n    virBufferAsprintf(&buf,\n                      _(\"Invalid chain name '%s'. Please use a chain name \"\n                      \"called '%s' or any of the following prefixes: \"),\n                      chainname,\n                      virNWFilterChainSuffixTypeToString(\n                          VIR_NWFILTER_CHAINSUFFIX_ROOT));\n    for (i = 0; i < VIR_NWFILTER_CHAINSUFFIX_LAST; i++) {\n        if (i == VIR_NWFILTER_CHAINSUFFIX_ROOT)\n            continue;\n        if (printed)\n            virBufferAddLit(&buf, \", \");\n        virBufferAdd(&buf, virNWFilterChainSuffixTypeToString(i), -1);\n        printed = true;\n    }\n\n    msg = virBufferContentAndReset(&buf);\n\n    virReportError(VIR_ERR_INVALID_ARG, \"%s\", msg);\n    VIR_FREE(msg);\n\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const char *\nvirNWFilterIsAllowedChain(const char *chainname)\n{\n    virNWFilterChainSuffixType i;\n    const char *name;\n    char *msg;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool printed = false;\n\n    if (!virNWFilterIsValidChainName(chainname))\n        return NULL;\n\n    for (i = 0; i < VIR_NWFILTER_CHAINSUFFIX_LAST; i++) {\n        name = virNWFilterChainSuffixTypeToString(i);\n        if (i == VIR_NWFILTER_CHAINSUFFIX_ROOT) {\n            /* allow 'root' as a complete name but not as a prefix */\n            if (STREQ(chainname, name))\n                return name;\n            if (STRPREFIX(chainname, name))\n                return NULL;\n        }\n        if (STRPREFIX(chainname, name))\n            return name;\n    }\n\n    virBufferAsprintf(&buf,\n                      _(\"Invalid chain name '%s'. Please use a chain name \"\n                      \"called '%s' or any of the following prefixes: \"),\n                      chainname,\n                      virNWFilterChainSuffixTypeToString(\n                          VIR_NWFILTER_CHAINSUFFIX_ROOT));\n    for (i = 0; i < VIR_NWFILTER_CHAINSUFFIX_LAST; i++) {\n        if (i == VIR_NWFILTER_CHAINSUFFIX_ROOT)\n            continue;\n        if (printed)\n            virBufferAddLit(&buf, \", \");\n        virBufferAdd(&buf, virNWFilterChainSuffixTypeToString(i), -1);\n        printed = true;\n    }\n\n    msg = virBufferContentAndReset(&buf);\n\n    virReportError(VIR_ERR_INVALID_ARG, \"%s\", msg);\n    VIR_FREE(msg);\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Priority '%d' is outside valid \"\n                             \"range of [%d,%d]\")",
            "chain_priority",
            "NWFILTER_MIN_FILTER_PRIORITY",
            "NWFILTER_MAX_FILTER_PRIORITY"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Could not parse chain priority '%s'\")",
            "chain_pri_s"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "chain_pri_s",
            "NULL",
            "10",
            "&chain_priority"
          ],
          "line": 2631
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"filter has no name\")"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ret"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map chain_priorities[] = {\n    INTMAP_ENTRY(NWFILTER_ROOT_FILTER_PRI, \"root\"),\n    INTMAP_ENTRY(NWFILTER_MAC_FILTER_PRI,  \"mac\"),\n    INTMAP_ENTRY(NWFILTER_VLAN_FILTER_PRI, \"vlan\"),\n    INTMAP_ENTRY(NWFILTER_IPV4_FILTER_PRI, \"ipv4\"),\n    INTMAP_ENTRY(NWFILTER_IPV6_FILTER_PRI, \"ipv6\"),\n    INTMAP_ENTRY(NWFILTER_ARP_FILTER_PRI,  \"arp\"),\n    INTMAP_ENTRY(NWFILTER_RARP_FILTER_PRI, \"rarp\"),\n    INTMAP_ENTRY_LAST,\n};\n\nstatic virNWFilterDefPtr\nvirNWFilterDefParseXML(xmlXPathContextPtr ctxt)\n{\n    virNWFilterDefPtr ret;\n    xmlNodePtr curr = ctxt->node;\n    char *uuid = NULL;\n    char *chain = NULL;\n    char *chain_pri_s = NULL;\n    virNWFilterEntryPtr entry;\n    int chain_priority;\n    const char *name_prefix;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->name = virXPathString(\"string(./@name)\", ctxt);\n    if (!ret->name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"filter has no name\"));\n        goto cleanup;\n    }\n\n    chain_pri_s = virXPathString(\"string(./@priority)\", ctxt);\n    if (chain_pri_s) {\n        if (virStrToLong_i(chain_pri_s, NULL, 10, &chain_priority) < 0) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Could not parse chain priority '%s'\"),\n                           chain_pri_s);\n            goto cleanup;\n        }\n        if (chain_priority < NWFILTER_MIN_FILTER_PRIORITY ||\n            chain_priority > NWFILTER_MAX_FILTER_PRIORITY) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Priority '%d' is outside valid \"\n                             \"range of [%d,%d]\"),\n                           chain_priority,\n                           NWFILTER_MIN_FILTER_PRIORITY,\n                           NWFILTER_MAX_FILTER_PRIORITY);\n            goto cleanup;\n        }\n    }\n\n    chain = virXPathString(\"string(./@chain)\", ctxt);\n    if (chain) {\n        name_prefix = virNWFilterIsAllowedChain(chain);\n        if (name_prefix == NULL)\n            goto cleanup;\n        ret->chainsuffix = chain;\n\n        if (chain_pri_s) {\n            ret->chainPriority = chain_priority;\n        } else {\n            /* assign default priority if none can be found via lookup */\n            if (intMapGetByString(chain_priorities, name_prefix,\n                                  0, &ret->chainPriority) < 0) {\n                ret->chainPriority = (NWFILTER_MAX_FILTER_PRIORITY +\n                                      NWFILTER_MIN_FILTER_PRIORITY) / 2;\n            }\n        }\n        chain = NULL;\n    } else {\n        ret->chainsuffix = g_strdup(virNWFilterChainSuffixTypeToString(VIR_NWFILTER_CHAINSUFFIX_ROOT));\n    }\n\n    uuid = virXPathString(\"string(./uuid)\", ctxt);\n    ret->uuid_specified = (uuid != NULL);\n    if (uuid == NULL) {\n        if (virUUIDGenerate(ret->uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"unable to generate uuid\"));\n            goto cleanup;\n        }\n    } else {\n        if (virUUIDParse(uuid, ret->uuid) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"malformed uuid element\"));\n            goto cleanup;\n        }\n        VIR_FREE(uuid);\n    }\n\n    curr = curr->children;\n\n    while (curr != NULL) {\n        if (curr->type == XML_ELEMENT_NODE) {\n            if (VIR_ALLOC(entry) < 0)\n                goto cleanup;\n\n            if (virXMLNodeNameEqual(curr, \"rule\")) {\n                if (!(entry->rule = virNWFilterRuleParse(curr))) {\n                    virNWFilterEntryFree(entry);\n                    goto cleanup;\n                }\n            } else if (virXMLNodeNameEqual(curr, \"filterref\")) {\n                if (!(entry->include = virNWFilterIncludeParse(curr))) {\n                    virNWFilterEntryFree(entry);\n                    goto cleanup;\n                }\n            }\n\n            if (entry->rule || entry->include) {\n                if (VIR_APPEND_ELEMENT_COPY(ret->filterEntries,\n                                            ret->nentries, entry) < 0) {\n                    virNWFilterEntryFree(entry);\n                    goto cleanup;\n                }\n            } else {\n                virNWFilterEntryFree(entry);\n            }\n        }\n        curr = curr->next;\n    }\n\n    VIR_FREE(chain);\n    VIR_FREE(chain_pri_s);\n\n    return ret;\n\n cleanup:\n    virNWFilterDefFree(ret);\n    VIR_FREE(chain);\n    VIR_FREE(uuid);\n    VIR_FREE(chain_pri_s);\n    return NULL;\n}"
  },
  {
    "function_name": "virNWFilterIsAllowedChain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "2558-2604",
    "snippet": "static const char *\nvirNWFilterIsAllowedChain(const char *chainname)\n{\n    virNWFilterChainSuffixType i;\n    const char *name;\n    char *msg;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool printed = false;\n\n    if (!virNWFilterIsValidChainName(chainname))\n        return NULL;\n\n    for (i = 0; i < VIR_NWFILTER_CHAINSUFFIX_LAST; i++) {\n        name = virNWFilterChainSuffixTypeToString(i);\n        if (i == VIR_NWFILTER_CHAINSUFFIX_ROOT) {\n            /* allow 'root' as a complete name but not as a prefix */\n            if (STREQ(chainname, name))\n                return name;\n            if (STRPREFIX(chainname, name))\n                return NULL;\n        }\n        if (STRPREFIX(chainname, name))\n            return name;\n    }\n\n    virBufferAsprintf(&buf,\n                      _(\"Invalid chain name '%s'. Please use a chain name \"\n                      \"called '%s' or any of the following prefixes: \"),\n                      chainname,\n                      virNWFilterChainSuffixTypeToString(\n                          VIR_NWFILTER_CHAINSUFFIX_ROOT));\n    for (i = 0; i < VIR_NWFILTER_CHAINSUFFIX_LAST; i++) {\n        if (i == VIR_NWFILTER_CHAINSUFFIX_ROOT)\n            continue;\n        if (printed)\n            virBufferAddLit(&buf, \", \");\n        virBufferAdd(&buf, virNWFilterChainSuffixTypeToString(i), -1);\n        printed = true;\n    }\n\n    msg = virBufferContentAndReset(&buf);\n\n    virReportError(VIR_ERR_INVALID_ARG, \"%s\", msg);\n    VIR_FREE(msg);\n\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "msg"
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "msg"
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "&buf",
            "virNWFilterChainSuffixTypeToString(i)",
            "-1"
          ],
          "line": 2594
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterChainSuffixTypeToString",
          "args": [
            "i"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\", \""
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "_(\"Invalid chain name '%s'. Please use a chain name \"\n                      \"called '%s' or any of the following prefixes: \")",
            "chainname",
            "virNWFilterChainSuffixTypeToString(\n                          VIR_NWFILTER_CHAINSUFFIX_ROOT)"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterChainSuffixTypeToString",
          "args": [
            "VIR_NWFILTER_CHAINSUFFIX_ROOT"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid chain name '%s'. Please use a chain name \"\n                      \"called '%s' or any of the following prefixes: \""
          ],
          "line": 2584
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "chainname",
            "name"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "chainname",
            "name"
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "chainname",
            "name"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterChainSuffixTypeToString",
          "args": [
            "i"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterIsValidChainName",
          "args": [
            "chainname"
          ],
          "line": 2567
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterIsValidChainName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "2532-2550",
          "snippet": "static bool\nvirNWFilterIsValidChainName(const char *chainname)\n{\n    if (strlen(chainname) > MAX_CHAIN_SUFFIX_SIZE) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Name of chain is longer than \"\n                         \"%u characters\"),\n                       MAX_CHAIN_SUFFIX_SIZE);\n        return false;\n    }\n\n    if (chainname[strspn(chainname, VALID_CHAINNAME)] != 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Chain name contains invalid characters\"));\n        return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool\nvirNWFilterIsValidChainName(const char *chainname)\n{\n    if (strlen(chainname) > MAX_CHAIN_SUFFIX_SIZE) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Name of chain is longer than \"\n                         \"%u characters\"),\n                       MAX_CHAIN_SUFFIX_SIZE);\n        return false;\n    }\n\n    if (chainname[strspn(chainname, VALID_CHAINNAME)] != 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Chain name contains invalid characters\"));\n        return false;\n    }\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const char *\nvirNWFilterIsAllowedChain(const char *chainname)\n{\n    virNWFilterChainSuffixType i;\n    const char *name;\n    char *msg;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool printed = false;\n\n    if (!virNWFilterIsValidChainName(chainname))\n        return NULL;\n\n    for (i = 0; i < VIR_NWFILTER_CHAINSUFFIX_LAST; i++) {\n        name = virNWFilterChainSuffixTypeToString(i);\n        if (i == VIR_NWFILTER_CHAINSUFFIX_ROOT) {\n            /* allow 'root' as a complete name but not as a prefix */\n            if (STREQ(chainname, name))\n                return name;\n            if (STRPREFIX(chainname, name))\n                return NULL;\n        }\n        if (STRPREFIX(chainname, name))\n            return name;\n    }\n\n    virBufferAsprintf(&buf,\n                      _(\"Invalid chain name '%s'. Please use a chain name \"\n                      \"called '%s' or any of the following prefixes: \"),\n                      chainname,\n                      virNWFilterChainSuffixTypeToString(\n                          VIR_NWFILTER_CHAINSUFFIX_ROOT));\n    for (i = 0; i < VIR_NWFILTER_CHAINSUFFIX_LAST; i++) {\n        if (i == VIR_NWFILTER_CHAINSUFFIX_ROOT)\n            continue;\n        if (printed)\n            virBufferAddLit(&buf, \", \");\n        virBufferAdd(&buf, virNWFilterChainSuffixTypeToString(i), -1);\n        printed = true;\n    }\n\n    msg = virBufferContentAndReset(&buf);\n\n    virReportError(VIR_ERR_INVALID_ARG, \"%s\", msg);\n    VIR_FREE(msg);\n\n    return NULL;\n}"
  },
  {
    "function_name": "virNWFilterIsValidChainName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "2532-2550",
    "snippet": "static bool\nvirNWFilterIsValidChainName(const char *chainname)\n{\n    if (strlen(chainname) > MAX_CHAIN_SUFFIX_SIZE) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Name of chain is longer than \"\n                         \"%u characters\"),\n                       MAX_CHAIN_SUFFIX_SIZE);\n        return false;\n    }\n\n    if (chainname[strspn(chainname, VALID_CHAINNAME)] != 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Chain name contains invalid characters\"));\n        return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Chain name contains invalid characters\")"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Chain name contains invalid characters\""
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "chainname",
            "VALID_CHAINNAME"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Name of chain is longer than \"\n                         \"%u characters\")",
            "MAX_CHAIN_SUFFIX_SIZE"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "chainname"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool\nvirNWFilterIsValidChainName(const char *chainname)\n{\n    if (strlen(chainname) > MAX_CHAIN_SUFFIX_SIZE) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Name of chain is longer than \"\n                         \"%u characters\"),\n                       MAX_CHAIN_SUFFIX_SIZE);\n        return false;\n    }\n\n    if (chainname[strspn(chainname, VALID_CHAINNAME)] != 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Chain name contains invalid characters\"));\n        return false;\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "virNWFilterRuleParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "2412-2529",
    "snippet": "static virNWFilterRuleDefPtr\nvirNWFilterRuleParse(xmlNodePtr node)\n{\n    char *action;\n    char *direction;\n    char *prio;\n    char *statematch;\n    bool found;\n    int found_i = 0;\n    int priority;\n\n    xmlNodePtr cur;\n    virNWFilterRuleDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    action     = virXMLPropString(node, \"action\");\n    direction  = virXMLPropString(node, \"direction\");\n    prio       = virXMLPropString(node, \"priority\");\n    statematch = virXMLPropString(node, \"statematch\");\n\n    if (!action) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"rule node requires action attribute\"));\n        goto err_exit;\n    }\n\n    if ((ret->action = virNWFilterRuleActionTypeFromString(action)) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       \"%s\",\n                       _(\"unknown rule action attribute value\"));\n        goto err_exit;\n    }\n\n    if (!direction) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"rule node requires direction attribute\"));\n        goto err_exit;\n    }\n\n    if ((ret->tt = virNWFilterRuleDirectionTypeFromString(direction)) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       \"%s\",\n                       _(\"unknown rule direction attribute value\"));\n        goto err_exit;\n    }\n\n    ret->priority = MAX_RULE_PRIORITY / 2;\n\n    if (prio) {\n        if (virStrToLong_i(prio, NULL, 10, &priority) >= 0) {\n            if (priority <= MAX_RULE_PRIORITY &&\n                priority >= MIN_RULE_PRIORITY)\n                ret->priority = priority;\n        }\n    }\n\n    if (statematch &&\n        (STREQ(statematch, \"0\") || STRCASEEQ(statematch, \"false\")))\n        ret->flags |= RULE_FLAG_NO_STATEMATCH;\n\n    cur = node->children;\n\n    found = false;\n\n    while (cur != NULL) {\n        if (cur->type == XML_ELEMENT_NODE) {\n            size_t i = 0;\n            while (1) {\n                if (found)\n                    i = found_i;\n\n                if (virXMLNodeNameEqual(cur, virAttr[i].id)) {\n\n                    found_i = i;\n                    found = true;\n                    ret->prtclType = virAttr[i].prtclType;\n\n                    if (virNWFilterRuleDetailsParse(cur,\n                                                    ret,\n                                                    virAttr[i].att) < 0) {\n                        goto err_exit;\n                    }\n                    if (virNWFilterRuleValidate(ret) < 0)\n                        goto err_exit;\n                    break;\n                }\n                if (!found) {\n                    i++;\n                    if (!virAttr[i].id)\n                        break;\n                } else {\n                   break;\n                }\n            }\n        }\n\n        cur = cur->next;\n    }\n\n    virNWFilterRuleDefFixup(ret);\n\n cleanup:\n    VIR_FREE(prio);\n    VIR_FREE(action);\n    VIR_FREE(direction);\n    VIR_FREE(statematch);\n\n    return ret;\n\n err_exit:\n    virNWFilterRuleDefFree(ret);\n    ret = NULL;\n    goto cleanup;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const virAttributes virAttr[] = {\n    PROTOCOL_ENTRY(\"arp\",     arpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ARP),\n    PROTOCOL_ENTRY(\"rarp\",    arpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_RARP),\n    PROTOCOL_ENTRY(\"mac\",     macAttributes,     VIR_NWFILTER_RULE_PROTOCOL_MAC),\n    PROTOCOL_ENTRY(\"vlan\",    vlanAttributes,    VIR_NWFILTER_RULE_PROTOCOL_VLAN),\n    PROTOCOL_ENTRY(\"stp\",     stpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_STP),\n    PROTOCOL_ENTRY(\"ip\",      ipAttributes,      VIR_NWFILTER_RULE_PROTOCOL_IP),\n    PROTOCOL_ENTRY(\"ipv6\",    ipv6Attributes,    VIR_NWFILTER_RULE_PROTOCOL_IPV6),\n    PROTOCOL_ENTRY(\"tcp\",     tcpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_TCP),\n    PROTOCOL_ENTRY(\"udp\",     udpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_UDP),\n    PROTOCOL_ENTRY(\"udplite\", udpliteAttributes, VIR_NWFILTER_RULE_PROTOCOL_UDPLITE),\n    PROTOCOL_ENTRY(\"esp\",     espAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ESP),\n    PROTOCOL_ENTRY(\"ah\",      ahAttributes,      VIR_NWFILTER_RULE_PROTOCOL_AH),\n    PROTOCOL_ENTRY(\"sctp\",    sctpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_SCTP),\n    PROTOCOL_ENTRY(\"icmp\",    icmpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_ICMP),\n    PROTOCOL_ENTRY(\"all\",     allAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ALL),\n    PROTOCOL_ENTRY(\"igmp\",    igmpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_IGMP),\n    PROTOCOL_ENTRY(\"tcp-ipv6\",     tcpipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6),\n    PROTOCOL_ENTRY(\"udp-ipv6\",     udpipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6),\n    PROTOCOL_ENTRY(\"udplite-ipv6\", udpliteipv6Attributes, VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6),\n    PROTOCOL_ENTRY(\"esp-ipv6\",     espipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6),\n    PROTOCOL_ENTRY(\"ah-ipv6\",      ahipv6Attributes,      VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6),\n    PROTOCOL_ENTRY(\"sctp-ipv6\",    sctpipv6Attributes,    VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6),\n    PROTOCOL_ENTRY(\"icmpv6\",       icmpv6Attributes,      VIR_NWFILTER_RULE_PROTOCOL_ICMPV6),\n    PROTOCOL_ENTRY(\"all-ipv6\",     allipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6),\n    PROTOCOL_ENTRY_LAST\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNWFilterRuleDefFree",
          "args": [
            "ret"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRuleDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "301-318",
          "snippet": "void\nvirNWFilterRuleDefFree(virNWFilterRuleDefPtr def)\n{\n    size_t i;\n    if (!def)\n        return;\n\n    for (i = 0; i < def->nVarAccess; i++)\n        virNWFilterVarAccessFree(def->varAccess[i]);\n\n    for (i = 0; i < def->nstrings; i++)\n        VIR_FREE(def->strings[i]);\n\n    VIR_FREE(def->varAccess);\n    VIR_FREE(def->strings);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirNWFilterRuleDefFree(virNWFilterRuleDefPtr def)\n{\n    size_t i;\n    if (!def)\n        return;\n\n    for (i = 0; i < def->nVarAccess; i++)\n        virNWFilterVarAccessFree(def->varAccess[i]);\n\n    for (i = 0; i < def->nstrings; i++)\n        VIR_FREE(def->strings[i]);\n\n    VIR_FREE(def->varAccess);\n    VIR_FREE(def->strings);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "statematch"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "direction"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "action"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "prio"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleDefFixup",
          "args": [
            "ret"
          ],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRuleDefFixup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "2196-2409",
          "snippet": "static void\nvirNWFilterRuleDefFixup(virNWFilterRuleDefPtr rule)\n{\n#define COPY_NEG_SIGN(A, B) \\\n    (A).flags = ((A).flags & ~NWFILTER_ENTRY_ITEM_FLAG_IS_NEG) | \\\n                ((B).flags &  NWFILTER_ENTRY_ITEM_FLAG_IS_NEG);\n\n    switch (rule->prtclType) {\n    case VIR_NWFILTER_RULE_PROTOCOL_MAC:\n        COPY_NEG_SIGN(rule->p.ethHdrFilter.ethHdr.dataSrcMACMask,\n                      rule->p.ethHdrFilter.ethHdr.dataSrcMACAddr);\n        COPY_NEG_SIGN(rule->p.ethHdrFilter.ethHdr.dataDstMACMask,\n                      rule->p.ethHdrFilter.ethHdr.dataDstMACAddr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_VLAN:\n        COPY_NEG_SIGN(rule->p.vlanHdrFilter.ethHdr.dataSrcMACMask,\n                      rule->p.vlanHdrFilter.ethHdr.dataSrcMACAddr);\n        COPY_NEG_SIGN(rule->p.vlanHdrFilter.ethHdr.dataDstMACMask,\n                      rule->p.vlanHdrFilter.ethHdr.dataDstMACAddr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_STP:\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.ethHdr.dataSrcMACMask,\n                      rule->p.stpHdrFilter.ethHdr.dataSrcMACAddr);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataRootPriHi,\n                      rule->p.stpHdrFilter.dataRootPri);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataRootAddrMask,\n                      rule->p.stpHdrFilter.dataRootAddr);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataRootCostHi,\n                      rule->p.stpHdrFilter.dataRootCost);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataSndrPrioHi,\n                      rule->p.stpHdrFilter.dataSndrPrio);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataSndrAddrMask,\n                      rule->p.stpHdrFilter.dataSndrAddr);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataPortHi,\n                      rule->p.stpHdrFilter.dataPort);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataAgeHi,\n                      rule->p.stpHdrFilter.dataAge);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataMaxAgeHi,\n                      rule->p.stpHdrFilter.dataMaxAge);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataHelloTimeHi,\n                      rule->p.stpHdrFilter.dataHelloTime);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataFwdDelayHi,\n                      rule->p.stpHdrFilter.dataFwdDelay);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IP:\n        COPY_NEG_SIGN(rule->p.ipHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.ipHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.ipHdrFilter.ipHdr.dataDstIPAddr);\n        virNWFilterRuleDefFixupIPSet(&rule->p.ipHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IPV6:\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.dataICMPTypeEnd,\n                      rule->p.ipv6HdrFilter.dataICMPTypeStart);\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.dataICMPCodeStart,\n                      rule->p.ipv6HdrFilter.dataICMPTypeStart);\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.dataICMPCodeEnd,\n                      rule->p.ipv6HdrFilter.dataICMPTypeStart);\n        virNWFilterRuleDefFixupIPSet(&rule->p.ipv6HdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_RARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_NONE:\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_TCP:\n    case VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6:\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.tcpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.tcpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.tcpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.tcpHdrFilter.ipHdr.dataDstIPFrom);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.portData.dataSrcPortEnd,\n                      rule->p.tcpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.portData.dataDstPortStart,\n                      rule->p.tcpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.portData.dataDstPortEnd,\n                      rule->p.tcpHdrFilter.portData.dataSrcPortStart);\n        virNWFilterRuleDefFixupIPSet(&rule->p.tcpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDP:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6:\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.udpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.udpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.udpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.udpHdrFilter.ipHdr.dataDstIPFrom);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.portData.dataSrcPortEnd,\n                      rule->p.udpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.portData.dataDstPortStart,\n                      rule->p.udpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.portData.dataDstPortEnd,\n                      rule->p.udpHdrFilter.portData.dataSrcPortStart);\n        virNWFilterRuleDefFixupIPSet(&rule->p.udpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITE:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6:\n        COPY_NEG_SIGN(rule->p.udpliteHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.udpliteHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.udpliteHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.udpliteHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.udpliteHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.udpliteHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.udpliteHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.udpliteHdrFilter.ipHdr.dataDstIPFrom);\n        virNWFilterRuleDefFixupIPSet(&rule->p.udpliteHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ESP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6:\n        COPY_NEG_SIGN(rule->p.espHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.espHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.espHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.espHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.espHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.espHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.espHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.espHdrFilter.ipHdr.dataDstIPFrom);\n        virNWFilterRuleDefFixupIPSet(&rule->p.espHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_AH:\n    case VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6:\n        COPY_NEG_SIGN(rule->p.ahHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.ahHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.ahHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.ahHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.ahHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.ahHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.ahHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.ahHdrFilter.ipHdr.dataDstIPFrom);\n        virNWFilterRuleDefFixupIPSet(&rule->p.ahHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTP:\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6:\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.sctpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.sctpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.sctpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.sctpHdrFilter.ipHdr.dataDstIPFrom);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.portData.dataSrcPortEnd,\n                      rule->p.sctpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.portData.dataDstPortStart,\n                      rule->p.sctpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.portData.dataDstPortEnd,\n                      rule->p.sctpHdrFilter.portData.dataSrcPortStart);\n        virNWFilterRuleDefFixupIPSet(&rule->p.sctpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMPV6:\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.icmpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.icmpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.icmpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.icmpHdrFilter.ipHdr.dataDstIPFrom);\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.dataICMPCode,\n                      rule->p.icmpHdrFilter.dataICMPType);\n        virNWFilterRuleDefFixupIPSet(&rule->p.icmpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ALL:\n    case VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6:\n        COPY_NEG_SIGN(rule->p.allHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.allHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.allHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.allHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.allHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.allHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.allHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.allHdrFilter.ipHdr.dataDstIPFrom);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IGMP:\n        COPY_NEG_SIGN(rule->p.igmpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.igmpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.igmpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.igmpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.igmpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.igmpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.igmpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.igmpHdrFilter.ipHdr.dataDstIPFrom);\n        virNWFilterRuleDefFixupIPSet(&rule->p.igmpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_LAST:\n    break;\n    }\n#undef COPY_NEG_SIGN\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirNWFilterRuleDefFixup(virNWFilterRuleDefPtr rule)\n{\n#define COPY_NEG_SIGN(A, B) \\\n    (A).flags = ((A).flags & ~NWFILTER_ENTRY_ITEM_FLAG_IS_NEG) | \\\n                ((B).flags &  NWFILTER_ENTRY_ITEM_FLAG_IS_NEG);\n\n    switch (rule->prtclType) {\n    case VIR_NWFILTER_RULE_PROTOCOL_MAC:\n        COPY_NEG_SIGN(rule->p.ethHdrFilter.ethHdr.dataSrcMACMask,\n                      rule->p.ethHdrFilter.ethHdr.dataSrcMACAddr);\n        COPY_NEG_SIGN(rule->p.ethHdrFilter.ethHdr.dataDstMACMask,\n                      rule->p.ethHdrFilter.ethHdr.dataDstMACAddr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_VLAN:\n        COPY_NEG_SIGN(rule->p.vlanHdrFilter.ethHdr.dataSrcMACMask,\n                      rule->p.vlanHdrFilter.ethHdr.dataSrcMACAddr);\n        COPY_NEG_SIGN(rule->p.vlanHdrFilter.ethHdr.dataDstMACMask,\n                      rule->p.vlanHdrFilter.ethHdr.dataDstMACAddr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_STP:\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.ethHdr.dataSrcMACMask,\n                      rule->p.stpHdrFilter.ethHdr.dataSrcMACAddr);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataRootPriHi,\n                      rule->p.stpHdrFilter.dataRootPri);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataRootAddrMask,\n                      rule->p.stpHdrFilter.dataRootAddr);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataRootCostHi,\n                      rule->p.stpHdrFilter.dataRootCost);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataSndrPrioHi,\n                      rule->p.stpHdrFilter.dataSndrPrio);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataSndrAddrMask,\n                      rule->p.stpHdrFilter.dataSndrAddr);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataPortHi,\n                      rule->p.stpHdrFilter.dataPort);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataAgeHi,\n                      rule->p.stpHdrFilter.dataAge);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataMaxAgeHi,\n                      rule->p.stpHdrFilter.dataMaxAge);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataHelloTimeHi,\n                      rule->p.stpHdrFilter.dataHelloTime);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataFwdDelayHi,\n                      rule->p.stpHdrFilter.dataFwdDelay);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IP:\n        COPY_NEG_SIGN(rule->p.ipHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.ipHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.ipHdrFilter.ipHdr.dataDstIPAddr);\n        virNWFilterRuleDefFixupIPSet(&rule->p.ipHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IPV6:\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.dataICMPTypeEnd,\n                      rule->p.ipv6HdrFilter.dataICMPTypeStart);\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.dataICMPCodeStart,\n                      rule->p.ipv6HdrFilter.dataICMPTypeStart);\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.dataICMPCodeEnd,\n                      rule->p.ipv6HdrFilter.dataICMPTypeStart);\n        virNWFilterRuleDefFixupIPSet(&rule->p.ipv6HdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_RARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_NONE:\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_TCP:\n    case VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6:\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.tcpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.tcpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.tcpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.tcpHdrFilter.ipHdr.dataDstIPFrom);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.portData.dataSrcPortEnd,\n                      rule->p.tcpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.portData.dataDstPortStart,\n                      rule->p.tcpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.portData.dataDstPortEnd,\n                      rule->p.tcpHdrFilter.portData.dataSrcPortStart);\n        virNWFilterRuleDefFixupIPSet(&rule->p.tcpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDP:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6:\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.udpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.udpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.udpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.udpHdrFilter.ipHdr.dataDstIPFrom);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.portData.dataSrcPortEnd,\n                      rule->p.udpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.portData.dataDstPortStart,\n                      rule->p.udpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.portData.dataDstPortEnd,\n                      rule->p.udpHdrFilter.portData.dataSrcPortStart);\n        virNWFilterRuleDefFixupIPSet(&rule->p.udpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITE:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6:\n        COPY_NEG_SIGN(rule->p.udpliteHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.udpliteHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.udpliteHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.udpliteHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.udpliteHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.udpliteHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.udpliteHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.udpliteHdrFilter.ipHdr.dataDstIPFrom);\n        virNWFilterRuleDefFixupIPSet(&rule->p.udpliteHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ESP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6:\n        COPY_NEG_SIGN(rule->p.espHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.espHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.espHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.espHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.espHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.espHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.espHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.espHdrFilter.ipHdr.dataDstIPFrom);\n        virNWFilterRuleDefFixupIPSet(&rule->p.espHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_AH:\n    case VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6:\n        COPY_NEG_SIGN(rule->p.ahHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.ahHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.ahHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.ahHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.ahHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.ahHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.ahHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.ahHdrFilter.ipHdr.dataDstIPFrom);\n        virNWFilterRuleDefFixupIPSet(&rule->p.ahHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTP:\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6:\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.sctpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.sctpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.sctpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.sctpHdrFilter.ipHdr.dataDstIPFrom);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.portData.dataSrcPortEnd,\n                      rule->p.sctpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.portData.dataDstPortStart,\n                      rule->p.sctpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.portData.dataDstPortEnd,\n                      rule->p.sctpHdrFilter.portData.dataSrcPortStart);\n        virNWFilterRuleDefFixupIPSet(&rule->p.sctpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMPV6:\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.icmpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.icmpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.icmpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.icmpHdrFilter.ipHdr.dataDstIPFrom);\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.dataICMPCode,\n                      rule->p.icmpHdrFilter.dataICMPType);\n        virNWFilterRuleDefFixupIPSet(&rule->p.icmpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ALL:\n    case VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6:\n        COPY_NEG_SIGN(rule->p.allHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.allHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.allHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.allHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.allHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.allHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.allHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.allHdrFilter.ipHdr.dataDstIPFrom);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IGMP:\n        COPY_NEG_SIGN(rule->p.igmpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.igmpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.igmpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.igmpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.igmpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.igmpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.igmpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.igmpHdrFilter.ipHdr.dataDstIPFrom);\n        virNWFilterRuleDefFixupIPSet(&rule->p.igmpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_LAST:\n    break;\n    }\n#undef COPY_NEG_SIGN\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleValidate",
          "args": [
            "ret"
          ],
          "line": 2498
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRuleValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "2116-2193",
          "snippet": "static int\nvirNWFilterRuleValidate(virNWFilterRuleDefPtr rule)\n{\n    int ret = 0;\n    portDataDefPtr portData = NULL;\n    nwItemDescPtr dataProtocolID = NULL;\n    const char *protocol = NULL;\n\n    switch (rule->prtclType) {\n    case VIR_NWFILTER_RULE_PROTOCOL_IP:\n        portData = &rule->p.ipHdrFilter.portData;\n        protocol = \"IP\";\n        dataProtocolID = &rule->p.ipHdrFilter.ipHdr.dataProtocolID;\n        G_GNUC_FALLTHROUGH;\n    case VIR_NWFILTER_RULE_PROTOCOL_IPV6:\n        if (portData == NULL) {\n            portData = &rule->p.ipv6HdrFilter.portData;\n            protocol = \"IPv6\";\n            dataProtocolID = &rule->p.ipv6HdrFilter.ipHdr.dataProtocolID;\n        }\n        if (HAS_ENTRY_ITEM(&portData->dataSrcPortStart) ||\n            HAS_ENTRY_ITEM(&portData->dataDstPortStart) ||\n            HAS_ENTRY_ITEM(&portData->dataSrcPortEnd) ||\n            HAS_ENTRY_ITEM(&portData->dataDstPortEnd)) {\n            if (HAS_ENTRY_ITEM(dataProtocolID)) {\n                switch (dataProtocolID->u.u8) {\n                case 6:   /* tcp */\n                case 17:  /* udp */\n                case 33:  /* dccp */\n                case 132: /* sctp */\n                    break;\n                default:\n                    ret = -1;\n                }\n            } else {\n                ret = -1;\n            }\n            if (ret < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s rule with port specification requires \"\n                                 \"protocol specification with protocol to be \"\n                                 \"either one of tcp(6), udp(17), dccp(33), or \"\n                                 \"sctp(132)\"), protocol);\n            }\n        }\n        break;\n    case VIR_NWFILTER_RULE_PROTOCOL_NONE:\n    case VIR_NWFILTER_RULE_PROTOCOL_MAC:\n    case VIR_NWFILTER_RULE_PROTOCOL_VLAN:\n    case VIR_NWFILTER_RULE_PROTOCOL_STP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_RARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_TCP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMP:\n    case VIR_NWFILTER_RULE_PROTOCOL_IGMP:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDP:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITE:\n    case VIR_NWFILTER_RULE_PROTOCOL_ESP:\n    case VIR_NWFILTER_RULE_PROTOCOL_AH:\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ALL:\n    case VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6:\n        break;\n    case VIR_NWFILTER_RULE_PROTOCOL_LAST:\n    default:\n        virReportEnumRangeError(virNWFilterRuleProtocolType, rule->prtclType);\n        return -1;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirNWFilterRuleValidate(virNWFilterRuleDefPtr rule)\n{\n    int ret = 0;\n    portDataDefPtr portData = NULL;\n    nwItemDescPtr dataProtocolID = NULL;\n    const char *protocol = NULL;\n\n    switch (rule->prtclType) {\n    case VIR_NWFILTER_RULE_PROTOCOL_IP:\n        portData = &rule->p.ipHdrFilter.portData;\n        protocol = \"IP\";\n        dataProtocolID = &rule->p.ipHdrFilter.ipHdr.dataProtocolID;\n        G_GNUC_FALLTHROUGH;\n    case VIR_NWFILTER_RULE_PROTOCOL_IPV6:\n        if (portData == NULL) {\n            portData = &rule->p.ipv6HdrFilter.portData;\n            protocol = \"IPv6\";\n            dataProtocolID = &rule->p.ipv6HdrFilter.ipHdr.dataProtocolID;\n        }\n        if (HAS_ENTRY_ITEM(&portData->dataSrcPortStart) ||\n            HAS_ENTRY_ITEM(&portData->dataDstPortStart) ||\n            HAS_ENTRY_ITEM(&portData->dataSrcPortEnd) ||\n            HAS_ENTRY_ITEM(&portData->dataDstPortEnd)) {\n            if (HAS_ENTRY_ITEM(dataProtocolID)) {\n                switch (dataProtocolID->u.u8) {\n                case 6:   /* tcp */\n                case 17:  /* udp */\n                case 33:  /* dccp */\n                case 132: /* sctp */\n                    break;\n                default:\n                    ret = -1;\n                }\n            } else {\n                ret = -1;\n            }\n            if (ret < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s rule with port specification requires \"\n                                 \"protocol specification with protocol to be \"\n                                 \"either one of tcp(6), udp(17), dccp(33), or \"\n                                 \"sctp(132)\"), protocol);\n            }\n        }\n        break;\n    case VIR_NWFILTER_RULE_PROTOCOL_NONE:\n    case VIR_NWFILTER_RULE_PROTOCOL_MAC:\n    case VIR_NWFILTER_RULE_PROTOCOL_VLAN:\n    case VIR_NWFILTER_RULE_PROTOCOL_STP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_RARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_TCP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMP:\n    case VIR_NWFILTER_RULE_PROTOCOL_IGMP:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDP:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITE:\n    case VIR_NWFILTER_RULE_PROTOCOL_ESP:\n    case VIR_NWFILTER_RULE_PROTOCOL_AH:\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ALL:\n    case VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6:\n        break;\n    case VIR_NWFILTER_RULE_PROTOCOL_LAST:\n    default:\n        virReportEnumRangeError(virNWFilterRuleProtocolType, rule->prtclType);\n        return -1;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleDetailsParse",
          "args": [
            "cur",
            "ret",
            "virAttr[i].att"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRuleDetailsParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "1799-2064",
          "snippet": "static int\nvirNWFilterRuleDetailsParse(xmlNodePtr node,\n                            virNWFilterRuleDefPtr nwf,\n                            const virXMLAttr2Struct *att)\n{\n    int rc = 0, g_rc = 0;\n    int idx = 0;\n    char *prop;\n    bool found = false;\n    enum attrDatatype datatype, att_datatypes;\n    virNWFilterEntryItemFlags *flags, match_flag = 0, flags_set = 0;\n    nwItemDesc *item;\n    int int_val;\n    unsigned int uint_val;\n    union data data;\n    valueValidator validator;\n    char *match = virXMLPropString(node, \"match\");\n    virSocketAddr ipaddr;\n    int base;\n\n    if (match && STREQ(match, \"no\"))\n        match_flag = NWFILTER_ENTRY_ITEM_FLAG_IS_NEG;\n    VIR_FREE(match);\n    match = NULL;\n\n    while (att[idx].name != NULL) {\n        prop = virXMLPropString(node, att[idx].name);\n\n        VIR_WARNINGS_NO_CAST_ALIGN\n        item = (nwItemDesc *)((char *)nwf + att[idx].dataIdx);\n        VIR_WARNINGS_RESET\n        flags = &item->flags;\n        flags_set = match_flag;\n\n        if (prop) {\n            found = false;\n\n            validator = NULL;\n\n            if (STRPREFIX(prop, \"$\")) {\n                flags_set |= NWFILTER_ENTRY_ITEM_FLAG_HAS_VAR;\n                if (virNWFilterRuleDefAddVar(nwf,\n                                             item,\n                                             &prop[1]) < 0)\n                    rc = -1;\n                found = true;\n            }\n\n            datatype = 1;\n\n            att_datatypes = att[idx].datatype;\n\n            while (datatype <= DATATYPE_LAST && found == 0 && rc == 0) {\n                if ((att_datatypes & datatype)) {\n\n                    att_datatypes ^= datatype;\n\n                    validator = att[idx].validator;\n\n                    base = 10;\n\n                    switch (datatype) {\n                        case DATATYPE_UINT8_HEX:\n                            base = 16;\n                            G_GNUC_FALLTHROUGH;\n                        case DATATYPE_UINT8:\n                            if (virStrToLong_ui(prop, NULL, base, &uint_val) >= 0) {\n                                if (uint_val <= 0xff) {\n                                    item->u.u8 = uint_val;\n                                    found = true;\n                                    data.ui = uint_val;\n                                } else {\n                                    rc = -1;\n                                }\n                            } else {\n                                rc = -1;\n                            }\n                        break;\n\n                        case DATATYPE_UINT16_HEX:\n                            base = 16;\n                            G_GNUC_FALLTHROUGH;\n                        case DATATYPE_UINT16:\n                            if (virStrToLong_ui(prop, NULL, base, &uint_val) >= 0) {\n                                if (uint_val <= 0xffff) {\n                                    item->u.u16 = uint_val;\n                                    found = true;\n                                    data.ui = uint_val;\n                                } else {\n                                    rc = -1;\n                                }\n                            } else {\n                                rc = -1;\n                            }\n                        break;\n\n                        case DATATYPE_UINT32_HEX:\n                            base = 16;\n                            G_GNUC_FALLTHROUGH;\n                        case DATATYPE_UINT32:\n                            if (virStrToLong_ui(prop, NULL, base, &uint_val) >= 0) {\n                                item->u.u32 = uint_val;\n                                found = true;\n                                data.ui = uint_val;\n                            } else {\n                                rc = -1;\n                            }\n                        break;\n\n                        case DATATYPE_IPADDR:\n                            if (virSocketAddrParseIPv4(&item->u.ipaddr, prop) < 0)\n                                rc = -1;\n                            found = true;\n                        break;\n\n                        case DATATYPE_IPMASK:\n                            if (virStrToLong_ui(prop, NULL, 10, &uint_val) == 0) {\n                                if (uint_val <= 32) {\n                                    if (!validator)\n                                        item->u.u8 = (uint8_t)uint_val;\n                                    found = true;\n                                    data.ui = uint_val;\n                                } else {\n                                    rc = -1;\n                                }\n                            } else {\n                                if (virSocketAddrParseIPv4(&ipaddr, prop) < 0) {\n                                    rc = -1;\n                                } else {\n                                    int_val = virSocketAddrGetNumNetmaskBits(&ipaddr);\n                                    if (int_val >= 0)\n                                        item->u.u8 = int_val;\n                                    else\n                                        rc = -1;\n                                    found = true;\n                                }\n                            }\n                        break;\n\n                        case DATATYPE_MACADDR:\n                            if (virMacAddrParse(prop,\n                                                &item->u.macaddr) < 0) {\n                                rc = -1;\n                            }\n                            found = true;\n                        break;\n\n                        case DATATYPE_MACMASK:\n                            validator = checkMACMask;\n                            if (virMacAddrParse(prop,\n                                                &item->u.macaddr) < 0) {\n                                rc = -1;\n                            }\n                            data.v = &item->u.macaddr;\n                            found = true;\n                        break;\n\n                        case DATATYPE_IPV6ADDR:\n                            if (virSocketAddrParseIPv6(&item->u.ipaddr, prop) < 0)\n                                rc = -1;\n                            found = true;\n                        break;\n\n                        case DATATYPE_IPV6MASK:\n                            if (virStrToLong_ui(prop, NULL, 10, &uint_val) == 0) {\n                                if (uint_val <= 128) {\n                                    if (!validator)\n                                        item->u.u8 = (uint8_t)uint_val;\n                                    found = true;\n                                    data.ui = uint_val;\n                                } else {\n                                    rc = -1;\n                                }\n                            } else {\n                                if (virSocketAddrParseIPv6(&ipaddr, prop) < 0) {\n                                    rc = -1;\n                                } else {\n                                    int_val = virSocketAddrGetNumNetmaskBits(&ipaddr);\n                                    if (int_val >= 0)\n                                        item->u.u8 = int_val;\n                                    else\n                                        rc = -1;\n                                    found = true;\n                                }\n                            }\n                        break;\n\n                        case DATATYPE_STRING:\n                        case DATATYPE_IPSETFLAGS:\n                        case DATATYPE_IPSETNAME:\n                            if (!validator) {\n                                /* not supported */\n                                rc = -1;\n                                break;\n                            }\n                            data.c = prop;\n                            found = true;\n                        break;\n\n                        case DATATYPE_STRINGCOPY:\n                            if (!(item->u.string =\n                                  virNWFilterRuleDefAddString(nwf, prop,\n                                                       att[idx].maxstrlen))) {\n                                rc = -1;\n                                break;\n                            }\n                            data.c = item->u.string;\n                            found = true;\n                        break;\n\n                        case DATATYPE_BOOLEAN:\n                            if (STREQ(prop, \"true\") ||\n                                STREQ(prop, \"1\") ||\n                                STREQ(prop, \"yes\"))\n                                item->u.boolean = true;\n                            else\n                                item->u.boolean = false;\n\n                            data.ui = item->u.boolean;\n                            found = true;\n                        break;\n\n                        case DATATYPE_LAST:\n                        default:\n                        break;\n                    }\n                }\n\n                if (rc != 0 && att_datatypes != 0) {\n                    rc = 0;\n                    found = false;\n                }\n\n                datatype <<= 1;\n            } /* while */\n\n            if (found && rc == 0) {\n                *flags = NWFILTER_ENTRY_ITEM_FLAG_EXISTS | flags_set;\n                item->datatype = datatype >> 1;\n                if (validator) {\n                    if (!validator(datatype >> 1, &data, nwf, item)) {\n                        rc = -1;\n                        *flags = 0;\n                    }\n                }\n            }\n\n            if (!found || rc) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s has illegal value %s\"),\n                               att[idx].name, prop);\n                rc = -1;\n            }\n            VIR_FREE(prop);\n        }\n\n        if (rc) {\n            g_rc = rc;\n            rc = 0;\n        }\n\n        idx++;\n    }\n\n    return g_rc;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirNWFilterRuleDetailsParse(xmlNodePtr node,\n                            virNWFilterRuleDefPtr nwf,\n                            const virXMLAttr2Struct *att)\n{\n    int rc = 0, g_rc = 0;\n    int idx = 0;\n    char *prop;\n    bool found = false;\n    enum attrDatatype datatype, att_datatypes;\n    virNWFilterEntryItemFlags *flags, match_flag = 0, flags_set = 0;\n    nwItemDesc *item;\n    int int_val;\n    unsigned int uint_val;\n    union data data;\n    valueValidator validator;\n    char *match = virXMLPropString(node, \"match\");\n    virSocketAddr ipaddr;\n    int base;\n\n    if (match && STREQ(match, \"no\"))\n        match_flag = NWFILTER_ENTRY_ITEM_FLAG_IS_NEG;\n    VIR_FREE(match);\n    match = NULL;\n\n    while (att[idx].name != NULL) {\n        prop = virXMLPropString(node, att[idx].name);\n\n        VIR_WARNINGS_NO_CAST_ALIGN\n        item = (nwItemDesc *)((char *)nwf + att[idx].dataIdx);\n        VIR_WARNINGS_RESET\n        flags = &item->flags;\n        flags_set = match_flag;\n\n        if (prop) {\n            found = false;\n\n            validator = NULL;\n\n            if (STRPREFIX(prop, \"$\")) {\n                flags_set |= NWFILTER_ENTRY_ITEM_FLAG_HAS_VAR;\n                if (virNWFilterRuleDefAddVar(nwf,\n                                             item,\n                                             &prop[1]) < 0)\n                    rc = -1;\n                found = true;\n            }\n\n            datatype = 1;\n\n            att_datatypes = att[idx].datatype;\n\n            while (datatype <= DATATYPE_LAST && found == 0 && rc == 0) {\n                if ((att_datatypes & datatype)) {\n\n                    att_datatypes ^= datatype;\n\n                    validator = att[idx].validator;\n\n                    base = 10;\n\n                    switch (datatype) {\n                        case DATATYPE_UINT8_HEX:\n                            base = 16;\n                            G_GNUC_FALLTHROUGH;\n                        case DATATYPE_UINT8:\n                            if (virStrToLong_ui(prop, NULL, base, &uint_val) >= 0) {\n                                if (uint_val <= 0xff) {\n                                    item->u.u8 = uint_val;\n                                    found = true;\n                                    data.ui = uint_val;\n                                } else {\n                                    rc = -1;\n                                }\n                            } else {\n                                rc = -1;\n                            }\n                        break;\n\n                        case DATATYPE_UINT16_HEX:\n                            base = 16;\n                            G_GNUC_FALLTHROUGH;\n                        case DATATYPE_UINT16:\n                            if (virStrToLong_ui(prop, NULL, base, &uint_val) >= 0) {\n                                if (uint_val <= 0xffff) {\n                                    item->u.u16 = uint_val;\n                                    found = true;\n                                    data.ui = uint_val;\n                                } else {\n                                    rc = -1;\n                                }\n                            } else {\n                                rc = -1;\n                            }\n                        break;\n\n                        case DATATYPE_UINT32_HEX:\n                            base = 16;\n                            G_GNUC_FALLTHROUGH;\n                        case DATATYPE_UINT32:\n                            if (virStrToLong_ui(prop, NULL, base, &uint_val) >= 0) {\n                                item->u.u32 = uint_val;\n                                found = true;\n                                data.ui = uint_val;\n                            } else {\n                                rc = -1;\n                            }\n                        break;\n\n                        case DATATYPE_IPADDR:\n                            if (virSocketAddrParseIPv4(&item->u.ipaddr, prop) < 0)\n                                rc = -1;\n                            found = true;\n                        break;\n\n                        case DATATYPE_IPMASK:\n                            if (virStrToLong_ui(prop, NULL, 10, &uint_val) == 0) {\n                                if (uint_val <= 32) {\n                                    if (!validator)\n                                        item->u.u8 = (uint8_t)uint_val;\n                                    found = true;\n                                    data.ui = uint_val;\n                                } else {\n                                    rc = -1;\n                                }\n                            } else {\n                                if (virSocketAddrParseIPv4(&ipaddr, prop) < 0) {\n                                    rc = -1;\n                                } else {\n                                    int_val = virSocketAddrGetNumNetmaskBits(&ipaddr);\n                                    if (int_val >= 0)\n                                        item->u.u8 = int_val;\n                                    else\n                                        rc = -1;\n                                    found = true;\n                                }\n                            }\n                        break;\n\n                        case DATATYPE_MACADDR:\n                            if (virMacAddrParse(prop,\n                                                &item->u.macaddr) < 0) {\n                                rc = -1;\n                            }\n                            found = true;\n                        break;\n\n                        case DATATYPE_MACMASK:\n                            validator = checkMACMask;\n                            if (virMacAddrParse(prop,\n                                                &item->u.macaddr) < 0) {\n                                rc = -1;\n                            }\n                            data.v = &item->u.macaddr;\n                            found = true;\n                        break;\n\n                        case DATATYPE_IPV6ADDR:\n                            if (virSocketAddrParseIPv6(&item->u.ipaddr, prop) < 0)\n                                rc = -1;\n                            found = true;\n                        break;\n\n                        case DATATYPE_IPV6MASK:\n                            if (virStrToLong_ui(prop, NULL, 10, &uint_val) == 0) {\n                                if (uint_val <= 128) {\n                                    if (!validator)\n                                        item->u.u8 = (uint8_t)uint_val;\n                                    found = true;\n                                    data.ui = uint_val;\n                                } else {\n                                    rc = -1;\n                                }\n                            } else {\n                                if (virSocketAddrParseIPv6(&ipaddr, prop) < 0) {\n                                    rc = -1;\n                                } else {\n                                    int_val = virSocketAddrGetNumNetmaskBits(&ipaddr);\n                                    if (int_val >= 0)\n                                        item->u.u8 = int_val;\n                                    else\n                                        rc = -1;\n                                    found = true;\n                                }\n                            }\n                        break;\n\n                        case DATATYPE_STRING:\n                        case DATATYPE_IPSETFLAGS:\n                        case DATATYPE_IPSETNAME:\n                            if (!validator) {\n                                /* not supported */\n                                rc = -1;\n                                break;\n                            }\n                            data.c = prop;\n                            found = true;\n                        break;\n\n                        case DATATYPE_STRINGCOPY:\n                            if (!(item->u.string =\n                                  virNWFilterRuleDefAddString(nwf, prop,\n                                                       att[idx].maxstrlen))) {\n                                rc = -1;\n                                break;\n                            }\n                            data.c = item->u.string;\n                            found = true;\n                        break;\n\n                        case DATATYPE_BOOLEAN:\n                            if (STREQ(prop, \"true\") ||\n                                STREQ(prop, \"1\") ||\n                                STREQ(prop, \"yes\"))\n                                item->u.boolean = true;\n                            else\n                                item->u.boolean = false;\n\n                            data.ui = item->u.boolean;\n                            found = true;\n                        break;\n\n                        case DATATYPE_LAST:\n                        default:\n                        break;\n                    }\n                }\n\n                if (rc != 0 && att_datatypes != 0) {\n                    rc = 0;\n                    found = false;\n                }\n\n                datatype <<= 1;\n            } /* while */\n\n            if (found && rc == 0) {\n                *flags = NWFILTER_ENTRY_ITEM_FLAG_EXISTS | flags_set;\n                item->datatype = datatype >> 1;\n                if (validator) {\n                    if (!validator(datatype >> 1, &data, nwf, item)) {\n                        rc = -1;\n                        *flags = 0;\n                    }\n                }\n            }\n\n            if (!found || rc) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s has illegal value %s\"),\n                               att[idx].name, prop);\n                rc = -1;\n            }\n            VIR_FREE(prop);\n        }\n\n        if (rc) {\n            g_rc = rc;\n            rc = 0;\n        }\n\n        idx++;\n    }\n\n    return g_rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLNodeNameEqual",
          "args": [
            "cur",
            "virAttr[i].id"
          ],
          "line": 2487
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeNameEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1013-1018",
          "snippet": "bool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nbool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "statematch",
            "\"false\""
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "statematch",
            "\"0\""
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "prio",
            "NULL",
            "10",
            "&priority"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unknown rule direction attribute value\")"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown rule direction attribute value\""
          ],
          "line": 2458
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleDirectionTypeFromString",
          "args": [
            "direction"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"rule node requires direction attribute\")"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unknown rule action attribute value\")"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleActionTypeFromString",
          "args": [
            "action"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"rule node requires action attribute\")"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "node",
            "\"statematch\""
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ret"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const virAttributes virAttr[] = {\n    PROTOCOL_ENTRY(\"arp\",     arpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ARP),\n    PROTOCOL_ENTRY(\"rarp\",    arpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_RARP),\n    PROTOCOL_ENTRY(\"mac\",     macAttributes,     VIR_NWFILTER_RULE_PROTOCOL_MAC),\n    PROTOCOL_ENTRY(\"vlan\",    vlanAttributes,    VIR_NWFILTER_RULE_PROTOCOL_VLAN),\n    PROTOCOL_ENTRY(\"stp\",     stpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_STP),\n    PROTOCOL_ENTRY(\"ip\",      ipAttributes,      VIR_NWFILTER_RULE_PROTOCOL_IP),\n    PROTOCOL_ENTRY(\"ipv6\",    ipv6Attributes,    VIR_NWFILTER_RULE_PROTOCOL_IPV6),\n    PROTOCOL_ENTRY(\"tcp\",     tcpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_TCP),\n    PROTOCOL_ENTRY(\"udp\",     udpAttributes,     VIR_NWFILTER_RULE_PROTOCOL_UDP),\n    PROTOCOL_ENTRY(\"udplite\", udpliteAttributes, VIR_NWFILTER_RULE_PROTOCOL_UDPLITE),\n    PROTOCOL_ENTRY(\"esp\",     espAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ESP),\n    PROTOCOL_ENTRY(\"ah\",      ahAttributes,      VIR_NWFILTER_RULE_PROTOCOL_AH),\n    PROTOCOL_ENTRY(\"sctp\",    sctpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_SCTP),\n    PROTOCOL_ENTRY(\"icmp\",    icmpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_ICMP),\n    PROTOCOL_ENTRY(\"all\",     allAttributes,     VIR_NWFILTER_RULE_PROTOCOL_ALL),\n    PROTOCOL_ENTRY(\"igmp\",    igmpAttributes,    VIR_NWFILTER_RULE_PROTOCOL_IGMP),\n    PROTOCOL_ENTRY(\"tcp-ipv6\",     tcpipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6),\n    PROTOCOL_ENTRY(\"udp-ipv6\",     udpipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6),\n    PROTOCOL_ENTRY(\"udplite-ipv6\", udpliteipv6Attributes, VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6),\n    PROTOCOL_ENTRY(\"esp-ipv6\",     espipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6),\n    PROTOCOL_ENTRY(\"ah-ipv6\",      ahipv6Attributes,      VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6),\n    PROTOCOL_ENTRY(\"sctp-ipv6\",    sctpipv6Attributes,    VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6),\n    PROTOCOL_ENTRY(\"icmpv6\",       icmpv6Attributes,      VIR_NWFILTER_RULE_PROTOCOL_ICMPV6),\n    PROTOCOL_ENTRY(\"all-ipv6\",     allipv6Attributes,     VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6),\n    PROTOCOL_ENTRY_LAST\n};\n\nstatic virNWFilterRuleDefPtr\nvirNWFilterRuleParse(xmlNodePtr node)\n{\n    char *action;\n    char *direction;\n    char *prio;\n    char *statematch;\n    bool found;\n    int found_i = 0;\n    int priority;\n\n    xmlNodePtr cur;\n    virNWFilterRuleDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    action     = virXMLPropString(node, \"action\");\n    direction  = virXMLPropString(node, \"direction\");\n    prio       = virXMLPropString(node, \"priority\");\n    statematch = virXMLPropString(node, \"statematch\");\n\n    if (!action) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"rule node requires action attribute\"));\n        goto err_exit;\n    }\n\n    if ((ret->action = virNWFilterRuleActionTypeFromString(action)) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       \"%s\",\n                       _(\"unknown rule action attribute value\"));\n        goto err_exit;\n    }\n\n    if (!direction) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"rule node requires direction attribute\"));\n        goto err_exit;\n    }\n\n    if ((ret->tt = virNWFilterRuleDirectionTypeFromString(direction)) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       \"%s\",\n                       _(\"unknown rule direction attribute value\"));\n        goto err_exit;\n    }\n\n    ret->priority = MAX_RULE_PRIORITY / 2;\n\n    if (prio) {\n        if (virStrToLong_i(prio, NULL, 10, &priority) >= 0) {\n            if (priority <= MAX_RULE_PRIORITY &&\n                priority >= MIN_RULE_PRIORITY)\n                ret->priority = priority;\n        }\n    }\n\n    if (statematch &&\n        (STREQ(statematch, \"0\") || STRCASEEQ(statematch, \"false\")))\n        ret->flags |= RULE_FLAG_NO_STATEMATCH;\n\n    cur = node->children;\n\n    found = false;\n\n    while (cur != NULL) {\n        if (cur->type == XML_ELEMENT_NODE) {\n            size_t i = 0;\n            while (1) {\n                if (found)\n                    i = found_i;\n\n                if (virXMLNodeNameEqual(cur, virAttr[i].id)) {\n\n                    found_i = i;\n                    found = true;\n                    ret->prtclType = virAttr[i].prtclType;\n\n                    if (virNWFilterRuleDetailsParse(cur,\n                                                    ret,\n                                                    virAttr[i].att) < 0) {\n                        goto err_exit;\n                    }\n                    if (virNWFilterRuleValidate(ret) < 0)\n                        goto err_exit;\n                    break;\n                }\n                if (!found) {\n                    i++;\n                    if (!virAttr[i].id)\n                        break;\n                } else {\n                   break;\n                }\n            }\n        }\n\n        cur = cur->next;\n    }\n\n    virNWFilterRuleDefFixup(ret);\n\n cleanup:\n    VIR_FREE(prio);\n    VIR_FREE(action);\n    VIR_FREE(direction);\n    VIR_FREE(statematch);\n\n    return ret;\n\n err_exit:\n    virNWFilterRuleDefFree(ret);\n    ret = NULL;\n    goto cleanup;\n}"
  },
  {
    "function_name": "virNWFilterRuleDefFixup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "2196-2409",
    "snippet": "static void\nvirNWFilterRuleDefFixup(virNWFilterRuleDefPtr rule)\n{\n#define COPY_NEG_SIGN(A, B) \\\n    (A).flags = ((A).flags & ~NWFILTER_ENTRY_ITEM_FLAG_IS_NEG) | \\\n                ((B).flags &  NWFILTER_ENTRY_ITEM_FLAG_IS_NEG);\n\n    switch (rule->prtclType) {\n    case VIR_NWFILTER_RULE_PROTOCOL_MAC:\n        COPY_NEG_SIGN(rule->p.ethHdrFilter.ethHdr.dataSrcMACMask,\n                      rule->p.ethHdrFilter.ethHdr.dataSrcMACAddr);\n        COPY_NEG_SIGN(rule->p.ethHdrFilter.ethHdr.dataDstMACMask,\n                      rule->p.ethHdrFilter.ethHdr.dataDstMACAddr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_VLAN:\n        COPY_NEG_SIGN(rule->p.vlanHdrFilter.ethHdr.dataSrcMACMask,\n                      rule->p.vlanHdrFilter.ethHdr.dataSrcMACAddr);\n        COPY_NEG_SIGN(rule->p.vlanHdrFilter.ethHdr.dataDstMACMask,\n                      rule->p.vlanHdrFilter.ethHdr.dataDstMACAddr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_STP:\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.ethHdr.dataSrcMACMask,\n                      rule->p.stpHdrFilter.ethHdr.dataSrcMACAddr);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataRootPriHi,\n                      rule->p.stpHdrFilter.dataRootPri);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataRootAddrMask,\n                      rule->p.stpHdrFilter.dataRootAddr);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataRootCostHi,\n                      rule->p.stpHdrFilter.dataRootCost);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataSndrPrioHi,\n                      rule->p.stpHdrFilter.dataSndrPrio);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataSndrAddrMask,\n                      rule->p.stpHdrFilter.dataSndrAddr);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataPortHi,\n                      rule->p.stpHdrFilter.dataPort);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataAgeHi,\n                      rule->p.stpHdrFilter.dataAge);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataMaxAgeHi,\n                      rule->p.stpHdrFilter.dataMaxAge);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataHelloTimeHi,\n                      rule->p.stpHdrFilter.dataHelloTime);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataFwdDelayHi,\n                      rule->p.stpHdrFilter.dataFwdDelay);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IP:\n        COPY_NEG_SIGN(rule->p.ipHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.ipHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.ipHdrFilter.ipHdr.dataDstIPAddr);\n        virNWFilterRuleDefFixupIPSet(&rule->p.ipHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IPV6:\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.dataICMPTypeEnd,\n                      rule->p.ipv6HdrFilter.dataICMPTypeStart);\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.dataICMPCodeStart,\n                      rule->p.ipv6HdrFilter.dataICMPTypeStart);\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.dataICMPCodeEnd,\n                      rule->p.ipv6HdrFilter.dataICMPTypeStart);\n        virNWFilterRuleDefFixupIPSet(&rule->p.ipv6HdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_RARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_NONE:\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_TCP:\n    case VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6:\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.tcpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.tcpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.tcpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.tcpHdrFilter.ipHdr.dataDstIPFrom);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.portData.dataSrcPortEnd,\n                      rule->p.tcpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.portData.dataDstPortStart,\n                      rule->p.tcpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.portData.dataDstPortEnd,\n                      rule->p.tcpHdrFilter.portData.dataSrcPortStart);\n        virNWFilterRuleDefFixupIPSet(&rule->p.tcpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDP:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6:\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.udpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.udpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.udpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.udpHdrFilter.ipHdr.dataDstIPFrom);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.portData.dataSrcPortEnd,\n                      rule->p.udpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.portData.dataDstPortStart,\n                      rule->p.udpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.portData.dataDstPortEnd,\n                      rule->p.udpHdrFilter.portData.dataSrcPortStart);\n        virNWFilterRuleDefFixupIPSet(&rule->p.udpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITE:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6:\n        COPY_NEG_SIGN(rule->p.udpliteHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.udpliteHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.udpliteHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.udpliteHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.udpliteHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.udpliteHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.udpliteHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.udpliteHdrFilter.ipHdr.dataDstIPFrom);\n        virNWFilterRuleDefFixupIPSet(&rule->p.udpliteHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ESP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6:\n        COPY_NEG_SIGN(rule->p.espHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.espHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.espHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.espHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.espHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.espHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.espHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.espHdrFilter.ipHdr.dataDstIPFrom);\n        virNWFilterRuleDefFixupIPSet(&rule->p.espHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_AH:\n    case VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6:\n        COPY_NEG_SIGN(rule->p.ahHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.ahHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.ahHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.ahHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.ahHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.ahHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.ahHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.ahHdrFilter.ipHdr.dataDstIPFrom);\n        virNWFilterRuleDefFixupIPSet(&rule->p.ahHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTP:\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6:\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.sctpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.sctpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.sctpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.sctpHdrFilter.ipHdr.dataDstIPFrom);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.portData.dataSrcPortEnd,\n                      rule->p.sctpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.portData.dataDstPortStart,\n                      rule->p.sctpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.portData.dataDstPortEnd,\n                      rule->p.sctpHdrFilter.portData.dataSrcPortStart);\n        virNWFilterRuleDefFixupIPSet(&rule->p.sctpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMPV6:\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.icmpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.icmpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.icmpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.icmpHdrFilter.ipHdr.dataDstIPFrom);\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.dataICMPCode,\n                      rule->p.icmpHdrFilter.dataICMPType);\n        virNWFilterRuleDefFixupIPSet(&rule->p.icmpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ALL:\n    case VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6:\n        COPY_NEG_SIGN(rule->p.allHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.allHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.allHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.allHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.allHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.allHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.allHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.allHdrFilter.ipHdr.dataDstIPFrom);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IGMP:\n        COPY_NEG_SIGN(rule->p.igmpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.igmpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.igmpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.igmpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.igmpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.igmpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.igmpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.igmpHdrFilter.ipHdr.dataDstIPFrom);\n        virNWFilterRuleDefFixupIPSet(&rule->p.igmpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_LAST:\n    break;\n    }\n#undef COPY_NEG_SIGN\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNWFilterRuleDefFixupIPSet",
          "args": [
            "&rule->p.igmpHdrFilter.ipHdr"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRuleDefFixupIPSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "2095-2107",
          "snippet": "static void\nvirNWFilterRuleDefFixupIPSet(ipHdrDataDefPtr ipHdr)\n{\n    if (HAS_ENTRY_ITEM(&ipHdr->dataIPSet) &&\n        !HAS_ENTRY_ITEM(&ipHdr->dataIPSetFlags)) {\n        ipHdr->dataIPSetFlags.flags = NWFILTER_ENTRY_ITEM_FLAG_EXISTS;\n        ipHdr->dataIPSetFlags.u.ipset.numFlags = 1;\n        ipHdr->dataIPSetFlags.u.ipset.flags = 1;\n    } else {\n        ipHdr->dataIPSet.flags = 0;\n        ipHdr->dataIPSetFlags.flags = 0;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirNWFilterRuleDefFixupIPSet(ipHdrDataDefPtr ipHdr)\n{\n    if (HAS_ENTRY_ITEM(&ipHdr->dataIPSet) &&\n        !HAS_ENTRY_ITEM(&ipHdr->dataIPSetFlags)) {\n        ipHdr->dataIPSetFlags.flags = NWFILTER_ENTRY_ITEM_FLAG_EXISTS;\n        ipHdr->dataIPSetFlags.u.ipset.numFlags = 1;\n        ipHdr->dataIPSetFlags.u.ipset.flags = 1;\n    } else {\n        ipHdr->dataIPSet.flags = 0;\n        ipHdr->dataIPSetFlags.flags = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.igmpHdrFilter.ipHdr.dataDstIPTo",
            "rule->p.igmpHdrFilter.ipHdr.dataDstIPFrom"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.igmpHdrFilter.ipHdr.dataSrcIPTo",
            "rule->p.igmpHdrFilter.ipHdr.dataSrcIPFrom"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.igmpHdrFilter.ipHdr.dataDstIPMask",
            "rule->p.igmpHdrFilter.ipHdr.dataDstIPAddr"
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.igmpHdrFilter.ipHdr.dataSrcIPMask",
            "rule->p.igmpHdrFilter.ipHdr.dataSrcIPAddr"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.allHdrFilter.ipHdr.dataDstIPTo",
            "rule->p.allHdrFilter.ipHdr.dataDstIPFrom"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.allHdrFilter.ipHdr.dataSrcIPTo",
            "rule->p.allHdrFilter.ipHdr.dataSrcIPFrom"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.allHdrFilter.ipHdr.dataDstIPMask",
            "rule->p.allHdrFilter.ipHdr.dataDstIPAddr"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.allHdrFilter.ipHdr.dataSrcIPMask",
            "rule->p.allHdrFilter.ipHdr.dataSrcIPAddr"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.icmpHdrFilter.dataICMPCode",
            "rule->p.icmpHdrFilter.dataICMPType"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.icmpHdrFilter.ipHdr.dataDstIPTo",
            "rule->p.icmpHdrFilter.ipHdr.dataDstIPFrom"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.icmpHdrFilter.ipHdr.dataSrcIPTo",
            "rule->p.icmpHdrFilter.ipHdr.dataSrcIPFrom"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.icmpHdrFilter.ipHdr.dataDstIPMask",
            "rule->p.icmpHdrFilter.ipHdr.dataDstIPAddr"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.icmpHdrFilter.ipHdr.dataSrcIPMask",
            "rule->p.icmpHdrFilter.ipHdr.dataSrcIPAddr"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.sctpHdrFilter.portData.dataDstPortEnd",
            "rule->p.sctpHdrFilter.portData.dataSrcPortStart"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.sctpHdrFilter.portData.dataDstPortStart",
            "rule->p.sctpHdrFilter.portData.dataSrcPortStart"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.sctpHdrFilter.portData.dataSrcPortEnd",
            "rule->p.sctpHdrFilter.portData.dataSrcPortStart"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.sctpHdrFilter.ipHdr.dataDstIPTo",
            "rule->p.sctpHdrFilter.ipHdr.dataDstIPFrom"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.sctpHdrFilter.ipHdr.dataSrcIPTo",
            "rule->p.sctpHdrFilter.ipHdr.dataSrcIPFrom"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.sctpHdrFilter.ipHdr.dataDstIPMask",
            "rule->p.sctpHdrFilter.ipHdr.dataDstIPAddr"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.sctpHdrFilter.ipHdr.dataSrcIPMask",
            "rule->p.sctpHdrFilter.ipHdr.dataSrcIPAddr"
          ],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.ahHdrFilter.ipHdr.dataDstIPTo",
            "rule->p.ahHdrFilter.ipHdr.dataDstIPFrom"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.ahHdrFilter.ipHdr.dataSrcIPTo",
            "rule->p.ahHdrFilter.ipHdr.dataSrcIPFrom"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.ahHdrFilter.ipHdr.dataDstIPMask",
            "rule->p.ahHdrFilter.ipHdr.dataDstIPAddr"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.ahHdrFilter.ipHdr.dataSrcIPMask",
            "rule->p.ahHdrFilter.ipHdr.dataSrcIPAddr"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.espHdrFilter.ipHdr.dataDstIPTo",
            "rule->p.espHdrFilter.ipHdr.dataDstIPFrom"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.espHdrFilter.ipHdr.dataSrcIPTo",
            "rule->p.espHdrFilter.ipHdr.dataSrcIPFrom"
          ],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.espHdrFilter.ipHdr.dataDstIPMask",
            "rule->p.espHdrFilter.ipHdr.dataDstIPAddr"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.espHdrFilter.ipHdr.dataSrcIPMask",
            "rule->p.espHdrFilter.ipHdr.dataSrcIPAddr"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.udpliteHdrFilter.ipHdr.dataDstIPTo",
            "rule->p.udpliteHdrFilter.ipHdr.dataDstIPFrom"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.udpliteHdrFilter.ipHdr.dataSrcIPTo",
            "rule->p.udpliteHdrFilter.ipHdr.dataSrcIPFrom"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.udpliteHdrFilter.ipHdr.dataDstIPMask",
            "rule->p.udpliteHdrFilter.ipHdr.dataDstIPAddr"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.udpliteHdrFilter.ipHdr.dataSrcIPMask",
            "rule->p.udpliteHdrFilter.ipHdr.dataSrcIPAddr"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.udpHdrFilter.portData.dataDstPortEnd",
            "rule->p.udpHdrFilter.portData.dataSrcPortStart"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.udpHdrFilter.portData.dataDstPortStart",
            "rule->p.udpHdrFilter.portData.dataSrcPortStart"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.udpHdrFilter.portData.dataSrcPortEnd",
            "rule->p.udpHdrFilter.portData.dataSrcPortStart"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.udpHdrFilter.ipHdr.dataDstIPTo",
            "rule->p.udpHdrFilter.ipHdr.dataDstIPFrom"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.udpHdrFilter.ipHdr.dataSrcIPTo",
            "rule->p.udpHdrFilter.ipHdr.dataSrcIPFrom"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.udpHdrFilter.ipHdr.dataDstIPMask",
            "rule->p.udpHdrFilter.ipHdr.dataDstIPAddr"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.udpHdrFilter.ipHdr.dataSrcIPMask",
            "rule->p.udpHdrFilter.ipHdr.dataSrcIPAddr"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.tcpHdrFilter.portData.dataDstPortEnd",
            "rule->p.tcpHdrFilter.portData.dataSrcPortStart"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.tcpHdrFilter.portData.dataDstPortStart",
            "rule->p.tcpHdrFilter.portData.dataSrcPortStart"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.tcpHdrFilter.portData.dataSrcPortEnd",
            "rule->p.tcpHdrFilter.portData.dataSrcPortStart"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.tcpHdrFilter.ipHdr.dataDstIPTo",
            "rule->p.tcpHdrFilter.ipHdr.dataDstIPFrom"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.tcpHdrFilter.ipHdr.dataSrcIPTo",
            "rule->p.tcpHdrFilter.ipHdr.dataSrcIPFrom"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.tcpHdrFilter.ipHdr.dataDstIPMask",
            "rule->p.tcpHdrFilter.ipHdr.dataDstIPAddr"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.tcpHdrFilter.ipHdr.dataSrcIPMask",
            "rule->p.tcpHdrFilter.ipHdr.dataSrcIPAddr"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.ipv6HdrFilter.dataICMPCodeEnd",
            "rule->p.ipv6HdrFilter.dataICMPTypeStart"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.ipv6HdrFilter.dataICMPCodeStart",
            "rule->p.ipv6HdrFilter.dataICMPTypeStart"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.ipv6HdrFilter.dataICMPTypeEnd",
            "rule->p.ipv6HdrFilter.dataICMPTypeStart"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.ipv6HdrFilter.ipHdr.dataDstIPMask",
            "rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.ipv6HdrFilter.ipHdr.dataSrcIPMask",
            "rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.ipHdrFilter.ipHdr.dataDstIPMask",
            "rule->p.ipHdrFilter.ipHdr.dataDstIPAddr"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.ipHdrFilter.ipHdr.dataSrcIPMask",
            "rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.stpHdrFilter.dataFwdDelayHi",
            "rule->p.stpHdrFilter.dataFwdDelay"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.stpHdrFilter.dataHelloTimeHi",
            "rule->p.stpHdrFilter.dataHelloTime"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.stpHdrFilter.dataMaxAgeHi",
            "rule->p.stpHdrFilter.dataMaxAge"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.stpHdrFilter.dataAgeHi",
            "rule->p.stpHdrFilter.dataAge"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.stpHdrFilter.dataPortHi",
            "rule->p.stpHdrFilter.dataPort"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.stpHdrFilter.dataSndrAddrMask",
            "rule->p.stpHdrFilter.dataSndrAddr"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.stpHdrFilter.dataSndrPrioHi",
            "rule->p.stpHdrFilter.dataSndrPrio"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.stpHdrFilter.dataRootCostHi",
            "rule->p.stpHdrFilter.dataRootCost"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.stpHdrFilter.dataRootAddrMask",
            "rule->p.stpHdrFilter.dataRootAddr"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.stpHdrFilter.dataRootPriHi",
            "rule->p.stpHdrFilter.dataRootPri"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.stpHdrFilter.ethHdr.dataSrcMACMask",
            "rule->p.stpHdrFilter.ethHdr.dataSrcMACAddr"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.vlanHdrFilter.ethHdr.dataDstMACMask",
            "rule->p.vlanHdrFilter.ethHdr.dataDstMACAddr"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.vlanHdrFilter.ethHdr.dataSrcMACMask",
            "rule->p.vlanHdrFilter.ethHdr.dataSrcMACAddr"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.ethHdrFilter.ethHdr.dataDstMACMask",
            "rule->p.ethHdrFilter.ethHdr.dataDstMACAddr"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_NEG_SIGN",
          "args": [
            "rule->p.ethHdrFilter.ethHdr.dataSrcMACMask",
            "rule->p.ethHdrFilter.ethHdr.dataSrcMACAddr"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirNWFilterRuleDefFixup(virNWFilterRuleDefPtr rule)\n{\n#define COPY_NEG_SIGN(A, B) \\\n    (A).flags = ((A).flags & ~NWFILTER_ENTRY_ITEM_FLAG_IS_NEG) | \\\n                ((B).flags &  NWFILTER_ENTRY_ITEM_FLAG_IS_NEG);\n\n    switch (rule->prtclType) {\n    case VIR_NWFILTER_RULE_PROTOCOL_MAC:\n        COPY_NEG_SIGN(rule->p.ethHdrFilter.ethHdr.dataSrcMACMask,\n                      rule->p.ethHdrFilter.ethHdr.dataSrcMACAddr);\n        COPY_NEG_SIGN(rule->p.ethHdrFilter.ethHdr.dataDstMACMask,\n                      rule->p.ethHdrFilter.ethHdr.dataDstMACAddr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_VLAN:\n        COPY_NEG_SIGN(rule->p.vlanHdrFilter.ethHdr.dataSrcMACMask,\n                      rule->p.vlanHdrFilter.ethHdr.dataSrcMACAddr);\n        COPY_NEG_SIGN(rule->p.vlanHdrFilter.ethHdr.dataDstMACMask,\n                      rule->p.vlanHdrFilter.ethHdr.dataDstMACAddr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_STP:\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.ethHdr.dataSrcMACMask,\n                      rule->p.stpHdrFilter.ethHdr.dataSrcMACAddr);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataRootPriHi,\n                      rule->p.stpHdrFilter.dataRootPri);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataRootAddrMask,\n                      rule->p.stpHdrFilter.dataRootAddr);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataRootCostHi,\n                      rule->p.stpHdrFilter.dataRootCost);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataSndrPrioHi,\n                      rule->p.stpHdrFilter.dataSndrPrio);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataSndrAddrMask,\n                      rule->p.stpHdrFilter.dataSndrAddr);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataPortHi,\n                      rule->p.stpHdrFilter.dataPort);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataAgeHi,\n                      rule->p.stpHdrFilter.dataAge);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataMaxAgeHi,\n                      rule->p.stpHdrFilter.dataMaxAge);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataHelloTimeHi,\n                      rule->p.stpHdrFilter.dataHelloTime);\n        COPY_NEG_SIGN(rule->p.stpHdrFilter.dataFwdDelayHi,\n                      rule->p.stpHdrFilter.dataFwdDelay);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IP:\n        COPY_NEG_SIGN(rule->p.ipHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.ipHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.ipHdrFilter.ipHdr.dataDstIPAddr);\n        virNWFilterRuleDefFixupIPSet(&rule->p.ipHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IPV6:\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.dataICMPTypeEnd,\n                      rule->p.ipv6HdrFilter.dataICMPTypeStart);\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.dataICMPCodeStart,\n                      rule->p.ipv6HdrFilter.dataICMPTypeStart);\n        COPY_NEG_SIGN(rule->p.ipv6HdrFilter.dataICMPCodeEnd,\n                      rule->p.ipv6HdrFilter.dataICMPTypeStart);\n        virNWFilterRuleDefFixupIPSet(&rule->p.ipv6HdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_RARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_NONE:\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_TCP:\n    case VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6:\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.tcpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.tcpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.tcpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.tcpHdrFilter.ipHdr.dataDstIPFrom);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.portData.dataSrcPortEnd,\n                      rule->p.tcpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.portData.dataDstPortStart,\n                      rule->p.tcpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.tcpHdrFilter.portData.dataDstPortEnd,\n                      rule->p.tcpHdrFilter.portData.dataSrcPortStart);\n        virNWFilterRuleDefFixupIPSet(&rule->p.tcpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDP:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6:\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.udpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.udpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.udpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.udpHdrFilter.ipHdr.dataDstIPFrom);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.portData.dataSrcPortEnd,\n                      rule->p.udpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.portData.dataDstPortStart,\n                      rule->p.udpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.udpHdrFilter.portData.dataDstPortEnd,\n                      rule->p.udpHdrFilter.portData.dataSrcPortStart);\n        virNWFilterRuleDefFixupIPSet(&rule->p.udpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITE:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6:\n        COPY_NEG_SIGN(rule->p.udpliteHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.udpliteHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.udpliteHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.udpliteHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.udpliteHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.udpliteHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.udpliteHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.udpliteHdrFilter.ipHdr.dataDstIPFrom);\n        virNWFilterRuleDefFixupIPSet(&rule->p.udpliteHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ESP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6:\n        COPY_NEG_SIGN(rule->p.espHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.espHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.espHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.espHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.espHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.espHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.espHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.espHdrFilter.ipHdr.dataDstIPFrom);\n        virNWFilterRuleDefFixupIPSet(&rule->p.espHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_AH:\n    case VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6:\n        COPY_NEG_SIGN(rule->p.ahHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.ahHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.ahHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.ahHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.ahHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.ahHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.ahHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.ahHdrFilter.ipHdr.dataDstIPFrom);\n        virNWFilterRuleDefFixupIPSet(&rule->p.ahHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTP:\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6:\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.sctpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.sctpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.sctpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.sctpHdrFilter.ipHdr.dataDstIPFrom);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.portData.dataSrcPortEnd,\n                      rule->p.sctpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.portData.dataDstPortStart,\n                      rule->p.sctpHdrFilter.portData.dataSrcPortStart);\n        COPY_NEG_SIGN(rule->p.sctpHdrFilter.portData.dataDstPortEnd,\n                      rule->p.sctpHdrFilter.portData.dataSrcPortStart);\n        virNWFilterRuleDefFixupIPSet(&rule->p.sctpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMPV6:\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.icmpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.icmpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.icmpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.icmpHdrFilter.ipHdr.dataDstIPFrom);\n        COPY_NEG_SIGN(rule->p.icmpHdrFilter.dataICMPCode,\n                      rule->p.icmpHdrFilter.dataICMPType);\n        virNWFilterRuleDefFixupIPSet(&rule->p.icmpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ALL:\n    case VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6:\n        COPY_NEG_SIGN(rule->p.allHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.allHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.allHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.allHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.allHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.allHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.allHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.allHdrFilter.ipHdr.dataDstIPFrom);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IGMP:\n        COPY_NEG_SIGN(rule->p.igmpHdrFilter.ipHdr.dataSrcIPMask,\n                      rule->p.igmpHdrFilter.ipHdr.dataSrcIPAddr);\n        COPY_NEG_SIGN(rule->p.igmpHdrFilter.ipHdr.dataDstIPMask,\n                      rule->p.igmpHdrFilter.ipHdr.dataDstIPAddr);\n        COPY_NEG_SIGN(rule->p.igmpHdrFilter.ipHdr.dataSrcIPTo,\n                      rule->p.igmpHdrFilter.ipHdr.dataSrcIPFrom);\n        COPY_NEG_SIGN(rule->p.igmpHdrFilter.ipHdr.dataDstIPTo,\n                      rule->p.igmpHdrFilter.ipHdr.dataDstIPFrom);\n        virNWFilterRuleDefFixupIPSet(&rule->p.igmpHdrFilter.ipHdr);\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_LAST:\n    break;\n    }\n#undef COPY_NEG_SIGN\n}"
  },
  {
    "function_name": "virNWFilterRuleValidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "2116-2193",
    "snippet": "static int\nvirNWFilterRuleValidate(virNWFilterRuleDefPtr rule)\n{\n    int ret = 0;\n    portDataDefPtr portData = NULL;\n    nwItemDescPtr dataProtocolID = NULL;\n    const char *protocol = NULL;\n\n    switch (rule->prtclType) {\n    case VIR_NWFILTER_RULE_PROTOCOL_IP:\n        portData = &rule->p.ipHdrFilter.portData;\n        protocol = \"IP\";\n        dataProtocolID = &rule->p.ipHdrFilter.ipHdr.dataProtocolID;\n        G_GNUC_FALLTHROUGH;\n    case VIR_NWFILTER_RULE_PROTOCOL_IPV6:\n        if (portData == NULL) {\n            portData = &rule->p.ipv6HdrFilter.portData;\n            protocol = \"IPv6\";\n            dataProtocolID = &rule->p.ipv6HdrFilter.ipHdr.dataProtocolID;\n        }\n        if (HAS_ENTRY_ITEM(&portData->dataSrcPortStart) ||\n            HAS_ENTRY_ITEM(&portData->dataDstPortStart) ||\n            HAS_ENTRY_ITEM(&portData->dataSrcPortEnd) ||\n            HAS_ENTRY_ITEM(&portData->dataDstPortEnd)) {\n            if (HAS_ENTRY_ITEM(dataProtocolID)) {\n                switch (dataProtocolID->u.u8) {\n                case 6:   /* tcp */\n                case 17:  /* udp */\n                case 33:  /* dccp */\n                case 132: /* sctp */\n                    break;\n                default:\n                    ret = -1;\n                }\n            } else {\n                ret = -1;\n            }\n            if (ret < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s rule with port specification requires \"\n                                 \"protocol specification with protocol to be \"\n                                 \"either one of tcp(6), udp(17), dccp(33), or \"\n                                 \"sctp(132)\"), protocol);\n            }\n        }\n        break;\n    case VIR_NWFILTER_RULE_PROTOCOL_NONE:\n    case VIR_NWFILTER_RULE_PROTOCOL_MAC:\n    case VIR_NWFILTER_RULE_PROTOCOL_VLAN:\n    case VIR_NWFILTER_RULE_PROTOCOL_STP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_RARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_TCP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMP:\n    case VIR_NWFILTER_RULE_PROTOCOL_IGMP:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDP:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITE:\n    case VIR_NWFILTER_RULE_PROTOCOL_ESP:\n    case VIR_NWFILTER_RULE_PROTOCOL_AH:\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ALL:\n    case VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6:\n        break;\n    case VIR_NWFILTER_RULE_PROTOCOL_LAST:\n    default:\n        virReportEnumRangeError(virNWFilterRuleProtocolType, rule->prtclType);\n        return -1;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNWFilterRuleProtocolType",
            "rule->prtclType"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"%s rule with port specification requires \"\n                                 \"protocol specification with protocol to be \"\n                                 \"either one of tcp(6), udp(17), dccp(33), or \"\n                                 \"sctp(132)\")",
            "protocol"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"%s rule with port specification requires \"\n                                 \"protocol specification with protocol to be \"\n                                 \"either one of tcp(6), udp(17), dccp(33), or \"\n                                 \"sctp(132)\""
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "dataProtocolID"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&portData->dataDstPortEnd"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&portData->dataSrcPortEnd"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&portData->dataDstPortStart"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&portData->dataSrcPortStart"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirNWFilterRuleValidate(virNWFilterRuleDefPtr rule)\n{\n    int ret = 0;\n    portDataDefPtr portData = NULL;\n    nwItemDescPtr dataProtocolID = NULL;\n    const char *protocol = NULL;\n\n    switch (rule->prtclType) {\n    case VIR_NWFILTER_RULE_PROTOCOL_IP:\n        portData = &rule->p.ipHdrFilter.portData;\n        protocol = \"IP\";\n        dataProtocolID = &rule->p.ipHdrFilter.ipHdr.dataProtocolID;\n        G_GNUC_FALLTHROUGH;\n    case VIR_NWFILTER_RULE_PROTOCOL_IPV6:\n        if (portData == NULL) {\n            portData = &rule->p.ipv6HdrFilter.portData;\n            protocol = \"IPv6\";\n            dataProtocolID = &rule->p.ipv6HdrFilter.ipHdr.dataProtocolID;\n        }\n        if (HAS_ENTRY_ITEM(&portData->dataSrcPortStart) ||\n            HAS_ENTRY_ITEM(&portData->dataDstPortStart) ||\n            HAS_ENTRY_ITEM(&portData->dataSrcPortEnd) ||\n            HAS_ENTRY_ITEM(&portData->dataDstPortEnd)) {\n            if (HAS_ENTRY_ITEM(dataProtocolID)) {\n                switch (dataProtocolID->u.u8) {\n                case 6:   /* tcp */\n                case 17:  /* udp */\n                case 33:  /* dccp */\n                case 132: /* sctp */\n                    break;\n                default:\n                    ret = -1;\n                }\n            } else {\n                ret = -1;\n            }\n            if (ret < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s rule with port specification requires \"\n                                 \"protocol specification with protocol to be \"\n                                 \"either one of tcp(6), udp(17), dccp(33), or \"\n                                 \"sctp(132)\"), protocol);\n            }\n        }\n        break;\n    case VIR_NWFILTER_RULE_PROTOCOL_NONE:\n    case VIR_NWFILTER_RULE_PROTOCOL_MAC:\n    case VIR_NWFILTER_RULE_PROTOCOL_VLAN:\n    case VIR_NWFILTER_RULE_PROTOCOL_STP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_RARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_TCP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMP:\n    case VIR_NWFILTER_RULE_PROTOCOL_IGMP:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDP:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITE:\n    case VIR_NWFILTER_RULE_PROTOCOL_ESP:\n    case VIR_NWFILTER_RULE_PROTOCOL_AH:\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ALL:\n    case VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6:\n    case VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6:\n        break;\n    case VIR_NWFILTER_RULE_PROTOCOL_LAST:\n    default:\n        virReportEnumRangeError(virNWFilterRuleProtocolType, rule->prtclType);\n        return -1;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virNWFilterRuleDefFixupIPSet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "2095-2107",
    "snippet": "static void\nvirNWFilterRuleDefFixupIPSet(ipHdrDataDefPtr ipHdr)\n{\n    if (HAS_ENTRY_ITEM(&ipHdr->dataIPSet) &&\n        !HAS_ENTRY_ITEM(&ipHdr->dataIPSetFlags)) {\n        ipHdr->dataIPSetFlags.flags = NWFILTER_ENTRY_ITEM_FLAG_EXISTS;\n        ipHdr->dataIPSetFlags.u.ipset.numFlags = 1;\n        ipHdr->dataIPSetFlags.u.ipset.flags = 1;\n    } else {\n        ipHdr->dataIPSet.flags = 0;\n        ipHdr->dataIPSetFlags.flags = 0;\n    }\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ipHdr->dataIPSetFlags"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ipHdr->dataIPSet"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirNWFilterRuleDefFixupIPSet(ipHdrDataDefPtr ipHdr)\n{\n    if (HAS_ENTRY_ITEM(&ipHdr->dataIPSet) &&\n        !HAS_ENTRY_ITEM(&ipHdr->dataIPSetFlags)) {\n        ipHdr->dataIPSetFlags.flags = NWFILTER_ENTRY_ITEM_FLAG_EXISTS;\n        ipHdr->dataIPSetFlags.u.ipset.numFlags = 1;\n        ipHdr->dataIPSetFlags.u.ipset.flags = 1;\n    } else {\n        ipHdr->dataIPSet.flags = 0;\n        ipHdr->dataIPSetFlags.flags = 0;\n    }\n}"
  },
  {
    "function_name": "virNWFilterIncludeParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "2067-2092",
    "snippet": "static virNWFilterIncludeDefPtr\nvirNWFilterIncludeParse(xmlNodePtr cur)\n{\n    virNWFilterIncludeDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->filterref = virXMLPropString(cur, \"filter\");\n    if (!ret->filterref) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"rule node requires action attribute\"));\n        goto err_exit;\n    }\n\n    ret->params = virNWFilterParseParamAttributes(cur);\n    if (!ret->params)\n        goto err_exit;\n\n    return ret;\n\n err_exit:\n    virNWFilterIncludeDefFree(ret);\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNWFilterIncludeDefFree",
          "args": [
            "ret"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterIncludeDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "321-329",
          "snippet": "static void\nvirNWFilterIncludeDefFree(virNWFilterIncludeDefPtr inc)\n{\n    if (!inc)\n        return;\n    virHashFree(inc->params);\n    VIR_FREE(inc->filterref);\n    VIR_FREE(inc);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirNWFilterIncludeDefFree(virNWFilterIncludeDefPtr inc)\n{\n    if (!inc)\n        return;\n    virHashFree(inc->params);\n    VIR_FREE(inc->filterref);\n    VIR_FREE(inc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterParseParamAttributes",
          "args": [
            "cur"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterParseParamAttributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_params.c",
          "lines": "717-773",
          "snippet": "virHashTablePtr\nvirNWFilterParseParamAttributes(xmlNodePtr cur)\n{\n    char *nam, *val;\n    virNWFilterVarValuePtr value;\n\n    virHashTablePtr table = virNWFilterHashTableCreate(0);\n    if (!table)\n        return NULL;\n\n    cur = cur->children;\n\n    while (cur != NULL) {\n        if (cur->type == XML_ELEMENT_NODE) {\n            if (virXMLNodeNameEqual(cur, \"parameter\")) {\n                nam = virXMLPropString(cur, \"name\");\n                val = virXMLPropString(cur, \"value\");\n                value = NULL;\n                if (nam != NULL && val != NULL) {\n                    if (!isValidVarName(nam))\n                        goto skip_entry;\n                    if (!isValidVarValue(val))\n                        goto skip_entry;\n                    value = virHashLookup(table, nam);\n                    if (value) {\n                        /* add value to existing value -> list */\n                        if (virNWFilterVarValueAddValue(value, val) < 0) {\n                            value = NULL;\n                            goto err_exit;\n                        }\n                        val = NULL;\n                    } else {\n                        value = virNWFilterParseVarValue(val);\n                        if (!value)\n                            goto skip_entry;\n                        if (virHashUpdateEntry(table, nam, value) < 0)\n                            goto err_exit;\n                    }\n                    value = NULL;\n                }\n skip_entry:\n                virNWFilterVarValueFree(value);\n                VIR_FREE(nam);\n                VIR_FREE(val);\n            }\n        }\n        cur = cur->next;\n    }\n    return table;\n\n err_exit:\n    VIR_FREE(nam);\n    VIR_FREE(val);\n    virNWFilterVarValueFree(value);\n    virHashFree(table);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool isValidVarValue(const char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic bool isValidVarValue(const char *value);\n\nvirHashTablePtr\nvirNWFilterParseParamAttributes(xmlNodePtr cur)\n{\n    char *nam, *val;\n    virNWFilterVarValuePtr value;\n\n    virHashTablePtr table = virNWFilterHashTableCreate(0);\n    if (!table)\n        return NULL;\n\n    cur = cur->children;\n\n    while (cur != NULL) {\n        if (cur->type == XML_ELEMENT_NODE) {\n            if (virXMLNodeNameEqual(cur, \"parameter\")) {\n                nam = virXMLPropString(cur, \"name\");\n                val = virXMLPropString(cur, \"value\");\n                value = NULL;\n                if (nam != NULL && val != NULL) {\n                    if (!isValidVarName(nam))\n                        goto skip_entry;\n                    if (!isValidVarValue(val))\n                        goto skip_entry;\n                    value = virHashLookup(table, nam);\n                    if (value) {\n                        /* add value to existing value -> list */\n                        if (virNWFilterVarValueAddValue(value, val) < 0) {\n                            value = NULL;\n                            goto err_exit;\n                        }\n                        val = NULL;\n                    } else {\n                        value = virNWFilterParseVarValue(val);\n                        if (!value)\n                            goto skip_entry;\n                        if (virHashUpdateEntry(table, nam, value) < 0)\n                            goto err_exit;\n                    }\n                    value = NULL;\n                }\n skip_entry:\n                virNWFilterVarValueFree(value);\n                VIR_FREE(nam);\n                VIR_FREE(val);\n            }\n        }\n        cur = cur->next;\n    }\n    return table;\n\n err_exit:\n    VIR_FREE(nam);\n    VIR_FREE(val);\n    virNWFilterVarValueFree(value);\n    virHashFree(table);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"rule node requires action attribute\")"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"rule node requires action attribute\""
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "cur",
            "\"filter\""
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ret"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNWFilterIncludeDefPtr\nvirNWFilterIncludeParse(xmlNodePtr cur)\n{\n    virNWFilterIncludeDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->filterref = virXMLPropString(cur, \"filter\");\n    if (!ret->filterref) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"rule node requires action attribute\"));\n        goto err_exit;\n    }\n\n    ret->params = virNWFilterParseParamAttributes(cur);\n    if (!ret->params)\n        goto err_exit;\n\n    return ret;\n\n err_exit:\n    virNWFilterIncludeDefFree(ret);\n    return NULL;\n}"
  },
  {
    "function_name": "virNWFilterRuleDetailsParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "1799-2064",
    "snippet": "static int\nvirNWFilterRuleDetailsParse(xmlNodePtr node,\n                            virNWFilterRuleDefPtr nwf,\n                            const virXMLAttr2Struct *att)\n{\n    int rc = 0, g_rc = 0;\n    int idx = 0;\n    char *prop;\n    bool found = false;\n    enum attrDatatype datatype, att_datatypes;\n    virNWFilterEntryItemFlags *flags, match_flag = 0, flags_set = 0;\n    nwItemDesc *item;\n    int int_val;\n    unsigned int uint_val;\n    union data data;\n    valueValidator validator;\n    char *match = virXMLPropString(node, \"match\");\n    virSocketAddr ipaddr;\n    int base;\n\n    if (match && STREQ(match, \"no\"))\n        match_flag = NWFILTER_ENTRY_ITEM_FLAG_IS_NEG;\n    VIR_FREE(match);\n    match = NULL;\n\n    while (att[idx].name != NULL) {\n        prop = virXMLPropString(node, att[idx].name);\n\n        VIR_WARNINGS_NO_CAST_ALIGN\n        item = (nwItemDesc *)((char *)nwf + att[idx].dataIdx);\n        VIR_WARNINGS_RESET\n        flags = &item->flags;\n        flags_set = match_flag;\n\n        if (prop) {\n            found = false;\n\n            validator = NULL;\n\n            if (STRPREFIX(prop, \"$\")) {\n                flags_set |= NWFILTER_ENTRY_ITEM_FLAG_HAS_VAR;\n                if (virNWFilterRuleDefAddVar(nwf,\n                                             item,\n                                             &prop[1]) < 0)\n                    rc = -1;\n                found = true;\n            }\n\n            datatype = 1;\n\n            att_datatypes = att[idx].datatype;\n\n            while (datatype <= DATATYPE_LAST && found == 0 && rc == 0) {\n                if ((att_datatypes & datatype)) {\n\n                    att_datatypes ^= datatype;\n\n                    validator = att[idx].validator;\n\n                    base = 10;\n\n                    switch (datatype) {\n                        case DATATYPE_UINT8_HEX:\n                            base = 16;\n                            G_GNUC_FALLTHROUGH;\n                        case DATATYPE_UINT8:\n                            if (virStrToLong_ui(prop, NULL, base, &uint_val) >= 0) {\n                                if (uint_val <= 0xff) {\n                                    item->u.u8 = uint_val;\n                                    found = true;\n                                    data.ui = uint_val;\n                                } else {\n                                    rc = -1;\n                                }\n                            } else {\n                                rc = -1;\n                            }\n                        break;\n\n                        case DATATYPE_UINT16_HEX:\n                            base = 16;\n                            G_GNUC_FALLTHROUGH;\n                        case DATATYPE_UINT16:\n                            if (virStrToLong_ui(prop, NULL, base, &uint_val) >= 0) {\n                                if (uint_val <= 0xffff) {\n                                    item->u.u16 = uint_val;\n                                    found = true;\n                                    data.ui = uint_val;\n                                } else {\n                                    rc = -1;\n                                }\n                            } else {\n                                rc = -1;\n                            }\n                        break;\n\n                        case DATATYPE_UINT32_HEX:\n                            base = 16;\n                            G_GNUC_FALLTHROUGH;\n                        case DATATYPE_UINT32:\n                            if (virStrToLong_ui(prop, NULL, base, &uint_val) >= 0) {\n                                item->u.u32 = uint_val;\n                                found = true;\n                                data.ui = uint_val;\n                            } else {\n                                rc = -1;\n                            }\n                        break;\n\n                        case DATATYPE_IPADDR:\n                            if (virSocketAddrParseIPv4(&item->u.ipaddr, prop) < 0)\n                                rc = -1;\n                            found = true;\n                        break;\n\n                        case DATATYPE_IPMASK:\n                            if (virStrToLong_ui(prop, NULL, 10, &uint_val) == 0) {\n                                if (uint_val <= 32) {\n                                    if (!validator)\n                                        item->u.u8 = (uint8_t)uint_val;\n                                    found = true;\n                                    data.ui = uint_val;\n                                } else {\n                                    rc = -1;\n                                }\n                            } else {\n                                if (virSocketAddrParseIPv4(&ipaddr, prop) < 0) {\n                                    rc = -1;\n                                } else {\n                                    int_val = virSocketAddrGetNumNetmaskBits(&ipaddr);\n                                    if (int_val >= 0)\n                                        item->u.u8 = int_val;\n                                    else\n                                        rc = -1;\n                                    found = true;\n                                }\n                            }\n                        break;\n\n                        case DATATYPE_MACADDR:\n                            if (virMacAddrParse(prop,\n                                                &item->u.macaddr) < 0) {\n                                rc = -1;\n                            }\n                            found = true;\n                        break;\n\n                        case DATATYPE_MACMASK:\n                            validator = checkMACMask;\n                            if (virMacAddrParse(prop,\n                                                &item->u.macaddr) < 0) {\n                                rc = -1;\n                            }\n                            data.v = &item->u.macaddr;\n                            found = true;\n                        break;\n\n                        case DATATYPE_IPV6ADDR:\n                            if (virSocketAddrParseIPv6(&item->u.ipaddr, prop) < 0)\n                                rc = -1;\n                            found = true;\n                        break;\n\n                        case DATATYPE_IPV6MASK:\n                            if (virStrToLong_ui(prop, NULL, 10, &uint_val) == 0) {\n                                if (uint_val <= 128) {\n                                    if (!validator)\n                                        item->u.u8 = (uint8_t)uint_val;\n                                    found = true;\n                                    data.ui = uint_val;\n                                } else {\n                                    rc = -1;\n                                }\n                            } else {\n                                if (virSocketAddrParseIPv6(&ipaddr, prop) < 0) {\n                                    rc = -1;\n                                } else {\n                                    int_val = virSocketAddrGetNumNetmaskBits(&ipaddr);\n                                    if (int_val >= 0)\n                                        item->u.u8 = int_val;\n                                    else\n                                        rc = -1;\n                                    found = true;\n                                }\n                            }\n                        break;\n\n                        case DATATYPE_STRING:\n                        case DATATYPE_IPSETFLAGS:\n                        case DATATYPE_IPSETNAME:\n                            if (!validator) {\n                                /* not supported */\n                                rc = -1;\n                                break;\n                            }\n                            data.c = prop;\n                            found = true;\n                        break;\n\n                        case DATATYPE_STRINGCOPY:\n                            if (!(item->u.string =\n                                  virNWFilterRuleDefAddString(nwf, prop,\n                                                       att[idx].maxstrlen))) {\n                                rc = -1;\n                                break;\n                            }\n                            data.c = item->u.string;\n                            found = true;\n                        break;\n\n                        case DATATYPE_BOOLEAN:\n                            if (STREQ(prop, \"true\") ||\n                                STREQ(prop, \"1\") ||\n                                STREQ(prop, \"yes\"))\n                                item->u.boolean = true;\n                            else\n                                item->u.boolean = false;\n\n                            data.ui = item->u.boolean;\n                            found = true;\n                        break;\n\n                        case DATATYPE_LAST:\n                        default:\n                        break;\n                    }\n                }\n\n                if (rc != 0 && att_datatypes != 0) {\n                    rc = 0;\n                    found = false;\n                }\n\n                datatype <<= 1;\n            } /* while */\n\n            if (found && rc == 0) {\n                *flags = NWFILTER_ENTRY_ITEM_FLAG_EXISTS | flags_set;\n                item->datatype = datatype >> 1;\n                if (validator) {\n                    if (!validator(datatype >> 1, &data, nwf, item)) {\n                        rc = -1;\n                        *flags = 0;\n                    }\n                }\n            }\n\n            if (!found || rc) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s has illegal value %s\"),\n                               att[idx].name, prop);\n                rc = -1;\n            }\n            VIR_FREE(prop);\n        }\n\n        if (rc) {\n            g_rc = rc;\n            rc = 0;\n        }\n\n        idx++;\n    }\n\n    return g_rc;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "prop"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"%s has illegal value %s\")",
            "att[idx].name",
            "prop"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"%s has illegal value %s\""
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validator",
          "args": [
            "datatype >> 1",
            "&data",
            "nwf",
            "item"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "prop",
            "\"yes\""
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "prop",
            "\"1\""
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "prop",
            "\"true\""
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleDefAddString",
          "args": [
            "nwf",
            "prop",
            "att[idx].maxstrlen"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRuleDefAddString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "396-408",
          "snippet": "static char *\nvirNWFilterRuleDefAddString(virNWFilterRuleDefPtr nwf,\n                            const char *string,\n                            size_t maxstrlen)\n{\n    char *tmp;\n\n    tmp = g_strndup(string, maxstrlen);\n    if (VIR_APPEND_ELEMENT_COPY(nwf->strings, nwf->nstrings, tmp) < 0)\n        VIR_FREE(tmp);\n\n    return tmp;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nvirNWFilterRuleDefAddString(virNWFilterRuleDefPtr nwf,\n                            const char *string,\n                            size_t maxstrlen)\n{\n    char *tmp;\n\n    tmp = g_strndup(string, maxstrlen);\n    if (VIR_APPEND_ELEMENT_COPY(nwf->strings, nwf->nstrings, tmp) < 0)\n        VIR_FREE(tmp);\n\n    return tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrGetNumNetmaskBits",
          "args": [
            "&ipaddr"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetNumNetmaskBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1009-1084",
          "snippet": "int virSocketAddrGetNumNetmaskBits(const virSocketAddr *netmask)\n{\n    size_t i, j;\n    int c = 0;\n\n    if (netmask->data.stor.ss_family == AF_INET) {\n        virSocketAddrIPv4 tm;\n        uint8_t bit;\n\n        if (virSocketAddrGetIPv4Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 4; i++)\n            if (tm[i] == 0xff)\n                c += 8;\n            else\n                break;\n\n        if (c == 8 * 4)\n            return c;\n\n        j = i << 3;\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                return -1;\n            j++;\n        }\n\n        return c;\n    } else if (netmask->data.stor.ss_family == AF_INET6) {\n        virSocketAddrIPv6 tm;\n        uint16_t bit;\n\n        if (virSocketAddrGetIPv6Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 8; i++)\n            if (tm[i] == 0xffff)\n                c += 16;\n            else\n                break;\n\n        if (c == 16 * 8)\n            return c;\n\n        j = i << 4;\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4]) & bit)\n                return -1;\n            j++;\n        }\n\n        return c;\n    }\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrGetNumNetmaskBits(const virSocketAddr *netmask)\n{\n    size_t i, j;\n    int c = 0;\n\n    if (netmask->data.stor.ss_family == AF_INET) {\n        virSocketAddrIPv4 tm;\n        uint8_t bit;\n\n        if (virSocketAddrGetIPv4Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 4; i++)\n            if (tm[i] == 0xff)\n                c += 8;\n            else\n                break;\n\n        if (c == 8 * 4)\n            return c;\n\n        j = i << 3;\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                return -1;\n            j++;\n        }\n\n        return c;\n    } else if (netmask->data.stor.ss_family == AF_INET6) {\n        virSocketAddrIPv6 tm;\n        uint16_t bit;\n\n        if (virSocketAddrGetIPv6Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 8; i++)\n            if (tm[i] == 0xffff)\n                c += 16;\n            else\n                break;\n\n        if (c == 16 * 8)\n            return c;\n\n        j = i << 4;\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4]) & bit)\n                return -1;\n            j++;\n        }\n\n        return c;\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrParseIPv6",
          "args": [
            "&ipaddr",
            "prop"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParseIPv6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "230-234",
          "snippet": "int\nvirSocketAddrParseIPv6(virSocketAddrPtr addr, const char *val)\n{\n    return virSocketAddrParse(addr, val, AF_INET6);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrParseIPv6(virSocketAddrPtr addr, const char *val)\n{\n    return virSocketAddrParse(addr, val, AF_INET6);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "prop",
            "NULL",
            "10",
            "&uint_val"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrParse",
          "args": [
            "prop",
            "&item->u.macaddr"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "205-218",
          "snippet": "int\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrParseIPv4",
          "args": [
            "&ipaddr",
            "prop"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParseIPv4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "215-219",
          "snippet": "int\nvirSocketAddrParseIPv4(virSocketAddrPtr addr, const char *val)\n{\n    return virSocketAddrParse(addr, val, AF_INET);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrParseIPv4(virSocketAddrPtr addr, const char *val)\n{\n    return virSocketAddrParse(addr, val, AF_INET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleDefAddVar",
          "args": [
            "nwf",
            "item",
            "&prop[1]"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRuleDefAddVar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "363-393",
          "snippet": "static int\nvirNWFilterRuleDefAddVar(virNWFilterRuleDefPtr nwf,\n                         nwItemDesc *item,\n                         const char *var)\n{\n    size_t i = 0;\n    virNWFilterVarAccessPtr varAccess;\n\n    varAccess = virNWFilterVarAccessParse(var);\n    if (varAccess == NULL)\n        return -1;\n\n    if (nwf->varAccess) {\n        for (i = 0; i < nwf->nVarAccess; i++)\n            if (virNWFilterVarAccessEqual(nwf->varAccess[i], varAccess)) {\n                virNWFilterVarAccessFree(varAccess);\n                item->varAccess = nwf->varAccess[i];\n                return 0;\n            }\n    }\n\n    if (VIR_EXPAND_N(nwf->varAccess, nwf->nVarAccess, 1) < 0) {\n        virNWFilterVarAccessFree(varAccess);\n        return -1;\n    }\n\n    nwf->varAccess[nwf->nVarAccess - 1] = varAccess;\n    item->varAccess = varAccess;\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirNWFilterRuleDefAddVar(virNWFilterRuleDefPtr nwf,\n                         nwItemDesc *item,\n                         const char *var)\n{\n    size_t i = 0;\n    virNWFilterVarAccessPtr varAccess;\n\n    varAccess = virNWFilterVarAccessParse(var);\n    if (varAccess == NULL)\n        return -1;\n\n    if (nwf->varAccess) {\n        for (i = 0; i < nwf->nVarAccess; i++)\n            if (virNWFilterVarAccessEqual(nwf->varAccess[i], varAccess)) {\n                virNWFilterVarAccessFree(varAccess);\n                item->varAccess = nwf->varAccess[i];\n                return 0;\n            }\n    }\n\n    if (VIR_EXPAND_N(nwf->varAccess, nwf->nVarAccess, 1) < 0) {\n        virNWFilterVarAccessFree(varAccess);\n        return -1;\n    }\n\n    nwf->varAccess[nwf->nVarAccess - 1] = varAccess;\n    item->varAccess = varAccess;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "prop",
            "\"$\""
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "node",
            "att[idx].name"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "match"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "match",
            "\"no\""
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirNWFilterRuleDetailsParse(xmlNodePtr node,\n                            virNWFilterRuleDefPtr nwf,\n                            const virXMLAttr2Struct *att)\n{\n    int rc = 0, g_rc = 0;\n    int idx = 0;\n    char *prop;\n    bool found = false;\n    enum attrDatatype datatype, att_datatypes;\n    virNWFilterEntryItemFlags *flags, match_flag = 0, flags_set = 0;\n    nwItemDesc *item;\n    int int_val;\n    unsigned int uint_val;\n    union data data;\n    valueValidator validator;\n    char *match = virXMLPropString(node, \"match\");\n    virSocketAddr ipaddr;\n    int base;\n\n    if (match && STREQ(match, \"no\"))\n        match_flag = NWFILTER_ENTRY_ITEM_FLAG_IS_NEG;\n    VIR_FREE(match);\n    match = NULL;\n\n    while (att[idx].name != NULL) {\n        prop = virXMLPropString(node, att[idx].name);\n\n        VIR_WARNINGS_NO_CAST_ALIGN\n        item = (nwItemDesc *)((char *)nwf + att[idx].dataIdx);\n        VIR_WARNINGS_RESET\n        flags = &item->flags;\n        flags_set = match_flag;\n\n        if (prop) {\n            found = false;\n\n            validator = NULL;\n\n            if (STRPREFIX(prop, \"$\")) {\n                flags_set |= NWFILTER_ENTRY_ITEM_FLAG_HAS_VAR;\n                if (virNWFilterRuleDefAddVar(nwf,\n                                             item,\n                                             &prop[1]) < 0)\n                    rc = -1;\n                found = true;\n            }\n\n            datatype = 1;\n\n            att_datatypes = att[idx].datatype;\n\n            while (datatype <= DATATYPE_LAST && found == 0 && rc == 0) {\n                if ((att_datatypes & datatype)) {\n\n                    att_datatypes ^= datatype;\n\n                    validator = att[idx].validator;\n\n                    base = 10;\n\n                    switch (datatype) {\n                        case DATATYPE_UINT8_HEX:\n                            base = 16;\n                            G_GNUC_FALLTHROUGH;\n                        case DATATYPE_UINT8:\n                            if (virStrToLong_ui(prop, NULL, base, &uint_val) >= 0) {\n                                if (uint_val <= 0xff) {\n                                    item->u.u8 = uint_val;\n                                    found = true;\n                                    data.ui = uint_val;\n                                } else {\n                                    rc = -1;\n                                }\n                            } else {\n                                rc = -1;\n                            }\n                        break;\n\n                        case DATATYPE_UINT16_HEX:\n                            base = 16;\n                            G_GNUC_FALLTHROUGH;\n                        case DATATYPE_UINT16:\n                            if (virStrToLong_ui(prop, NULL, base, &uint_val) >= 0) {\n                                if (uint_val <= 0xffff) {\n                                    item->u.u16 = uint_val;\n                                    found = true;\n                                    data.ui = uint_val;\n                                } else {\n                                    rc = -1;\n                                }\n                            } else {\n                                rc = -1;\n                            }\n                        break;\n\n                        case DATATYPE_UINT32_HEX:\n                            base = 16;\n                            G_GNUC_FALLTHROUGH;\n                        case DATATYPE_UINT32:\n                            if (virStrToLong_ui(prop, NULL, base, &uint_val) >= 0) {\n                                item->u.u32 = uint_val;\n                                found = true;\n                                data.ui = uint_val;\n                            } else {\n                                rc = -1;\n                            }\n                        break;\n\n                        case DATATYPE_IPADDR:\n                            if (virSocketAddrParseIPv4(&item->u.ipaddr, prop) < 0)\n                                rc = -1;\n                            found = true;\n                        break;\n\n                        case DATATYPE_IPMASK:\n                            if (virStrToLong_ui(prop, NULL, 10, &uint_val) == 0) {\n                                if (uint_val <= 32) {\n                                    if (!validator)\n                                        item->u.u8 = (uint8_t)uint_val;\n                                    found = true;\n                                    data.ui = uint_val;\n                                } else {\n                                    rc = -1;\n                                }\n                            } else {\n                                if (virSocketAddrParseIPv4(&ipaddr, prop) < 0) {\n                                    rc = -1;\n                                } else {\n                                    int_val = virSocketAddrGetNumNetmaskBits(&ipaddr);\n                                    if (int_val >= 0)\n                                        item->u.u8 = int_val;\n                                    else\n                                        rc = -1;\n                                    found = true;\n                                }\n                            }\n                        break;\n\n                        case DATATYPE_MACADDR:\n                            if (virMacAddrParse(prop,\n                                                &item->u.macaddr) < 0) {\n                                rc = -1;\n                            }\n                            found = true;\n                        break;\n\n                        case DATATYPE_MACMASK:\n                            validator = checkMACMask;\n                            if (virMacAddrParse(prop,\n                                                &item->u.macaddr) < 0) {\n                                rc = -1;\n                            }\n                            data.v = &item->u.macaddr;\n                            found = true;\n                        break;\n\n                        case DATATYPE_IPV6ADDR:\n                            if (virSocketAddrParseIPv6(&item->u.ipaddr, prop) < 0)\n                                rc = -1;\n                            found = true;\n                        break;\n\n                        case DATATYPE_IPV6MASK:\n                            if (virStrToLong_ui(prop, NULL, 10, &uint_val) == 0) {\n                                if (uint_val <= 128) {\n                                    if (!validator)\n                                        item->u.u8 = (uint8_t)uint_val;\n                                    found = true;\n                                    data.ui = uint_val;\n                                } else {\n                                    rc = -1;\n                                }\n                            } else {\n                                if (virSocketAddrParseIPv6(&ipaddr, prop) < 0) {\n                                    rc = -1;\n                                } else {\n                                    int_val = virSocketAddrGetNumNetmaskBits(&ipaddr);\n                                    if (int_val >= 0)\n                                        item->u.u8 = int_val;\n                                    else\n                                        rc = -1;\n                                    found = true;\n                                }\n                            }\n                        break;\n\n                        case DATATYPE_STRING:\n                        case DATATYPE_IPSETFLAGS:\n                        case DATATYPE_IPSETNAME:\n                            if (!validator) {\n                                /* not supported */\n                                rc = -1;\n                                break;\n                            }\n                            data.c = prop;\n                            found = true;\n                        break;\n\n                        case DATATYPE_STRINGCOPY:\n                            if (!(item->u.string =\n                                  virNWFilterRuleDefAddString(nwf, prop,\n                                                       att[idx].maxstrlen))) {\n                                rc = -1;\n                                break;\n                            }\n                            data.c = item->u.string;\n                            found = true;\n                        break;\n\n                        case DATATYPE_BOOLEAN:\n                            if (STREQ(prop, \"true\") ||\n                                STREQ(prop, \"1\") ||\n                                STREQ(prop, \"yes\"))\n                                item->u.boolean = true;\n                            else\n                                item->u.boolean = false;\n\n                            data.ui = item->u.boolean;\n                            found = true;\n                        break;\n\n                        case DATATYPE_LAST:\n                        default:\n                        break;\n                    }\n                }\n\n                if (rc != 0 && att_datatypes != 0) {\n                    rc = 0;\n                    found = false;\n                }\n\n                datatype <<= 1;\n            } /* while */\n\n            if (found && rc == 0) {\n                *flags = NWFILTER_ENTRY_ITEM_FLAG_EXISTS | flags_set;\n                item->datatype = datatype >> 1;\n                if (validator) {\n                    if (!validator(datatype >> 1, &data, nwf, item)) {\n                        rc = -1;\n                        *flags = 0;\n                    }\n                }\n            }\n\n            if (!found || rc) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"%s has illegal value %s\"),\n                               att[idx].name, prop);\n                rc = -1;\n            }\n            VIR_FREE(prop);\n        }\n\n        if (rc) {\n            g_rc = rc;\n            rc = 0;\n        }\n\n        idx++;\n    }\n\n    return g_rc;\n}"
  },
  {
    "function_name": "ipsetFlagsFormatter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "1048-1065",
    "snippet": "static bool\nipsetFlagsFormatter(virBufferPtr buf,\n                    virNWFilterRuleDefPtr nwf G_GNUC_UNUSED,\n                    nwItemDesc *item)\n{\n    uint8_t ctr;\n\n    for (ctr = 0; ctr < item->u.ipset.numFlags; ctr++) {\n        if (ctr != 0)\n            virBufferAddLit(buf, \",\");\n        if ((item->u.ipset.flags & (1 << ctr)))\n            virBufferAddLit(buf, \"src\");\n        else\n            virBufferAddLit(buf, \"dst\");\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"dst\""
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"src\""
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\",\""
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool\nipsetFlagsFormatter(virBufferPtr buf,\n                    virNWFilterRuleDefPtr nwf G_GNUC_UNUSED,\n                    nwItemDesc *item)\n{\n    uint8_t ctr;\n\n    for (ctr = 0; ctr < item->u.ipset.numFlags; ctr++) {\n        if (ctr != 0)\n            virBufferAddLit(buf, \",\");\n        if ((item->u.ipset.flags & (1 << ctr)))\n            virBufferAddLit(buf, \"src\");\n        else\n            virBufferAddLit(buf, \"dst\");\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "ipsetFlagsValidator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "1009-1045",
    "snippet": "static bool\nipsetFlagsValidator(enum attrDatatype datatype G_GNUC_UNUSED,\n                    union data *val,\n                    virNWFilterRuleDefPtr nwf G_GNUC_UNUSED,\n                    nwItemDesc *item)\n{\n    const char *errmsg = NULL;\n    size_t idx = 0;\n\n    item->u.ipset.numFlags = 0;\n    item->u.ipset.flags = 0;\n\n    errmsg = _(\"malformed ipset flags\");\n\n    while (item->u.ipset.numFlags < 6) {\n        if (STRCASEEQLEN(&val->c[idx], \"src\", 3)) {\n            item->u.ipset.flags |= (1 << item->u.ipset.numFlags);\n        } else if (!STRCASEEQLEN(&val->c[idx], \"dst\", 3)) {\n            goto arg_err_exit;\n        }\n        item->u.ipset.numFlags++;\n        idx += 3;\n        if (val->c[idx] != ',')\n            break;\n        idx++;\n    }\n\n    if (val->c[idx] != '\\0')\n        goto arg_err_exit;\n\n    return true;\n\n arg_err_exit:\n    virReportError(VIR_ERR_INVALID_ARG,\n                   \"%s\", errmsg);\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "errmsg"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQLEN",
          "args": [
            "&val->c[idx]",
            "\"dst\"",
            "3"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQLEN",
          "args": [
            "&val->c[idx]",
            "\"src\"",
            "3"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"malformed ipset flags\""
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool\nipsetFlagsValidator(enum attrDatatype datatype G_GNUC_UNUSED,\n                    union data *val,\n                    virNWFilterRuleDefPtr nwf G_GNUC_UNUSED,\n                    nwItemDesc *item)\n{\n    const char *errmsg = NULL;\n    size_t idx = 0;\n\n    item->u.ipset.numFlags = 0;\n    item->u.ipset.flags = 0;\n\n    errmsg = _(\"malformed ipset flags\");\n\n    while (item->u.ipset.numFlags < 6) {\n        if (STRCASEEQLEN(&val->c[idx], \"src\", 3)) {\n            item->u.ipset.flags |= (1 << item->u.ipset.numFlags);\n        } else if (!STRCASEEQLEN(&val->c[idx], \"dst\", 3)) {\n            goto arg_err_exit;\n        }\n        item->u.ipset.numFlags++;\n        idx += 3;\n        if (val->c[idx] != ',')\n            break;\n        idx++;\n    }\n\n    if (val->c[idx] != '\\0')\n        goto arg_err_exit;\n\n    return true;\n\n arg_err_exit:\n    virReportError(VIR_ERR_INVALID_ARG,\n                   \"%s\", errmsg);\n    return false;\n}"
  },
  {
    "function_name": "ipsetFormatter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "998-1006",
    "snippet": "static bool\nipsetFormatter(virBufferPtr buf,\n               virNWFilterRuleDefPtr nwf G_GNUC_UNUSED,\n               nwItemDesc *item)\n{\n    virBufferAdd(buf, item->u.ipset.setname, -1);\n\n    return true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "buf",
            "item->u.ipset.setname",
            "-1"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool\nipsetFormatter(virBufferPtr buf,\n               virNWFilterRuleDefPtr nwf G_GNUC_UNUSED,\n               nwItemDesc *item)\n{\n    virBufferAdd(buf, item->u.ipset.setname, -1);\n\n    return true;\n}"
  },
  {
    "function_name": "ipsetValidator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "970-995",
    "snippet": "static bool\nipsetValidator(enum attrDatatype datatype G_GNUC_UNUSED,\n               union data *val,\n               virNWFilterRuleDefPtr nwf G_GNUC_UNUSED,\n               nwItemDesc *item)\n{\n    const char *errmsg = NULL;\n\n    if (virStrcpyStatic(item->u.ipset.setname, val->c) < 0) {\n        errmsg = _(\"ipset name is too long\");\n        goto arg_err_exit;\n    }\n\n    if (item->u.ipset.setname[strspn(item->u.ipset.setname,\n                                     VALID_IPSETNAME)] != 0) {\n        errmsg = _(\"ipset name contains invalid characters\");\n        goto arg_err_exit;\n    }\n\n    return true;\n\n arg_err_exit:\n    virReportError(VIR_ERR_INVALID_ARG,\n                   \"%s\", errmsg);\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "errmsg"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"ipset name contains invalid characters\""
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "item->u.ipset.setname",
            "VALID_IPSETNAME"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "item->u.ipset.setname",
            "val->c"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool\nipsetValidator(enum attrDatatype datatype G_GNUC_UNUSED,\n               union data *val,\n               virNWFilterRuleDefPtr nwf G_GNUC_UNUSED,\n               nwItemDesc *item)\n{\n    const char *errmsg = NULL;\n\n    if (virStrcpyStatic(item->u.ipset.setname, val->c) < 0) {\n        errmsg = _(\"ipset name is too long\");\n        goto arg_err_exit;\n    }\n\n    if (item->u.ipset.setname[strspn(item->u.ipset.setname,\n                                     VALID_IPSETNAME)] != 0) {\n        errmsg = _(\"ipset name contains invalid characters\");\n        goto arg_err_exit;\n    }\n\n    return true;\n\n arg_err_exit:\n    virReportError(VIR_ERR_INVALID_ARG,\n                   \"%s\", errmsg);\n    return false;\n}"
  },
  {
    "function_name": "tcpFlagsFormatter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "957-967",
    "snippet": "static bool\ntcpFlagsFormatter(virBufferPtr buf,\n                  virNWFilterRuleDefPtr nwf G_GNUC_UNUSED,\n                  nwItemDesc *item)\n{\n    printTCPFlags(buf, item->u.tcpFlags.mask);\n    virBufferAddLit(buf, \"/\");\n    printTCPFlags(buf, item->u.tcpFlags.flags);\n\n    return true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct int_map tcpFlags[] = {\n    INTMAP_ENTRY(0x1,  \"FIN\"),\n    INTMAP_ENTRY(0x2,  \"SYN\"),\n    INTMAP_ENTRY(0x4,  \"RST\"),\n    INTMAP_ENTRY(0x8,  \"PSH\"),\n    INTMAP_ENTRY(0x10, \"ACK\"),\n    INTMAP_ENTRY(0x20, \"URG\"),\n    INTMAP_ENTRY(0x3F, \"ALL\"),\n    INTMAP_ENTRY(0x0,  \"NONE\"),\n    INTMAP_ENTRY_LAST\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printTCPFlags",
          "args": [
            "buf",
            "item->u.tcpFlags.flags"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "printTCPFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "935-945",
          "snippet": "static void\nprintTCPFlags(virBufferPtr buf,\n              uint8_t flags)\n{\n    if (flags == 0)\n        virBufferAddLit(buf, \"NONE\");\n    else if (flags == 0x3f)\n        virBufferAddLit(buf, \"ALL\");\n    else\n        printStringItems(buf, tcpFlags, flags, \",\");\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct int_map tcpFlags[] = {\n    INTMAP_ENTRY(0x1,  \"FIN\"),\n    INTMAP_ENTRY(0x2,  \"SYN\"),\n    INTMAP_ENTRY(0x4,  \"RST\"),\n    INTMAP_ENTRY(0x8,  \"PSH\"),\n    INTMAP_ENTRY(0x10, \"ACK\"),\n    INTMAP_ENTRY(0x20, \"URG\"),\n    INTMAP_ENTRY(0x3F, \"ALL\"),\n    INTMAP_ENTRY(0x0,  \"NONE\"),\n    INTMAP_ENTRY_LAST\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map tcpFlags[] = {\n    INTMAP_ENTRY(0x1,  \"FIN\"),\n    INTMAP_ENTRY(0x2,  \"SYN\"),\n    INTMAP_ENTRY(0x4,  \"RST\"),\n    INTMAP_ENTRY(0x8,  \"PSH\"),\n    INTMAP_ENTRY(0x10, \"ACK\"),\n    INTMAP_ENTRY(0x20, \"URG\"),\n    INTMAP_ENTRY(0x3F, \"ALL\"),\n    INTMAP_ENTRY(0x0,  \"NONE\"),\n    INTMAP_ENTRY_LAST\n};\n\nstatic void\nprintTCPFlags(virBufferPtr buf,\n              uint8_t flags)\n{\n    if (flags == 0)\n        virBufferAddLit(buf, \"NONE\");\n    else if (flags == 0x3f)\n        virBufferAddLit(buf, \"ALL\");\n    else\n        printStringItems(buf, tcpFlags, flags, \",\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/\""
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map tcpFlags[] = {\n    INTMAP_ENTRY(0x1,  \"FIN\"),\n    INTMAP_ENTRY(0x2,  \"SYN\"),\n    INTMAP_ENTRY(0x4,  \"RST\"),\n    INTMAP_ENTRY(0x8,  \"PSH\"),\n    INTMAP_ENTRY(0x10, \"ACK\"),\n    INTMAP_ENTRY(0x20, \"URG\"),\n    INTMAP_ENTRY(0x3F, \"ALL\"),\n    INTMAP_ENTRY(0x0,  \"NONE\"),\n    INTMAP_ENTRY_LAST\n};\n\nstatic bool\ntcpFlagsFormatter(virBufferPtr buf,\n                  virNWFilterRuleDefPtr nwf G_GNUC_UNUSED,\n                  nwItemDesc *item)\n{\n    printTCPFlags(buf, item->u.tcpFlags.mask);\n    virBufferAddLit(buf, \"/\");\n    printTCPFlags(buf, item->u.tcpFlags.flags);\n\n    return true;\n}"
  },
  {
    "function_name": "virNWFilterPrintTCPFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "948-954",
    "snippet": "char *\nvirNWFilterPrintTCPFlags(uint8_t flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    printTCPFlags(&buf, flags);\n    return virBufferContentAndReset(&buf);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printTCPFlags",
          "args": [
            "&buf",
            "flags"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "printTCPFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "935-945",
          "snippet": "static void\nprintTCPFlags(virBufferPtr buf,\n              uint8_t flags)\n{\n    if (flags == 0)\n        virBufferAddLit(buf, \"NONE\");\n    else if (flags == 0x3f)\n        virBufferAddLit(buf, \"ALL\");\n    else\n        printStringItems(buf, tcpFlags, flags, \",\");\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct int_map tcpFlags[] = {\n    INTMAP_ENTRY(0x1,  \"FIN\"),\n    INTMAP_ENTRY(0x2,  \"SYN\"),\n    INTMAP_ENTRY(0x4,  \"RST\"),\n    INTMAP_ENTRY(0x8,  \"PSH\"),\n    INTMAP_ENTRY(0x10, \"ACK\"),\n    INTMAP_ENTRY(0x20, \"URG\"),\n    INTMAP_ENTRY(0x3F, \"ALL\"),\n    INTMAP_ENTRY(0x0,  \"NONE\"),\n    INTMAP_ENTRY_LAST\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map tcpFlags[] = {\n    INTMAP_ENTRY(0x1,  \"FIN\"),\n    INTMAP_ENTRY(0x2,  \"SYN\"),\n    INTMAP_ENTRY(0x4,  \"RST\"),\n    INTMAP_ENTRY(0x8,  \"PSH\"),\n    INTMAP_ENTRY(0x10, \"ACK\"),\n    INTMAP_ENTRY(0x20, \"URG\"),\n    INTMAP_ENTRY(0x3F, \"ALL\"),\n    INTMAP_ENTRY(0x0,  \"NONE\"),\n    INTMAP_ENTRY_LAST\n};\n\nstatic void\nprintTCPFlags(virBufferPtr buf,\n              uint8_t flags)\n{\n    if (flags == 0)\n        virBufferAddLit(buf, \"NONE\");\n    else if (flags == 0x3f)\n        virBufferAddLit(buf, \"ALL\");\n    else\n        printStringItems(buf, tcpFlags, flags, \",\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirNWFilterPrintTCPFlags(uint8_t flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    printTCPFlags(&buf, flags);\n    return virBufferContentAndReset(&buf);\n}"
  },
  {
    "function_name": "printTCPFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "935-945",
    "snippet": "static void\nprintTCPFlags(virBufferPtr buf,\n              uint8_t flags)\n{\n    if (flags == 0)\n        virBufferAddLit(buf, \"NONE\");\n    else if (flags == 0x3f)\n        virBufferAddLit(buf, \"ALL\");\n    else\n        printStringItems(buf, tcpFlags, flags, \",\");\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct int_map tcpFlags[] = {\n    INTMAP_ENTRY(0x1,  \"FIN\"),\n    INTMAP_ENTRY(0x2,  \"SYN\"),\n    INTMAP_ENTRY(0x4,  \"RST\"),\n    INTMAP_ENTRY(0x8,  \"PSH\"),\n    INTMAP_ENTRY(0x10, \"ACK\"),\n    INTMAP_ENTRY(0x20, \"URG\"),\n    INTMAP_ENTRY(0x3F, \"ALL\"),\n    INTMAP_ENTRY(0x0,  \"NONE\"),\n    INTMAP_ENTRY_LAST\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printStringItems",
          "args": [
            "buf",
            "tcpFlags",
            "flags",
            "\",\""
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "printStringItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "799-827",
          "snippet": "static int\nprintStringItems(virBufferPtr buf,\n                 const struct int_map *int_map,\n                 int32_t flags,\n                 const char *sep)\n{\n    size_t i;\n    unsigned int c = 0;\n    int32_t mask = 0x1;\n\n    while (mask) {\n        if ((mask & flags)) {\n            for (i = 0; int_map[i].val; i++) {\n                if (mask == int_map[i].attr) {\n                    if (c >= 1)\n                        virBufferAdd(buf, sep, -1);\n                    virBufferAdd(buf, int_map[i].val, -1);\n                    c++;\n                }\n            }\n            flags ^= mask;\n        }\n        if (!flags)\n            break;\n        mask <<= 1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprintStringItems(virBufferPtr buf,\n                 const struct int_map *int_map,\n                 int32_t flags,\n                 const char *sep)\n{\n    size_t i;\n    unsigned int c = 0;\n    int32_t mask = 0x1;\n\n    while (mask) {\n        if ((mask & flags)) {\n            for (i = 0; int_map[i].val; i++) {\n                if (mask == int_map[i].attr) {\n                    if (c >= 1)\n                        virBufferAdd(buf, sep, -1);\n                    virBufferAdd(buf, int_map[i].val, -1);\n                    c++;\n                }\n            }\n            flags ^= mask;\n        }\n        if (!flags)\n            break;\n        mask <<= 1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"ALL\""
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"NONE\""
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map tcpFlags[] = {\n    INTMAP_ENTRY(0x1,  \"FIN\"),\n    INTMAP_ENTRY(0x2,  \"SYN\"),\n    INTMAP_ENTRY(0x4,  \"RST\"),\n    INTMAP_ENTRY(0x8,  \"PSH\"),\n    INTMAP_ENTRY(0x10, \"ACK\"),\n    INTMAP_ENTRY(0x20, \"URG\"),\n    INTMAP_ENTRY(0x3F, \"ALL\"),\n    INTMAP_ENTRY(0x0,  \"NONE\"),\n    INTMAP_ENTRY_LAST\n};\n\nstatic void\nprintTCPFlags(virBufferPtr buf,\n              uint8_t flags)\n{\n    if (flags == 0)\n        virBufferAddLit(buf, \"NONE\");\n    else if (flags == 0x3f)\n        virBufferAddLit(buf, \"ALL\");\n    else\n        printStringItems(buf, tcpFlags, flags, \",\");\n}"
  },
  {
    "function_name": "tcpFlagsValidator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "903-932",
    "snippet": "static bool\ntcpFlagsValidator(enum attrDatatype datatype G_GNUC_UNUSED,\n                  union data *val,\n                  virNWFilterRuleDefPtr nwf G_GNUC_UNUSED,\n                  nwItemDesc *item)\n{\n    bool rc = false;\n    char *s_mask = val->c;\n    char *sep = strchr(val->c, '/');\n    char *s_flags;\n    int32_t mask = 0, flags = 0;\n\n    if (!sep)\n        return false;\n\n    s_flags = sep + 1;\n\n    *sep = '\\0';\n\n    if (parseStringItems(tcpFlags, s_mask, &mask, ',') == 0 &&\n        parseStringItems(tcpFlags, s_flags, &flags, ',') == 0) {\n        item->u.tcpFlags.mask  = mask  & 0x3f;\n        item->u.tcpFlags.flags = flags & 0x3f;\n        rc = true;\n    }\n\n    *sep = '/';\n\n    return rc;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct int_map tcpFlags[] = {\n    INTMAP_ENTRY(0x1,  \"FIN\"),\n    INTMAP_ENTRY(0x2,  \"SYN\"),\n    INTMAP_ENTRY(0x4,  \"RST\"),\n    INTMAP_ENTRY(0x8,  \"PSH\"),\n    INTMAP_ENTRY(0x10, \"ACK\"),\n    INTMAP_ENTRY(0x20, \"URG\"),\n    INTMAP_ENTRY(0x3F, \"ALL\"),\n    INTMAP_ENTRY(0x0,  \"NONE\"),\n    INTMAP_ENTRY_LAST\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parseStringItems",
          "args": [
            "tcpFlags",
            "s_flags",
            "&flags",
            "','"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "parseStringItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "764-796",
          "snippet": "static int\nparseStringItems(const struct int_map *int_map,\n                 const char *input,\n                 int32_t *flags,\n                 char sep)\n{\n    int rc = 0;\n    size_t i, j;\n    bool found;\n\n    i = 0;\n    while (input[i]) {\n        found = false;\n        while (g_ascii_isspace(input[i]) || input[i] == sep)\n            i++;\n        if (!input[i])\n            break;\n        for (j = 0; int_map[j].val; j++) {\n            if (STRCASEEQLEN(&input[i], int_map[j].val,\n                             strlen(int_map[j].val))) {\n                *flags |= int_map[j].attr;\n                i += strlen(int_map[j].val);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            rc = -1;\n            break;\n        }\n    }\n    return rc;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nparseStringItems(const struct int_map *int_map,\n                 const char *input,\n                 int32_t *flags,\n                 char sep)\n{\n    int rc = 0;\n    size_t i, j;\n    bool found;\n\n    i = 0;\n    while (input[i]) {\n        found = false;\n        while (g_ascii_isspace(input[i]) || input[i] == sep)\n            i++;\n        if (!input[i])\n            break;\n        for (j = 0; int_map[j].val; j++) {\n            if (STRCASEEQLEN(&input[i], int_map[j].val,\n                             strlen(int_map[j].val))) {\n                *flags |= int_map[j].attr;\n                i += strlen(int_map[j].val);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            rc = -1;\n            break;\n        }\n    }\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "val->c",
            "'/'"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map tcpFlags[] = {\n    INTMAP_ENTRY(0x1,  \"FIN\"),\n    INTMAP_ENTRY(0x2,  \"SYN\"),\n    INTMAP_ENTRY(0x4,  \"RST\"),\n    INTMAP_ENTRY(0x8,  \"PSH\"),\n    INTMAP_ENTRY(0x10, \"ACK\"),\n    INTMAP_ENTRY(0x20, \"URG\"),\n    INTMAP_ENTRY(0x3F, \"ALL\"),\n    INTMAP_ENTRY(0x0,  \"NONE\"),\n    INTMAP_ENTRY_LAST\n};\n\nstatic bool\ntcpFlagsValidator(enum attrDatatype datatype G_GNUC_UNUSED,\n                  union data *val,\n                  virNWFilterRuleDefPtr nwf G_GNUC_UNUSED,\n                  nwItemDesc *item)\n{\n    bool rc = false;\n    char *s_mask = val->c;\n    char *sep = strchr(val->c, '/');\n    char *s_flags;\n    int32_t mask = 0, flags = 0;\n\n    if (!sep)\n        return false;\n\n    s_flags = sep + 1;\n\n    *sep = '\\0';\n\n    if (parseStringItems(tcpFlags, s_mask, &mask, ',') == 0 &&\n        parseStringItems(tcpFlags, s_flags, &flags, ',') == 0) {\n        item->u.tcpFlags.mask  = mask  & 0x3f;\n        item->u.tcpFlags.flags = flags & 0x3f;\n        rc = true;\n    }\n\n    *sep = '/';\n\n    return rc;\n}"
  },
  {
    "function_name": "stateFormatter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "879-887",
    "snippet": "static bool\nstateFormatter(virBufferPtr buf,\n               virNWFilterRuleDefPtr nwf G_GNUC_UNUSED,\n               nwItemDesc *item)\n{\n    virNWFilterPrintStateMatchFlags(buf, \"\", item->u.u16, true);\n\n    return true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNWFilterPrintStateMatchFlags",
          "args": [
            "buf",
            "\"\"",
            "item->u.u16",
            "true"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterPrintStateMatchFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "843-855",
          "snippet": "void\nvirNWFilterPrintStateMatchFlags(virBufferPtr buf,\n                                const char *prefix,\n                                int32_t flags,\n                                bool disp_none)\n{\n    if (!disp_none && (flags & RULE_FLAG_STATE_NONE))\n        return;\n\n    virBufferAdd(buf, prefix, -1);\n\n    printStringItems(buf, stateMatchMap, flags, \",\");\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct int_map stateMatchMap[] = {\n    INTMAP_ENTRY(RULE_FLAG_STATE_NEW,           \"NEW\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_ESTABLISHED,   \"ESTABLISHED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_RELATED,       \"RELATED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_INVALID,       \"INVALID\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_NONE,          \"NONE\"),\n    INTMAP_ENTRY_LAST,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map stateMatchMap[] = {\n    INTMAP_ENTRY(RULE_FLAG_STATE_NEW,           \"NEW\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_ESTABLISHED,   \"ESTABLISHED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_RELATED,       \"RELATED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_INVALID,       \"INVALID\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_NONE,          \"NONE\"),\n    INTMAP_ENTRY_LAST,\n};\n\nvoid\nvirNWFilterPrintStateMatchFlags(virBufferPtr buf,\n                                const char *prefix,\n                                int32_t flags,\n                                bool disp_none)\n{\n    if (!disp_none && (flags & RULE_FLAG_STATE_NONE))\n        return;\n\n    virBufferAdd(buf, prefix, -1);\n\n    printStringItems(buf, stateMatchMap, flags, \",\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool\nstateFormatter(virBufferPtr buf,\n               virNWFilterRuleDefPtr nwf G_GNUC_UNUSED,\n               nwItemDesc *item)\n{\n    virNWFilterPrintStateMatchFlags(buf, \"\", item->u.u16, true);\n\n    return true;\n}"
  },
  {
    "function_name": "stateValidator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "858-876",
    "snippet": "static bool\nstateValidator(enum attrDatatype datatype G_GNUC_UNUSED,\n               union data *val,\n               virNWFilterRuleDefPtr nwf,\n               nwItemDesc *item)\n{\n    char *input = val->c;\n    int32_t flags = 0;\n\n    if (parseStateMatch(input, &flags) < 0)\n        return false;\n\n    item->u.u16 = flags;\n    nwf->flags |= flags;\n\n    item->datatype = DATATYPE_UINT16;\n\n    return true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parseStateMatch",
          "args": [
            "input",
            "&flags"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "parseStateMatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "830-840",
          "snippet": "static int\nparseStateMatch(const char *statematch,\n                int32_t *flags)\n{\n    int rc = parseStringItems(stateMatchMap, statematch, flags, ',');\n\n    if ((*flags & RULE_FLAG_STATE_NONE))\n        *flags = RULE_FLAG_STATE_NONE;\n\n    return rc;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct int_map stateMatchMap[] = {\n    INTMAP_ENTRY(RULE_FLAG_STATE_NEW,           \"NEW\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_ESTABLISHED,   \"ESTABLISHED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_RELATED,       \"RELATED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_INVALID,       \"INVALID\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_NONE,          \"NONE\"),\n    INTMAP_ENTRY_LAST,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map stateMatchMap[] = {\n    INTMAP_ENTRY(RULE_FLAG_STATE_NEW,           \"NEW\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_ESTABLISHED,   \"ESTABLISHED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_RELATED,       \"RELATED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_INVALID,       \"INVALID\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_NONE,          \"NONE\"),\n    INTMAP_ENTRY_LAST,\n};\n\nstatic int\nparseStateMatch(const char *statematch,\n                int32_t *flags)\n{\n    int rc = parseStringItems(stateMatchMap, statematch, flags, ',');\n\n    if ((*flags & RULE_FLAG_STATE_NONE))\n        *flags = RULE_FLAG_STATE_NONE;\n\n    return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool\nstateValidator(enum attrDatatype datatype G_GNUC_UNUSED,\n               union data *val,\n               virNWFilterRuleDefPtr nwf,\n               nwItemDesc *item)\n{\n    char *input = val->c;\n    int32_t flags = 0;\n\n    if (parseStateMatch(input, &flags) < 0)\n        return false;\n\n    item->u.u16 = flags;\n    nwf->flags |= flags;\n\n    item->datatype = DATATYPE_UINT16;\n\n    return true;\n}"
  },
  {
    "function_name": "virNWFilterPrintStateMatchFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "843-855",
    "snippet": "void\nvirNWFilterPrintStateMatchFlags(virBufferPtr buf,\n                                const char *prefix,\n                                int32_t flags,\n                                bool disp_none)\n{\n    if (!disp_none && (flags & RULE_FLAG_STATE_NONE))\n        return;\n\n    virBufferAdd(buf, prefix, -1);\n\n    printStringItems(buf, stateMatchMap, flags, \",\");\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct int_map stateMatchMap[] = {\n    INTMAP_ENTRY(RULE_FLAG_STATE_NEW,           \"NEW\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_ESTABLISHED,   \"ESTABLISHED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_RELATED,       \"RELATED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_INVALID,       \"INVALID\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_NONE,          \"NONE\"),\n    INTMAP_ENTRY_LAST,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printStringItems",
          "args": [
            "buf",
            "stateMatchMap",
            "flags",
            "\",\""
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "printStringItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "799-827",
          "snippet": "static int\nprintStringItems(virBufferPtr buf,\n                 const struct int_map *int_map,\n                 int32_t flags,\n                 const char *sep)\n{\n    size_t i;\n    unsigned int c = 0;\n    int32_t mask = 0x1;\n\n    while (mask) {\n        if ((mask & flags)) {\n            for (i = 0; int_map[i].val; i++) {\n                if (mask == int_map[i].attr) {\n                    if (c >= 1)\n                        virBufferAdd(buf, sep, -1);\n                    virBufferAdd(buf, int_map[i].val, -1);\n                    c++;\n                }\n            }\n            flags ^= mask;\n        }\n        if (!flags)\n            break;\n        mask <<= 1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprintStringItems(virBufferPtr buf,\n                 const struct int_map *int_map,\n                 int32_t flags,\n                 const char *sep)\n{\n    size_t i;\n    unsigned int c = 0;\n    int32_t mask = 0x1;\n\n    while (mask) {\n        if ((mask & flags)) {\n            for (i = 0; int_map[i].val; i++) {\n                if (mask == int_map[i].attr) {\n                    if (c >= 1)\n                        virBufferAdd(buf, sep, -1);\n                    virBufferAdd(buf, int_map[i].val, -1);\n                    c++;\n                }\n            }\n            flags ^= mask;\n        }\n        if (!flags)\n            break;\n        mask <<= 1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "buf",
            "prefix",
            "-1"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map stateMatchMap[] = {\n    INTMAP_ENTRY(RULE_FLAG_STATE_NEW,           \"NEW\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_ESTABLISHED,   \"ESTABLISHED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_RELATED,       \"RELATED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_INVALID,       \"INVALID\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_NONE,          \"NONE\"),\n    INTMAP_ENTRY_LAST,\n};\n\nvoid\nvirNWFilterPrintStateMatchFlags(virBufferPtr buf,\n                                const char *prefix,\n                                int32_t flags,\n                                bool disp_none)\n{\n    if (!disp_none && (flags & RULE_FLAG_STATE_NONE))\n        return;\n\n    virBufferAdd(buf, prefix, -1);\n\n    printStringItems(buf, stateMatchMap, flags, \",\");\n}"
  },
  {
    "function_name": "parseStateMatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "830-840",
    "snippet": "static int\nparseStateMatch(const char *statematch,\n                int32_t *flags)\n{\n    int rc = parseStringItems(stateMatchMap, statematch, flags, ',');\n\n    if ((*flags & RULE_FLAG_STATE_NONE))\n        *flags = RULE_FLAG_STATE_NONE;\n\n    return rc;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct int_map stateMatchMap[] = {\n    INTMAP_ENTRY(RULE_FLAG_STATE_NEW,           \"NEW\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_ESTABLISHED,   \"ESTABLISHED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_RELATED,       \"RELATED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_INVALID,       \"INVALID\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_NONE,          \"NONE\"),\n    INTMAP_ENTRY_LAST,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parseStringItems",
          "args": [
            "stateMatchMap",
            "statematch",
            "flags",
            "','"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "parseStringItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "764-796",
          "snippet": "static int\nparseStringItems(const struct int_map *int_map,\n                 const char *input,\n                 int32_t *flags,\n                 char sep)\n{\n    int rc = 0;\n    size_t i, j;\n    bool found;\n\n    i = 0;\n    while (input[i]) {\n        found = false;\n        while (g_ascii_isspace(input[i]) || input[i] == sep)\n            i++;\n        if (!input[i])\n            break;\n        for (j = 0; int_map[j].val; j++) {\n            if (STRCASEEQLEN(&input[i], int_map[j].val,\n                             strlen(int_map[j].val))) {\n                *flags |= int_map[j].attr;\n                i += strlen(int_map[j].val);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            rc = -1;\n            break;\n        }\n    }\n    return rc;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nparseStringItems(const struct int_map *int_map,\n                 const char *input,\n                 int32_t *flags,\n                 char sep)\n{\n    int rc = 0;\n    size_t i, j;\n    bool found;\n\n    i = 0;\n    while (input[i]) {\n        found = false;\n        while (g_ascii_isspace(input[i]) || input[i] == sep)\n            i++;\n        if (!input[i])\n            break;\n        for (j = 0; int_map[j].val; j++) {\n            if (STRCASEEQLEN(&input[i], int_map[j].val,\n                             strlen(int_map[j].val))) {\n                *flags |= int_map[j].attr;\n                i += strlen(int_map[j].val);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            rc = -1;\n            break;\n        }\n    }\n    return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map stateMatchMap[] = {\n    INTMAP_ENTRY(RULE_FLAG_STATE_NEW,           \"NEW\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_ESTABLISHED,   \"ESTABLISHED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_RELATED,       \"RELATED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_INVALID,       \"INVALID\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_NONE,          \"NONE\"),\n    INTMAP_ENTRY_LAST,\n};\n\nstatic int\nparseStateMatch(const char *statematch,\n                int32_t *flags)\n{\n    int rc = parseStringItems(stateMatchMap, statematch, flags, ',');\n\n    if ((*flags & RULE_FLAG_STATE_NONE))\n        *flags = RULE_FLAG_STATE_NONE;\n\n    return rc;\n}"
  },
  {
    "function_name": "printStringItems",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "799-827",
    "snippet": "static int\nprintStringItems(virBufferPtr buf,\n                 const struct int_map *int_map,\n                 int32_t flags,\n                 const char *sep)\n{\n    size_t i;\n    unsigned int c = 0;\n    int32_t mask = 0x1;\n\n    while (mask) {\n        if ((mask & flags)) {\n            for (i = 0; int_map[i].val; i++) {\n                if (mask == int_map[i].attr) {\n                    if (c >= 1)\n                        virBufferAdd(buf, sep, -1);\n                    virBufferAdd(buf, int_map[i].val, -1);\n                    c++;\n                }\n            }\n            flags ^= mask;\n        }\n        if (!flags)\n            break;\n        mask <<= 1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "buf",
            "int_map[i].val",
            "-1"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprintStringItems(virBufferPtr buf,\n                 const struct int_map *int_map,\n                 int32_t flags,\n                 const char *sep)\n{\n    size_t i;\n    unsigned int c = 0;\n    int32_t mask = 0x1;\n\n    while (mask) {\n        if ((mask & flags)) {\n            for (i = 0; int_map[i].val; i++) {\n                if (mask == int_map[i].attr) {\n                    if (c >= 1)\n                        virBufferAdd(buf, sep, -1);\n                    virBufferAdd(buf, int_map[i].val, -1);\n                    c++;\n                }\n            }\n            flags ^= mask;\n        }\n        if (!flags)\n            break;\n        mask <<= 1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "parseStringItems",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "764-796",
    "snippet": "static int\nparseStringItems(const struct int_map *int_map,\n                 const char *input,\n                 int32_t *flags,\n                 char sep)\n{\n    int rc = 0;\n    size_t i, j;\n    bool found;\n\n    i = 0;\n    while (input[i]) {\n        found = false;\n        while (g_ascii_isspace(input[i]) || input[i] == sep)\n            i++;\n        if (!input[i])\n            break;\n        for (j = 0; int_map[j].val; j++) {\n            if (STRCASEEQLEN(&input[i], int_map[j].val,\n                             strlen(int_map[j].val))) {\n                *flags |= int_map[j].attr;\n                i += strlen(int_map[j].val);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            rc = -1;\n            break;\n        }\n    }\n    return rc;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "int_map[j].val"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQLEN",
          "args": [
            "&input[i]",
            "int_map[j].val",
            "strlen(int_map[j].val)"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "int_map[j].val"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ascii_isspace",
          "args": [
            "input[i]"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nparseStringItems(const struct int_map *int_map,\n                 const char *input,\n                 int32_t *flags,\n                 char sep)\n{\n    int rc = 0;\n    size_t i, j;\n    bool found;\n\n    i = 0;\n    while (input[i]) {\n        found = false;\n        while (g_ascii_isspace(input[i]) || input[i] == sep)\n            i++;\n        if (!input[i])\n            break;\n        for (j = 0; int_map[j].val; j++) {\n            if (STRCASEEQLEN(&input[i], int_map[j].val,\n                             strlen(int_map[j].val))) {\n                *flags |= int_map[j].attr;\n                i += strlen(int_map[j].val);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            rc = -1;\n            break;\n        }\n    }\n    return rc;\n}"
  },
  {
    "function_name": "dscpValidator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "738-751",
    "snippet": "static bool\ndscpValidator(enum attrDatatype datatype,\n              union data *val,\n              virNWFilterRuleDefPtr nwf,\n              nwItemDesc *item G_GNUC_UNUSED)\n{\n    uint8_t dscp = val->ui;\n    if (dscp > 63)\n        return false;\n\n    nwf->p.ipHdrFilter.ipHdr.dataDSCP.datatype = datatype;\n\n    return true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool\ndscpValidator(enum attrDatatype datatype,\n              union data *val,\n              virNWFilterRuleDefPtr nwf,\n              nwItemDesc *item G_GNUC_UNUSED)\n{\n    uint8_t dscp = val->ui;\n    if (dscp > 63)\n        return false;\n\n    nwf->p.ipHdrFilter.ipHdr.dataDSCP.datatype = datatype;\n\n    return true;\n}"
  },
  {
    "function_name": "formatIPProtocolID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "716-735",
    "snippet": "static bool\nformatIPProtocolID(virBufferPtr buf,\n                   virNWFilterRuleDefPtr nwf,\n                   nwItemDesc *item G_GNUC_UNUSED)\n{\n    const char *str = NULL;\n    bool asHex = true;\n\n    if (intMapGetByInt(ipProtoMap,\n                       nwf->p.ipHdrFilter.ipHdr.dataProtocolID.u.u8,\n                       &str) == 0) {\n        virBufferAdd(buf, str, -1);\n    } else {\n        if (nwf->p.ipHdrFilter.ipHdr.dataProtocolID.datatype == DATATYPE_UINT8)\n            asHex = false;\n        virBufferAsprintf(buf, asHex ? \"0x%x\" : \"%d\",\n                          nwf->p.ipHdrFilter.ipHdr.dataProtocolID.u.u8);\n    }\n    return true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct int_map ipProtoMap[] = {\n    INTMAP_ENTRY(IPPROTO_TCP, \"tcp\"),\n    INTMAP_ENTRY(IPPROTO_UDP, \"udp\"),\n#ifdef IPPROTO_UDPLITE\n    INTMAP_ENTRY(IPPROTO_UDPLITE, \"udplite\"),\n#endif\n    INTMAP_ENTRY(IPPROTO_ESP, \"esp\"),\n    INTMAP_ENTRY(IPPROTO_AH,  \"ah\"),\n    INTMAP_ENTRY(IPPROTO_ICMP, \"icmp\"),\n    INTMAP_ENTRY(IPPROTO_IGMP, \"igmp\"),\n#ifdef IPPROTO_SCTP\n    INTMAP_ENTRY(IPPROTO_SCTP, \"sctp\"),\n#endif\n    INTMAP_ENTRY(IPPROTO_ICMPV6, \"icmpv6\"),\n    INTMAP_ENTRY_LAST\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "asHex ? \"0x%x\" : \"%d\"",
            "nwf->p.ipHdrFilter.ipHdr.dataProtocolID.u.u8"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "buf",
            "str",
            "-1"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "intMapGetByInt",
          "args": [
            "ipProtoMap",
            "nwf->p.ipHdrFilter.ipHdr.dataProtocolID.u.u8",
            "&str"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "intMapGetByInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "249-265",
          "snippet": "static int\nintMapGetByInt(const struct int_map *intmap,\n               int32_t attr,\n               const char **res)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if (intmap[i].attr == attr) {\n            *res = intmap[i].val;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nintMapGetByInt(const struct int_map *intmap,\n               int32_t attr,\n               const char **res)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if (intmap[i].attr == attr) {\n            *res = intmap[i].val;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map ipProtoMap[] = {\n    INTMAP_ENTRY(IPPROTO_TCP, \"tcp\"),\n    INTMAP_ENTRY(IPPROTO_UDP, \"udp\"),\n#ifdef IPPROTO_UDPLITE\n    INTMAP_ENTRY(IPPROTO_UDPLITE, \"udplite\"),\n#endif\n    INTMAP_ENTRY(IPPROTO_ESP, \"esp\"),\n    INTMAP_ENTRY(IPPROTO_AH,  \"ah\"),\n    INTMAP_ENTRY(IPPROTO_ICMP, \"icmp\"),\n    INTMAP_ENTRY(IPPROTO_IGMP, \"igmp\"),\n#ifdef IPPROTO_SCTP\n    INTMAP_ENTRY(IPPROTO_SCTP, \"sctp\"),\n#endif\n    INTMAP_ENTRY(IPPROTO_ICMPV6, \"icmpv6\"),\n    INTMAP_ENTRY_LAST\n};\n\nstatic bool\nformatIPProtocolID(virBufferPtr buf,\n                   virNWFilterRuleDefPtr nwf,\n                   nwItemDesc *item G_GNUC_UNUSED)\n{\n    const char *str = NULL;\n    bool asHex = true;\n\n    if (intMapGetByInt(ipProtoMap,\n                       nwf->p.ipHdrFilter.ipHdr.dataProtocolID.u.u8,\n                       &str) == 0) {\n        virBufferAdd(buf, str, -1);\n    } else {\n        if (nwf->p.ipHdrFilter.ipHdr.dataProtocolID.datatype == DATATYPE_UINT8)\n            asHex = false;\n        virBufferAsprintf(buf, asHex ? \"0x%x\" : \"%d\",\n                          nwf->p.ipHdrFilter.ipHdr.dataProtocolID.u.u8);\n    }\n    return true;\n}"
  },
  {
    "function_name": "checkIPProtocolID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "690-713",
    "snippet": "static bool\ncheckIPProtocolID(enum attrDatatype datatype,\n                  union data *value,\n                  virNWFilterRuleDefPtr nwf,\n                  nwItemDesc *item G_GNUC_UNUSED)\n{\n    int32_t res = -1;\n\n    if (datatype == DATATYPE_STRING) {\n        if (intMapGetByString(ipProtoMap, value->c, 1, &res) < 0)\n            res = -1;\n        datatype = DATATYPE_UINT8_HEX;\n    } else if (datatype == DATATYPE_UINT8 ||\n               datatype == DATATYPE_UINT8_HEX) {\n        res = (uint32_t)value->ui;\n    }\n\n    if (res != -1) {\n        nwf->p.ipHdrFilter.ipHdr.dataProtocolID.u.u8 = res;\n        nwf->p.ipHdrFilter.ipHdr.dataProtocolID.datatype = datatype;\n        return true;\n    }\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct int_map ipProtoMap[] = {\n    INTMAP_ENTRY(IPPROTO_TCP, \"tcp\"),\n    INTMAP_ENTRY(IPPROTO_UDP, \"udp\"),\n#ifdef IPPROTO_UDPLITE\n    INTMAP_ENTRY(IPPROTO_UDPLITE, \"udplite\"),\n#endif\n    INTMAP_ENTRY(IPPROTO_ESP, \"esp\"),\n    INTMAP_ENTRY(IPPROTO_AH,  \"ah\"),\n    INTMAP_ENTRY(IPPROTO_ICMP, \"icmp\"),\n    INTMAP_ENTRY(IPPROTO_IGMP, \"igmp\"),\n#ifdef IPPROTO_SCTP\n    INTMAP_ENTRY(IPPROTO_SCTP, \"sctp\"),\n#endif\n    INTMAP_ENTRY(IPPROTO_ICMPV6, \"icmpv6\"),\n    INTMAP_ENTRY_LAST\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "intMapGetByString",
          "args": [
            "ipProtoMap",
            "value->c",
            "1",
            "&res"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "intMapGetByString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "280-298",
          "snippet": "static int\nintMapGetByString(const struct int_map *intmap,\n                  const char *str,\n                  int casecmp,\n                  int32_t *result)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if ((casecmp && STRCASEEQ(intmap[i].val, str)) ||\n            STREQ(intmap[i].val, str)) {\n            *result = intmap[i].attr;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nintMapGetByString(const struct int_map *intmap,\n                  const char *str,\n                  int casecmp,\n                  int32_t *result)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if ((casecmp && STRCASEEQ(intmap[i].val, str)) ||\n            STREQ(intmap[i].val, str)) {\n            *result = intmap[i].attr;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map ipProtoMap[] = {\n    INTMAP_ENTRY(IPPROTO_TCP, \"tcp\"),\n    INTMAP_ENTRY(IPPROTO_UDP, \"udp\"),\n#ifdef IPPROTO_UDPLITE\n    INTMAP_ENTRY(IPPROTO_UDPLITE, \"udplite\"),\n#endif\n    INTMAP_ENTRY(IPPROTO_ESP, \"esp\"),\n    INTMAP_ENTRY(IPPROTO_AH,  \"ah\"),\n    INTMAP_ENTRY(IPPROTO_ICMP, \"icmp\"),\n    INTMAP_ENTRY(IPPROTO_IGMP, \"igmp\"),\n#ifdef IPPROTO_SCTP\n    INTMAP_ENTRY(IPPROTO_SCTP, \"sctp\"),\n#endif\n    INTMAP_ENTRY(IPPROTO_ICMPV6, \"icmpv6\"),\n    INTMAP_ENTRY_LAST\n};\n\nstatic bool\ncheckIPProtocolID(enum attrDatatype datatype,\n                  union data *value,\n                  virNWFilterRuleDefPtr nwf,\n                  nwItemDesc *item G_GNUC_UNUSED)\n{\n    int32_t res = -1;\n\n    if (datatype == DATATYPE_STRING) {\n        if (intMapGetByString(ipProtoMap, value->c, 1, &res) < 0)\n            res = -1;\n        datatype = DATATYPE_UINT8_HEX;\n    } else if (datatype == DATATYPE_UINT8 ||\n               datatype == DATATYPE_UINT8_HEX) {\n        res = (uint32_t)value->ui;\n    }\n\n    if (res != -1) {\n        nwf->p.ipHdrFilter.ipHdr.dataProtocolID.u.u8 = res;\n        nwf->p.ipHdrFilter.ipHdr.dataProtocolID.datatype = datatype;\n        return true;\n    }\n    return false;\n}"
  },
  {
    "function_name": "arpOpcodeFormatter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "654-669",
    "snippet": "static bool\narpOpcodeFormatter(virBufferPtr buf,\n                   virNWFilterRuleDefPtr nwf,\n                   nwItemDesc *item G_GNUC_UNUSED)\n{\n    const char *str = NULL;\n\n    if (intMapGetByInt(arpOpcodeMap,\n                       nwf->p.arpHdrFilter.dataOpcode.u.u16,\n                       &str) == 0) {\n        virBufferAdd(buf, str, -1);\n    } else {\n        virBufferAsprintf(buf, \"%d\", nwf->p.arpHdrFilter.dataOpcode.u.u16);\n    }\n    return true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct int_map arpOpcodeMap[] = {\n    INTMAP_ENTRY(1, \"Request\"),\n    INTMAP_ENTRY(2, \"Reply\"),\n    INTMAP_ENTRY(3, \"Request_Reverse\"),\n    INTMAP_ENTRY(4, \"Reply_Reverse\"),\n    INTMAP_ENTRY(5, \"DRARP_Request\"),\n    INTMAP_ENTRY(6, \"DRARP_Reply\"),\n    INTMAP_ENTRY(7, \"DRARP_Error\"),\n    INTMAP_ENTRY(8, \"InARP_Request\"),\n    INTMAP_ENTRY(9, \"ARP_NAK\"),\n    INTMAP_ENTRY_LAST\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"%d\"",
            "nwf->p.arpHdrFilter.dataOpcode.u.u16"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "buf",
            "str",
            "-1"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "intMapGetByInt",
          "args": [
            "arpOpcodeMap",
            "nwf->p.arpHdrFilter.dataOpcode.u.u16",
            "&str"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "intMapGetByInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "249-265",
          "snippet": "static int\nintMapGetByInt(const struct int_map *intmap,\n               int32_t attr,\n               const char **res)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if (intmap[i].attr == attr) {\n            *res = intmap[i].val;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nintMapGetByInt(const struct int_map *intmap,\n               int32_t attr,\n               const char **res)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if (intmap[i].attr == attr) {\n            *res = intmap[i].val;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map arpOpcodeMap[] = {\n    INTMAP_ENTRY(1, \"Request\"),\n    INTMAP_ENTRY(2, \"Reply\"),\n    INTMAP_ENTRY(3, \"Request_Reverse\"),\n    INTMAP_ENTRY(4, \"Reply_Reverse\"),\n    INTMAP_ENTRY(5, \"DRARP_Request\"),\n    INTMAP_ENTRY(6, \"DRARP_Reply\"),\n    INTMAP_ENTRY(7, \"DRARP_Error\"),\n    INTMAP_ENTRY(8, \"InARP_Request\"),\n    INTMAP_ENTRY(9, \"ARP_NAK\"),\n    INTMAP_ENTRY_LAST\n};\n\nstatic bool\narpOpcodeFormatter(virBufferPtr buf,\n                   virNWFilterRuleDefPtr nwf,\n                   nwItemDesc *item G_GNUC_UNUSED)\n{\n    const char *str = NULL;\n\n    if (intMapGetByInt(arpOpcodeMap,\n                       nwf->p.arpHdrFilter.dataOpcode.u.u16,\n                       &str) == 0) {\n        virBufferAdd(buf, str, -1);\n    } else {\n        virBufferAsprintf(buf, \"%d\", nwf->p.arpHdrFilter.dataOpcode.u.u16);\n    }\n    return true;\n}"
  },
  {
    "function_name": "arpOpcodeValidator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "628-651",
    "snippet": "static bool\narpOpcodeValidator(enum attrDatatype datatype,\n                   union data *value,\n                   virNWFilterRuleDefPtr nwf,\n                   nwItemDesc *item G_GNUC_UNUSED)\n{\n    int32_t res = -1;\n\n    if (datatype == DATATYPE_STRING) {\n        if (intMapGetByString(arpOpcodeMap, value->c, 1, &res) < 0)\n            res = -1;\n        datatype = DATATYPE_UINT16;\n    } else if (datatype == DATATYPE_UINT16 ||\n               datatype == DATATYPE_UINT16_HEX) {\n        res = (uint32_t)value->ui;\n    }\n\n    if (res != -1) {\n        nwf->p.arpHdrFilter.dataOpcode.u.u16 = res;\n        nwf->p.arpHdrFilter.dataOpcode.datatype = datatype;\n        return true;\n    }\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct int_map arpOpcodeMap[] = {\n    INTMAP_ENTRY(1, \"Request\"),\n    INTMAP_ENTRY(2, \"Reply\"),\n    INTMAP_ENTRY(3, \"Request_Reverse\"),\n    INTMAP_ENTRY(4, \"Reply_Reverse\"),\n    INTMAP_ENTRY(5, \"DRARP_Request\"),\n    INTMAP_ENTRY(6, \"DRARP_Reply\"),\n    INTMAP_ENTRY(7, \"DRARP_Error\"),\n    INTMAP_ENTRY(8, \"InARP_Request\"),\n    INTMAP_ENTRY(9, \"ARP_NAK\"),\n    INTMAP_ENTRY_LAST\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "intMapGetByString",
          "args": [
            "arpOpcodeMap",
            "value->c",
            "1",
            "&res"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "intMapGetByString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "280-298",
          "snippet": "static int\nintMapGetByString(const struct int_map *intmap,\n                  const char *str,\n                  int casecmp,\n                  int32_t *result)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if ((casecmp && STRCASEEQ(intmap[i].val, str)) ||\n            STREQ(intmap[i].val, str)) {\n            *result = intmap[i].attr;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nintMapGetByString(const struct int_map *intmap,\n                  const char *str,\n                  int casecmp,\n                  int32_t *result)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if ((casecmp && STRCASEEQ(intmap[i].val, str)) ||\n            STREQ(intmap[i].val, str)) {\n            *result = intmap[i].attr;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map arpOpcodeMap[] = {\n    INTMAP_ENTRY(1, \"Request\"),\n    INTMAP_ENTRY(2, \"Reply\"),\n    INTMAP_ENTRY(3, \"Request_Reverse\"),\n    INTMAP_ENTRY(4, \"Reply_Reverse\"),\n    INTMAP_ENTRY(5, \"DRARP_Request\"),\n    INTMAP_ENTRY(6, \"DRARP_Reply\"),\n    INTMAP_ENTRY(7, \"DRARP_Error\"),\n    INTMAP_ENTRY(8, \"InARP_Request\"),\n    INTMAP_ENTRY(9, \"ARP_NAK\"),\n    INTMAP_ENTRY_LAST\n};\n\nstatic bool\narpOpcodeValidator(enum attrDatatype datatype,\n                   union data *value,\n                   virNWFilterRuleDefPtr nwf,\n                   nwItemDesc *item G_GNUC_UNUSED)\n{\n    int32_t res = -1;\n\n    if (datatype == DATATYPE_STRING) {\n        if (intMapGetByString(arpOpcodeMap, value->c, 1, &res) < 0)\n            res = -1;\n        datatype = DATATYPE_UINT16;\n    } else if (datatype == DATATYPE_UINT16 ||\n               datatype == DATATYPE_UINT16_HEX) {\n        res = (uint32_t)value->ui;\n    }\n\n    if (res != -1) {\n        nwf->p.arpHdrFilter.dataOpcode.u.u16 = res;\n        nwf->p.arpHdrFilter.dataOpcode.datatype = datatype;\n        return true;\n    }\n    return false;\n}"
  },
  {
    "function_name": "checkMACMask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "601-608",
    "snippet": "static bool\ncheckMACMask(enum attrDatatype datatype G_GNUC_UNUSED,\n             union data *macMask,\n             virNWFilterRuleDefPtr nwf G_GNUC_UNUSED,\n             nwItemDesc *item G_GNUC_UNUSED)\n{\n    return checkValidMask(macMask->uc, 6);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "checkValidMask",
          "args": [
            "macMask->uc",
            "6"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "checkValidMask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "575-598",
          "snippet": "static bool\ncheckValidMask(unsigned char *data,\n               int len)\n{\n    uint32_t idx = 0;\n    uint8_t mask = 0x80;\n    bool checkones = true;\n\n    while ((idx >> 3) < len) {\n        if (checkones) {\n            if (!(data[idx>>3] & mask))\n                checkones = false;\n        } else {\n            if ((data[idx>>3] & mask))\n                return false;\n        }\n\n        idx++;\n        mask >>= 1;\n        if (!mask)\n            mask = 0x80;\n    }\n    return true;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool\ncheckValidMask(unsigned char *data,\n               int len)\n{\n    uint32_t idx = 0;\n    uint8_t mask = 0x80;\n    bool checkones = true;\n\n    while ((idx >> 3) < len) {\n        if (checkones) {\n            if (!(data[idx>>3] & mask))\n                checkones = false;\n        } else {\n            if ((data[idx>>3] & mask))\n                return false;\n        }\n\n        idx++;\n        mask >>= 1;\n        if (!mask)\n            mask = 0x80;\n    }\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool\ncheckMACMask(enum attrDatatype datatype G_GNUC_UNUSED,\n             union data *macMask,\n             virNWFilterRuleDefPtr nwf G_GNUC_UNUSED,\n             nwItemDesc *item G_GNUC_UNUSED)\n{\n    return checkValidMask(macMask->uc, 6);\n}"
  },
  {
    "function_name": "checkValidMask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "575-598",
    "snippet": "static bool\ncheckValidMask(unsigned char *data,\n               int len)\n{\n    uint32_t idx = 0;\n    uint8_t mask = 0x80;\n    bool checkones = true;\n\n    while ((idx >> 3) < len) {\n        if (checkones) {\n            if (!(data[idx>>3] & mask))\n                checkones = false;\n        } else {\n            if ((data[idx>>3] & mask))\n                return false;\n        }\n\n        idx++;\n        mask >>= 1;\n        if (!mask)\n            mask = 0x80;\n    }\n    return true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool\ncheckValidMask(unsigned char *data,\n               int len)\n{\n    uint32_t idx = 0;\n    uint8_t mask = 0x80;\n    bool checkones = true;\n\n    while ((idx >> 3) < len) {\n        if (checkones) {\n            if (!(data[idx>>3] & mask))\n                checkones = false;\n        } else {\n            if ((data[idx>>3] & mask))\n                return false;\n        }\n\n        idx++;\n        mask >>= 1;\n        if (!mask)\n            mask = 0x80;\n    }\n    return true;\n}"
  },
  {
    "function_name": "vlanProtocolIDFormatter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "549-568",
    "snippet": "static bool\nvlanProtocolIDFormatter(virBufferPtr buf,\n                        virNWFilterRuleDefPtr nwf,\n                        nwItemDesc *item G_GNUC_UNUSED)\n{\n    const char *str = NULL;\n    bool asHex = true;\n\n    if (intMapGetByInt(macProtoMap,\n                       nwf->p.vlanHdrFilter.dataVlanEncap.u.u16,\n                       &str) == 0) {\n        virBufferAdd(buf, str, -1);\n    } else {\n        if (nwf->p.vlanHdrFilter.dataVlanEncap.datatype == DATATYPE_UINT16)\n            asHex = false;\n        virBufferAsprintf(buf, asHex ? \"0x%x\" : \"%d\",\n                          nwf->p.vlanHdrFilter.dataVlanEncap.u.u16);\n    }\n    return true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct int_map macProtoMap[] = {\n    INTMAP_ENTRY(ETHERTYPE_ARP,    \"arp\"),\n    INTMAP_ENTRY(ETHERTYPE_REVARP, \"rarp\"),\n    INTMAP_ENTRY(ETHERTYPE_IP,     \"ipv4\"),\n    INTMAP_ENTRY(ETHERTYPE_IPV6,   \"ipv6\"),\n    INTMAP_ENTRY(ETHERTYPE_VLAN,   \"vlan\"),\n    INTMAP_ENTRY_LAST\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "asHex ? \"0x%x\" : \"%d\"",
            "nwf->p.vlanHdrFilter.dataVlanEncap.u.u16"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "buf",
            "str",
            "-1"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "intMapGetByInt",
          "args": [
            "macProtoMap",
            "nwf->p.vlanHdrFilter.dataVlanEncap.u.u16",
            "&str"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "intMapGetByInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "249-265",
          "snippet": "static int\nintMapGetByInt(const struct int_map *intmap,\n               int32_t attr,\n               const char **res)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if (intmap[i].attr == attr) {\n            *res = intmap[i].val;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nintMapGetByInt(const struct int_map *intmap,\n               int32_t attr,\n               const char **res)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if (intmap[i].attr == attr) {\n            *res = intmap[i].val;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map macProtoMap[] = {\n    INTMAP_ENTRY(ETHERTYPE_ARP,    \"arp\"),\n    INTMAP_ENTRY(ETHERTYPE_REVARP, \"rarp\"),\n    INTMAP_ENTRY(ETHERTYPE_IP,     \"ipv4\"),\n    INTMAP_ENTRY(ETHERTYPE_IPV6,   \"ipv6\"),\n    INTMAP_ENTRY(ETHERTYPE_VLAN,   \"vlan\"),\n    INTMAP_ENTRY_LAST\n};\n\nstatic bool\nvlanProtocolIDFormatter(virBufferPtr buf,\n                        virNWFilterRuleDefPtr nwf,\n                        nwItemDesc *item G_GNUC_UNUSED)\n{\n    const char *str = NULL;\n    bool asHex = true;\n\n    if (intMapGetByInt(macProtoMap,\n                       nwf->p.vlanHdrFilter.dataVlanEncap.u.u16,\n                       &str) == 0) {\n        virBufferAdd(buf, str, -1);\n    } else {\n        if (nwf->p.vlanHdrFilter.dataVlanEncap.datatype == DATATYPE_UINT16)\n            asHex = false;\n        virBufferAsprintf(buf, asHex ? \"0x%x\" : \"%d\",\n                          nwf->p.vlanHdrFilter.dataVlanEncap.u.u16);\n    }\n    return true;\n}"
  },
  {
    "function_name": "checkVlanProtocolID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "520-546",
    "snippet": "static bool\ncheckVlanProtocolID(enum attrDatatype datatype,\n                    union data *value,\n                    virNWFilterRuleDefPtr nwf,\n                    nwItemDesc *item G_GNUC_UNUSED)\n{\n    int32_t res = -1;\n\n    if (datatype == DATATYPE_STRING) {\n        if (intMapGetByString(macProtoMap, value->c, 1, &res) < 0)\n            res = -1;\n        datatype = DATATYPE_UINT16;\n    } else if (datatype == DATATYPE_UINT16 ||\n               datatype == DATATYPE_UINT16_HEX) {\n        res = value->ui;\n        if (res < 0x3c)\n            res = -1;\n    }\n\n    if (res != -1) {\n        nwf->p.vlanHdrFilter.dataVlanEncap.u.u16 = res;\n        nwf->p.vlanHdrFilter.dataVlanEncap.datatype = datatype;\n        return true;\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct int_map macProtoMap[] = {\n    INTMAP_ENTRY(ETHERTYPE_ARP,    \"arp\"),\n    INTMAP_ENTRY(ETHERTYPE_REVARP, \"rarp\"),\n    INTMAP_ENTRY(ETHERTYPE_IP,     \"ipv4\"),\n    INTMAP_ENTRY(ETHERTYPE_IPV6,   \"ipv6\"),\n    INTMAP_ENTRY(ETHERTYPE_VLAN,   \"vlan\"),\n    INTMAP_ENTRY_LAST\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "intMapGetByString",
          "args": [
            "macProtoMap",
            "value->c",
            "1",
            "&res"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "intMapGetByString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "280-298",
          "snippet": "static int\nintMapGetByString(const struct int_map *intmap,\n                  const char *str,\n                  int casecmp,\n                  int32_t *result)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if ((casecmp && STRCASEEQ(intmap[i].val, str)) ||\n            STREQ(intmap[i].val, str)) {\n            *result = intmap[i].attr;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nintMapGetByString(const struct int_map *intmap,\n                  const char *str,\n                  int casecmp,\n                  int32_t *result)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if ((casecmp && STRCASEEQ(intmap[i].val, str)) ||\n            STREQ(intmap[i].val, str)) {\n            *result = intmap[i].attr;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map macProtoMap[] = {\n    INTMAP_ENTRY(ETHERTYPE_ARP,    \"arp\"),\n    INTMAP_ENTRY(ETHERTYPE_REVARP, \"rarp\"),\n    INTMAP_ENTRY(ETHERTYPE_IP,     \"ipv4\"),\n    INTMAP_ENTRY(ETHERTYPE_IPV6,   \"ipv6\"),\n    INTMAP_ENTRY(ETHERTYPE_VLAN,   \"vlan\"),\n    INTMAP_ENTRY_LAST\n};\n\nstatic bool\ncheckVlanProtocolID(enum attrDatatype datatype,\n                    union data *value,\n                    virNWFilterRuleDefPtr nwf,\n                    nwItemDesc *item G_GNUC_UNUSED)\n{\n    int32_t res = -1;\n\n    if (datatype == DATATYPE_STRING) {\n        if (intMapGetByString(macProtoMap, value->c, 1, &res) < 0)\n            res = -1;\n        datatype = DATATYPE_UINT16;\n    } else if (datatype == DATATYPE_UINT16 ||\n               datatype == DATATYPE_UINT16_HEX) {\n        res = value->ui;\n        if (res < 0x3c)\n            res = -1;\n    }\n\n    if (res != -1) {\n        nwf->p.vlanHdrFilter.dataVlanEncap.u.u16 = res;\n        nwf->p.vlanHdrFilter.dataVlanEncap.datatype = datatype;\n        return true;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "checkVlanVlanID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "498-517",
    "snippet": "static bool\ncheckVlanVlanID(enum attrDatatype datatype,\n                union data *value,\n                virNWFilterRuleDefPtr nwf,\n                nwItemDesc *item G_GNUC_UNUSED)\n{\n    int32_t res;\n\n    res = value->ui;\n    if (res < 0 || res > 4095)\n        res = -1;\n\n    if (res != -1) {\n        nwf->p.vlanHdrFilter.dataVlanID.u.u16 = res;\n        nwf->p.vlanHdrFilter.dataVlanID.datatype = datatype;\n        return true;\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool\ncheckVlanVlanID(enum attrDatatype datatype,\n                union data *value,\n                virNWFilterRuleDefPtr nwf,\n                nwItemDesc *item G_GNUC_UNUSED)\n{\n    int32_t res;\n\n    res = value->ui;\n    if (res < 0 || res > 4095)\n        res = -1;\n\n    if (res != -1) {\n        nwf->p.vlanHdrFilter.dataVlanID.u.u16 = res;\n        nwf->p.vlanHdrFilter.dataVlanID.datatype = datatype;\n        return true;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "macProtocolIDFormatter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "476-495",
    "snippet": "static bool\nmacProtocolIDFormatter(virBufferPtr buf,\n                       virNWFilterRuleDefPtr nwf,\n                       nwItemDesc *item G_GNUC_UNUSED)\n{\n    const char *str = NULL;\n    bool asHex = true;\n\n    if (intMapGetByInt(macProtoMap,\n                       nwf->p.ethHdrFilter.dataProtocolID.u.u16,\n                       &str) == 0) {\n        virBufferAdd(buf, str, -1);\n    } else {\n        if (nwf->p.ethHdrFilter.dataProtocolID.datatype == DATATYPE_UINT16)\n            asHex = false;\n        virBufferAsprintf(buf, asHex ? \"0x%x\" : \"%d\",\n                          nwf->p.ethHdrFilter.dataProtocolID.u.u16);\n    }\n    return true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct int_map macProtoMap[] = {\n    INTMAP_ENTRY(ETHERTYPE_ARP,    \"arp\"),\n    INTMAP_ENTRY(ETHERTYPE_REVARP, \"rarp\"),\n    INTMAP_ENTRY(ETHERTYPE_IP,     \"ipv4\"),\n    INTMAP_ENTRY(ETHERTYPE_IPV6,   \"ipv6\"),\n    INTMAP_ENTRY(ETHERTYPE_VLAN,   \"vlan\"),\n    INTMAP_ENTRY_LAST\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "asHex ? \"0x%x\" : \"%d\"",
            "nwf->p.ethHdrFilter.dataProtocolID.u.u16"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "buf",
            "str",
            "-1"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "intMapGetByInt",
          "args": [
            "macProtoMap",
            "nwf->p.ethHdrFilter.dataProtocolID.u.u16",
            "&str"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "intMapGetByInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "249-265",
          "snippet": "static int\nintMapGetByInt(const struct int_map *intmap,\n               int32_t attr,\n               const char **res)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if (intmap[i].attr == attr) {\n            *res = intmap[i].val;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nintMapGetByInt(const struct int_map *intmap,\n               int32_t attr,\n               const char **res)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if (intmap[i].attr == attr) {\n            *res = intmap[i].val;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map macProtoMap[] = {\n    INTMAP_ENTRY(ETHERTYPE_ARP,    \"arp\"),\n    INTMAP_ENTRY(ETHERTYPE_REVARP, \"rarp\"),\n    INTMAP_ENTRY(ETHERTYPE_IP,     \"ipv4\"),\n    INTMAP_ENTRY(ETHERTYPE_IPV6,   \"ipv6\"),\n    INTMAP_ENTRY(ETHERTYPE_VLAN,   \"vlan\"),\n    INTMAP_ENTRY_LAST\n};\n\nstatic bool\nmacProtocolIDFormatter(virBufferPtr buf,\n                       virNWFilterRuleDefPtr nwf,\n                       nwItemDesc *item G_GNUC_UNUSED)\n{\n    const char *str = NULL;\n    bool asHex = true;\n\n    if (intMapGetByInt(macProtoMap,\n                       nwf->p.ethHdrFilter.dataProtocolID.u.u16,\n                       &str) == 0) {\n        virBufferAdd(buf, str, -1);\n    } else {\n        if (nwf->p.ethHdrFilter.dataProtocolID.datatype == DATATYPE_UINT16)\n            asHex = false;\n        virBufferAsprintf(buf, asHex ? \"0x%x\" : \"%d\",\n                          nwf->p.ethHdrFilter.dataProtocolID.u.u16);\n    }\n    return true;\n}"
  },
  {
    "function_name": "checkMacProtocolID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "447-473",
    "snippet": "static bool\ncheckMacProtocolID(enum attrDatatype datatype,\n                   union data *value,\n                   virNWFilterRuleDefPtr nwf G_GNUC_UNUSED,\n                   nwItemDesc *item G_GNUC_UNUSED)\n{\n    int32_t res = -1;\n\n    if (datatype == DATATYPE_STRING) {\n        if (intMapGetByString(macProtoMap, value->c, 1, &res) < 0)\n            res = -1;\n        datatype = DATATYPE_UINT16;\n    } else if (datatype == DATATYPE_UINT16 ||\n               datatype == DATATYPE_UINT16_HEX) {\n        res = value->ui;\n        if (res < 0x600)\n            res = -1;\n    }\n\n    if (res != -1) {\n        nwf->p.ethHdrFilter.dataProtocolID.u.u16 = res;\n        nwf->p.ethHdrFilter.dataProtocolID.datatype = datatype;\n        return true;\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct int_map macProtoMap[] = {\n    INTMAP_ENTRY(ETHERTYPE_ARP,    \"arp\"),\n    INTMAP_ENTRY(ETHERTYPE_REVARP, \"rarp\"),\n    INTMAP_ENTRY(ETHERTYPE_IP,     \"ipv4\"),\n    INTMAP_ENTRY(ETHERTYPE_IPV6,   \"ipv6\"),\n    INTMAP_ENTRY(ETHERTYPE_VLAN,   \"vlan\"),\n    INTMAP_ENTRY_LAST\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "intMapGetByString",
          "args": [
            "macProtoMap",
            "value->c",
            "1",
            "&res"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "intMapGetByString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "280-298",
          "snippet": "static int\nintMapGetByString(const struct int_map *intmap,\n                  const char *str,\n                  int casecmp,\n                  int32_t *result)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if ((casecmp && STRCASEEQ(intmap[i].val, str)) ||\n            STREQ(intmap[i].val, str)) {\n            *result = intmap[i].attr;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nintMapGetByString(const struct int_map *intmap,\n                  const char *str,\n                  int casecmp,\n                  int32_t *result)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if ((casecmp && STRCASEEQ(intmap[i].val, str)) ||\n            STREQ(intmap[i].val, str)) {\n            *result = intmap[i].attr;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map macProtoMap[] = {\n    INTMAP_ENTRY(ETHERTYPE_ARP,    \"arp\"),\n    INTMAP_ENTRY(ETHERTYPE_REVARP, \"rarp\"),\n    INTMAP_ENTRY(ETHERTYPE_IP,     \"ipv4\"),\n    INTMAP_ENTRY(ETHERTYPE_IPV6,   \"ipv6\"),\n    INTMAP_ENTRY(ETHERTYPE_VLAN,   \"vlan\"),\n    INTMAP_ENTRY_LAST\n};\n\nstatic bool\ncheckMacProtocolID(enum attrDatatype datatype,\n                   union data *value,\n                   virNWFilterRuleDefPtr nwf G_GNUC_UNUSED,\n                   nwItemDesc *item G_GNUC_UNUSED)\n{\n    int32_t res = -1;\n\n    if (datatype == DATATYPE_STRING) {\n        if (intMapGetByString(macProtoMap, value->c, 1, &res) < 0)\n            res = -1;\n        datatype = DATATYPE_UINT16;\n    } else if (datatype == DATATYPE_UINT16 ||\n               datatype == DATATYPE_UINT16_HEX) {\n        res = value->ui;\n        if (res < 0x600)\n            res = -1;\n    }\n\n    if (res != -1) {\n        nwf->p.ethHdrFilter.dataProtocolID.u.u16 = res;\n        nwf->p.ethHdrFilter.dataProtocolID.datatype = datatype;\n        return true;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virNWFilterRuleDefAddString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "396-408",
    "snippet": "static char *\nvirNWFilterRuleDefAddString(virNWFilterRuleDefPtr nwf,\n                            const char *string,\n                            size_t maxstrlen)\n{\n    char *tmp;\n\n    tmp = g_strndup(string, maxstrlen);\n    if (VIR_APPEND_ELEMENT_COPY(nwf->strings, nwf->nstrings, tmp) < 0)\n        VIR_FREE(tmp);\n\n    return tmp;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT_COPY",
          "args": [
            "nwf->strings",
            "nwf->nstrings",
            "tmp"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "string",
            "maxstrlen"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nvirNWFilterRuleDefAddString(virNWFilterRuleDefPtr nwf,\n                            const char *string,\n                            size_t maxstrlen)\n{\n    char *tmp;\n\n    tmp = g_strndup(string, maxstrlen);\n    if (VIR_APPEND_ELEMENT_COPY(nwf->strings, nwf->nstrings, tmp) < 0)\n        VIR_FREE(tmp);\n\n    return tmp;\n}"
  },
  {
    "function_name": "virNWFilterRuleDefAddVar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "363-393",
    "snippet": "static int\nvirNWFilterRuleDefAddVar(virNWFilterRuleDefPtr nwf,\n                         nwItemDesc *item,\n                         const char *var)\n{\n    size_t i = 0;\n    virNWFilterVarAccessPtr varAccess;\n\n    varAccess = virNWFilterVarAccessParse(var);\n    if (varAccess == NULL)\n        return -1;\n\n    if (nwf->varAccess) {\n        for (i = 0; i < nwf->nVarAccess; i++)\n            if (virNWFilterVarAccessEqual(nwf->varAccess[i], varAccess)) {\n                virNWFilterVarAccessFree(varAccess);\n                item->varAccess = nwf->varAccess[i];\n                return 0;\n            }\n    }\n\n    if (VIR_EXPAND_N(nwf->varAccess, nwf->nVarAccess, 1) < 0) {\n        virNWFilterVarAccessFree(varAccess);\n        return -1;\n    }\n\n    nwf->varAccess[nwf->nVarAccess - 1] = varAccess;\n    item->varAccess = varAccess;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNWFilterVarAccessFree",
          "args": [
            "varAccess"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterVarAccessFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_params.c",
          "lines": "832-840",
          "snippet": "void\nvirNWFilterVarAccessFree(virNWFilterVarAccessPtr varAccess)\n{\n    if (!varAccess)\n        return;\n\n    VIR_FREE(varAccess->varName);\n    VIR_FREE(varAccess);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNWFilterVarAccessSetIntIterId(virNWFilterVarAccessPtr,\n                                             unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNWFilterVarAccessSetIntIterId(virNWFilterVarAccessPtr,\n                                             unsigned int);\n\nvoid\nvirNWFilterVarAccessFree(virNWFilterVarAccessPtr varAccess)\n{\n    if (!varAccess)\n        return;\n\n    VIR_FREE(varAccess->varName);\n    VIR_FREE(varAccess);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "nwf->varAccess",
            "nwf->nVarAccess",
            "1"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterVarAccessEqual",
          "args": [
            "nwf->varAccess[i]",
            "varAccess"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterVarAccessEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_params.c",
          "lines": "842-864",
          "snippet": "bool\nvirNWFilterVarAccessEqual(const virNWFilterVarAccess *a,\n                          const virNWFilterVarAccess *b)\n{\n    if (a->accessType != b->accessType)\n        return false;\n\n    if (STRNEQ(a->varName, b->varName))\n        return false;\n\n    switch (a->accessType) {\n    case VIR_NWFILTER_VAR_ACCESS_ELEMENT:\n        return (a->u.index.idx == b->u.index.idx &&\n                a->u.index.intIterId == b->u.index.intIterId);\n        break;\n    case VIR_NWFILTER_VAR_ACCESS_ITERATOR:\n        return a->u.iterId == b->u.iterId;\n        break;\n    case VIR_NWFILTER_VAR_ACCESS_LAST:\n        break;\n    }\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int virNWFilterVarAccessGetIntIterId(const virNWFilterVarAccess *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic unsigned int virNWFilterVarAccessGetIntIterId(const virNWFilterVarAccess *);\n\nbool\nvirNWFilterVarAccessEqual(const virNWFilterVarAccess *a,\n                          const virNWFilterVarAccess *b)\n{\n    if (a->accessType != b->accessType)\n        return false;\n\n    if (STRNEQ(a->varName, b->varName))\n        return false;\n\n    switch (a->accessType) {\n    case VIR_NWFILTER_VAR_ACCESS_ELEMENT:\n        return (a->u.index.idx == b->u.index.idx &&\n                a->u.index.intIterId == b->u.index.intIterId);\n        break;\n    case VIR_NWFILTER_VAR_ACCESS_ITERATOR:\n        return a->u.iterId == b->u.iterId;\n        break;\n    case VIR_NWFILTER_VAR_ACCESS_LAST:\n        break;\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterVarAccessParse",
          "args": [
            "var"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterVarAccessParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_params.c",
          "lines": "870-957",
          "snippet": "virNWFilterVarAccessPtr\nvirNWFilterVarAccessParse(const char *varAccess)\n{\n    size_t idx, varNameLen;\n    virNWFilterVarAccessPtr dest;\n    const char *input = varAccess;\n\n    if (VIR_ALLOC(dest) < 0)\n        return NULL;\n\n    idx = strspn(input, VALID_VARNAME);\n\n    if (input[idx] == '\\0') {\n        /* in the form 'IP', which is equivalent to IP[@0] */\n        dest->varName = g_strndup(input, idx);\n        dest->accessType = VIR_NWFILTER_VAR_ACCESS_ITERATOR;\n        dest->u.iterId = 0;\n        return dest;\n    }\n\n    if (input[idx] == '[') {\n        char *end_ptr;\n        unsigned int result;\n        bool parseError = false;\n\n        varNameLen = idx;\n\n        dest->varName = g_strndup(input, varNameLen);\n\n        input += idx + 1;\n        virSkipSpaces(&input);\n\n        if (*input == '@') {\n            /* in the form 'IP[@<number>] -> iterator */\n            dest->accessType = VIR_NWFILTER_VAR_ACCESS_ITERATOR;\n            input++;\n        } else {\n            /* in the form 'IP[<number>] -> element */\n            dest->accessType = VIR_NWFILTER_VAR_ACCESS_ELEMENT;\n        }\n\n        if (virStrToLong_ui(input, &end_ptr, 10, &result) < 0)\n            parseError = true;\n        if (!parseError) {\n            input = end_ptr;\n            virSkipSpaces(&input);\n            if (*input != ']')\n                parseError = true;\n        }\n        if (parseError) {\n            if (dest->accessType == VIR_NWFILTER_VAR_ACCESS_ELEMENT)\n                virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                               _(\"Malformatted array index\"));\n            else\n                virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                               _(\"Malformatted iterator id\"));\n            goto err_exit;\n        }\n\n        switch (dest->accessType) {\n        case VIR_NWFILTER_VAR_ACCESS_ELEMENT:\n            dest->u.index.idx = result;\n            dest->u.index.intIterId = ~0;\n            break;\n        case VIR_NWFILTER_VAR_ACCESS_ITERATOR:\n            if (result > VIR_NWFILTER_MAX_ITERID) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Iterator ID exceeds maximum ID \"\n                                 \"of %u\"), VIR_NWFILTER_MAX_ITERID);\n                goto err_exit;\n            }\n            dest->u.iterId = result;\n            break;\n        case VIR_NWFILTER_VAR_ACCESS_LAST:\n            goto err_exit;\n        }\n\n        return dest;\n    } else {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Malformatted variable\"));\n    }\n\n err_exit:\n    virNWFilterVarAccessFree(dest);\n\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNWFilterVarAccessSetIntIterId(virNWFilterVarAccessPtr,\n                                             unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNWFilterVarAccessSetIntIterId(virNWFilterVarAccessPtr,\n                                             unsigned int);\n\nvirNWFilterVarAccessPtr\nvirNWFilterVarAccessParse(const char *varAccess)\n{\n    size_t idx, varNameLen;\n    virNWFilterVarAccessPtr dest;\n    const char *input = varAccess;\n\n    if (VIR_ALLOC(dest) < 0)\n        return NULL;\n\n    idx = strspn(input, VALID_VARNAME);\n\n    if (input[idx] == '\\0') {\n        /* in the form 'IP', which is equivalent to IP[@0] */\n        dest->varName = g_strndup(input, idx);\n        dest->accessType = VIR_NWFILTER_VAR_ACCESS_ITERATOR;\n        dest->u.iterId = 0;\n        return dest;\n    }\n\n    if (input[idx] == '[') {\n        char *end_ptr;\n        unsigned int result;\n        bool parseError = false;\n\n        varNameLen = idx;\n\n        dest->varName = g_strndup(input, varNameLen);\n\n        input += idx + 1;\n        virSkipSpaces(&input);\n\n        if (*input == '@') {\n            /* in the form 'IP[@<number>] -> iterator */\n            dest->accessType = VIR_NWFILTER_VAR_ACCESS_ITERATOR;\n            input++;\n        } else {\n            /* in the form 'IP[<number>] -> element */\n            dest->accessType = VIR_NWFILTER_VAR_ACCESS_ELEMENT;\n        }\n\n        if (virStrToLong_ui(input, &end_ptr, 10, &result) < 0)\n            parseError = true;\n        if (!parseError) {\n            input = end_ptr;\n            virSkipSpaces(&input);\n            if (*input != ']')\n                parseError = true;\n        }\n        if (parseError) {\n            if (dest->accessType == VIR_NWFILTER_VAR_ACCESS_ELEMENT)\n                virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                               _(\"Malformatted array index\"));\n            else\n                virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                               _(\"Malformatted iterator id\"));\n            goto err_exit;\n        }\n\n        switch (dest->accessType) {\n        case VIR_NWFILTER_VAR_ACCESS_ELEMENT:\n            dest->u.index.idx = result;\n            dest->u.index.intIterId = ~0;\n            break;\n        case VIR_NWFILTER_VAR_ACCESS_ITERATOR:\n            if (result > VIR_NWFILTER_MAX_ITERID) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Iterator ID exceeds maximum ID \"\n                                 \"of %u\"), VIR_NWFILTER_MAX_ITERID);\n                goto err_exit;\n            }\n            dest->u.iterId = result;\n            break;\n        case VIR_NWFILTER_VAR_ACCESS_LAST:\n            goto err_exit;\n        }\n\n        return dest;\n    } else {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Malformatted variable\"));\n    }\n\n err_exit:\n    virNWFilterVarAccessFree(dest);\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirNWFilterRuleDefAddVar(virNWFilterRuleDefPtr nwf,\n                         nwItemDesc *item,\n                         const char *var)\n{\n    size_t i = 0;\n    virNWFilterVarAccessPtr varAccess;\n\n    varAccess = virNWFilterVarAccessParse(var);\n    if (varAccess == NULL)\n        return -1;\n\n    if (nwf->varAccess) {\n        for (i = 0; i < nwf->nVarAccess; i++)\n            if (virNWFilterVarAccessEqual(nwf->varAccess[i], varAccess)) {\n                virNWFilterVarAccessFree(varAccess);\n                item->varAccess = nwf->varAccess[i];\n                return 0;\n            }\n    }\n\n    if (VIR_EXPAND_N(nwf->varAccess, nwf->nVarAccess, 1) < 0) {\n        virNWFilterVarAccessFree(varAccess);\n        return -1;\n    }\n\n    nwf->varAccess[nwf->nVarAccess - 1] = varAccess;\n    item->varAccess = varAccess;\n\n    return 0;\n}"
  },
  {
    "function_name": "virNWFilterDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "344-360",
    "snippet": "void\nvirNWFilterDefFree(virNWFilterDefPtr def)\n{\n    size_t i;\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n\n    for (i = 0; i < def->nentries; i++)\n        virNWFilterEntryFree(def->filterEntries[i]);\n\n    VIR_FREE(def->filterEntries);\n    VIR_FREE(def->chainsuffix);\n\n    VIR_FREE(def);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->chainsuffix"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->filterEntries"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterEntryFree",
          "args": [
            "def->filterEntries[i]"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterEntryFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "332-341",
          "snippet": "static void\nvirNWFilterEntryFree(virNWFilterEntryPtr entry)\n{\n    if (!entry)\n        return;\n\n    virNWFilterRuleDefFree(entry->rule);\n    virNWFilterIncludeDefFree(entry->include);\n    VIR_FREE(entry);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirNWFilterEntryFree(virNWFilterEntryPtr entry)\n{\n    if (!entry)\n        return;\n\n    virNWFilterRuleDefFree(entry->rule);\n    virNWFilterIncludeDefFree(entry->include);\n    VIR_FREE(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->name"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirNWFilterDefFree(virNWFilterDefPtr def)\n{\n    size_t i;\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n\n    for (i = 0; i < def->nentries; i++)\n        virNWFilterEntryFree(def->filterEntries[i]);\n\n    VIR_FREE(def->filterEntries);\n    VIR_FREE(def->chainsuffix);\n\n    VIR_FREE(def);\n}"
  },
  {
    "function_name": "virNWFilterEntryFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "332-341",
    "snippet": "static void\nvirNWFilterEntryFree(virNWFilterEntryPtr entry)\n{\n    if (!entry)\n        return;\n\n    virNWFilterRuleDefFree(entry->rule);\n    virNWFilterIncludeDefFree(entry->include);\n    VIR_FREE(entry);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "entry"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterIncludeDefFree",
          "args": [
            "entry->include"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterIncludeDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "321-329",
          "snippet": "static void\nvirNWFilterIncludeDefFree(virNWFilterIncludeDefPtr inc)\n{\n    if (!inc)\n        return;\n    virHashFree(inc->params);\n    VIR_FREE(inc->filterref);\n    VIR_FREE(inc);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirNWFilterIncludeDefFree(virNWFilterIncludeDefPtr inc)\n{\n    if (!inc)\n        return;\n    virHashFree(inc->params);\n    VIR_FREE(inc->filterref);\n    VIR_FREE(inc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleDefFree",
          "args": [
            "entry->rule"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRuleDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "301-318",
          "snippet": "void\nvirNWFilterRuleDefFree(virNWFilterRuleDefPtr def)\n{\n    size_t i;\n    if (!def)\n        return;\n\n    for (i = 0; i < def->nVarAccess; i++)\n        virNWFilterVarAccessFree(def->varAccess[i]);\n\n    for (i = 0; i < def->nstrings; i++)\n        VIR_FREE(def->strings[i]);\n\n    VIR_FREE(def->varAccess);\n    VIR_FREE(def->strings);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirNWFilterRuleDefFree(virNWFilterRuleDefPtr def)\n{\n    size_t i;\n    if (!def)\n        return;\n\n    for (i = 0; i < def->nVarAccess; i++)\n        virNWFilterVarAccessFree(def->varAccess[i]);\n\n    for (i = 0; i < def->nstrings; i++)\n        VIR_FREE(def->strings[i]);\n\n    VIR_FREE(def->varAccess);\n    VIR_FREE(def->strings);\n\n    VIR_FREE(def);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirNWFilterEntryFree(virNWFilterEntryPtr entry)\n{\n    if (!entry)\n        return;\n\n    virNWFilterRuleDefFree(entry->rule);\n    virNWFilterIncludeDefFree(entry->include);\n    VIR_FREE(entry);\n}"
  },
  {
    "function_name": "virNWFilterIncludeDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "321-329",
    "snippet": "static void\nvirNWFilterIncludeDefFree(virNWFilterIncludeDefPtr inc)\n{\n    if (!inc)\n        return;\n    virHashFree(inc->params);\n    VIR_FREE(inc->filterref);\n    VIR_FREE(inc);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "inc"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "inc->filterref"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "inc->params"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirNWFilterIncludeDefFree(virNWFilterIncludeDefPtr inc)\n{\n    if (!inc)\n        return;\n    virHashFree(inc->params);\n    VIR_FREE(inc->filterref);\n    VIR_FREE(inc);\n}"
  },
  {
    "function_name": "virNWFilterRuleDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "301-318",
    "snippet": "void\nvirNWFilterRuleDefFree(virNWFilterRuleDefPtr def)\n{\n    size_t i;\n    if (!def)\n        return;\n\n    for (i = 0; i < def->nVarAccess; i++)\n        virNWFilterVarAccessFree(def->varAccess[i]);\n\n    for (i = 0; i < def->nstrings; i++)\n        VIR_FREE(def->strings[i]);\n\n    VIR_FREE(def->varAccess);\n    VIR_FREE(def->strings);\n\n    VIR_FREE(def);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->strings"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->varAccess"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->strings[i]"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterVarAccessFree",
          "args": [
            "def->varAccess[i]"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterVarAccessFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_params.c",
          "lines": "832-840",
          "snippet": "void\nvirNWFilterVarAccessFree(virNWFilterVarAccessPtr varAccess)\n{\n    if (!varAccess)\n        return;\n\n    VIR_FREE(varAccess->varName);\n    VIR_FREE(varAccess);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNWFilterVarAccessSetIntIterId(virNWFilterVarAccessPtr,\n                                             unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNWFilterVarAccessSetIntIterId(virNWFilterVarAccessPtr,\n                                             unsigned int);\n\nvoid\nvirNWFilterVarAccessFree(virNWFilterVarAccessPtr varAccess)\n{\n    if (!varAccess)\n        return;\n\n    VIR_FREE(varAccess->varName);\n    VIR_FREE(varAccess);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirNWFilterRuleDefFree(virNWFilterRuleDefPtr def)\n{\n    size_t i;\n    if (!def)\n        return;\n\n    for (i = 0; i < def->nVarAccess; i++)\n        virNWFilterVarAccessFree(def->varAccess[i]);\n\n    for (i = 0; i < def->nstrings; i++)\n        VIR_FREE(def->strings[i]);\n\n    VIR_FREE(def->varAccess);\n    VIR_FREE(def->strings);\n\n    VIR_FREE(def);\n}"
  },
  {
    "function_name": "intMapGetByString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "280-298",
    "snippet": "static int\nintMapGetByString(const struct int_map *intmap,\n                  const char *str,\n                  int casecmp,\n                  int32_t *result)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if ((casecmp && STRCASEEQ(intmap[i].val, str)) ||\n            STREQ(intmap[i].val, str)) {\n            *result = intmap[i].attr;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "intmap[i].val",
            "str"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "intmap[i].val",
            "str"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nintMapGetByString(const struct int_map *intmap,\n                  const char *str,\n                  int casecmp,\n                  int32_t *result)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if ((casecmp && STRCASEEQ(intmap[i].val, str)) ||\n            STREQ(intmap[i].val, str)) {\n            *result = intmap[i].attr;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}"
  },
  {
    "function_name": "intMapGetByInt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "249-265",
    "snippet": "static int\nintMapGetByInt(const struct int_map *intmap,\n               int32_t attr,\n               const char **res)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if (intmap[i].attr == attr) {\n            *res = intmap[i].val;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nintMapGetByInt(const struct int_map *intmap,\n               int32_t attr,\n               const char **res)\n{\n    size_t i = 0;\n    bool found = false;\n\n    while (intmap[i].val && !found) {\n        if (intmap[i].attr == attr) {\n            *res = intmap[i].val;\n            found = true;\n        }\n        i++;\n    }\n    return (found) ? 0 : -1;\n}"
  },
  {
    "function_name": "virNWFilterUnlockFilterUpdates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "174-178",
    "snippet": "void\nvirNWFilterUnlockFilterUpdates(void)\n{\n    virRWLockUnlock(&updateLock);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virRWLock updateLock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virRWLockUnlock",
          "args": [
            "&updateLock"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "virRWLockUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "120-123",
          "snippet": "void virRWLockUnlock(virRWLockPtr m)\n{\n    pthread_rwlock_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virRWLockUnlock(virRWLockPtr m)\n{\n    pthread_rwlock_unlock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virRWLock updateLock;\n\nvoid\nvirNWFilterUnlockFilterUpdates(void)\n{\n    virRWLockUnlock(&updateLock);\n}"
  },
  {
    "function_name": "virNWFilterWriteLockFilterUpdates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "167-171",
    "snippet": "void\nvirNWFilterWriteLockFilterUpdates(void)\n{\n    virRWLockWrite(&updateLock);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virRWLock updateLock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virRWLockWrite",
          "args": [
            "&updateLock"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "virRWLockWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "114-117",
          "snippet": "void virRWLockWrite(virRWLockPtr m)\n{\n    pthread_rwlock_wrlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virRWLockWrite(virRWLockPtr m)\n{\n    pthread_rwlock_wrlock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virRWLock updateLock;\n\nvoid\nvirNWFilterWriteLockFilterUpdates(void)\n{\n    virRWLockWrite(&updateLock);\n}"
  },
  {
    "function_name": "virNWFilterReadLockFilterUpdates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
    "lines": "160-164",
    "snippet": "void\nvirNWFilterReadLockFilterUpdates(void)\n{\n    virRWLockRead(&updateLock);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"domain_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"nwfilter_params.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "# include <net/ethernet.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virRWLock updateLock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virRWLockRead",
          "args": [
            "&updateLock"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "virRWLockRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "109-112",
          "snippet": "void virRWLockRead(virRWLockPtr m)\n{\n    pthread_rwlock_rdlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virRWLockRead(virRWLockPtr m)\n{\n    pthread_rwlock_rdlock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virRWLock updateLock;\n\nvoid\nvirNWFilterReadLockFilterUpdates(void)\n{\n    virRWLockRead(&updateLock);\n}"
  }
]