[
  {
    "function_name": "qemuMigrationEatCookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "1462-1527",
    "snippet": "qemuMigrationCookiePtr\nqemuMigrationEatCookie(virQEMUDriverPtr driver,\n                       const virDomainDef *def,\n                       const char *origname,\n                       qemuDomainObjPrivatePtr priv,\n                       const char *cookiein,\n                       int cookieinlen,\n                       unsigned int flags)\n{\n    qemuMigrationCookiePtr mig = NULL;\n\n    /* Parse & validate incoming cookie (if any) */\n    if (cookiein && cookieinlen &&\n        cookiein[cookieinlen-1] != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration cookie was not NULL terminated\"));\n        goto error;\n    }\n\n    VIR_DEBUG(\"cookielen=%d cookie='%s'\", cookieinlen, NULLSTR(cookiein));\n\n    if (!(mig = qemuMigrationCookieNew(def, origname)))\n        return NULL;\n\n    if (cookiein && cookieinlen &&\n        qemuMigrationCookieXMLParseStr(mig,\n                                       driver,\n                                       priv ? priv->qemuCaps : NULL,\n                                       cookiein,\n                                       flags) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_PERSISTENT &&\n        mig->persistent &&\n        STRNEQ(def->name, mig->persistent->name)) {\n        VIR_FREE(mig->persistent->name);\n        mig->persistent->name = g_strdup(def->name);\n    }\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) {\n        if (!mig->lockDriver) {\n            if (virLockManagerPluginUsesState(driver->lockManager)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Missing %s lock state for migration cookie\"),\n                               virLockManagerPluginGetName(driver->lockManager));\n                goto error;\n            }\n        } else if (STRNEQ(mig->lockDriver,\n                          virLockManagerPluginGetName(driver->lockManager))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Source host lock driver %s different from target %s\"),\n                           mig->lockDriver,\n                           virLockManagerPluginGetName(driver->lockManager));\n            goto error;\n        }\n    }\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS && mig->jobInfo)\n        mig->jobInfo->operation = priv->job.current->operation;\n\n    return mig;\n\n error:\n    qemuMigrationCookieFree(mig);\n    return NULL;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMigrationCookieFree",
          "args": [
            "mig"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "110-130",
          "snippet": "void\nqemuMigrationCookieFree(qemuMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    qemuMigrationCookieGraphicsFree(mig->graphics);\n    virDomainDefFree(mig->persistent);\n    qemuMigrationCookieNetworkFree(mig->network);\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    VIR_FREE(mig->localHostname);\n    VIR_FREE(mig->remoteHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig->lockState);\n    VIR_FREE(mig->lockDriver);\n    VIR_FREE(mig->jobInfo);\n    virCPUDefFree(mig->cpu);\n    qemuMigrationCookieCapsFree(mig->caps);\n    VIR_FREE(mig);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nvoid\nqemuMigrationCookieFree(qemuMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    qemuMigrationCookieGraphicsFree(mig->graphics);\n    virDomainDefFree(mig->persistent);\n    qemuMigrationCookieNetworkFree(mig->network);\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    VIR_FREE(mig->localHostname);\n    VIR_FREE(mig->remoteHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig->lockState);\n    VIR_FREE(mig->lockDriver);\n    VIR_FREE(mig->jobInfo);\n    virCPUDefFree(mig->cpu);\n    qemuMigrationCookieCapsFree(mig->caps);\n    VIR_FREE(mig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Source host lock driver %s different from target %s\")",
            "mig->lockDriver",
            "virLockManagerPluginGetName(driver->lockManager)"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerPluginGetName",
          "args": [
            "driver->lockManager"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerPluginGetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_manager.c",
          "lines": "259-264",
          "snippet": "const char *virLockManagerPluginGetName(virLockManagerPluginPtr plugin)\n{\n    VIR_DEBUG(\"plugin=%p\", plugin);\n\n    return plugin->name;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "# include <dlfcn.h>",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"lock_driver_nop.h\"",
            "#include \"lock_manager.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include <unistd.h>\n# include <dlfcn.h>\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lock_driver_nop.h\"\n#include \"lock_manager.h\"\n#include <config.h>\n\nconst char *virLockManagerPluginGetName(virLockManagerPluginPtr plugin)\n{\n    VIR_DEBUG(\"plugin=%p\", plugin);\n\n    return plugin->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Source host lock driver %s different from target %s\""
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "mig->lockDriver",
            "virLockManagerPluginGetName(driver->lockManager)"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing %s lock state for migration cookie\")",
            "virLockManagerPluginGetName(driver->lockManager)"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerPluginUsesState",
          "args": [
            "driver->lockManager"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerPluginUsesState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_manager.c",
          "lines": "267-272",
          "snippet": "bool virLockManagerPluginUsesState(virLockManagerPluginPtr plugin)\n{\n    VIR_DEBUG(\"plugin=%p\", plugin);\n\n    return plugin->driver->flags & VIR_LOCK_MANAGER_USES_STATE;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "# include <dlfcn.h>",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"lock_driver_nop.h\"",
            "#include \"lock_manager.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include <unistd.h>\n# include <dlfcn.h>\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lock_driver_nop.h\"\n#include \"lock_manager.h\"\n#include <config.h>\n\nbool virLockManagerPluginUsesState(virLockManagerPluginPtr plugin)\n{\n    VIR_DEBUG(\"plugin=%p\", plugin);\n\n    return plugin->driver->flags & VIR_LOCK_MANAGER_USES_STATE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "def->name"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mig->persistent->name"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "def->name",
            "mig->persistent->name"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieXMLParseStr",
          "args": [
            "mig",
            "driver",
            "priv ? priv->qemuCaps : NULL",
            "cookiein",
            "flags"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieXMLParseStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "1371-1394",
          "snippet": "static int\nqemuMigrationCookieXMLParseStr(qemuMigrationCookiePtr mig,\n                               virQEMUDriverPtr driver,\n                               virQEMUCapsPtr qemuCaps,\n                               const char *xml,\n                               unsigned int flags)\n{\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    int ret = -1;\n\n    VIR_DEBUG(\"xml=%s\", NULLSTR(xml));\n\n    if (!(doc = virXMLParseStringCtxt(xml, _(\"(qemu_migration_cookie)\"), &ctxt)))\n        goto cleanup;\n\n    ret = qemuMigrationCookieXMLParse(mig, driver, qemuCaps, doc, ctxt, flags);\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n\n    return ret;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieXMLParseStr(qemuMigrationCookiePtr mig,\n                               virQEMUDriverPtr driver,\n                               virQEMUCapsPtr qemuCaps,\n                               const char *xml,\n                               unsigned int flags)\n{\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    int ret = -1;\n\n    VIR_DEBUG(\"xml=%s\", NULLSTR(xml));\n\n    if (!(doc = virXMLParseStringCtxt(xml, _(\"(qemu_migration_cookie)\"), &ctxt)))\n        goto cleanup;\n\n    ret = qemuMigrationCookieXMLParse(mig, driver, qemuCaps, doc, ctxt, flags);\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieNew",
          "args": [
            "def",
            "origname"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "280-310",
          "snippet": "static qemuMigrationCookiePtr\nqemuMigrationCookieNew(const virDomainDef *def,\n                       const char *origname)\n{\n    qemuMigrationCookiePtr mig = NULL;\n    const char *name;\n\n    if (VIR_ALLOC(mig) < 0)\n        goto error;\n\n    if (origname)\n        name = origname;\n    else\n        name = def->name;\n    mig->name = g_strdup(name);\n    memcpy(mig->uuid, def->uuid, VIR_UUID_BUFLEN);\n\n    if (!(mig->localHostname = virGetHostname()))\n        goto error;\n    if (virGetHostUUID(mig->localHostuuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to obtain host UUID\"));\n        goto error;\n    }\n\n    return mig;\n\n error:\n    qemuMigrationCookieFree(mig);\n    return NULL;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic qemuMigrationCookiePtr\nqemuMigrationCookieNew(const virDomainDef *def,\n                       const char *origname)\n{\n    qemuMigrationCookiePtr mig = NULL;\n    const char *name;\n\n    if (VIR_ALLOC(mig) < 0)\n        goto error;\n\n    if (origname)\n        name = origname;\n    else\n        name = def->name;\n    mig->name = g_strdup(name);\n    memcpy(mig->uuid, def->uuid, VIR_UUID_BUFLEN);\n\n    if (!(mig->localHostname = virGetHostname()))\n        goto error;\n    if (virGetHostUUID(mig->localHostuuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to obtain host UUID\"));\n        goto error;\n    }\n\n    return mig;\n\n error:\n    qemuMigrationCookieFree(mig);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cookielen=%d cookie='%s'\"",
            "cookieinlen",
            "NULLSTR(cookiein)"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "cookiein"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Migration cookie was not NULL terminated\")"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nqemuMigrationCookiePtr\nqemuMigrationEatCookie(virQEMUDriverPtr driver,\n                       const virDomainDef *def,\n                       const char *origname,\n                       qemuDomainObjPrivatePtr priv,\n                       const char *cookiein,\n                       int cookieinlen,\n                       unsigned int flags)\n{\n    qemuMigrationCookiePtr mig = NULL;\n\n    /* Parse & validate incoming cookie (if any) */\n    if (cookiein && cookieinlen &&\n        cookiein[cookieinlen-1] != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration cookie was not NULL terminated\"));\n        goto error;\n    }\n\n    VIR_DEBUG(\"cookielen=%d cookie='%s'\", cookieinlen, NULLSTR(cookiein));\n\n    if (!(mig = qemuMigrationCookieNew(def, origname)))\n        return NULL;\n\n    if (cookiein && cookieinlen &&\n        qemuMigrationCookieXMLParseStr(mig,\n                                       driver,\n                                       priv ? priv->qemuCaps : NULL,\n                                       cookiein,\n                                       flags) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_PERSISTENT &&\n        mig->persistent &&\n        STRNEQ(def->name, mig->persistent->name)) {\n        VIR_FREE(mig->persistent->name);\n        mig->persistent->name = g_strdup(def->name);\n    }\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) {\n        if (!mig->lockDriver) {\n            if (virLockManagerPluginUsesState(driver->lockManager)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Missing %s lock state for migration cookie\"),\n                               virLockManagerPluginGetName(driver->lockManager));\n                goto error;\n            }\n        } else if (STRNEQ(mig->lockDriver,\n                          virLockManagerPluginGetName(driver->lockManager))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Source host lock driver %s different from target %s\"),\n                           mig->lockDriver,\n                           virLockManagerPluginGetName(driver->lockManager));\n            goto error;\n        }\n    }\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS && mig->jobInfo)\n        mig->jobInfo->operation = priv->job.current->operation;\n\n    return mig;\n\n error:\n    qemuMigrationCookieFree(mig);\n    return NULL;\n}"
  },
  {
    "function_name": "qemuMigrationBakeCookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "1397-1459",
    "snippet": "int\nqemuMigrationBakeCookie(qemuMigrationCookiePtr mig,\n                        virQEMUDriverPtr driver,\n                        virDomainObjPtr dom,\n                        qemuMigrationParty party,\n                        char **cookieout,\n                        int *cookieoutlen,\n                        unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = dom->privateData;\n\n    if (!cookieout || !cookieoutlen)\n        return 0;\n\n    *cookieoutlen = 0;\n\n    if (flags & QEMU_MIGRATION_COOKIE_GRAPHICS &&\n        qemuMigrationCookieAddGraphics(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_LOCKSTATE &&\n        qemuMigrationCookieAddLockstate(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_NETWORK &&\n        qemuMigrationCookieAddNetwork(mig, driver, dom) < 0) {\n        return -1;\n    }\n\n    if ((flags & QEMU_MIGRATION_COOKIE_NBD) &&\n        qemuMigrationCookieAddNBD(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS &&\n        qemuMigrationCookieAddStatistics(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_CPU_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU &&\n        qemuMigrationCookieAddCPU(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_ALLOW_REBOOT)\n        qemuMigrationCookieAddAllowReboot(mig, dom);\n\n    if (flags & QEMU_MIGRATION_COOKIE_CAPS &&\n        qemuMigrationCookieAddCaps(mig, dom, party) < 0)\n        return -1;\n\n    if (!(*cookieout = qemuMigrationCookieXMLFormatStr(driver, priv->qemuCaps, mig)))\n        return -1;\n\n    *cookieoutlen = strlen(*cookieout) + 1;\n\n    VIR_DEBUG(\"cookielen=%d cookie=%s\", *cookieoutlen, *cookieout);\n\n    return 0;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cookielen=%d cookie=%s\"",
            "*cookieoutlen",
            "*cookieout"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*cookieout"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieXMLFormatStr",
          "args": [
            "driver",
            "priv->qemuCaps",
            "mig"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieXMLFormatStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "868-881",
          "snippet": "static char *\nqemuMigrationCookieXMLFormatStr(virQEMUDriverPtr driver,\n                                virQEMUCapsPtr qemuCaps,\n                                qemuMigrationCookiePtr mig)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (qemuMigrationCookieXMLFormat(driver, qemuCaps, &buf, mig) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic char *\nqemuMigrationCookieXMLFormatStr(virQEMUDriverPtr driver,\n                                virQEMUCapsPtr qemuCaps,\n                                qemuMigrationCookiePtr mig)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (qemuMigrationCookieXMLFormat(driver, qemuCaps, &buf, mig) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieAddCaps",
          "args": [
            "mig",
            "dom",
            "party"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieAddCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "557-581",
          "snippet": "static int\nqemuMigrationCookieAddCaps(qemuMigrationCookiePtr mig,\n                           virDomainObjPtr vm,\n                           qemuMigrationParty party)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    qemuMigrationCookieCapsFree(mig->caps);\n    if (VIR_ALLOC(mig->caps) < 0)\n        return -1;\n\n    if (priv->migrationCaps)\n        mig->caps->supported = virBitmapNewCopy(priv->migrationCaps);\n    else\n        mig->caps->supported = virBitmapNew(0);\n\n    mig->caps->automatic = qemuMigrationParamsGetAlwaysOnCaps(party);\n\n    if (!mig->caps->supported || !mig->caps->automatic)\n        return -1;\n\n    mig->flags |= QEMU_MIGRATION_COOKIE_CAPS;\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieAddCaps(qemuMigrationCookiePtr mig,\n                           virDomainObjPtr vm,\n                           qemuMigrationParty party)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    qemuMigrationCookieCapsFree(mig->caps);\n    if (VIR_ALLOC(mig->caps) < 0)\n        return -1;\n\n    if (priv->migrationCaps)\n        mig->caps->supported = virBitmapNewCopy(priv->migrationCaps);\n    else\n        mig->caps->supported = virBitmapNew(0);\n\n    mig->caps->automatic = qemuMigrationParamsGetAlwaysOnCaps(party);\n\n    if (!mig->caps->supported || !mig->caps->automatic)\n        return -1;\n\n    mig->flags |= QEMU_MIGRATION_COOKIE_CAPS;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieAddAllowReboot",
          "args": [
            "mig",
            "dom"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieAddAllowReboot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "545-554",
          "snippet": "static void\nqemuMigrationCookieAddAllowReboot(qemuMigrationCookiePtr mig,\n                                  virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    mig->allowReboot = priv->allowReboot;\n\n    mig->flags |= QEMU_MIGRATION_COOKIE_ALLOW_REBOOT;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieAddAllowReboot(qemuMigrationCookiePtr mig,\n                                  virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    mig->allowReboot = priv->allowReboot;\n\n    mig->flags |= QEMU_MIGRATION_COOKIE_ALLOW_REBOOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieAddCPU",
          "args": [
            "mig",
            "dom"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieAddCPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "526-542",
          "snippet": "static int\nqemuMigrationCookieAddCPU(qemuMigrationCookiePtr mig,\n                          virDomainObjPtr vm)\n{\n    if (mig->cpu)\n        return 0;\n\n    if (!(mig->cpu = virCPUDefCopy(vm->def->cpu)))\n        return -1;\n\n    if (qemuDomainMakeCPUMigratable(mig->cpu) < 0)\n        return -1;\n\n    mig->flags |= QEMU_MIGRATION_COOKIE_CPU;\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieAddCPU(qemuMigrationCookiePtr mig,\n                          virDomainObjPtr vm)\n{\n    if (mig->cpu)\n        return 0;\n\n    if (!(mig->cpu = virCPUDefCopy(vm->def->cpu)))\n        return -1;\n\n    if (qemuDomainMakeCPUMigratable(mig->cpu) < 0)\n        return -1;\n\n    mig->flags |= QEMU_MIGRATION_COOKIE_CPU;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieAddStatistics",
          "args": [
            "mig",
            "dom"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieAddStatistics",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "507-523",
          "snippet": "static int\nqemuMigrationCookieAddStatistics(qemuMigrationCookiePtr mig,\n                                 virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!priv->job.completed)\n        return 0;\n\n    if (!mig->jobInfo && VIR_ALLOC(mig->jobInfo) < 0)\n        return -1;\n\n    *mig->jobInfo = *priv->job.completed;\n    mig->flags |= QEMU_MIGRATION_COOKIE_STATS;\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieAddStatistics(qemuMigrationCookiePtr mig,\n                                 virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!priv->job.completed)\n        return 0;\n\n    if (!mig->jobInfo && VIR_ALLOC(mig->jobInfo) < 0)\n        return -1;\n\n    *mig->jobInfo = *priv->job.completed;\n    mig->flags |= QEMU_MIGRATION_COOKIE_STATS;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieAddNBD",
          "args": [
            "mig",
            "driver",
            "dom"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieAddNBD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "451-504",
          "snippet": "static int\nqemuMigrationCookieAddNBD(qemuMigrationCookiePtr mig,\n                          virQEMUDriverPtr driver,\n                          virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virHashTable) stats = virHashNew(virHashValueFree);\n    bool blockdev = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV);\n    size_t i;\n    int rc;\n\n    /* It is not a bug if there already is a NBD data */\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    mig->nbd = g_new0(qemuMigrationCookieNBD, 1);\n\n    mig->nbd->port = priv->nbdPort;\n    mig->flags |= QEMU_MIGRATION_COOKIE_NBD;\n\n    if (vm->def->ndisks == 0)\n        return 0;\n\n    mig->nbd->disks = g_new0(struct qemuMigrationCookieNBDDisk, vm->def->ndisks);\n    mig->nbd->ndisks = 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, priv->job.asyncJob) < 0)\n        return -1;\n    if (blockdev)\n        rc = qemuMonitorBlockStatsUpdateCapacityBlockdev(priv->mon, stats);\n    else\n        rc = qemuMonitorBlockStatsUpdateCapacity(priv->mon, stats, false);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        return -1;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuBlockStats *entry;\n\n        if (blockdev) {\n            if (!(entry = virHashLookup(stats, disk->src->nodeformat)))\n                continue;\n        } else {\n            if (!disk->info.alias ||\n                !(entry = virHashLookup(stats, disk->info.alias)))\n                continue;\n        }\n\n        mig->nbd->disks[mig->nbd->ndisks].target = g_strdup(disk->dst);\n        mig->nbd->disks[mig->nbd->ndisks].capacity = entry->capacity;\n        mig->nbd->ndisks++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieAddNBD(qemuMigrationCookiePtr mig,\n                          virQEMUDriverPtr driver,\n                          virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virHashTable) stats = virHashNew(virHashValueFree);\n    bool blockdev = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV);\n    size_t i;\n    int rc;\n\n    /* It is not a bug if there already is a NBD data */\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    mig->nbd = g_new0(qemuMigrationCookieNBD, 1);\n\n    mig->nbd->port = priv->nbdPort;\n    mig->flags |= QEMU_MIGRATION_COOKIE_NBD;\n\n    if (vm->def->ndisks == 0)\n        return 0;\n\n    mig->nbd->disks = g_new0(struct qemuMigrationCookieNBDDisk, vm->def->ndisks);\n    mig->nbd->ndisks = 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, priv->job.asyncJob) < 0)\n        return -1;\n    if (blockdev)\n        rc = qemuMonitorBlockStatsUpdateCapacityBlockdev(priv->mon, stats);\n    else\n        rc = qemuMonitorBlockStatsUpdateCapacity(priv->mon, stats, false);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        return -1;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuBlockStats *entry;\n\n        if (blockdev) {\n            if (!(entry = virHashLookup(stats, disk->src->nodeformat)))\n                continue;\n        } else {\n            if (!disk->info.alias ||\n                !(entry = virHashLookup(stats, disk->info.alias)))\n                continue;\n        }\n\n        mig->nbd->disks[mig->nbd->ndisks].target = g_strdup(disk->dst);\n        mig->nbd->disks[mig->nbd->ndisks].capacity = entry->capacity;\n        mig->nbd->ndisks++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieAddNetwork",
          "args": [
            "mig",
            "driver",
            "dom"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieAddNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "429-448",
          "snippet": "static int\nqemuMigrationCookieAddNetwork(qemuMigrationCookiePtr mig,\n                              virQEMUDriverPtr driver,\n                              virDomainObjPtr dom)\n{\n    if (mig->flags & QEMU_MIGRATION_COOKIE_NETWORK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Network migration data already present\"));\n        return -1;\n    }\n\n    if (dom->def->nnets > 0) {\n        mig->network = qemuMigrationCookieNetworkAlloc(driver, dom->def);\n        if (!mig->network)\n            return -1;\n        mig->flags |= QEMU_MIGRATION_COOKIE_NETWORK;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieAddNetwork(qemuMigrationCookiePtr mig,\n                              virQEMUDriverPtr driver,\n                              virDomainObjPtr dom)\n{\n    if (mig->flags & QEMU_MIGRATION_COOKIE_NETWORK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Network migration data already present\"));\n        return -1;\n    }\n\n    if (dom->def->nnets > 0) {\n        mig->network = qemuMigrationCookieNetworkAlloc(driver, dom->def);\n        if (!mig->network)\n            return -1;\n        mig->flags |= QEMU_MIGRATION_COOKIE_NETWORK;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieAddLockstate",
          "args": [
            "mig",
            "driver",
            "dom"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieAddLockstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "366-392",
          "snippet": "static int\nqemuMigrationCookieAddLockstate(qemuMigrationCookiePtr mig,\n                                virQEMUDriverPtr driver,\n                                virDomainObjPtr dom)\n{\n    qemuDomainObjPrivatePtr priv = dom->privateData;\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration lockstate data already present\"));\n        return -1;\n    }\n\n    if (virDomainObjGetState(dom, NULL) == VIR_DOMAIN_PAUSED) {\n        mig->lockState = g_strdup(priv->lockState);\n    } else {\n        if (virDomainLockProcessInquire(driver->lockManager, dom, &mig->lockState) < 0)\n            return -1;\n    }\n\n    mig->lockDriver = g_strdup(virLockManagerPluginGetName(driver->lockManager));\n\n    mig->flags |= QEMU_MIGRATION_COOKIE_LOCKSTATE;\n    mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_LOCKSTATE;\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieAddLockstate(qemuMigrationCookiePtr mig,\n                                virQEMUDriverPtr driver,\n                                virDomainObjPtr dom)\n{\n    qemuDomainObjPrivatePtr priv = dom->privateData;\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration lockstate data already present\"));\n        return -1;\n    }\n\n    if (virDomainObjGetState(dom, NULL) == VIR_DOMAIN_PAUSED) {\n        mig->lockState = g_strdup(priv->lockState);\n    } else {\n        if (virDomainLockProcessInquire(driver->lockManager, dom, &mig->lockState) < 0)\n            return -1;\n    }\n\n    mig->lockDriver = g_strdup(virLockManagerPluginGetName(driver->lockManager));\n\n    mig->flags |= QEMU_MIGRATION_COOKIE_LOCKSTATE;\n    mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_LOCKSTATE;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieAddGraphics",
          "args": [
            "mig",
            "driver",
            "dom"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieAddGraphics",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "313-363",
          "snippet": "static int\nqemuMigrationCookieAddGraphics(qemuMigrationCookiePtr mig,\n                               virQEMUDriverPtr driver,\n                               virDomainObjPtr dom)\n{\n    size_t i = 0;\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_GRAPHICS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration graphics data already present\"));\n        return -1;\n    }\n\n    for (i = 0; i < dom->def->ngraphics; i++) {\n        if (dom->def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            virDomainGraphicsListenDefPtr glisten =\n                virDomainGraphicsGetListen(dom->def->graphics[i], 0);\n\n            if (!glisten) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing listen element\"));\n                return -1;\n            }\n\n            switch (glisten->type) {\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS:\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NETWORK:\n                /* Seamless migration is supported only for listen types\n                 * 'address and 'network'. */\n                if (!(mig->graphics =\n                      qemuMigrationCookieGraphicsSpiceAlloc(driver,\n                                                            dom->def->graphics[i],\n                                                            glisten)))\n                    return -1;\n                mig->flags |= QEMU_MIGRATION_COOKIE_GRAPHICS;\n                break;\n\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET:\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NONE:\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_LAST:\n                break;\n            }\n\n            /* Seamless migration is supported only for one graphics. */\n            if (mig->graphics)\n                break;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieAddGraphics(qemuMigrationCookiePtr mig,\n                               virQEMUDriverPtr driver,\n                               virDomainObjPtr dom)\n{\n    size_t i = 0;\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_GRAPHICS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration graphics data already present\"));\n        return -1;\n    }\n\n    for (i = 0; i < dom->def->ngraphics; i++) {\n        if (dom->def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            virDomainGraphicsListenDefPtr glisten =\n                virDomainGraphicsGetListen(dom->def->graphics[i], 0);\n\n            if (!glisten) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing listen element\"));\n                return -1;\n            }\n\n            switch (glisten->type) {\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS:\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NETWORK:\n                /* Seamless migration is supported only for listen types\n                 * 'address and 'network'. */\n                if (!(mig->graphics =\n                      qemuMigrationCookieGraphicsSpiceAlloc(driver,\n                                                            dom->def->graphics[i],\n                                                            glisten)))\n                    return -1;\n                mig->flags |= QEMU_MIGRATION_COOKIE_GRAPHICS;\n                break;\n\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET:\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NONE:\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_LAST:\n                break;\n            }\n\n            /* Seamless migration is supported only for one graphics. */\n            if (mig->graphics)\n                break;\n        }\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nint\nqemuMigrationBakeCookie(qemuMigrationCookiePtr mig,\n                        virQEMUDriverPtr driver,\n                        virDomainObjPtr dom,\n                        qemuMigrationParty party,\n                        char **cookieout,\n                        int *cookieoutlen,\n                        unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = dom->privateData;\n\n    if (!cookieout || !cookieoutlen)\n        return 0;\n\n    *cookieoutlen = 0;\n\n    if (flags & QEMU_MIGRATION_COOKIE_GRAPHICS &&\n        qemuMigrationCookieAddGraphics(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_LOCKSTATE &&\n        qemuMigrationCookieAddLockstate(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_NETWORK &&\n        qemuMigrationCookieAddNetwork(mig, driver, dom) < 0) {\n        return -1;\n    }\n\n    if ((flags & QEMU_MIGRATION_COOKIE_NBD) &&\n        qemuMigrationCookieAddNBD(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS &&\n        qemuMigrationCookieAddStatistics(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_CPU_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU &&\n        qemuMigrationCookieAddCPU(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_ALLOW_REBOOT)\n        qemuMigrationCookieAddAllowReboot(mig, dom);\n\n    if (flags & QEMU_MIGRATION_COOKIE_CAPS &&\n        qemuMigrationCookieAddCaps(mig, dom, party) < 0)\n        return -1;\n\n    if (!(*cookieout = qemuMigrationCookieXMLFormatStr(driver, priv->qemuCaps, mig)))\n        return -1;\n\n    *cookieoutlen = strlen(*cookieout) + 1;\n\n    VIR_DEBUG(\"cookielen=%d cookie=%s\", *cookieoutlen, *cookieout);\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationCookieXMLParseStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "1371-1394",
    "snippet": "static int\nqemuMigrationCookieXMLParseStr(qemuMigrationCookiePtr mig,\n                               virQEMUDriverPtr driver,\n                               virQEMUCapsPtr qemuCaps,\n                               const char *xml,\n                               unsigned int flags)\n{\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    int ret = -1;\n\n    VIR_DEBUG(\"xml=%s\", NULLSTR(xml));\n\n    if (!(doc = virXMLParseStringCtxt(xml, _(\"(qemu_migration_cookie)\"), &ctxt)))\n        goto cleanup;\n\n    ret = qemuMigrationCookieXMLParse(mig, driver, qemuCaps, doc, ctxt, flags);\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "doc"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "ctxt"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieXMLParse",
          "args": [
            "mig",
            "driver",
            "qemuCaps",
            "doc",
            "ctxt",
            "flags"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieXMLParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "1184-1368",
          "snippet": "static int\nqemuMigrationCookieXMLParse(qemuMigrationCookiePtr mig,\n                            virQEMUDriverPtr driver,\n                            virQEMUCapsPtr qemuCaps,\n                            xmlDocPtr doc,\n                            xmlXPathContextPtr ctxt,\n                            unsigned int flags)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *tmp = NULL;\n    xmlNodePtr *nodes = NULL;\n    size_t i;\n    int n;\n\n    /* We don't store the uuid, name, hostname, or hostuuid\n     * values. We just compare them to local data to do some\n     * sanity checking on migration operation\n     */\n\n    /* Extract domain name */\n    if (!(tmp = virXPathString(\"string(./name[1])\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing name element in migration data\"));\n        goto error;\n    }\n    if (STRNEQ(tmp, mig->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incoming cookie data had unexpected name %s vs %s\"),\n                       tmp, mig->name);\n        goto error;\n    }\n    VIR_FREE(tmp);\n\n    /* Extract domain uuid */\n    tmp = virXPathString(\"string(./uuid[1])\", ctxt);\n    if (!tmp) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing uuid element in migration data\"));\n        goto error;\n    }\n    virUUIDFormat(mig->uuid, uuidstr);\n    if (STRNEQ(tmp, uuidstr)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incoming cookie data had unexpected UUID %s vs %s\"),\n                       tmp, uuidstr);\n        goto error;\n    }\n    VIR_FREE(tmp);\n\n    if (!(mig->remoteHostname = virXPathString(\"string(./hostname[1])\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing hostname element in migration data\"));\n        goto error;\n    }\n    /* Historically, this is the place where we checked whether remoteHostname\n     * and localHostname are the same. But even if they were, it doesn't mean\n     * the domain is migrating onto the same host. Rely on UUID which can tell\n     * for sure. */\n\n    /* Check & forbid localhost migration */\n    if (!(tmp = virXPathString(\"string(./hostuuid[1])\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing hostuuid element in migration data\"));\n        goto error;\n    }\n    if (virUUIDParse(tmp, mig->remoteHostuuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"malformed hostuuid element in migration data\"));\n        goto error;\n    }\n    if (memcmp(mig->remoteHostuuid, mig->localHostuuid, VIR_UUID_BUFLEN) == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Attempt to migrate guest to the same host %s\"),\n                       tmp);\n        goto error;\n    }\n    VIR_FREE(tmp);\n\n    /* Check to ensure all mandatory features from XML are also\n     * present in 'flags' */\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) < 0)\n        goto error;\n\n    for (i = 0; i < n; i++) {\n        int val;\n        char *str = virXMLPropString(nodes[i], \"name\");\n        if (!str) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"missing feature name\"));\n            goto error;\n        }\n\n        if ((val = qemuMigrationCookieFlagTypeFromString(str)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown migration cookie feature %s\"),\n                           str);\n            VIR_FREE(str);\n            goto error;\n        }\n\n        if ((flags & (1 << val)) == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unsupported migration cookie feature %s\"),\n                           str);\n            VIR_FREE(str);\n            goto error;\n        }\n        VIR_FREE(str);\n    }\n    VIR_FREE(nodes);\n\n    if ((flags & QEMU_MIGRATION_COOKIE_GRAPHICS) &&\n        virXPathBoolean(\"count(./graphics) > 0\", ctxt) &&\n        (!(mig->graphics = qemuMigrationCookieGraphicsXMLParse(ctxt))))\n        goto error;\n\n    if ((flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) &&\n        virXPathBoolean(\"count(./lockstate) > 0\", ctxt)) {\n        mig->lockDriver = virXPathString(\"string(./lockstate[1]/@driver)\", ctxt);\n        if (!mig->lockDriver) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing lock driver name in migration cookie\"));\n            goto error;\n        }\n        mig->lockState = virXPathString(\"string(./lockstate[1]/leases[1])\", ctxt);\n        if (mig->lockState && STREQ(mig->lockState, \"\"))\n            VIR_FREE(mig->lockState);\n    }\n\n    if ((flags & QEMU_MIGRATION_COOKIE_PERSISTENT) &&\n        virXPathBoolean(\"count(./domain) > 0\", ctxt)) {\n        if ((n = virXPathNodeSet(\"./domain\", ctxt, &nodes)) > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Too many domain elements in \"\n                             \"migration cookie: %d\"),\n                           n);\n            goto error;\n        }\n        mig->persistent = virDomainDefParseNode(doc, nodes[0],\n                                                driver->xmlopt, qemuCaps,\n                                                VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                VIR_DOMAIN_DEF_PARSE_ABI_UPDATE_MIGRATION |\n                                                VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n        if (!mig->persistent) {\n            /* virDomainDefParseNode already reported\n             * an error for us */\n            goto error;\n        }\n        VIR_FREE(nodes);\n    }\n\n    if ((flags & QEMU_MIGRATION_COOKIE_NETWORK) &&\n        virXPathBoolean(\"count(./network) > 0\", ctxt) &&\n        (!(mig->network = qemuMigrationCookieNetworkXMLParse(ctxt))))\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_NBD &&\n        virXPathBoolean(\"boolean(./nbd)\", ctxt) &&\n        (!(mig->nbd = qemuMigrationCookieNBDXMLParse(ctxt))))\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS &&\n        virXPathBoolean(\"boolean(./statistics)\", ctxt) &&\n        (!(mig->jobInfo = qemuMigrationCookieStatisticsXMLParse(ctxt))))\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU &&\n        virCPUDefParseXML(ctxt, \"./cpu[1]\", VIR_CPU_TYPE_GUEST, &mig->cpu) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_ALLOW_REBOOT &&\n        qemuDomainObjPrivateXMLParseAllowReboot(ctxt, &mig->allowReboot) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CAPS &&\n        !(mig->caps = qemuMigrationCookieCapsXMLParse(ctxt)))\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FREE(tmp);\n    VIR_FREE(nodes);\n    return -1;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieXMLParse(qemuMigrationCookiePtr mig,\n                            virQEMUDriverPtr driver,\n                            virQEMUCapsPtr qemuCaps,\n                            xmlDocPtr doc,\n                            xmlXPathContextPtr ctxt,\n                            unsigned int flags)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *tmp = NULL;\n    xmlNodePtr *nodes = NULL;\n    size_t i;\n    int n;\n\n    /* We don't store the uuid, name, hostname, or hostuuid\n     * values. We just compare them to local data to do some\n     * sanity checking on migration operation\n     */\n\n    /* Extract domain name */\n    if (!(tmp = virXPathString(\"string(./name[1])\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing name element in migration data\"));\n        goto error;\n    }\n    if (STRNEQ(tmp, mig->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incoming cookie data had unexpected name %s vs %s\"),\n                       tmp, mig->name);\n        goto error;\n    }\n    VIR_FREE(tmp);\n\n    /* Extract domain uuid */\n    tmp = virXPathString(\"string(./uuid[1])\", ctxt);\n    if (!tmp) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing uuid element in migration data\"));\n        goto error;\n    }\n    virUUIDFormat(mig->uuid, uuidstr);\n    if (STRNEQ(tmp, uuidstr)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incoming cookie data had unexpected UUID %s vs %s\"),\n                       tmp, uuidstr);\n        goto error;\n    }\n    VIR_FREE(tmp);\n\n    if (!(mig->remoteHostname = virXPathString(\"string(./hostname[1])\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing hostname element in migration data\"));\n        goto error;\n    }\n    /* Historically, this is the place where we checked whether remoteHostname\n     * and localHostname are the same. But even if they were, it doesn't mean\n     * the domain is migrating onto the same host. Rely on UUID which can tell\n     * for sure. */\n\n    /* Check & forbid localhost migration */\n    if (!(tmp = virXPathString(\"string(./hostuuid[1])\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing hostuuid element in migration data\"));\n        goto error;\n    }\n    if (virUUIDParse(tmp, mig->remoteHostuuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"malformed hostuuid element in migration data\"));\n        goto error;\n    }\n    if (memcmp(mig->remoteHostuuid, mig->localHostuuid, VIR_UUID_BUFLEN) == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Attempt to migrate guest to the same host %s\"),\n                       tmp);\n        goto error;\n    }\n    VIR_FREE(tmp);\n\n    /* Check to ensure all mandatory features from XML are also\n     * present in 'flags' */\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) < 0)\n        goto error;\n\n    for (i = 0; i < n; i++) {\n        int val;\n        char *str = virXMLPropString(nodes[i], \"name\");\n        if (!str) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"missing feature name\"));\n            goto error;\n        }\n\n        if ((val = qemuMigrationCookieFlagTypeFromString(str)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown migration cookie feature %s\"),\n                           str);\n            VIR_FREE(str);\n            goto error;\n        }\n\n        if ((flags & (1 << val)) == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unsupported migration cookie feature %s\"),\n                           str);\n            VIR_FREE(str);\n            goto error;\n        }\n        VIR_FREE(str);\n    }\n    VIR_FREE(nodes);\n\n    if ((flags & QEMU_MIGRATION_COOKIE_GRAPHICS) &&\n        virXPathBoolean(\"count(./graphics) > 0\", ctxt) &&\n        (!(mig->graphics = qemuMigrationCookieGraphicsXMLParse(ctxt))))\n        goto error;\n\n    if ((flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) &&\n        virXPathBoolean(\"count(./lockstate) > 0\", ctxt)) {\n        mig->lockDriver = virXPathString(\"string(./lockstate[1]/@driver)\", ctxt);\n        if (!mig->lockDriver) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing lock driver name in migration cookie\"));\n            goto error;\n        }\n        mig->lockState = virXPathString(\"string(./lockstate[1]/leases[1])\", ctxt);\n        if (mig->lockState && STREQ(mig->lockState, \"\"))\n            VIR_FREE(mig->lockState);\n    }\n\n    if ((flags & QEMU_MIGRATION_COOKIE_PERSISTENT) &&\n        virXPathBoolean(\"count(./domain) > 0\", ctxt)) {\n        if ((n = virXPathNodeSet(\"./domain\", ctxt, &nodes)) > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Too many domain elements in \"\n                             \"migration cookie: %d\"),\n                           n);\n            goto error;\n        }\n        mig->persistent = virDomainDefParseNode(doc, nodes[0],\n                                                driver->xmlopt, qemuCaps,\n                                                VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                VIR_DOMAIN_DEF_PARSE_ABI_UPDATE_MIGRATION |\n                                                VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n        if (!mig->persistent) {\n            /* virDomainDefParseNode already reported\n             * an error for us */\n            goto error;\n        }\n        VIR_FREE(nodes);\n    }\n\n    if ((flags & QEMU_MIGRATION_COOKIE_NETWORK) &&\n        virXPathBoolean(\"count(./network) > 0\", ctxt) &&\n        (!(mig->network = qemuMigrationCookieNetworkXMLParse(ctxt))))\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_NBD &&\n        virXPathBoolean(\"boolean(./nbd)\", ctxt) &&\n        (!(mig->nbd = qemuMigrationCookieNBDXMLParse(ctxt))))\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS &&\n        virXPathBoolean(\"boolean(./statistics)\", ctxt) &&\n        (!(mig->jobInfo = qemuMigrationCookieStatisticsXMLParse(ctxt))))\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU &&\n        virCPUDefParseXML(ctxt, \"./cpu[1]\", VIR_CPU_TYPE_GUEST, &mig->cpu) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_ALLOW_REBOOT &&\n        qemuDomainObjPrivateXMLParseAllowReboot(ctxt, &mig->allowReboot) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CAPS &&\n        !(mig->caps = qemuMigrationCookieCapsXMLParse(ctxt)))\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FREE(tmp);\n    VIR_FREE(nodes);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLParseStringCtxt",
          "args": [
            "xml",
            "_(\"(qemu_migration_cookie)\")",
            "&ctxt"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"(qemu_migration_cookie)\""
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"xml=%s\"",
            "NULLSTR(xml)"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "xml"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieXMLParseStr(qemuMigrationCookiePtr mig,\n                               virQEMUDriverPtr driver,\n                               virQEMUCapsPtr qemuCaps,\n                               const char *xml,\n                               unsigned int flags)\n{\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    int ret = -1;\n\n    VIR_DEBUG(\"xml=%s\", NULLSTR(xml));\n\n    if (!(doc = virXMLParseStringCtxt(xml, _(\"(qemu_migration_cookie)\"), &ctxt)))\n        goto cleanup;\n\n    ret = qemuMigrationCookieXMLParse(mig, driver, qemuCaps, doc, ctxt, flags);\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationCookieXMLParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "1184-1368",
    "snippet": "static int\nqemuMigrationCookieXMLParse(qemuMigrationCookiePtr mig,\n                            virQEMUDriverPtr driver,\n                            virQEMUCapsPtr qemuCaps,\n                            xmlDocPtr doc,\n                            xmlXPathContextPtr ctxt,\n                            unsigned int flags)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *tmp = NULL;\n    xmlNodePtr *nodes = NULL;\n    size_t i;\n    int n;\n\n    /* We don't store the uuid, name, hostname, or hostuuid\n     * values. We just compare them to local data to do some\n     * sanity checking on migration operation\n     */\n\n    /* Extract domain name */\n    if (!(tmp = virXPathString(\"string(./name[1])\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing name element in migration data\"));\n        goto error;\n    }\n    if (STRNEQ(tmp, mig->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incoming cookie data had unexpected name %s vs %s\"),\n                       tmp, mig->name);\n        goto error;\n    }\n    VIR_FREE(tmp);\n\n    /* Extract domain uuid */\n    tmp = virXPathString(\"string(./uuid[1])\", ctxt);\n    if (!tmp) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing uuid element in migration data\"));\n        goto error;\n    }\n    virUUIDFormat(mig->uuid, uuidstr);\n    if (STRNEQ(tmp, uuidstr)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incoming cookie data had unexpected UUID %s vs %s\"),\n                       tmp, uuidstr);\n        goto error;\n    }\n    VIR_FREE(tmp);\n\n    if (!(mig->remoteHostname = virXPathString(\"string(./hostname[1])\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing hostname element in migration data\"));\n        goto error;\n    }\n    /* Historically, this is the place where we checked whether remoteHostname\n     * and localHostname are the same. But even if they were, it doesn't mean\n     * the domain is migrating onto the same host. Rely on UUID which can tell\n     * for sure. */\n\n    /* Check & forbid localhost migration */\n    if (!(tmp = virXPathString(\"string(./hostuuid[1])\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing hostuuid element in migration data\"));\n        goto error;\n    }\n    if (virUUIDParse(tmp, mig->remoteHostuuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"malformed hostuuid element in migration data\"));\n        goto error;\n    }\n    if (memcmp(mig->remoteHostuuid, mig->localHostuuid, VIR_UUID_BUFLEN) == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Attempt to migrate guest to the same host %s\"),\n                       tmp);\n        goto error;\n    }\n    VIR_FREE(tmp);\n\n    /* Check to ensure all mandatory features from XML are also\n     * present in 'flags' */\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) < 0)\n        goto error;\n\n    for (i = 0; i < n; i++) {\n        int val;\n        char *str = virXMLPropString(nodes[i], \"name\");\n        if (!str) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"missing feature name\"));\n            goto error;\n        }\n\n        if ((val = qemuMigrationCookieFlagTypeFromString(str)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown migration cookie feature %s\"),\n                           str);\n            VIR_FREE(str);\n            goto error;\n        }\n\n        if ((flags & (1 << val)) == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unsupported migration cookie feature %s\"),\n                           str);\n            VIR_FREE(str);\n            goto error;\n        }\n        VIR_FREE(str);\n    }\n    VIR_FREE(nodes);\n\n    if ((flags & QEMU_MIGRATION_COOKIE_GRAPHICS) &&\n        virXPathBoolean(\"count(./graphics) > 0\", ctxt) &&\n        (!(mig->graphics = qemuMigrationCookieGraphicsXMLParse(ctxt))))\n        goto error;\n\n    if ((flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) &&\n        virXPathBoolean(\"count(./lockstate) > 0\", ctxt)) {\n        mig->lockDriver = virXPathString(\"string(./lockstate[1]/@driver)\", ctxt);\n        if (!mig->lockDriver) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing lock driver name in migration cookie\"));\n            goto error;\n        }\n        mig->lockState = virXPathString(\"string(./lockstate[1]/leases[1])\", ctxt);\n        if (mig->lockState && STREQ(mig->lockState, \"\"))\n            VIR_FREE(mig->lockState);\n    }\n\n    if ((flags & QEMU_MIGRATION_COOKIE_PERSISTENT) &&\n        virXPathBoolean(\"count(./domain) > 0\", ctxt)) {\n        if ((n = virXPathNodeSet(\"./domain\", ctxt, &nodes)) > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Too many domain elements in \"\n                             \"migration cookie: %d\"),\n                           n);\n            goto error;\n        }\n        mig->persistent = virDomainDefParseNode(doc, nodes[0],\n                                                driver->xmlopt, qemuCaps,\n                                                VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                VIR_DOMAIN_DEF_PARSE_ABI_UPDATE_MIGRATION |\n                                                VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n        if (!mig->persistent) {\n            /* virDomainDefParseNode already reported\n             * an error for us */\n            goto error;\n        }\n        VIR_FREE(nodes);\n    }\n\n    if ((flags & QEMU_MIGRATION_COOKIE_NETWORK) &&\n        virXPathBoolean(\"count(./network) > 0\", ctxt) &&\n        (!(mig->network = qemuMigrationCookieNetworkXMLParse(ctxt))))\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_NBD &&\n        virXPathBoolean(\"boolean(./nbd)\", ctxt) &&\n        (!(mig->nbd = qemuMigrationCookieNBDXMLParse(ctxt))))\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS &&\n        virXPathBoolean(\"boolean(./statistics)\", ctxt) &&\n        (!(mig->jobInfo = qemuMigrationCookieStatisticsXMLParse(ctxt))))\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU &&\n        virCPUDefParseXML(ctxt, \"./cpu[1]\", VIR_CPU_TYPE_GUEST, &mig->cpu) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_ALLOW_REBOOT &&\n        qemuDomainObjPrivateXMLParseAllowReboot(ctxt, &mig->allowReboot) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CAPS &&\n        !(mig->caps = qemuMigrationCookieCapsXMLParse(ctxt)))\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FREE(tmp);\n    VIR_FREE(nodes);\n    return -1;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieCapsXMLParse",
          "args": [
            "ctxt"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieCapsXMLParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "1131-1181",
          "snippet": "static qemuMigrationCookieCapsPtr\nqemuMigrationCookieCapsXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuMigrationCookieCapsPtr caps = NULL;\n    xmlNodePtr *nodes = NULL;\n    qemuMigrationCookieCapsPtr ret = NULL;\n    char *name = NULL;\n    char *automatic = NULL;\n    int cap;\n    size_t i;\n    int n;\n\n    if (VIR_ALLOC(caps) < 0)\n        return NULL;\n\n    if (!(caps->supported = virBitmapNew(QEMU_MIGRATION_CAP_LAST)) ||\n        !(caps->automatic = virBitmapNew(QEMU_MIGRATION_CAP_LAST)))\n        goto cleanup;\n\n    if ((n = virXPathNodeSet(\"./capabilities[1]/cap\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        if (!(name = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing migration capability name\"));\n            goto cleanup;\n        }\n\n        if ((cap = qemuMigrationCapabilityTypeFromString(name)) < 0)\n            VIR_DEBUG(\"unknown migration capability '%s'\", name);\n        else\n            ignore_value(virBitmapSetBit(caps->supported, cap));\n\n        if ((automatic = virXMLPropString(nodes[i], \"auto\")) &&\n            STREQ(automatic, \"yes\"))\n            ignore_value(virBitmapSetBit(caps->automatic, cap));\n\n        VIR_FREE(name);\n        VIR_FREE(automatic);\n    }\n\n    ret = g_steal_pointer(&caps);\n\n cleanup:\n    qemuMigrationCookieCapsFree(caps);\n    VIR_FREE(nodes);\n    VIR_FREE(name);\n    VIR_FREE(automatic);\n    return ret;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic qemuMigrationCookieCapsPtr\nqemuMigrationCookieCapsXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuMigrationCookieCapsPtr caps = NULL;\n    xmlNodePtr *nodes = NULL;\n    qemuMigrationCookieCapsPtr ret = NULL;\n    char *name = NULL;\n    char *automatic = NULL;\n    int cap;\n    size_t i;\n    int n;\n\n    if (VIR_ALLOC(caps) < 0)\n        return NULL;\n\n    if (!(caps->supported = virBitmapNew(QEMU_MIGRATION_CAP_LAST)) ||\n        !(caps->automatic = virBitmapNew(QEMU_MIGRATION_CAP_LAST)))\n        goto cleanup;\n\n    if ((n = virXPathNodeSet(\"./capabilities[1]/cap\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        if (!(name = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing migration capability name\"));\n            goto cleanup;\n        }\n\n        if ((cap = qemuMigrationCapabilityTypeFromString(name)) < 0)\n            VIR_DEBUG(\"unknown migration capability '%s'\", name);\n        else\n            ignore_value(virBitmapSetBit(caps->supported, cap));\n\n        if ((automatic = virXMLPropString(nodes[i], \"auto\")) &&\n            STREQ(automatic, \"yes\"))\n            ignore_value(virBitmapSetBit(caps->automatic, cap));\n\n        VIR_FREE(name);\n        VIR_FREE(automatic);\n    }\n\n    ret = g_steal_pointer(&caps);\n\n cleanup:\n    qemuMigrationCookieCapsFree(caps);\n    VIR_FREE(nodes);\n    VIR_FREE(name);\n    VIR_FREE(automatic);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjPrivateXMLParseAllowReboot",
          "args": [
            "ctxt",
            "&mig->allowReboot"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjPrivateXMLParseAllowReboot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "3518-3535",
          "snippet": "int\nqemuDomainObjPrivateXMLParseAllowReboot(xmlXPathContextPtr ctxt,\n                                        virTristateBool *allowReboot)\n{\n    int val;\n    g_autofree char *valStr = NULL;\n\n    if ((valStr = virXPathString(\"string(./allowReboot/@value)\", ctxt))) {\n        if ((val = virTristateBoolTypeFromString(valStr)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"invalid allowReboot value '%s'\"), valStr);\n            return -1;\n        }\n        *allowReboot = val;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainObjPrivateXMLParseAllowReboot(xmlXPathContextPtr ctxt,\n                                        virTristateBool *allowReboot)\n{\n    int val;\n    g_autofree char *valStr = NULL;\n\n    if ((valStr = virXPathString(\"string(./allowReboot/@value)\", ctxt))) {\n        if ((val = virTristateBoolTypeFromString(valStr)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"invalid allowReboot value '%s'\"), valStr);\n            return -1;\n        }\n        *allowReboot = val;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefParseXML",
          "args": [
            "ctxt",
            "\"./cpu[1]\"",
            "VIR_CPU_TYPE_GUEST",
            "&mig->cpu"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "329-681",
          "snippet": "int\nvirCPUDefParseXML(xmlXPathContextPtr ctxt,\n                  const char *xpath,\n                  virCPUType type,\n                  virCPUDefPtr *cpu)\n{\n    virCPUDefPtr def = NULL;\n    xmlNodePtr *nodes = NULL;\n    xmlNodePtr oldnode = ctxt->node;\n    int n;\n    size_t i;\n    char *cpuMode;\n    char *fallback = NULL;\n    char *vendor_id = NULL;\n    char *tscScaling = NULL;\n    virHostCPUTscInfoPtr tsc = NULL;\n    int ret = -1;\n\n    *cpu = NULL;\n\n    if (xpath && !(ctxt->node = virXPathNode(xpath, ctxt))) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virXMLNodeNameEqual(ctxt->node, \"cpu\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"XML does not contain expected 'cpu' element\"));\n        goto cleanup;\n    }\n\n    def = virCPUDefNew();\n\n    if (type == VIR_CPU_TYPE_AUTO) {\n        if (virXPathBoolean(\"boolean(./arch)\", ctxt)) {\n            if (virXPathBoolean(\"boolean(./@match)\", ctxt)) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"'arch' element cannot be used inside 'cpu'\"\n                                 \" element with 'match' attribute'\"));\n                goto cleanup;\n            }\n            def->type = VIR_CPU_TYPE_HOST;\n        } else {\n            def->type = VIR_CPU_TYPE_GUEST;\n        }\n    } else {\n        def->type = type;\n    }\n\n    if ((cpuMode = virXMLPropString(ctxt->node, \"mode\"))) {\n        if (def->type == VIR_CPU_TYPE_HOST) {\n            VIR_FREE(cpuMode);\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Attribute mode is only allowed for guest CPU\"));\n            goto cleanup;\n        } else {\n            def->mode = virCPUModeTypeFromString(cpuMode);\n\n            if (def->mode < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid mode attribute '%s'\"),\n                               cpuMode);\n                VIR_FREE(cpuMode);\n                goto cleanup;\n            }\n            VIR_FREE(cpuMode);\n        }\n    } else {\n        if (def->type == VIR_CPU_TYPE_HOST)\n            def->mode = -1;\n        else\n            def->mode = VIR_CPU_MODE_CUSTOM;\n    }\n\n    if (def->type == VIR_CPU_TYPE_GUEST) {\n        char *match = virXMLPropString(ctxt->node, \"match\");\n        char *check;\n\n        if (match) {\n            def->match = virCPUMatchTypeFromString(match);\n            VIR_FREE(match);\n\n            if (def->match < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid match attribute for CPU \"\n                                 \"specification\"));\n                goto cleanup;\n            }\n        }\n\n        if ((check = virXMLPropString(ctxt->node, \"check\"))) {\n            int value = virCPUCheckTypeFromString(check);\n            VIR_FREE(check);\n\n            if (value < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid check attribute for CPU \"\n                                 \"specification\"));\n                goto cleanup;\n            }\n            def->check = value;\n        }\n    }\n\n    if (def->type == VIR_CPU_TYPE_HOST) {\n        char *arch = virXPathString(\"string(./arch[1])\", ctxt);\n        if (!arch) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing CPU architecture\"));\n            goto cleanup;\n        }\n        if ((def->arch = virArchFromString(arch)) == VIR_ARCH_NONE) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unknown architecture %s\"), arch);\n            VIR_FREE(arch);\n            goto cleanup;\n        }\n        VIR_FREE(arch);\n\n        if (virXPathBoolean(\"boolean(./microcode[1]/@version)\", ctxt) > 0 &&\n            virXPathUInt(\"string(./microcode[1]/@version)\", ctxt,\n                         &def->microcodeVersion) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"invalid microcode version\"));\n            goto cleanup;\n        }\n\n        if (virXPathBoolean(\"boolean(./counter[@name='tsc'])\", ctxt) > 0) {\n            if (VIR_ALLOC(tsc) < 0)\n                goto cleanup;\n\n            if (virXPathULongLong(\"string(./counter[@name='tsc']/@frequency)\",\n                                  ctxt, &tsc->frequency) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid TSC frequency\"));\n                goto cleanup;\n            }\n\n            tscScaling = virXPathString(\"string(./counter[@name='tsc']/@scaling)\",\n                                        ctxt);\n            if (tscScaling) {\n                int scaling = virTristateBoolTypeFromString(tscScaling);\n                if (scaling < 0) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Invalid TSC scaling attribute\"));\n                    goto cleanup;\n                }\n                tsc->scaling = scaling;\n            }\n\n            def->tsc = g_steal_pointer(&tsc);\n        }\n    }\n\n    if (!(def->model = virXPathString(\"string(./model[1])\", ctxt)) &&\n        def->type == VIR_CPU_TYPE_HOST) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                        _(\"Missing CPU model name\"));\n        goto cleanup;\n    }\n\n    if (def->type == VIR_CPU_TYPE_GUEST &&\n        def->mode != VIR_CPU_MODE_HOST_PASSTHROUGH) {\n\n        if ((fallback = virXPathString(\"string(./model[1]/@fallback)\", ctxt))) {\n            if ((def->fallback = virCPUFallbackTypeFromString(fallback)) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid fallback attribute\"));\n                goto cleanup;\n            }\n        }\n\n        if ((vendor_id = virXPathString(\"string(./model[1]/@vendor_id)\",\n                                        ctxt))) {\n            if (strlen(vendor_id) != VIR_CPU_VENDOR_ID_LENGTH) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"vendor_id must be exactly %d characters long\"),\n                               VIR_CPU_VENDOR_ID_LENGTH);\n                goto cleanup;\n            }\n\n            /* ensure that the string can be passed to qemu */\n            if (strchr(vendor_id, ',')) {\n                    virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                                   _(\"vendor id is invalid\"));\n                    goto cleanup;\n            }\n\n            def->vendor_id = vendor_id;\n            vendor_id = NULL;\n        }\n    }\n\n    def->vendor = virXPathString(\"string(./vendor[1])\", ctxt);\n    if (def->vendor && !def->model) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"CPU vendor specified without CPU model\"));\n        goto cleanup;\n    }\n\n    if (virXPathNode(\"./topology[1]\", ctxt)) {\n        unsigned long ul;\n\n        if (virXPathULong(\"string(./topology[1]/@sockets)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'sockets' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->sockets = (unsigned int) ul;\n\n        if (virXPathNode(\"./topology[1]/@dies\", ctxt)) {\n            if (virXPathULong(\"string(./topology[1]/@dies)\", ctxt, &ul) < 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"Malformed 'dies' attribute in CPU topology\"));\n                goto cleanup;\n            }\n            def->dies = (unsigned int) ul;\n        } else {\n            def->dies = 1;\n        }\n\n        if (virXPathULong(\"string(./topology[1]/@cores)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'cores' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->cores = (unsigned int) ul;\n\n        if (virXPathULong(\"string(./topology[1]/@threads)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'threads' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->threads = (unsigned int) ul;\n\n        if (!def->sockets || !def->cores || !def->threads || !def->dies) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Invalid CPU topology\"));\n            goto cleanup;\n        }\n    }\n\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    if (n > 0) {\n        if (!def->model && def->mode == VIR_CPU_MODE_CUSTOM) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Non-empty feature list specified without \"\n                             \"CPU model\"));\n            goto cleanup;\n        }\n\n        if (VIR_RESIZE_N(def->features, def->nfeatures_max,\n                         def->nfeatures, n) < 0)\n            goto cleanup;\n\n        def->nfeatures = n;\n    }\n\n    for (i = 0; i < n; i++) {\n        char *name;\n        int policy; /* enum virDomainCPUFeaturePolicy */\n        size_t j;\n\n        if (def->type == VIR_CPU_TYPE_GUEST) {\n            char *strpolicy;\n\n            strpolicy = virXMLPropString(nodes[i], \"policy\");\n            if (strpolicy == NULL)\n                policy = VIR_CPU_FEATURE_REQUIRE;\n            else\n                policy = virCPUFeaturePolicyTypeFromString(strpolicy);\n            VIR_FREE(strpolicy);\n\n            if (policy < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid CPU feature policy\"));\n                goto cleanup;\n            }\n        } else {\n            policy = -1;\n        }\n\n        if (!(name = virXMLPropString(nodes[i], \"name\")) || *name == 0) {\n            VIR_FREE(name);\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Invalid CPU feature name\"));\n            goto cleanup;\n        }\n\n        for (j = 0; j < i; j++) {\n            if (STREQ(name, def->features[j].name)) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"CPU feature '%s' specified more than once\"),\n                               name);\n                VIR_FREE(name);\n                goto cleanup;\n            }\n        }\n\n        def->features[i].name = name;\n        def->features[i].policy = policy;\n    }\n\n    if (virXPathInt(\"count(./cache)\", ctxt, &n) < 0) {\n        goto cleanup;\n    } else if (n > 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"at most one CPU cache element may be specified\"));\n        goto cleanup;\n    } else if (n == 1) {\n        int level = -1;\n        char *strmode;\n        int mode;\n\n        if (virXPathBoolean(\"boolean(./cache[1]/@level)\", ctxt) == 1 &&\n            (virXPathInt(\"string(./cache[1]/@level)\", ctxt, &level) < 0 ||\n             level < 1 || level > 3)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"invalid CPU cache level, must be in range [1,3]\"));\n            goto cleanup;\n        }\n\n        if (!(strmode = virXPathString(\"string(./cache[1]/@mode)\", ctxt)) ||\n            (mode = virCPUCacheModeTypeFromString(strmode)) < 0) {\n            VIR_FREE(strmode);\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing or invalid CPU cache mode\"));\n            goto cleanup;\n        }\n        VIR_FREE(strmode);\n\n        if (VIR_ALLOC(def->cache) < 0)\n            goto cleanup;\n\n        def->cache->level = level;\n        def->cache->mode = mode;\n    }\n\n    *cpu = g_steal_pointer(&def);\n    ret = 0;\n\n cleanup:\n    ctxt->node = oldnode;\n    VIR_FREE(fallback);\n    VIR_FREE(vendor_id);\n    VIR_FREE(nodes);\n    VIR_FREE(tscScaling);\n    VIR_FREE(tsc);\n    virCPUDefFree(def);\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefParseXML(xmlXPathContextPtr ctxt,\n                  const char *xpath,\n                  virCPUType type,\n                  virCPUDefPtr *cpu)\n{\n    virCPUDefPtr def = NULL;\n    xmlNodePtr *nodes = NULL;\n    xmlNodePtr oldnode = ctxt->node;\n    int n;\n    size_t i;\n    char *cpuMode;\n    char *fallback = NULL;\n    char *vendor_id = NULL;\n    char *tscScaling = NULL;\n    virHostCPUTscInfoPtr tsc = NULL;\n    int ret = -1;\n\n    *cpu = NULL;\n\n    if (xpath && !(ctxt->node = virXPathNode(xpath, ctxt))) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virXMLNodeNameEqual(ctxt->node, \"cpu\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"XML does not contain expected 'cpu' element\"));\n        goto cleanup;\n    }\n\n    def = virCPUDefNew();\n\n    if (type == VIR_CPU_TYPE_AUTO) {\n        if (virXPathBoolean(\"boolean(./arch)\", ctxt)) {\n            if (virXPathBoolean(\"boolean(./@match)\", ctxt)) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"'arch' element cannot be used inside 'cpu'\"\n                                 \" element with 'match' attribute'\"));\n                goto cleanup;\n            }\n            def->type = VIR_CPU_TYPE_HOST;\n        } else {\n            def->type = VIR_CPU_TYPE_GUEST;\n        }\n    } else {\n        def->type = type;\n    }\n\n    if ((cpuMode = virXMLPropString(ctxt->node, \"mode\"))) {\n        if (def->type == VIR_CPU_TYPE_HOST) {\n            VIR_FREE(cpuMode);\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Attribute mode is only allowed for guest CPU\"));\n            goto cleanup;\n        } else {\n            def->mode = virCPUModeTypeFromString(cpuMode);\n\n            if (def->mode < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid mode attribute '%s'\"),\n                               cpuMode);\n                VIR_FREE(cpuMode);\n                goto cleanup;\n            }\n            VIR_FREE(cpuMode);\n        }\n    } else {\n        if (def->type == VIR_CPU_TYPE_HOST)\n            def->mode = -1;\n        else\n            def->mode = VIR_CPU_MODE_CUSTOM;\n    }\n\n    if (def->type == VIR_CPU_TYPE_GUEST) {\n        char *match = virXMLPropString(ctxt->node, \"match\");\n        char *check;\n\n        if (match) {\n            def->match = virCPUMatchTypeFromString(match);\n            VIR_FREE(match);\n\n            if (def->match < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid match attribute for CPU \"\n                                 \"specification\"));\n                goto cleanup;\n            }\n        }\n\n        if ((check = virXMLPropString(ctxt->node, \"check\"))) {\n            int value = virCPUCheckTypeFromString(check);\n            VIR_FREE(check);\n\n            if (value < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid check attribute for CPU \"\n                                 \"specification\"));\n                goto cleanup;\n            }\n            def->check = value;\n        }\n    }\n\n    if (def->type == VIR_CPU_TYPE_HOST) {\n        char *arch = virXPathString(\"string(./arch[1])\", ctxt);\n        if (!arch) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing CPU architecture\"));\n            goto cleanup;\n        }\n        if ((def->arch = virArchFromString(arch)) == VIR_ARCH_NONE) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unknown architecture %s\"), arch);\n            VIR_FREE(arch);\n            goto cleanup;\n        }\n        VIR_FREE(arch);\n\n        if (virXPathBoolean(\"boolean(./microcode[1]/@version)\", ctxt) > 0 &&\n            virXPathUInt(\"string(./microcode[1]/@version)\", ctxt,\n                         &def->microcodeVersion) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"invalid microcode version\"));\n            goto cleanup;\n        }\n\n        if (virXPathBoolean(\"boolean(./counter[@name='tsc'])\", ctxt) > 0) {\n            if (VIR_ALLOC(tsc) < 0)\n                goto cleanup;\n\n            if (virXPathULongLong(\"string(./counter[@name='tsc']/@frequency)\",\n                                  ctxt, &tsc->frequency) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid TSC frequency\"));\n                goto cleanup;\n            }\n\n            tscScaling = virXPathString(\"string(./counter[@name='tsc']/@scaling)\",\n                                        ctxt);\n            if (tscScaling) {\n                int scaling = virTristateBoolTypeFromString(tscScaling);\n                if (scaling < 0) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Invalid TSC scaling attribute\"));\n                    goto cleanup;\n                }\n                tsc->scaling = scaling;\n            }\n\n            def->tsc = g_steal_pointer(&tsc);\n        }\n    }\n\n    if (!(def->model = virXPathString(\"string(./model[1])\", ctxt)) &&\n        def->type == VIR_CPU_TYPE_HOST) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                        _(\"Missing CPU model name\"));\n        goto cleanup;\n    }\n\n    if (def->type == VIR_CPU_TYPE_GUEST &&\n        def->mode != VIR_CPU_MODE_HOST_PASSTHROUGH) {\n\n        if ((fallback = virXPathString(\"string(./model[1]/@fallback)\", ctxt))) {\n            if ((def->fallback = virCPUFallbackTypeFromString(fallback)) < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid fallback attribute\"));\n                goto cleanup;\n            }\n        }\n\n        if ((vendor_id = virXPathString(\"string(./model[1]/@vendor_id)\",\n                                        ctxt))) {\n            if (strlen(vendor_id) != VIR_CPU_VENDOR_ID_LENGTH) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"vendor_id must be exactly %d characters long\"),\n                               VIR_CPU_VENDOR_ID_LENGTH);\n                goto cleanup;\n            }\n\n            /* ensure that the string can be passed to qemu */\n            if (strchr(vendor_id, ',')) {\n                    virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                                   _(\"vendor id is invalid\"));\n                    goto cleanup;\n            }\n\n            def->vendor_id = vendor_id;\n            vendor_id = NULL;\n        }\n    }\n\n    def->vendor = virXPathString(\"string(./vendor[1])\", ctxt);\n    if (def->vendor && !def->model) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"CPU vendor specified without CPU model\"));\n        goto cleanup;\n    }\n\n    if (virXPathNode(\"./topology[1]\", ctxt)) {\n        unsigned long ul;\n\n        if (virXPathULong(\"string(./topology[1]/@sockets)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'sockets' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->sockets = (unsigned int) ul;\n\n        if (virXPathNode(\"./topology[1]/@dies\", ctxt)) {\n            if (virXPathULong(\"string(./topology[1]/@dies)\", ctxt, &ul) < 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"Malformed 'dies' attribute in CPU topology\"));\n                goto cleanup;\n            }\n            def->dies = (unsigned int) ul;\n        } else {\n            def->dies = 1;\n        }\n\n        if (virXPathULong(\"string(./topology[1]/@cores)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'cores' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->cores = (unsigned int) ul;\n\n        if (virXPathULong(\"string(./topology[1]/@threads)\", ctxt, &ul) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'threads' attribute in CPU topology\"));\n            goto cleanup;\n        }\n        def->threads = (unsigned int) ul;\n\n        if (!def->sockets || !def->cores || !def->threads || !def->dies) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Invalid CPU topology\"));\n            goto cleanup;\n        }\n    }\n\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    if (n > 0) {\n        if (!def->model && def->mode == VIR_CPU_MODE_CUSTOM) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Non-empty feature list specified without \"\n                             \"CPU model\"));\n            goto cleanup;\n        }\n\n        if (VIR_RESIZE_N(def->features, def->nfeatures_max,\n                         def->nfeatures, n) < 0)\n            goto cleanup;\n\n        def->nfeatures = n;\n    }\n\n    for (i = 0; i < n; i++) {\n        char *name;\n        int policy; /* enum virDomainCPUFeaturePolicy */\n        size_t j;\n\n        if (def->type == VIR_CPU_TYPE_GUEST) {\n            char *strpolicy;\n\n            strpolicy = virXMLPropString(nodes[i], \"policy\");\n            if (strpolicy == NULL)\n                policy = VIR_CPU_FEATURE_REQUIRE;\n            else\n                policy = virCPUFeaturePolicyTypeFromString(strpolicy);\n            VIR_FREE(strpolicy);\n\n            if (policy < 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Invalid CPU feature policy\"));\n                goto cleanup;\n            }\n        } else {\n            policy = -1;\n        }\n\n        if (!(name = virXMLPropString(nodes[i], \"name\")) || *name == 0) {\n            VIR_FREE(name);\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Invalid CPU feature name\"));\n            goto cleanup;\n        }\n\n        for (j = 0; j < i; j++) {\n            if (STREQ(name, def->features[j].name)) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"CPU feature '%s' specified more than once\"),\n                               name);\n                VIR_FREE(name);\n                goto cleanup;\n            }\n        }\n\n        def->features[i].name = name;\n        def->features[i].policy = policy;\n    }\n\n    if (virXPathInt(\"count(./cache)\", ctxt, &n) < 0) {\n        goto cleanup;\n    } else if (n > 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"at most one CPU cache element may be specified\"));\n        goto cleanup;\n    } else if (n == 1) {\n        int level = -1;\n        char *strmode;\n        int mode;\n\n        if (virXPathBoolean(\"boolean(./cache[1]/@level)\", ctxt) == 1 &&\n            (virXPathInt(\"string(./cache[1]/@level)\", ctxt, &level) < 0 ||\n             level < 1 || level > 3)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"invalid CPU cache level, must be in range [1,3]\"));\n            goto cleanup;\n        }\n\n        if (!(strmode = virXPathString(\"string(./cache[1]/@mode)\", ctxt)) ||\n            (mode = virCPUCacheModeTypeFromString(strmode)) < 0) {\n            VIR_FREE(strmode);\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing or invalid CPU cache mode\"));\n            goto cleanup;\n        }\n        VIR_FREE(strmode);\n\n        if (VIR_ALLOC(def->cache) < 0)\n            goto cleanup;\n\n        def->cache->level = level;\n        def->cache->mode = mode;\n    }\n\n    *cpu = g_steal_pointer(&def);\n    ret = 0;\n\n cleanup:\n    ctxt->node = oldnode;\n    VIR_FREE(fallback);\n    VIR_FREE(vendor_id);\n    VIR_FREE(nodes);\n    VIR_FREE(tscScaling);\n    VIR_FREE(tsc);\n    virCPUDefFree(def);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieStatisticsXMLParse",
          "args": [
            "ctxt"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieStatisticsXMLParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "1044-1128",
          "snippet": "static qemuDomainJobInfoPtr\nqemuMigrationCookieStatisticsXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuDomainJobInfoPtr jobInfo = NULL;\n    qemuMonitorMigrationStats *stats;\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n\n    if (!(ctxt->node = virXPathNode(\"./statistics\", ctxt)))\n        return NULL;\n\n    if (VIR_ALLOC(jobInfo) < 0)\n        return NULL;\n\n    stats = &jobInfo->stats.mig;\n    jobInfo->status = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n\n    virXPathULongLong(\"string(./started[1])\", ctxt, &jobInfo->started);\n    virXPathULongLong(\"string(./stopped[1])\", ctxt, &jobInfo->stopped);\n    virXPathULongLong(\"string(./sent[1])\", ctxt, &jobInfo->sent);\n    if (virXPathLongLong(\"string(./delta[1])\", ctxt, &jobInfo->timeDelta) == 0)\n        jobInfo->timeDeltaSet = true;\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_TIME_ELAPSED \"[1])\",\n                      ctxt, &jobInfo->timeElapsed);\n\n    if (virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DOWNTIME \"[1])\",\n                          ctxt, &stats->downtime) == 0)\n        stats->downtime_set = true;\n    if (virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_SETUP_TIME \"[1])\",\n                          ctxt, &stats->setup_time) == 0)\n        stats->setup_time_set = true;\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_TOTAL \"[1])\",\n                      ctxt, &stats->ram_total);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_PROCESSED \"[1])\",\n                      ctxt, &stats->ram_transferred);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_REMAINING \"[1])\",\n                      ctxt, &stats->ram_remaining);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_BPS \"[1])\",\n                      ctxt, &stats->ram_bps);\n\n    if (virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_CONSTANT \"[1])\",\n                          ctxt, &stats->ram_duplicate) == 0)\n        stats->ram_duplicate_set = true;\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_NORMAL \"[1])\",\n                      ctxt, &stats->ram_normal);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES \"[1])\",\n                      ctxt, &stats->ram_normal_bytes);\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE \"[1])\",\n                      ctxt, &stats->ram_dirty_rate);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_ITERATION \"[1])\",\n                      ctxt, &stats->ram_iteration);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_POSTCOPY_REQS \"[1])\",\n                      ctxt, &stats->ram_postcopy_reqs);\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_PAGE_SIZE \"[1])\",\n                      ctxt, &stats->ram_page_size);\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DISK_TOTAL \"[1])\",\n                      ctxt, &stats->disk_total);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DISK_PROCESSED \"[1])\",\n                      ctxt, &stats->disk_transferred);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DISK_REMAINING \"[1])\",\n                      ctxt, &stats->disk_remaining);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DISK_BPS \"[1])\",\n                      ctxt, &stats->disk_bps);\n\n    if (virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_CACHE \"[1])\",\n                          ctxt, &stats->xbzrle_cache_size) == 0)\n        stats->xbzrle_set = true;\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_BYTES \"[1])\",\n                      ctxt, &stats->xbzrle_bytes);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_PAGES \"[1])\",\n                      ctxt, &stats->xbzrle_pages);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES \"[1])\",\n                      ctxt, &stats->xbzrle_cache_miss);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW \"[1])\",\n                      ctxt, &stats->xbzrle_overflow);\n\n    virXPathInt(\"string(./\" VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE \"[1])\",\n                ctxt, &stats->cpu_throttle_percentage);\n\n    return jobInfo;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic qemuDomainJobInfoPtr\nqemuMigrationCookieStatisticsXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuDomainJobInfoPtr jobInfo = NULL;\n    qemuMonitorMigrationStats *stats;\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n\n    if (!(ctxt->node = virXPathNode(\"./statistics\", ctxt)))\n        return NULL;\n\n    if (VIR_ALLOC(jobInfo) < 0)\n        return NULL;\n\n    stats = &jobInfo->stats.mig;\n    jobInfo->status = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n\n    virXPathULongLong(\"string(./started[1])\", ctxt, &jobInfo->started);\n    virXPathULongLong(\"string(./stopped[1])\", ctxt, &jobInfo->stopped);\n    virXPathULongLong(\"string(./sent[1])\", ctxt, &jobInfo->sent);\n    if (virXPathLongLong(\"string(./delta[1])\", ctxt, &jobInfo->timeDelta) == 0)\n        jobInfo->timeDeltaSet = true;\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_TIME_ELAPSED \"[1])\",\n                      ctxt, &jobInfo->timeElapsed);\n\n    if (virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DOWNTIME \"[1])\",\n                          ctxt, &stats->downtime) == 0)\n        stats->downtime_set = true;\n    if (virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_SETUP_TIME \"[1])\",\n                          ctxt, &stats->setup_time) == 0)\n        stats->setup_time_set = true;\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_TOTAL \"[1])\",\n                      ctxt, &stats->ram_total);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_PROCESSED \"[1])\",\n                      ctxt, &stats->ram_transferred);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_REMAINING \"[1])\",\n                      ctxt, &stats->ram_remaining);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_BPS \"[1])\",\n                      ctxt, &stats->ram_bps);\n\n    if (virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_CONSTANT \"[1])\",\n                          ctxt, &stats->ram_duplicate) == 0)\n        stats->ram_duplicate_set = true;\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_NORMAL \"[1])\",\n                      ctxt, &stats->ram_normal);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES \"[1])\",\n                      ctxt, &stats->ram_normal_bytes);\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE \"[1])\",\n                      ctxt, &stats->ram_dirty_rate);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_ITERATION \"[1])\",\n                      ctxt, &stats->ram_iteration);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_POSTCOPY_REQS \"[1])\",\n                      ctxt, &stats->ram_postcopy_reqs);\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_PAGE_SIZE \"[1])\",\n                      ctxt, &stats->ram_page_size);\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DISK_TOTAL \"[1])\",\n                      ctxt, &stats->disk_total);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DISK_PROCESSED \"[1])\",\n                      ctxt, &stats->disk_transferred);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DISK_REMAINING \"[1])\",\n                      ctxt, &stats->disk_remaining);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DISK_BPS \"[1])\",\n                      ctxt, &stats->disk_bps);\n\n    if (virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_CACHE \"[1])\",\n                          ctxt, &stats->xbzrle_cache_size) == 0)\n        stats->xbzrle_set = true;\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_BYTES \"[1])\",\n                      ctxt, &stats->xbzrle_bytes);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_PAGES \"[1])\",\n                      ctxt, &stats->xbzrle_pages);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES \"[1])\",\n                      ctxt, &stats->xbzrle_cache_miss);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW \"[1])\",\n                      ctxt, &stats->xbzrle_overflow);\n\n    virXPathInt(\"string(./\" VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE \"[1])\",\n                ctxt, &stats->cpu_throttle_percentage);\n\n    return jobInfo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathBoolean",
          "args": [
            "\"boolean(./statistics)\"",
            "ctxt"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "571-596",
          "snippet": "int\nvirXPathBoolean(const char *xpath,\n                xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathBoolean()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_BOOLEAN) ||\n        (obj->boolval < 0) || (obj->boolval > 1)) {\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n    ret = obj->boolval;\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathBoolean(const char *xpath,\n                xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathBoolean()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_BOOLEAN) ||\n        (obj->boolval < 0) || (obj->boolval > 1)) {\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n    ret = obj->boolval;\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieNBDXMLParse",
          "args": [
            "ctxt"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieNBDXMLParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "981-1041",
          "snippet": "static qemuMigrationCookieNBDPtr\nqemuMigrationCookieNBDXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuMigrationCookieNBDPtr ret = NULL;\n    char *port = NULL, *capacity = NULL;\n    size_t i;\n    int n;\n    xmlNodePtr *disks = NULL;\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    port = virXPathString(\"string(./nbd/@port)\", ctxt);\n    if (port && virStrToLong_i(port, NULL, 10, &ret->port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Malformed nbd port '%s'\"),\n                       port);\n        goto error;\n    }\n\n    /* Now check if source sent a list of disks to prealloc. We might be\n     * talking to an older server, so it's not an error if the list is\n     * missing. */\n    if ((n = virXPathNodeSet(\"./nbd/disk\", ctxt, &disks)) > 0) {\n        if (VIR_ALLOC_N(ret->disks, n) < 0)\n            goto error;\n        ret->ndisks = n;\n\n        for (i = 0; i < n; i++) {\n            ctxt->node = disks[i];\n            VIR_FREE(capacity);\n\n            if (!(ret->disks[i].target = virXPathString(\"string(./@target)\", ctxt))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Malformed disk target\"));\n                goto error;\n            }\n\n            capacity = virXPathString(\"string(./@capacity)\", ctxt);\n            if (!capacity ||\n                virStrToLong_ull(capacity, NULL, 10,\n                                 &ret->disks[i].capacity) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Malformed disk capacity: '%s'\"),\n                               NULLSTR(capacity));\n                goto error;\n            }\n        }\n    }\n\n cleanup:\n    VIR_FREE(port);\n    VIR_FREE(capacity);\n    VIR_FREE(disks);\n    return ret;\n error:\n    qemuMigrationCookieNBDFree(ret);\n    ret = NULL;\n    goto cleanup;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic qemuMigrationCookieNBDPtr\nqemuMigrationCookieNBDXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuMigrationCookieNBDPtr ret = NULL;\n    char *port = NULL, *capacity = NULL;\n    size_t i;\n    int n;\n    xmlNodePtr *disks = NULL;\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    port = virXPathString(\"string(./nbd/@port)\", ctxt);\n    if (port && virStrToLong_i(port, NULL, 10, &ret->port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Malformed nbd port '%s'\"),\n                       port);\n        goto error;\n    }\n\n    /* Now check if source sent a list of disks to prealloc. We might be\n     * talking to an older server, so it's not an error if the list is\n     * missing. */\n    if ((n = virXPathNodeSet(\"./nbd/disk\", ctxt, &disks)) > 0) {\n        if (VIR_ALLOC_N(ret->disks, n) < 0)\n            goto error;\n        ret->ndisks = n;\n\n        for (i = 0; i < n; i++) {\n            ctxt->node = disks[i];\n            VIR_FREE(capacity);\n\n            if (!(ret->disks[i].target = virXPathString(\"string(./@target)\", ctxt))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Malformed disk target\"));\n                goto error;\n            }\n\n            capacity = virXPathString(\"string(./@capacity)\", ctxt);\n            if (!capacity ||\n                virStrToLong_ull(capacity, NULL, 10,\n                                 &ret->disks[i].capacity) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Malformed disk capacity: '%s'\"),\n                               NULLSTR(capacity));\n                goto error;\n            }\n        }\n    }\n\n cleanup:\n    VIR_FREE(port);\n    VIR_FREE(capacity);\n    VIR_FREE(disks);\n    return ret;\n error:\n    qemuMigrationCookieNBDFree(ret);\n    ret = NULL;\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieNetworkXMLParse",
          "args": [
            "ctxt"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieNetworkXMLParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "933-978",
          "snippet": "static qemuMigrationCookieNetworkPtr\nqemuMigrationCookieNetworkXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuMigrationCookieNetworkPtr optr;\n    size_t i;\n    int n;\n    xmlNodePtr *interfaces = NULL;\n    char *vporttype;\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n\n    if (VIR_ALLOC(optr) < 0)\n        goto error;\n\n    if ((n = virXPathNodeSet(\"./network/interface\", ctxt, &interfaces)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing interface information\"));\n        goto error;\n    }\n\n    optr->nnets = n;\n    if (VIR_ALLOC_N(optr->net, optr->nnets) < 0)\n        goto error;\n\n    for (i = 0; i < n; i++) {\n        /* portdata is optional, and may not exist */\n        ctxt->node = interfaces[i];\n        optr->net[i].portdata = virXPathString(\"string(./portdata[1])\", ctxt);\n\n        if (!(vporttype = virXMLPropString(interfaces[i], \"vporttype\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"missing vporttype attribute in migration data\"));\n            goto error;\n        }\n        optr->net[i].vporttype = virNetDevVPortTypeFromString(vporttype);\n        VIR_FREE(vporttype);\n    }\n\n    VIR_FREE(interfaces);\n\n    return optr;\n\n error:\n    VIR_FREE(interfaces);\n    qemuMigrationCookieNetworkFree(optr);\n    return NULL;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic qemuMigrationCookieNetworkPtr\nqemuMigrationCookieNetworkXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuMigrationCookieNetworkPtr optr;\n    size_t i;\n    int n;\n    xmlNodePtr *interfaces = NULL;\n    char *vporttype;\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n\n    if (VIR_ALLOC(optr) < 0)\n        goto error;\n\n    if ((n = virXPathNodeSet(\"./network/interface\", ctxt, &interfaces)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing interface information\"));\n        goto error;\n    }\n\n    optr->nnets = n;\n    if (VIR_ALLOC_N(optr->net, optr->nnets) < 0)\n        goto error;\n\n    for (i = 0; i < n; i++) {\n        /* portdata is optional, and may not exist */\n        ctxt->node = interfaces[i];\n        optr->net[i].portdata = virXPathString(\"string(./portdata[1])\", ctxt);\n\n        if (!(vporttype = virXMLPropString(interfaces[i], \"vporttype\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"missing vporttype attribute in migration data\"));\n            goto error;\n        }\n        optr->net[i].vporttype = virNetDevVPortTypeFromString(vporttype);\n        VIR_FREE(vporttype);\n    }\n\n    VIR_FREE(interfaces);\n\n    return optr;\n\n error:\n    VIR_FREE(interfaces);\n    qemuMigrationCookieNetworkFree(optr);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefParseNode",
          "args": [
            "doc",
            "nodes[0]",
            "driver->xmlopt",
            "qemuCaps",
            "VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                VIR_DOMAIN_DEF_PARSE_ABI_UPDATE_MIGRATION |\n                                                VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefParseNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "22153-22180",
          "snippet": "virDomainDefPtr\nvirDomainDefParseNode(xmlDocPtr xml,\n                      xmlNodePtr root,\n                      virDomainXMLOptionPtr xmlopt,\n                      void *parseOpaque,\n                      unsigned int flags)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n    g_autoptr(virDomainDef) def = NULL;\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n\n    if (!(def = virDomainDefParseXML(xml, ctxt, xmlopt, flags)))\n        return NULL;\n\n    /* callback to fill driver specific domain aspects */\n    if (virDomainDefPostParse(def, flags, xmlopt, parseOpaque) < 0)\n        return NULL;\n\n    /* validate configuration */\n    if (virDomainDefValidate(def, flags, xmlopt) < 0)\n        return NULL;\n\n    return g_steal_pointer(&def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefParseNode(xmlDocPtr xml,\n                      xmlNodePtr root,\n                      virDomainXMLOptionPtr xmlopt,\n                      void *parseOpaque,\n                      unsigned int flags)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n    g_autoptr(virDomainDef) def = NULL;\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n\n    if (!(def = virDomainDefParseXML(xml, ctxt, xmlopt, flags)))\n        return NULL;\n\n    /* callback to fill driver specific domain aspects */\n    if (virDomainDefPostParse(def, flags, xmlopt, parseOpaque) < 0)\n        return NULL;\n\n    /* validate configuration */\n    if (virDomainDefValidate(def, flags, xmlopt) < 0)\n        return NULL;\n\n    return g_steal_pointer(&def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Too many domain elements in \"\n                             \"migration cookie: %d\")",
            "n"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Too many domain elements in \"\n                             \"migration cookie: %d\""
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./domain\"",
            "ctxt",
            "&nodes"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mig->lockState"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "mig->lockState",
            "\"\""
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./lockstate[1]/leases[1])\"",
            "ctxt"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing lock driver name in migration cookie\")"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieGraphicsXMLParse",
          "args": [
            "ctxt"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieGraphicsXMLParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "884-930",
          "snippet": "static qemuMigrationCookieGraphicsPtr\nqemuMigrationCookieGraphicsXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuMigrationCookieGraphicsPtr grap;\n    char *tmp;\n\n    if (VIR_ALLOC(grap) < 0)\n        goto error;\n\n    if (!(tmp = virXPathString(\"string(./graphics/@type)\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing type attribute in migration data\"));\n        goto error;\n    }\n    if ((grap->type = virDomainGraphicsTypeFromString(tmp)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown graphics type %s\"), tmp);\n        VIR_FREE(tmp);\n        goto error;\n    }\n    VIR_FREE(tmp);\n    if (virXPathInt(\"string(./graphics/@port)\", ctxt, &grap->port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing port attribute in migration data\"));\n        goto error;\n    }\n    if (grap->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n        if (virXPathInt(\"string(./graphics/@tlsPort)\", ctxt, &grap->tlsPort) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"missing tlsPort attribute in migration data\"));\n            goto error;\n        }\n    }\n    if (!(grap->listen = virXPathString(\"string(./graphics/@listen)\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing listen attribute in migration data\"));\n        goto error;\n    }\n    /* Optional */\n    grap->tlsSubject = virXPathString(\"string(./graphics/cert[@info='subject']/@value)\", ctxt);\n\n    return grap;\n\n error:\n    qemuMigrationCookieGraphicsFree(grap);\n    return NULL;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic qemuMigrationCookieGraphicsPtr\nqemuMigrationCookieGraphicsXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuMigrationCookieGraphicsPtr grap;\n    char *tmp;\n\n    if (VIR_ALLOC(grap) < 0)\n        goto error;\n\n    if (!(tmp = virXPathString(\"string(./graphics/@type)\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing type attribute in migration data\"));\n        goto error;\n    }\n    if ((grap->type = virDomainGraphicsTypeFromString(tmp)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown graphics type %s\"), tmp);\n        VIR_FREE(tmp);\n        goto error;\n    }\n    VIR_FREE(tmp);\n    if (virXPathInt(\"string(./graphics/@port)\", ctxt, &grap->port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing port attribute in migration data\"));\n        goto error;\n    }\n    if (grap->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n        if (virXPathInt(\"string(./graphics/@tlsPort)\", ctxt, &grap->tlsPort) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"missing tlsPort attribute in migration data\"));\n            goto error;\n        }\n    }\n    if (!(grap->listen = virXPathString(\"string(./graphics/@listen)\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing listen attribute in migration data\"));\n        goto error;\n    }\n    /* Optional */\n    grap->tlsSubject = virXPathString(\"string(./graphics/cert[@info='subject']/@value)\", ctxt);\n\n    return grap;\n\n error:\n    qemuMigrationCookieGraphicsFree(grap);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unsupported migration cookie feature %s\")",
            "str"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown migration cookie feature %s\")",
            "str"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieFlagTypeFromString",
          "args": [
            "str"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing feature name\")"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "nodes[i]",
            "\"name\""
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Attempt to migrate guest to the same host %s\")",
            "tmp"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "mig->remoteHostuuid",
            "mig->localHostuuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed hostuuid element in migration data\")"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "tmp",
            "mig->remoteHostuuid"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing hostuuid element in migration data\")"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing hostname element in migration data\")"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Incoming cookie data had unexpected UUID %s vs %s\")",
            "tmp",
            "uuidstr"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "tmp",
            "uuidstr"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "mig->uuid",
            "uuidstr"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing uuid element in migration data\")"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Incoming cookie data had unexpected name %s vs %s\")",
            "tmp",
            "mig->name"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "tmp",
            "mig->name"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing name element in migration data\")"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieXMLParse(qemuMigrationCookiePtr mig,\n                            virQEMUDriverPtr driver,\n                            virQEMUCapsPtr qemuCaps,\n                            xmlDocPtr doc,\n                            xmlXPathContextPtr ctxt,\n                            unsigned int flags)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *tmp = NULL;\n    xmlNodePtr *nodes = NULL;\n    size_t i;\n    int n;\n\n    /* We don't store the uuid, name, hostname, or hostuuid\n     * values. We just compare them to local data to do some\n     * sanity checking on migration operation\n     */\n\n    /* Extract domain name */\n    if (!(tmp = virXPathString(\"string(./name[1])\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing name element in migration data\"));\n        goto error;\n    }\n    if (STRNEQ(tmp, mig->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incoming cookie data had unexpected name %s vs %s\"),\n                       tmp, mig->name);\n        goto error;\n    }\n    VIR_FREE(tmp);\n\n    /* Extract domain uuid */\n    tmp = virXPathString(\"string(./uuid[1])\", ctxt);\n    if (!tmp) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing uuid element in migration data\"));\n        goto error;\n    }\n    virUUIDFormat(mig->uuid, uuidstr);\n    if (STRNEQ(tmp, uuidstr)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incoming cookie data had unexpected UUID %s vs %s\"),\n                       tmp, uuidstr);\n        goto error;\n    }\n    VIR_FREE(tmp);\n\n    if (!(mig->remoteHostname = virXPathString(\"string(./hostname[1])\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing hostname element in migration data\"));\n        goto error;\n    }\n    /* Historically, this is the place where we checked whether remoteHostname\n     * and localHostname are the same. But even if they were, it doesn't mean\n     * the domain is migrating onto the same host. Rely on UUID which can tell\n     * for sure. */\n\n    /* Check & forbid localhost migration */\n    if (!(tmp = virXPathString(\"string(./hostuuid[1])\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing hostuuid element in migration data\"));\n        goto error;\n    }\n    if (virUUIDParse(tmp, mig->remoteHostuuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"malformed hostuuid element in migration data\"));\n        goto error;\n    }\n    if (memcmp(mig->remoteHostuuid, mig->localHostuuid, VIR_UUID_BUFLEN) == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Attempt to migrate guest to the same host %s\"),\n                       tmp);\n        goto error;\n    }\n    VIR_FREE(tmp);\n\n    /* Check to ensure all mandatory features from XML are also\n     * present in 'flags' */\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) < 0)\n        goto error;\n\n    for (i = 0; i < n; i++) {\n        int val;\n        char *str = virXMLPropString(nodes[i], \"name\");\n        if (!str) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"missing feature name\"));\n            goto error;\n        }\n\n        if ((val = qemuMigrationCookieFlagTypeFromString(str)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown migration cookie feature %s\"),\n                           str);\n            VIR_FREE(str);\n            goto error;\n        }\n\n        if ((flags & (1 << val)) == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unsupported migration cookie feature %s\"),\n                           str);\n            VIR_FREE(str);\n            goto error;\n        }\n        VIR_FREE(str);\n    }\n    VIR_FREE(nodes);\n\n    if ((flags & QEMU_MIGRATION_COOKIE_GRAPHICS) &&\n        virXPathBoolean(\"count(./graphics) > 0\", ctxt) &&\n        (!(mig->graphics = qemuMigrationCookieGraphicsXMLParse(ctxt))))\n        goto error;\n\n    if ((flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) &&\n        virXPathBoolean(\"count(./lockstate) > 0\", ctxt)) {\n        mig->lockDriver = virXPathString(\"string(./lockstate[1]/@driver)\", ctxt);\n        if (!mig->lockDriver) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing lock driver name in migration cookie\"));\n            goto error;\n        }\n        mig->lockState = virXPathString(\"string(./lockstate[1]/leases[1])\", ctxt);\n        if (mig->lockState && STREQ(mig->lockState, \"\"))\n            VIR_FREE(mig->lockState);\n    }\n\n    if ((flags & QEMU_MIGRATION_COOKIE_PERSISTENT) &&\n        virXPathBoolean(\"count(./domain) > 0\", ctxt)) {\n        if ((n = virXPathNodeSet(\"./domain\", ctxt, &nodes)) > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Too many domain elements in \"\n                             \"migration cookie: %d\"),\n                           n);\n            goto error;\n        }\n        mig->persistent = virDomainDefParseNode(doc, nodes[0],\n                                                driver->xmlopt, qemuCaps,\n                                                VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                VIR_DOMAIN_DEF_PARSE_ABI_UPDATE_MIGRATION |\n                                                VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n        if (!mig->persistent) {\n            /* virDomainDefParseNode already reported\n             * an error for us */\n            goto error;\n        }\n        VIR_FREE(nodes);\n    }\n\n    if ((flags & QEMU_MIGRATION_COOKIE_NETWORK) &&\n        virXPathBoolean(\"count(./network) > 0\", ctxt) &&\n        (!(mig->network = qemuMigrationCookieNetworkXMLParse(ctxt))))\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_NBD &&\n        virXPathBoolean(\"boolean(./nbd)\", ctxt) &&\n        (!(mig->nbd = qemuMigrationCookieNBDXMLParse(ctxt))))\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS &&\n        virXPathBoolean(\"boolean(./statistics)\", ctxt) &&\n        (!(mig->jobInfo = qemuMigrationCookieStatisticsXMLParse(ctxt))))\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU &&\n        virCPUDefParseXML(ctxt, \"./cpu[1]\", VIR_CPU_TYPE_GUEST, &mig->cpu) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_ALLOW_REBOOT &&\n        qemuDomainObjPrivateXMLParseAllowReboot(ctxt, &mig->allowReboot) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CAPS &&\n        !(mig->caps = qemuMigrationCookieCapsXMLParse(ctxt)))\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FREE(tmp);\n    VIR_FREE(nodes);\n    return -1;\n}"
  },
  {
    "function_name": "qemuMigrationCookieCapsXMLParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "1131-1181",
    "snippet": "static qemuMigrationCookieCapsPtr\nqemuMigrationCookieCapsXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuMigrationCookieCapsPtr caps = NULL;\n    xmlNodePtr *nodes = NULL;\n    qemuMigrationCookieCapsPtr ret = NULL;\n    char *name = NULL;\n    char *automatic = NULL;\n    int cap;\n    size_t i;\n    int n;\n\n    if (VIR_ALLOC(caps) < 0)\n        return NULL;\n\n    if (!(caps->supported = virBitmapNew(QEMU_MIGRATION_CAP_LAST)) ||\n        !(caps->automatic = virBitmapNew(QEMU_MIGRATION_CAP_LAST)))\n        goto cleanup;\n\n    if ((n = virXPathNodeSet(\"./capabilities[1]/cap\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        if (!(name = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing migration capability name\"));\n            goto cleanup;\n        }\n\n        if ((cap = qemuMigrationCapabilityTypeFromString(name)) < 0)\n            VIR_DEBUG(\"unknown migration capability '%s'\", name);\n        else\n            ignore_value(virBitmapSetBit(caps->supported, cap));\n\n        if ((automatic = virXMLPropString(nodes[i], \"auto\")) &&\n            STREQ(automatic, \"yes\"))\n            ignore_value(virBitmapSetBit(caps->automatic, cap));\n\n        VIR_FREE(name);\n        VIR_FREE(automatic);\n    }\n\n    ret = g_steal_pointer(&caps);\n\n cleanup:\n    qemuMigrationCookieCapsFree(caps);\n    VIR_FREE(nodes);\n    VIR_FREE(name);\n    VIR_FREE(automatic);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "automatic"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieCapsFree",
          "args": [
            "caps"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieCapsFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "98-107",
          "snippet": "static void\nqemuMigrationCookieCapsFree(qemuMigrationCookieCapsPtr caps)\n{\n    if (!caps)\n        return;\n\n    virBitmapFree(caps->supported);\n    virBitmapFree(caps->automatic);\n    VIR_FREE(caps);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieCapsFree(qemuMigrationCookieCapsPtr caps)\n{\n    if (!caps)\n        return;\n\n    virBitmapFree(caps->supported);\n    virBitmapFree(caps->automatic);\n    VIR_FREE(caps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&caps"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "automatic"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(caps->automatic, cap)"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "caps->automatic",
            "cap"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "automatic",
            "\"yes\""
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "nodes[i]",
            "\"auto\""
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(caps->supported, cap)"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"unknown migration capability '%s'\"",
            "name"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationCapabilityTypeFromString",
          "args": [
            "name"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing migration capability name\")"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing migration capability name\""
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./capabilities[1]/cap\"",
            "ctxt",
            "&nodes"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "QEMU_MIGRATION_CAP_LAST"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "caps"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic qemuMigrationCookieCapsPtr\nqemuMigrationCookieCapsXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuMigrationCookieCapsPtr caps = NULL;\n    xmlNodePtr *nodes = NULL;\n    qemuMigrationCookieCapsPtr ret = NULL;\n    char *name = NULL;\n    char *automatic = NULL;\n    int cap;\n    size_t i;\n    int n;\n\n    if (VIR_ALLOC(caps) < 0)\n        return NULL;\n\n    if (!(caps->supported = virBitmapNew(QEMU_MIGRATION_CAP_LAST)) ||\n        !(caps->automatic = virBitmapNew(QEMU_MIGRATION_CAP_LAST)))\n        goto cleanup;\n\n    if ((n = virXPathNodeSet(\"./capabilities[1]/cap\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        if (!(name = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing migration capability name\"));\n            goto cleanup;\n        }\n\n        if ((cap = qemuMigrationCapabilityTypeFromString(name)) < 0)\n            VIR_DEBUG(\"unknown migration capability '%s'\", name);\n        else\n            ignore_value(virBitmapSetBit(caps->supported, cap));\n\n        if ((automatic = virXMLPropString(nodes[i], \"auto\")) &&\n            STREQ(automatic, \"yes\"))\n            ignore_value(virBitmapSetBit(caps->automatic, cap));\n\n        VIR_FREE(name);\n        VIR_FREE(automatic);\n    }\n\n    ret = g_steal_pointer(&caps);\n\n cleanup:\n    qemuMigrationCookieCapsFree(caps);\n    VIR_FREE(nodes);\n    VIR_FREE(name);\n    VIR_FREE(automatic);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationCookieStatisticsXMLParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "1044-1128",
    "snippet": "static qemuDomainJobInfoPtr\nqemuMigrationCookieStatisticsXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuDomainJobInfoPtr jobInfo = NULL;\n    qemuMonitorMigrationStats *stats;\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n\n    if (!(ctxt->node = virXPathNode(\"./statistics\", ctxt)))\n        return NULL;\n\n    if (VIR_ALLOC(jobInfo) < 0)\n        return NULL;\n\n    stats = &jobInfo->stats.mig;\n    jobInfo->status = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n\n    virXPathULongLong(\"string(./started[1])\", ctxt, &jobInfo->started);\n    virXPathULongLong(\"string(./stopped[1])\", ctxt, &jobInfo->stopped);\n    virXPathULongLong(\"string(./sent[1])\", ctxt, &jobInfo->sent);\n    if (virXPathLongLong(\"string(./delta[1])\", ctxt, &jobInfo->timeDelta) == 0)\n        jobInfo->timeDeltaSet = true;\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_TIME_ELAPSED \"[1])\",\n                      ctxt, &jobInfo->timeElapsed);\n\n    if (virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DOWNTIME \"[1])\",\n                          ctxt, &stats->downtime) == 0)\n        stats->downtime_set = true;\n    if (virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_SETUP_TIME \"[1])\",\n                          ctxt, &stats->setup_time) == 0)\n        stats->setup_time_set = true;\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_TOTAL \"[1])\",\n                      ctxt, &stats->ram_total);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_PROCESSED \"[1])\",\n                      ctxt, &stats->ram_transferred);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_REMAINING \"[1])\",\n                      ctxt, &stats->ram_remaining);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_BPS \"[1])\",\n                      ctxt, &stats->ram_bps);\n\n    if (virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_CONSTANT \"[1])\",\n                          ctxt, &stats->ram_duplicate) == 0)\n        stats->ram_duplicate_set = true;\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_NORMAL \"[1])\",\n                      ctxt, &stats->ram_normal);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES \"[1])\",\n                      ctxt, &stats->ram_normal_bytes);\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE \"[1])\",\n                      ctxt, &stats->ram_dirty_rate);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_ITERATION \"[1])\",\n                      ctxt, &stats->ram_iteration);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_POSTCOPY_REQS \"[1])\",\n                      ctxt, &stats->ram_postcopy_reqs);\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_PAGE_SIZE \"[1])\",\n                      ctxt, &stats->ram_page_size);\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DISK_TOTAL \"[1])\",\n                      ctxt, &stats->disk_total);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DISK_PROCESSED \"[1])\",\n                      ctxt, &stats->disk_transferred);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DISK_REMAINING \"[1])\",\n                      ctxt, &stats->disk_remaining);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DISK_BPS \"[1])\",\n                      ctxt, &stats->disk_bps);\n\n    if (virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_CACHE \"[1])\",\n                          ctxt, &stats->xbzrle_cache_size) == 0)\n        stats->xbzrle_set = true;\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_BYTES \"[1])\",\n                      ctxt, &stats->xbzrle_bytes);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_PAGES \"[1])\",\n                      ctxt, &stats->xbzrle_pages);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES \"[1])\",\n                      ctxt, &stats->xbzrle_cache_miss);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW \"[1])\",\n                      ctxt, &stats->xbzrle_overflow);\n\n    virXPathInt(\"string(./\" VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE \"[1])\",\n                ctxt, &stats->cpu_throttle_percentage);\n\n    return jobInfo;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virXPathInt",
          "args": [
            "\"string(./\" VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE \"[1])\"",
            "ctxt",
            "&stats->cpu_throttle_percentage"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "223-238",
          "snippet": "int\nvirXPathInt(const char *xpath,\n            xmlXPathContextPtr ctxt,\n            int *value)\n{\n    long tmp;\n    int ret;\n\n    ret = virXPathLongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathInt(const char *xpath,\n            xmlXPathContextPtr ctxt,\n            int *value)\n{\n    long tmp;\n    int ret;\n\n    ret = virXPathLongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathULongLong",
          "args": [
            "\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW \"[1])\"",
            "ctxt",
            "&stats->xbzrle_overflow"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "398-430",
          "snippet": "int\nvirXPathULongLong(const char *xpath,\n                  xmlXPathContextPtr ctxt,\n                  unsigned long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathULong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ull((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (unsigned long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathULongLong(const char *xpath,\n                  xmlXPathContextPtr ctxt,\n                  unsigned long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathULong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ull((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (unsigned long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathLongLong",
          "args": [
            "\"string(./delta[1])\"",
            "ctxt",
            "&jobInfo->timeDelta"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathLongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "444-476",
          "snippet": "int\nvirXPathLongLong(const char *xpath,\n                 xmlXPathContextPtr ctxt,\n                 long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathLongLong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ll((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathLongLong(const char *xpath,\n                 xmlXPathContextPtr ctxt,\n                 long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathLongLong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ll((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "jobInfo"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./statistics\"",
            "ctxt"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_XPATH_NODE_AUTORESTORE",
          "args": [
            "ctxt"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic qemuDomainJobInfoPtr\nqemuMigrationCookieStatisticsXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuDomainJobInfoPtr jobInfo = NULL;\n    qemuMonitorMigrationStats *stats;\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n\n    if (!(ctxt->node = virXPathNode(\"./statistics\", ctxt)))\n        return NULL;\n\n    if (VIR_ALLOC(jobInfo) < 0)\n        return NULL;\n\n    stats = &jobInfo->stats.mig;\n    jobInfo->status = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n\n    virXPathULongLong(\"string(./started[1])\", ctxt, &jobInfo->started);\n    virXPathULongLong(\"string(./stopped[1])\", ctxt, &jobInfo->stopped);\n    virXPathULongLong(\"string(./sent[1])\", ctxt, &jobInfo->sent);\n    if (virXPathLongLong(\"string(./delta[1])\", ctxt, &jobInfo->timeDelta) == 0)\n        jobInfo->timeDeltaSet = true;\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_TIME_ELAPSED \"[1])\",\n                      ctxt, &jobInfo->timeElapsed);\n\n    if (virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DOWNTIME \"[1])\",\n                          ctxt, &stats->downtime) == 0)\n        stats->downtime_set = true;\n    if (virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_SETUP_TIME \"[1])\",\n                          ctxt, &stats->setup_time) == 0)\n        stats->setup_time_set = true;\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_TOTAL \"[1])\",\n                      ctxt, &stats->ram_total);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_PROCESSED \"[1])\",\n                      ctxt, &stats->ram_transferred);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_REMAINING \"[1])\",\n                      ctxt, &stats->ram_remaining);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_BPS \"[1])\",\n                      ctxt, &stats->ram_bps);\n\n    if (virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_CONSTANT \"[1])\",\n                          ctxt, &stats->ram_duplicate) == 0)\n        stats->ram_duplicate_set = true;\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_NORMAL \"[1])\",\n                      ctxt, &stats->ram_normal);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES \"[1])\",\n                      ctxt, &stats->ram_normal_bytes);\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE \"[1])\",\n                      ctxt, &stats->ram_dirty_rate);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_ITERATION \"[1])\",\n                      ctxt, &stats->ram_iteration);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_POSTCOPY_REQS \"[1])\",\n                      ctxt, &stats->ram_postcopy_reqs);\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_MEMORY_PAGE_SIZE \"[1])\",\n                      ctxt, &stats->ram_page_size);\n\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DISK_TOTAL \"[1])\",\n                      ctxt, &stats->disk_total);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DISK_PROCESSED \"[1])\",\n                      ctxt, &stats->disk_transferred);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DISK_REMAINING \"[1])\",\n                      ctxt, &stats->disk_remaining);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_DISK_BPS \"[1])\",\n                      ctxt, &stats->disk_bps);\n\n    if (virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_CACHE \"[1])\",\n                          ctxt, &stats->xbzrle_cache_size) == 0)\n        stats->xbzrle_set = true;\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_BYTES \"[1])\",\n                      ctxt, &stats->xbzrle_bytes);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_PAGES \"[1])\",\n                      ctxt, &stats->xbzrle_pages);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES \"[1])\",\n                      ctxt, &stats->xbzrle_cache_miss);\n    virXPathULongLong(\"string(./\" VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW \"[1])\",\n                      ctxt, &stats->xbzrle_overflow);\n\n    virXPathInt(\"string(./\" VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE \"[1])\",\n                ctxt, &stats->cpu_throttle_percentage);\n\n    return jobInfo;\n}"
  },
  {
    "function_name": "qemuMigrationCookieNBDXMLParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "981-1041",
    "snippet": "static qemuMigrationCookieNBDPtr\nqemuMigrationCookieNBDXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuMigrationCookieNBDPtr ret = NULL;\n    char *port = NULL, *capacity = NULL;\n    size_t i;\n    int n;\n    xmlNodePtr *disks = NULL;\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    port = virXPathString(\"string(./nbd/@port)\", ctxt);\n    if (port && virStrToLong_i(port, NULL, 10, &ret->port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Malformed nbd port '%s'\"),\n                       port);\n        goto error;\n    }\n\n    /* Now check if source sent a list of disks to prealloc. We might be\n     * talking to an older server, so it's not an error if the list is\n     * missing. */\n    if ((n = virXPathNodeSet(\"./nbd/disk\", ctxt, &disks)) > 0) {\n        if (VIR_ALLOC_N(ret->disks, n) < 0)\n            goto error;\n        ret->ndisks = n;\n\n        for (i = 0; i < n; i++) {\n            ctxt->node = disks[i];\n            VIR_FREE(capacity);\n\n            if (!(ret->disks[i].target = virXPathString(\"string(./@target)\", ctxt))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Malformed disk target\"));\n                goto error;\n            }\n\n            capacity = virXPathString(\"string(./@capacity)\", ctxt);\n            if (!capacity ||\n                virStrToLong_ull(capacity, NULL, 10,\n                                 &ret->disks[i].capacity) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Malformed disk capacity: '%s'\"),\n                               NULLSTR(capacity));\n                goto error;\n            }\n        }\n    }\n\n cleanup:\n    VIR_FREE(port);\n    VIR_FREE(capacity);\n    VIR_FREE(disks);\n    return ret;\n error:\n    qemuMigrationCookieNBDFree(ret);\n    ret = NULL;\n    goto cleanup;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMigrationCookieNBDFree",
          "args": [
            "ret"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieNBDFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "85-95",
          "snippet": "static void\nqemuMigrationCookieNBDFree(qemuMigrationCookieNBDPtr nbd)\n{\n    if (!nbd)\n        return;\n\n    while (nbd->ndisks)\n        VIR_FREE(nbd->disks[--nbd->ndisks].target);\n    VIR_FREE(nbd->disks);\n    VIR_FREE(nbd);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieNBDFree(qemuMigrationCookieNBDPtr nbd)\n{\n    if (!nbd)\n        return;\n\n    while (nbd->ndisks)\n        VIR_FREE(nbd->disks[--nbd->ndisks].target);\n    VIR_FREE(nbd->disks);\n    VIR_FREE(nbd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "disks"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "capacity"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "port"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Malformed disk capacity: '%s'\")",
            "NULLSTR(capacity)"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "capacity"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Malformed disk capacity: '%s'\""
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ull",
          "args": [
            "capacity",
            "NULL",
            "10",
            "&ret->disks[i].capacity"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ullp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "568-586",
          "snippet": "int\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./@capacity)\"",
            "ctxt"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Malformed disk target\")"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "capacity"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "ret->disks",
            "n"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./nbd/disk\"",
            "ctxt",
            "&disks"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Malformed nbd port '%s'\")",
            "port"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "port",
            "NULL",
            "10",
            "&ret->port"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ret"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_XPATH_NODE_AUTORESTORE",
          "args": [
            "ctxt"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic qemuMigrationCookieNBDPtr\nqemuMigrationCookieNBDXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuMigrationCookieNBDPtr ret = NULL;\n    char *port = NULL, *capacity = NULL;\n    size_t i;\n    int n;\n    xmlNodePtr *disks = NULL;\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    port = virXPathString(\"string(./nbd/@port)\", ctxt);\n    if (port && virStrToLong_i(port, NULL, 10, &ret->port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Malformed nbd port '%s'\"),\n                       port);\n        goto error;\n    }\n\n    /* Now check if source sent a list of disks to prealloc. We might be\n     * talking to an older server, so it's not an error if the list is\n     * missing. */\n    if ((n = virXPathNodeSet(\"./nbd/disk\", ctxt, &disks)) > 0) {\n        if (VIR_ALLOC_N(ret->disks, n) < 0)\n            goto error;\n        ret->ndisks = n;\n\n        for (i = 0; i < n; i++) {\n            ctxt->node = disks[i];\n            VIR_FREE(capacity);\n\n            if (!(ret->disks[i].target = virXPathString(\"string(./@target)\", ctxt))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Malformed disk target\"));\n                goto error;\n            }\n\n            capacity = virXPathString(\"string(./@capacity)\", ctxt);\n            if (!capacity ||\n                virStrToLong_ull(capacity, NULL, 10,\n                                 &ret->disks[i].capacity) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Malformed disk capacity: '%s'\"),\n                               NULLSTR(capacity));\n                goto error;\n            }\n        }\n    }\n\n cleanup:\n    VIR_FREE(port);\n    VIR_FREE(capacity);\n    VIR_FREE(disks);\n    return ret;\n error:\n    qemuMigrationCookieNBDFree(ret);\n    ret = NULL;\n    goto cleanup;\n}"
  },
  {
    "function_name": "qemuMigrationCookieNetworkXMLParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "933-978",
    "snippet": "static qemuMigrationCookieNetworkPtr\nqemuMigrationCookieNetworkXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuMigrationCookieNetworkPtr optr;\n    size_t i;\n    int n;\n    xmlNodePtr *interfaces = NULL;\n    char *vporttype;\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n\n    if (VIR_ALLOC(optr) < 0)\n        goto error;\n\n    if ((n = virXPathNodeSet(\"./network/interface\", ctxt, &interfaces)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing interface information\"));\n        goto error;\n    }\n\n    optr->nnets = n;\n    if (VIR_ALLOC_N(optr->net, optr->nnets) < 0)\n        goto error;\n\n    for (i = 0; i < n; i++) {\n        /* portdata is optional, and may not exist */\n        ctxt->node = interfaces[i];\n        optr->net[i].portdata = virXPathString(\"string(./portdata[1])\", ctxt);\n\n        if (!(vporttype = virXMLPropString(interfaces[i], \"vporttype\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"missing vporttype attribute in migration data\"));\n            goto error;\n        }\n        optr->net[i].vporttype = virNetDevVPortTypeFromString(vporttype);\n        VIR_FREE(vporttype);\n    }\n\n    VIR_FREE(interfaces);\n\n    return optr;\n\n error:\n    VIR_FREE(interfaces);\n    qemuMigrationCookieNetworkFree(optr);\n    return NULL;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMigrationCookieNetworkFree",
          "args": [
            "optr"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieNetworkFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "68-82",
          "snippet": "static void\nqemuMigrationCookieNetworkFree(qemuMigrationCookieNetworkPtr network)\n{\n    size_t i;\n\n    if (!network)\n        return;\n\n    if (network->net) {\n        for (i = 0; i < network->nnets; i++)\n            VIR_FREE(network->net[i].portdata);\n    }\n    VIR_FREE(network->net);\n    VIR_FREE(network);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieNetworkFree(qemuMigrationCookieNetworkPtr network)\n{\n    size_t i;\n\n    if (!network)\n        return;\n\n    if (network->net) {\n        for (i = 0; i < network->nnets; i++)\n            VIR_FREE(network->net[i].portdata);\n    }\n    VIR_FREE(network->net);\n    VIR_FREE(network);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "interfaces"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "interfaces"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vporttype"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortTypeFromString",
          "args": [
            "vporttype"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing vporttype attribute in migration data\")"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing vporttype attribute in migration data\""
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "interfaces[i]",
            "\"vporttype\""
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./portdata[1])\"",
            "ctxt"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "optr->net",
            "optr->nnets"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing interface information\")"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./network/interface\"",
            "ctxt",
            "&interfaces"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "optr"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_XPATH_NODE_AUTORESTORE",
          "args": [
            "ctxt"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic qemuMigrationCookieNetworkPtr\nqemuMigrationCookieNetworkXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuMigrationCookieNetworkPtr optr;\n    size_t i;\n    int n;\n    xmlNodePtr *interfaces = NULL;\n    char *vporttype;\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n\n    if (VIR_ALLOC(optr) < 0)\n        goto error;\n\n    if ((n = virXPathNodeSet(\"./network/interface\", ctxt, &interfaces)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing interface information\"));\n        goto error;\n    }\n\n    optr->nnets = n;\n    if (VIR_ALLOC_N(optr->net, optr->nnets) < 0)\n        goto error;\n\n    for (i = 0; i < n; i++) {\n        /* portdata is optional, and may not exist */\n        ctxt->node = interfaces[i];\n        optr->net[i].portdata = virXPathString(\"string(./portdata[1])\", ctxt);\n\n        if (!(vporttype = virXMLPropString(interfaces[i], \"vporttype\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"missing vporttype attribute in migration data\"));\n            goto error;\n        }\n        optr->net[i].vporttype = virNetDevVPortTypeFromString(vporttype);\n        VIR_FREE(vporttype);\n    }\n\n    VIR_FREE(interfaces);\n\n    return optr;\n\n error:\n    VIR_FREE(interfaces);\n    qemuMigrationCookieNetworkFree(optr);\n    return NULL;\n}"
  },
  {
    "function_name": "qemuMigrationCookieGraphicsXMLParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "884-930",
    "snippet": "static qemuMigrationCookieGraphicsPtr\nqemuMigrationCookieGraphicsXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuMigrationCookieGraphicsPtr grap;\n    char *tmp;\n\n    if (VIR_ALLOC(grap) < 0)\n        goto error;\n\n    if (!(tmp = virXPathString(\"string(./graphics/@type)\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing type attribute in migration data\"));\n        goto error;\n    }\n    if ((grap->type = virDomainGraphicsTypeFromString(tmp)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown graphics type %s\"), tmp);\n        VIR_FREE(tmp);\n        goto error;\n    }\n    VIR_FREE(tmp);\n    if (virXPathInt(\"string(./graphics/@port)\", ctxt, &grap->port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing port attribute in migration data\"));\n        goto error;\n    }\n    if (grap->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n        if (virXPathInt(\"string(./graphics/@tlsPort)\", ctxt, &grap->tlsPort) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"missing tlsPort attribute in migration data\"));\n            goto error;\n        }\n    }\n    if (!(grap->listen = virXPathString(\"string(./graphics/@listen)\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing listen attribute in migration data\"));\n        goto error;\n    }\n    /* Optional */\n    grap->tlsSubject = virXPathString(\"string(./graphics/cert[@info='subject']/@value)\", ctxt);\n\n    return grap;\n\n error:\n    qemuMigrationCookieGraphicsFree(grap);\n    return NULL;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMigrationCookieGraphicsFree",
          "args": [
            "grap"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieGraphicsFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "57-65",
          "snippet": "static void\nqemuMigrationCookieGraphicsFree(qemuMigrationCookieGraphicsPtr grap)\n{\n    if (!grap)\n        return;\n    VIR_FREE(grap->listen);\n    VIR_FREE(grap->tlsSubject);\n    VIR_FREE(grap);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieGraphicsFree(qemuMigrationCookieGraphicsPtr grap)\n{\n    if (!grap)\n        return;\n    VIR_FREE(grap->listen);\n    VIR_FREE(grap->tlsSubject);\n    VIR_FREE(grap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./graphics/cert[@info='subject']/@value)\"",
            "ctxt"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing listen attribute in migration data\")"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing listen attribute in migration data\""
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing tlsPort attribute in migration data\")"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathInt",
          "args": [
            "\"string(./graphics/@tlsPort)\"",
            "ctxt",
            "&grap->tlsPort"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "223-238",
          "snippet": "int\nvirXPathInt(const char *xpath,\n            xmlXPathContextPtr ctxt,\n            int *value)\n{\n    long tmp;\n    int ret;\n\n    ret = virXPathLongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathInt(const char *xpath,\n            xmlXPathContextPtr ctxt,\n            int *value)\n{\n    long tmp;\n    int ret;\n\n    ret = virXPathLongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing port attribute in migration data\")"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown graphics type %s\")",
            "tmp"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsTypeFromString",
          "args": [
            "tmp"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing type attribute in migration data\")"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "grap"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic qemuMigrationCookieGraphicsPtr\nqemuMigrationCookieGraphicsXMLParse(xmlXPathContextPtr ctxt)\n{\n    qemuMigrationCookieGraphicsPtr grap;\n    char *tmp;\n\n    if (VIR_ALLOC(grap) < 0)\n        goto error;\n\n    if (!(tmp = virXPathString(\"string(./graphics/@type)\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing type attribute in migration data\"));\n        goto error;\n    }\n    if ((grap->type = virDomainGraphicsTypeFromString(tmp)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown graphics type %s\"), tmp);\n        VIR_FREE(tmp);\n        goto error;\n    }\n    VIR_FREE(tmp);\n    if (virXPathInt(\"string(./graphics/@port)\", ctxt, &grap->port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing port attribute in migration data\"));\n        goto error;\n    }\n    if (grap->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n        if (virXPathInt(\"string(./graphics/@tlsPort)\", ctxt, &grap->tlsPort) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"missing tlsPort attribute in migration data\"));\n            goto error;\n        }\n    }\n    if (!(grap->listen = virXPathString(\"string(./graphics/@listen)\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing listen attribute in migration data\"));\n        goto error;\n    }\n    /* Optional */\n    grap->tlsSubject = virXPathString(\"string(./graphics/cert[@info='subject']/@value)\", ctxt);\n\n    return grap;\n\n error:\n    qemuMigrationCookieGraphicsFree(grap);\n    return NULL;\n}"
  },
  {
    "function_name": "qemuMigrationCookieXMLFormatStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "868-881",
    "snippet": "static char *\nqemuMigrationCookieXMLFormatStr(virQEMUDriverPtr driver,\n                                virQEMUCapsPtr qemuCaps,\n                                qemuMigrationCookiePtr mig)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (qemuMigrationCookieXMLFormat(driver, qemuCaps, &buf, mig) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieXMLFormat",
          "args": [
            "driver",
            "qemuCaps",
            "&buf",
            "mig"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieXMLFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "774-865",
          "snippet": "static int\nqemuMigrationCookieXMLFormat(virQEMUDriverPtr driver,\n                             virQEMUCapsPtr qemuCaps,\n                             virBufferPtr buf,\n                             qemuMigrationCookiePtr mig)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char hostuuidstr[VIR_UUID_STRING_BUFLEN];\n    size_t i;\n\n    virUUIDFormat(mig->uuid, uuidstr);\n    virUUIDFormat(mig->localHostuuid, hostuuidstr);\n\n    virBufferAddLit(buf, \"<qemu-migration>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", mig->name);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n    virBufferEscapeString(buf, \"<hostname>%s</hostname>\\n\", mig->localHostname);\n    virBufferAsprintf(buf, \"<hostuuid>%s</hostuuid>\\n\", hostuuidstr);\n\n    for (i = 0; i < QEMU_MIGRATION_COOKIE_FLAG_LAST; i++) {\n        if (mig->flagsMandatory & (1 << i))\n            virBufferAsprintf(buf, \"<feature name='%s'/>\\n\",\n                              qemuMigrationCookieFlagTypeToString(i));\n    }\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_GRAPHICS) &&\n        mig->graphics)\n        qemuMigrationCookieGraphicsXMLFormat(buf, mig->graphics);\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) &&\n        mig->lockState) {\n        virBufferAsprintf(buf, \"<lockstate driver='%s'>\\n\",\n                          mig->lockDriver);\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<leases>%s</leases>\\n\",\n                          mig->lockState);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</lockstate>\\n\");\n    }\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_PERSISTENT) &&\n        mig->persistent) {\n        if (qemuDomainDefFormatBuf(driver,\n                                   qemuCaps,\n                                   mig->persistent,\n                                   VIR_DOMAIN_XML_INACTIVE |\n                                   VIR_DOMAIN_XML_SECURE |\n                                   VIR_DOMAIN_XML_MIGRATABLE,\n                                   buf) < 0)\n            return -1;\n    }\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_NETWORK) && mig->network)\n        qemuMigrationCookieNetworkXMLFormat(buf, mig->network);\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_NBD) && mig->nbd) {\n        virBufferAddLit(buf, \"<nbd\");\n        if (mig->nbd->port)\n            virBufferAsprintf(buf, \" port='%d'\", mig->nbd->port);\n        if (mig->nbd->ndisks) {\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (i = 0; i < mig->nbd->ndisks; i++) {\n                virBufferEscapeString(buf, \"<disk target='%s'\",\n                                      mig->nbd->disks[i].target);\n                virBufferAsprintf(buf, \" capacity='%llu'/>\\n\",\n                                  mig->nbd->disks[i].capacity);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</nbd>\\n\");\n        } else {\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_STATS && mig->jobInfo)\n        qemuMigrationCookieStatisticsXMLFormat(buf, mig->jobInfo);\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_CPU && mig->cpu)\n        virCPUDefFormatBufFull(buf, mig->cpu, NULL);\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_ALLOW_REBOOT)\n        qemuDomainObjPrivateXMLFormatAllowReboot(buf, mig->allowReboot);\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_CAPS)\n        qemuMigrationCookieCapsXMLFormat(buf, mig->caps);\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</qemu-migration>\\n\");\n    return 0;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieXMLFormat(virQEMUDriverPtr driver,\n                             virQEMUCapsPtr qemuCaps,\n                             virBufferPtr buf,\n                             qemuMigrationCookiePtr mig)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char hostuuidstr[VIR_UUID_STRING_BUFLEN];\n    size_t i;\n\n    virUUIDFormat(mig->uuid, uuidstr);\n    virUUIDFormat(mig->localHostuuid, hostuuidstr);\n\n    virBufferAddLit(buf, \"<qemu-migration>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", mig->name);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n    virBufferEscapeString(buf, \"<hostname>%s</hostname>\\n\", mig->localHostname);\n    virBufferAsprintf(buf, \"<hostuuid>%s</hostuuid>\\n\", hostuuidstr);\n\n    for (i = 0; i < QEMU_MIGRATION_COOKIE_FLAG_LAST; i++) {\n        if (mig->flagsMandatory & (1 << i))\n            virBufferAsprintf(buf, \"<feature name='%s'/>\\n\",\n                              qemuMigrationCookieFlagTypeToString(i));\n    }\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_GRAPHICS) &&\n        mig->graphics)\n        qemuMigrationCookieGraphicsXMLFormat(buf, mig->graphics);\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) &&\n        mig->lockState) {\n        virBufferAsprintf(buf, \"<lockstate driver='%s'>\\n\",\n                          mig->lockDriver);\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<leases>%s</leases>\\n\",\n                          mig->lockState);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</lockstate>\\n\");\n    }\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_PERSISTENT) &&\n        mig->persistent) {\n        if (qemuDomainDefFormatBuf(driver,\n                                   qemuCaps,\n                                   mig->persistent,\n                                   VIR_DOMAIN_XML_INACTIVE |\n                                   VIR_DOMAIN_XML_SECURE |\n                                   VIR_DOMAIN_XML_MIGRATABLE,\n                                   buf) < 0)\n            return -1;\n    }\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_NETWORK) && mig->network)\n        qemuMigrationCookieNetworkXMLFormat(buf, mig->network);\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_NBD) && mig->nbd) {\n        virBufferAddLit(buf, \"<nbd\");\n        if (mig->nbd->port)\n            virBufferAsprintf(buf, \" port='%d'\", mig->nbd->port);\n        if (mig->nbd->ndisks) {\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (i = 0; i < mig->nbd->ndisks; i++) {\n                virBufferEscapeString(buf, \"<disk target='%s'\",\n                                      mig->nbd->disks[i].target);\n                virBufferAsprintf(buf, \" capacity='%llu'/>\\n\",\n                                  mig->nbd->disks[i].capacity);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</nbd>\\n\");\n        } else {\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_STATS && mig->jobInfo)\n        qemuMigrationCookieStatisticsXMLFormat(buf, mig->jobInfo);\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_CPU && mig->cpu)\n        virCPUDefFormatBufFull(buf, mig->cpu, NULL);\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_ALLOW_REBOOT)\n        qemuDomainObjPrivateXMLFormatAllowReboot(buf, mig->allowReboot);\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_CAPS)\n        qemuMigrationCookieCapsXMLFormat(buf, mig->caps);\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</qemu-migration>\\n\");\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic char *\nqemuMigrationCookieXMLFormatStr(virQEMUDriverPtr driver,\n                                virQEMUCapsPtr qemuCaps,\n                                qemuMigrationCookiePtr mig)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (qemuMigrationCookieXMLFormat(driver, qemuCaps, &buf, mig) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
  },
  {
    "function_name": "qemuMigrationCookieXMLFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "774-865",
    "snippet": "static int\nqemuMigrationCookieXMLFormat(virQEMUDriverPtr driver,\n                             virQEMUCapsPtr qemuCaps,\n                             virBufferPtr buf,\n                             qemuMigrationCookiePtr mig)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char hostuuidstr[VIR_UUID_STRING_BUFLEN];\n    size_t i;\n\n    virUUIDFormat(mig->uuid, uuidstr);\n    virUUIDFormat(mig->localHostuuid, hostuuidstr);\n\n    virBufferAddLit(buf, \"<qemu-migration>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", mig->name);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n    virBufferEscapeString(buf, \"<hostname>%s</hostname>\\n\", mig->localHostname);\n    virBufferAsprintf(buf, \"<hostuuid>%s</hostuuid>\\n\", hostuuidstr);\n\n    for (i = 0; i < QEMU_MIGRATION_COOKIE_FLAG_LAST; i++) {\n        if (mig->flagsMandatory & (1 << i))\n            virBufferAsprintf(buf, \"<feature name='%s'/>\\n\",\n                              qemuMigrationCookieFlagTypeToString(i));\n    }\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_GRAPHICS) &&\n        mig->graphics)\n        qemuMigrationCookieGraphicsXMLFormat(buf, mig->graphics);\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) &&\n        mig->lockState) {\n        virBufferAsprintf(buf, \"<lockstate driver='%s'>\\n\",\n                          mig->lockDriver);\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<leases>%s</leases>\\n\",\n                          mig->lockState);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</lockstate>\\n\");\n    }\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_PERSISTENT) &&\n        mig->persistent) {\n        if (qemuDomainDefFormatBuf(driver,\n                                   qemuCaps,\n                                   mig->persistent,\n                                   VIR_DOMAIN_XML_INACTIVE |\n                                   VIR_DOMAIN_XML_SECURE |\n                                   VIR_DOMAIN_XML_MIGRATABLE,\n                                   buf) < 0)\n            return -1;\n    }\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_NETWORK) && mig->network)\n        qemuMigrationCookieNetworkXMLFormat(buf, mig->network);\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_NBD) && mig->nbd) {\n        virBufferAddLit(buf, \"<nbd\");\n        if (mig->nbd->port)\n            virBufferAsprintf(buf, \" port='%d'\", mig->nbd->port);\n        if (mig->nbd->ndisks) {\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (i = 0; i < mig->nbd->ndisks; i++) {\n                virBufferEscapeString(buf, \"<disk target='%s'\",\n                                      mig->nbd->disks[i].target);\n                virBufferAsprintf(buf, \" capacity='%llu'/>\\n\",\n                                  mig->nbd->disks[i].capacity);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</nbd>\\n\");\n        } else {\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_STATS && mig->jobInfo)\n        qemuMigrationCookieStatisticsXMLFormat(buf, mig->jobInfo);\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_CPU && mig->cpu)\n        virCPUDefFormatBufFull(buf, mig->cpu, NULL);\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_ALLOW_REBOOT)\n        qemuDomainObjPrivateXMLFormatAllowReboot(buf, mig->allowReboot);\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_CAPS)\n        qemuMigrationCookieCapsXMLFormat(buf, mig->caps);\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</qemu-migration>\\n\");\n    return 0;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</qemu-migration>\\n\""
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieCapsXMLFormat",
          "args": [
            "buf",
            "mig->caps"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieCapsXMLFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "747-771",
          "snippet": "static void\nqemuMigrationCookieCapsXMLFormat(virBufferPtr buf,\n                                 qemuMigrationCookieCapsPtr caps)\n{\n    qemuMigrationCapability cap;\n\n    virBufferAddLit(buf, \"<capabilities>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (cap = 0; cap < QEMU_MIGRATION_CAP_LAST; cap++) {\n        bool supported = false;\n        bool automatic = false;\n\n        ignore_value(virBitmapGetBit(caps->supported, cap, &supported));\n        ignore_value(virBitmapGetBit(caps->automatic, cap, &automatic));\n        if (supported) {\n            virBufferAsprintf(buf, \"<cap name='%s' auto='%s'/>\\n\",\n                              qemuMigrationCapabilityTypeToString(cap),\n                              automatic ? \"yes\" : \"no\");\n        }\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</capabilities>\\n\");\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieCapsXMLFormat(virBufferPtr buf,\n                                 qemuMigrationCookieCapsPtr caps)\n{\n    qemuMigrationCapability cap;\n\n    virBufferAddLit(buf, \"<capabilities>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (cap = 0; cap < QEMU_MIGRATION_CAP_LAST; cap++) {\n        bool supported = false;\n        bool automatic = false;\n\n        ignore_value(virBitmapGetBit(caps->supported, cap, &supported));\n        ignore_value(virBitmapGetBit(caps->automatic, cap, &automatic));\n        if (supported) {\n            virBufferAsprintf(buf, \"<cap name='%s' auto='%s'/>\\n\",\n                              qemuMigrationCapabilityTypeToString(cap),\n                              automatic ? \"yes\" : \"no\");\n        }\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</capabilities>\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjPrivateXMLFormatAllowReboot",
          "args": [
            "buf",
            "mig->allowReboot"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjPrivateXMLFormatAllowReboot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "2785-2792",
          "snippet": "void\nqemuDomainObjPrivateXMLFormatAllowReboot(virBufferPtr buf,\n                                         virTristateBool allowReboot)\n{\n    virBufferAsprintf(buf, \"<allowReboot value='%s'/>\\n\",\n                      virTristateBoolTypeToString(allowReboot));\n\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nvoid\nqemuDomainObjPrivateXMLFormatAllowReboot(virBufferPtr buf,\n                                         virTristateBool allowReboot)\n{\n    virBufferAsprintf(buf, \"<allowReboot value='%s'/>\\n\",\n                      virTristateBoolTypeToString(allowReboot));\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefFormatBufFull",
          "args": [
            "buf",
            "mig->cpu",
            "NULL"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFormatBufFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "701-773",
          "snippet": "int\nvirCPUDefFormatBufFull(virBufferPtr buf,\n                       virCPUDefPtr def,\n                       virDomainNumaPtr numa)\n{\n    int ret = -1;\n    virBuffer attributeBuf = VIR_BUFFER_INITIALIZER;\n    virBuffer childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n\n    if (!def)\n        return 0;\n\n    /* Format attributes for guest CPUs unless they only specify\n     * topology or cache. */\n    if (def->type == VIR_CPU_TYPE_GUEST &&\n        (def->mode != VIR_CPU_MODE_CUSTOM || def->model)) {\n        const char *tmp;\n\n        if (!(tmp = virCPUModeTypeToString(def->mode))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unexpected CPU mode %d\"), def->mode);\n            goto cleanup;\n        }\n        virBufferAsprintf(&attributeBuf, \" mode='%s'\", tmp);\n\n        if (def->mode == VIR_CPU_MODE_CUSTOM) {\n            if (!(tmp = virCPUMatchTypeToString(def->match))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected CPU match policy %d\"),\n                               def->match);\n                goto cleanup;\n            }\n            virBufferAsprintf(&attributeBuf, \" match='%s'\", tmp);\n        }\n\n        if (def->check) {\n            virBufferAsprintf(&attributeBuf, \" check='%s'\",\n                              virCPUCheckTypeToString(def->check));\n        }\n    }\n\n    /* Format children */\n    if (def->type == VIR_CPU_TYPE_HOST && def->arch)\n        virBufferAsprintf(&childrenBuf, \"<arch>%s</arch>\\n\",\n                          virArchToString(def->arch));\n    if (virCPUDefFormatBuf(&childrenBuf, def) < 0)\n        goto cleanup;\n\n    if (virDomainNumaDefCPUFormatXML(&childrenBuf, numa) < 0)\n        goto cleanup;\n\n    /* Put it all together */\n    if (virBufferUse(&attributeBuf) || virBufferUse(&childrenBuf)) {\n        virBufferAddLit(buf, \"<cpu\");\n\n        if (virBufferUse(&attributeBuf))\n            virBufferAddBuffer(buf, &attributeBuf);\n\n        if (virBufferUse(&childrenBuf)) {\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAddBuffer(buf, &childrenBuf);\n            virBufferAddLit(buf, \"</cpu>\\n\");\n        } else {\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&attributeBuf);\n    virBufferFreeAndReset(&childrenBuf);\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefFormatBufFull(virBufferPtr buf,\n                       virCPUDefPtr def,\n                       virDomainNumaPtr numa)\n{\n    int ret = -1;\n    virBuffer attributeBuf = VIR_BUFFER_INITIALIZER;\n    virBuffer childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n\n    if (!def)\n        return 0;\n\n    /* Format attributes for guest CPUs unless they only specify\n     * topology or cache. */\n    if (def->type == VIR_CPU_TYPE_GUEST &&\n        (def->mode != VIR_CPU_MODE_CUSTOM || def->model)) {\n        const char *tmp;\n\n        if (!(tmp = virCPUModeTypeToString(def->mode))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unexpected CPU mode %d\"), def->mode);\n            goto cleanup;\n        }\n        virBufferAsprintf(&attributeBuf, \" mode='%s'\", tmp);\n\n        if (def->mode == VIR_CPU_MODE_CUSTOM) {\n            if (!(tmp = virCPUMatchTypeToString(def->match))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected CPU match policy %d\"),\n                               def->match);\n                goto cleanup;\n            }\n            virBufferAsprintf(&attributeBuf, \" match='%s'\", tmp);\n        }\n\n        if (def->check) {\n            virBufferAsprintf(&attributeBuf, \" check='%s'\",\n                              virCPUCheckTypeToString(def->check));\n        }\n    }\n\n    /* Format children */\n    if (def->type == VIR_CPU_TYPE_HOST && def->arch)\n        virBufferAsprintf(&childrenBuf, \"<arch>%s</arch>\\n\",\n                          virArchToString(def->arch));\n    if (virCPUDefFormatBuf(&childrenBuf, def) < 0)\n        goto cleanup;\n\n    if (virDomainNumaDefCPUFormatXML(&childrenBuf, numa) < 0)\n        goto cleanup;\n\n    /* Put it all together */\n    if (virBufferUse(&attributeBuf) || virBufferUse(&childrenBuf)) {\n        virBufferAddLit(buf, \"<cpu\");\n\n        if (virBufferUse(&attributeBuf))\n            virBufferAddBuffer(buf, &attributeBuf);\n\n        if (virBufferUse(&childrenBuf)) {\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAddBuffer(buf, &childrenBuf);\n            virBufferAddLit(buf, \"</cpu>\\n\");\n        } else {\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&attributeBuf);\n    virBufferFreeAndReset(&childrenBuf);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieStatisticsXMLFormat",
          "args": [
            "buf",
            "mig->jobInfo"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieStatisticsXMLFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "641-744",
          "snippet": "static void\nqemuMigrationCookieStatisticsXMLFormat(virBufferPtr buf,\n                                       qemuDomainJobInfoPtr jobInfo)\n{\n    qemuMonitorMigrationStats *stats = &jobInfo->stats.mig;\n\n    virBufferAddLit(buf, \"<statistics>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virBufferAsprintf(buf, \"<started>%llu</started>\\n\", jobInfo->started);\n    virBufferAsprintf(buf, \"<stopped>%llu</stopped>\\n\", jobInfo->stopped);\n    virBufferAsprintf(buf, \"<sent>%llu</sent>\\n\", jobInfo->sent);\n    if (jobInfo->timeDeltaSet)\n        virBufferAsprintf(buf, \"<delta>%lld</delta>\\n\", jobInfo->timeDelta);\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_TIME_ELAPSED,\n                      jobInfo->timeElapsed);\n    if (stats->downtime_set)\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_DOWNTIME,\n                          stats->downtime);\n    if (stats->setup_time_set)\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_SETUP_TIME,\n                          stats->setup_time);\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_TOTAL,\n                      stats->ram_total);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_PROCESSED,\n                      stats->ram_transferred);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_REMAINING,\n                      stats->ram_remaining);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_BPS,\n                      stats->ram_bps);\n\n    if (stats->ram_duplicate_set) {\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_MEMORY_CONSTANT,\n                          stats->ram_duplicate);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_MEMORY_NORMAL,\n                          stats->ram_normal);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES,\n                          stats->ram_normal_bytes);\n    }\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE,\n                      stats->ram_dirty_rate);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_ITERATION,\n                      stats->ram_iteration);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_POSTCOPY_REQS,\n                      stats->ram_postcopy_reqs);\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_PAGE_SIZE,\n                      stats->ram_page_size);\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_DISK_TOTAL,\n                      stats->disk_total);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_DISK_PROCESSED,\n                      stats->disk_transferred);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_DISK_REMAINING,\n                      stats->disk_remaining);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_DISK_BPS,\n                      stats->disk_bps);\n\n    if (stats->xbzrle_set) {\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_CACHE,\n                          stats->xbzrle_cache_size);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_BYTES,\n                          stats->xbzrle_bytes);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_PAGES,\n                          stats->xbzrle_pages);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES,\n                          stats->xbzrle_cache_miss);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW,\n                          stats->xbzrle_overflow);\n    }\n\n    virBufferAsprintf(buf, \"<%1$s>%2$d</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE,\n                      stats->cpu_throttle_percentage);\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</statistics>\\n\");\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieStatisticsXMLFormat(virBufferPtr buf,\n                                       qemuDomainJobInfoPtr jobInfo)\n{\n    qemuMonitorMigrationStats *stats = &jobInfo->stats.mig;\n\n    virBufferAddLit(buf, \"<statistics>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virBufferAsprintf(buf, \"<started>%llu</started>\\n\", jobInfo->started);\n    virBufferAsprintf(buf, \"<stopped>%llu</stopped>\\n\", jobInfo->stopped);\n    virBufferAsprintf(buf, \"<sent>%llu</sent>\\n\", jobInfo->sent);\n    if (jobInfo->timeDeltaSet)\n        virBufferAsprintf(buf, \"<delta>%lld</delta>\\n\", jobInfo->timeDelta);\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_TIME_ELAPSED,\n                      jobInfo->timeElapsed);\n    if (stats->downtime_set)\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_DOWNTIME,\n                          stats->downtime);\n    if (stats->setup_time_set)\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_SETUP_TIME,\n                          stats->setup_time);\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_TOTAL,\n                      stats->ram_total);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_PROCESSED,\n                      stats->ram_transferred);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_REMAINING,\n                      stats->ram_remaining);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_BPS,\n                      stats->ram_bps);\n\n    if (stats->ram_duplicate_set) {\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_MEMORY_CONSTANT,\n                          stats->ram_duplicate);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_MEMORY_NORMAL,\n                          stats->ram_normal);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES,\n                          stats->ram_normal_bytes);\n    }\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE,\n                      stats->ram_dirty_rate);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_ITERATION,\n                      stats->ram_iteration);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_POSTCOPY_REQS,\n                      stats->ram_postcopy_reqs);\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_PAGE_SIZE,\n                      stats->ram_page_size);\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_DISK_TOTAL,\n                      stats->disk_total);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_DISK_PROCESSED,\n                      stats->disk_transferred);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_DISK_REMAINING,\n                      stats->disk_remaining);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_DISK_BPS,\n                      stats->disk_bps);\n\n    if (stats->xbzrle_set) {\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_CACHE,\n                          stats->xbzrle_cache_size);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_BYTES,\n                          stats->xbzrle_bytes);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_PAGES,\n                          stats->xbzrle_pages);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES,\n                          stats->xbzrle_cache_miss);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW,\n                          stats->xbzrle_overflow);\n    }\n\n    virBufferAsprintf(buf, \"<%1$s>%2$d</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE,\n                      stats->cpu_throttle_percentage);\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</statistics>\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</nbd>\\n\""
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\" capacity='%llu'/>\\n\"",
            "mig->nbd->disks[i].capacity"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<disk target='%s'\"",
            "mig->nbd->disks[i].target"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\">\\n\""
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<nbd\""
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieNetworkXMLFormat",
          "args": [
            "buf",
            "mig->network"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieNetworkXMLFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "605-638",
          "snippet": "static void\nqemuMigrationCookieNetworkXMLFormat(virBufferPtr buf,\n                                    qemuMigrationCookieNetworkPtr optr)\n{\n    size_t i;\n    bool empty = true;\n\n    for (i = 0; i < optr->nnets; i++) {\n        /* If optr->net[i].vporttype is not set, there is nothing to transfer */\n        if (optr->net[i].vporttype != VIR_NETDEV_VPORT_PROFILE_NONE) {\n            if (empty) {\n                virBufferAddLit(buf, \"<network>\\n\");\n                virBufferAdjustIndent(buf, 2);\n                empty = false;\n            }\n            virBufferAsprintf(buf, \"<interface index='%zu' vporttype='%s'\",\n                              i, virNetDevVPortTypeToString(optr->net[i].vporttype));\n            if (optr->net[i].portdata) {\n                virBufferAddLit(buf, \">\\n\");\n                virBufferAdjustIndent(buf, 2);\n                virBufferEscapeString(buf, \"<portdata>%s</portdata>\\n\",\n                                      optr->net[i].portdata);\n                virBufferAdjustIndent(buf, -2);\n                virBufferAddLit(buf, \"</interface>\\n\");\n            } else {\n                virBufferAddLit(buf, \"/>\\n\");\n            }\n        }\n    }\n    if (!empty) {\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</network>\\n\");\n    }\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieNetworkXMLFormat(virBufferPtr buf,\n                                    qemuMigrationCookieNetworkPtr optr)\n{\n    size_t i;\n    bool empty = true;\n\n    for (i = 0; i < optr->nnets; i++) {\n        /* If optr->net[i].vporttype is not set, there is nothing to transfer */\n        if (optr->net[i].vporttype != VIR_NETDEV_VPORT_PROFILE_NONE) {\n            if (empty) {\n                virBufferAddLit(buf, \"<network>\\n\");\n                virBufferAdjustIndent(buf, 2);\n                empty = false;\n            }\n            virBufferAsprintf(buf, \"<interface index='%zu' vporttype='%s'\",\n                              i, virNetDevVPortTypeToString(optr->net[i].vporttype));\n            if (optr->net[i].portdata) {\n                virBufferAddLit(buf, \">\\n\");\n                virBufferAdjustIndent(buf, 2);\n                virBufferEscapeString(buf, \"<portdata>%s</portdata>\\n\",\n                                      optr->net[i].portdata);\n                virBufferAdjustIndent(buf, -2);\n                virBufferAddLit(buf, \"</interface>\\n\");\n            } else {\n                virBufferAddLit(buf, \"/>\\n\");\n            }\n        }\n    }\n    if (!empty) {\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</network>\\n\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainDefFormatBuf",
          "args": [
            "driver",
            "qemuCaps",
            "mig->persistent",
            "VIR_DOMAIN_XML_INACTIVE |\n                                   VIR_DOMAIN_XML_SECURE |\n                                   VIR_DOMAIN_XML_MIGRATABLE",
            "buf"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainDefFormatBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10538-10546",
          "snippet": "int\nqemuDomainDefFormatBuf(virQEMUDriverPtr driver,\n                       virQEMUCapsPtr qemuCaps,\n                       virDomainDefPtr def,\n                       unsigned int flags,\n                       virBufferPtr buf)\n{\n    return qemuDomainDefFormatBufInternal(driver, qemuCaps, def, NULL, flags, buf);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainDefFormatBuf(virQEMUDriverPtr driver,\n                       virQEMUCapsPtr qemuCaps,\n                       virDomainDefPtr def,\n                       unsigned int flags,\n                       virBufferPtr buf)\n{\n    return qemuDomainDefFormatBufInternal(driver, qemuCaps, def, NULL, flags, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</lockstate>\\n\""
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieGraphicsXMLFormat",
          "args": [
            "buf",
            "mig->graphics"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieGraphicsXMLFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "584-602",
          "snippet": "static void\nqemuMigrationCookieGraphicsXMLFormat(virBufferPtr buf,\n                                     qemuMigrationCookieGraphicsPtr grap)\n{\n    virBufferAsprintf(buf, \"<graphics type='%s' port='%d' listen='%s'\",\n                      virDomainGraphicsTypeToString(grap->type),\n                      grap->port, grap->listen);\n    if (grap->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE)\n        virBufferAsprintf(buf, \" tlsPort='%d'\", grap->tlsPort);\n    if (grap->tlsSubject) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferEscapeString(buf, \"<cert info='subject' value='%s'/>\\n\", grap->tlsSubject);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</graphics>\\n\");\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieGraphicsXMLFormat(virBufferPtr buf,\n                                     qemuMigrationCookieGraphicsPtr grap)\n{\n    virBufferAsprintf(buf, \"<graphics type='%s' port='%d' listen='%s'\",\n                      virDomainGraphicsTypeToString(grap->type),\n                      grap->port, grap->listen);\n    if (grap->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE)\n        virBufferAsprintf(buf, \" tlsPort='%d'\", grap->tlsPort);\n    if (grap->tlsSubject) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferEscapeString(buf, \"<cert info='subject' value='%s'/>\\n\", grap->tlsSubject);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</graphics>\\n\");\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieFlagTypeToString",
          "args": [
            "i"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<qemu-migration>\\n\""
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "mig->localHostuuid",
            "hostuuidstr"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieXMLFormat(virQEMUDriverPtr driver,\n                             virQEMUCapsPtr qemuCaps,\n                             virBufferPtr buf,\n                             qemuMigrationCookiePtr mig)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char hostuuidstr[VIR_UUID_STRING_BUFLEN];\n    size_t i;\n\n    virUUIDFormat(mig->uuid, uuidstr);\n    virUUIDFormat(mig->localHostuuid, hostuuidstr);\n\n    virBufferAddLit(buf, \"<qemu-migration>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", mig->name);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n    virBufferEscapeString(buf, \"<hostname>%s</hostname>\\n\", mig->localHostname);\n    virBufferAsprintf(buf, \"<hostuuid>%s</hostuuid>\\n\", hostuuidstr);\n\n    for (i = 0; i < QEMU_MIGRATION_COOKIE_FLAG_LAST; i++) {\n        if (mig->flagsMandatory & (1 << i))\n            virBufferAsprintf(buf, \"<feature name='%s'/>\\n\",\n                              qemuMigrationCookieFlagTypeToString(i));\n    }\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_GRAPHICS) &&\n        mig->graphics)\n        qemuMigrationCookieGraphicsXMLFormat(buf, mig->graphics);\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) &&\n        mig->lockState) {\n        virBufferAsprintf(buf, \"<lockstate driver='%s'>\\n\",\n                          mig->lockDriver);\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<leases>%s</leases>\\n\",\n                          mig->lockState);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</lockstate>\\n\");\n    }\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_PERSISTENT) &&\n        mig->persistent) {\n        if (qemuDomainDefFormatBuf(driver,\n                                   qemuCaps,\n                                   mig->persistent,\n                                   VIR_DOMAIN_XML_INACTIVE |\n                                   VIR_DOMAIN_XML_SECURE |\n                                   VIR_DOMAIN_XML_MIGRATABLE,\n                                   buf) < 0)\n            return -1;\n    }\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_NETWORK) && mig->network)\n        qemuMigrationCookieNetworkXMLFormat(buf, mig->network);\n\n    if ((mig->flags & QEMU_MIGRATION_COOKIE_NBD) && mig->nbd) {\n        virBufferAddLit(buf, \"<nbd\");\n        if (mig->nbd->port)\n            virBufferAsprintf(buf, \" port='%d'\", mig->nbd->port);\n        if (mig->nbd->ndisks) {\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (i = 0; i < mig->nbd->ndisks; i++) {\n                virBufferEscapeString(buf, \"<disk target='%s'\",\n                                      mig->nbd->disks[i].target);\n                virBufferAsprintf(buf, \" capacity='%llu'/>\\n\",\n                                  mig->nbd->disks[i].capacity);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</nbd>\\n\");\n        } else {\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_STATS && mig->jobInfo)\n        qemuMigrationCookieStatisticsXMLFormat(buf, mig->jobInfo);\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_CPU && mig->cpu)\n        virCPUDefFormatBufFull(buf, mig->cpu, NULL);\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_ALLOW_REBOOT)\n        qemuDomainObjPrivateXMLFormatAllowReboot(buf, mig->allowReboot);\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_CAPS)\n        qemuMigrationCookieCapsXMLFormat(buf, mig->caps);\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</qemu-migration>\\n\");\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationCookieCapsXMLFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "747-771",
    "snippet": "static void\nqemuMigrationCookieCapsXMLFormat(virBufferPtr buf,\n                                 qemuMigrationCookieCapsPtr caps)\n{\n    qemuMigrationCapability cap;\n\n    virBufferAddLit(buf, \"<capabilities>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (cap = 0; cap < QEMU_MIGRATION_CAP_LAST; cap++) {\n        bool supported = false;\n        bool automatic = false;\n\n        ignore_value(virBitmapGetBit(caps->supported, cap, &supported));\n        ignore_value(virBitmapGetBit(caps->automatic, cap, &automatic));\n        if (supported) {\n            virBufferAsprintf(buf, \"<cap name='%s' auto='%s'/>\\n\",\n                              qemuMigrationCapabilityTypeToString(cap),\n                              automatic ? \"yes\" : \"no\");\n        }\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</capabilities>\\n\");\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</capabilities>\\n\""
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<cap name='%s' auto='%s'/>\\n\"",
            "qemuMigrationCapabilityTypeToString(cap)",
            "automatic ? \"yes\" : \"no\""
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCapabilityTypeToString",
          "args": [
            "cap"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapGetBit(caps->automatic, cap, &automatic)"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapGetBit",
          "args": [
            "caps->automatic",
            "cap",
            "&automatic"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapGetBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "320-330",
          "snippet": "int\nvirBitmapGetBit(virBitmapPtr bitmap,\n                size_t b,\n                bool *result)\n{\n    if (bitmap->nbits <= b)\n        return -1;\n\n    *result = virBitmapIsSet(bitmap, b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapGetBit(virBitmapPtr bitmap,\n                size_t b,\n                bool *result)\n{\n    if (bitmap->nbits <= b)\n        return -1;\n\n    *result = virBitmapIsSet(bitmap, b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapGetBit(caps->supported, cap, &supported)"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<capabilities>\\n\""
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieCapsXMLFormat(virBufferPtr buf,\n                                 qemuMigrationCookieCapsPtr caps)\n{\n    qemuMigrationCapability cap;\n\n    virBufferAddLit(buf, \"<capabilities>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (cap = 0; cap < QEMU_MIGRATION_CAP_LAST; cap++) {\n        bool supported = false;\n        bool automatic = false;\n\n        ignore_value(virBitmapGetBit(caps->supported, cap, &supported));\n        ignore_value(virBitmapGetBit(caps->automatic, cap, &automatic));\n        if (supported) {\n            virBufferAsprintf(buf, \"<cap name='%s' auto='%s'/>\\n\",\n                              qemuMigrationCapabilityTypeToString(cap),\n                              automatic ? \"yes\" : \"no\");\n        }\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</capabilities>\\n\");\n}"
  },
  {
    "function_name": "qemuMigrationCookieStatisticsXMLFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "641-744",
    "snippet": "static void\nqemuMigrationCookieStatisticsXMLFormat(virBufferPtr buf,\n                                       qemuDomainJobInfoPtr jobInfo)\n{\n    qemuMonitorMigrationStats *stats = &jobInfo->stats.mig;\n\n    virBufferAddLit(buf, \"<statistics>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virBufferAsprintf(buf, \"<started>%llu</started>\\n\", jobInfo->started);\n    virBufferAsprintf(buf, \"<stopped>%llu</stopped>\\n\", jobInfo->stopped);\n    virBufferAsprintf(buf, \"<sent>%llu</sent>\\n\", jobInfo->sent);\n    if (jobInfo->timeDeltaSet)\n        virBufferAsprintf(buf, \"<delta>%lld</delta>\\n\", jobInfo->timeDelta);\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_TIME_ELAPSED,\n                      jobInfo->timeElapsed);\n    if (stats->downtime_set)\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_DOWNTIME,\n                          stats->downtime);\n    if (stats->setup_time_set)\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_SETUP_TIME,\n                          stats->setup_time);\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_TOTAL,\n                      stats->ram_total);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_PROCESSED,\n                      stats->ram_transferred);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_REMAINING,\n                      stats->ram_remaining);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_BPS,\n                      stats->ram_bps);\n\n    if (stats->ram_duplicate_set) {\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_MEMORY_CONSTANT,\n                          stats->ram_duplicate);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_MEMORY_NORMAL,\n                          stats->ram_normal);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES,\n                          stats->ram_normal_bytes);\n    }\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE,\n                      stats->ram_dirty_rate);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_ITERATION,\n                      stats->ram_iteration);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_POSTCOPY_REQS,\n                      stats->ram_postcopy_reqs);\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_PAGE_SIZE,\n                      stats->ram_page_size);\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_DISK_TOTAL,\n                      stats->disk_total);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_DISK_PROCESSED,\n                      stats->disk_transferred);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_DISK_REMAINING,\n                      stats->disk_remaining);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_DISK_BPS,\n                      stats->disk_bps);\n\n    if (stats->xbzrle_set) {\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_CACHE,\n                          stats->xbzrle_cache_size);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_BYTES,\n                          stats->xbzrle_bytes);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_PAGES,\n                          stats->xbzrle_pages);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES,\n                          stats->xbzrle_cache_miss);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW,\n                          stats->xbzrle_overflow);\n    }\n\n    virBufferAsprintf(buf, \"<%1$s>%2$d</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE,\n                      stats->cpu_throttle_percentage);\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</statistics>\\n\");\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</statistics>\\n\""
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<%1$s>%2$d</%1$s>\\n\"",
            "VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE",
            "stats->cpu_throttle_percentage"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<statistics>\\n\""
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieStatisticsXMLFormat(virBufferPtr buf,\n                                       qemuDomainJobInfoPtr jobInfo)\n{\n    qemuMonitorMigrationStats *stats = &jobInfo->stats.mig;\n\n    virBufferAddLit(buf, \"<statistics>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virBufferAsprintf(buf, \"<started>%llu</started>\\n\", jobInfo->started);\n    virBufferAsprintf(buf, \"<stopped>%llu</stopped>\\n\", jobInfo->stopped);\n    virBufferAsprintf(buf, \"<sent>%llu</sent>\\n\", jobInfo->sent);\n    if (jobInfo->timeDeltaSet)\n        virBufferAsprintf(buf, \"<delta>%lld</delta>\\n\", jobInfo->timeDelta);\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_TIME_ELAPSED,\n                      jobInfo->timeElapsed);\n    if (stats->downtime_set)\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_DOWNTIME,\n                          stats->downtime);\n    if (stats->setup_time_set)\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_SETUP_TIME,\n                          stats->setup_time);\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_TOTAL,\n                      stats->ram_total);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_PROCESSED,\n                      stats->ram_transferred);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_REMAINING,\n                      stats->ram_remaining);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_BPS,\n                      stats->ram_bps);\n\n    if (stats->ram_duplicate_set) {\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_MEMORY_CONSTANT,\n                          stats->ram_duplicate);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_MEMORY_NORMAL,\n                          stats->ram_normal);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES,\n                          stats->ram_normal_bytes);\n    }\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE,\n                      stats->ram_dirty_rate);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_ITERATION,\n                      stats->ram_iteration);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_POSTCOPY_REQS,\n                      stats->ram_postcopy_reqs);\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_MEMORY_PAGE_SIZE,\n                      stats->ram_page_size);\n\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_DISK_TOTAL,\n                      stats->disk_total);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_DISK_PROCESSED,\n                      stats->disk_transferred);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_DISK_REMAINING,\n                      stats->disk_remaining);\n    virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_DISK_BPS,\n                      stats->disk_bps);\n\n    if (stats->xbzrle_set) {\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_CACHE,\n                          stats->xbzrle_cache_size);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_BYTES,\n                          stats->xbzrle_bytes);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_PAGES,\n                          stats->xbzrle_pages);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES,\n                          stats->xbzrle_cache_miss);\n        virBufferAsprintf(buf, \"<%1$s>%2$llu</%1$s>\\n\",\n                          VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW,\n                          stats->xbzrle_overflow);\n    }\n\n    virBufferAsprintf(buf, \"<%1$s>%2$d</%1$s>\\n\",\n                      VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE,\n                      stats->cpu_throttle_percentage);\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</statistics>\\n\");\n}"
  },
  {
    "function_name": "qemuMigrationCookieNetworkXMLFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "605-638",
    "snippet": "static void\nqemuMigrationCookieNetworkXMLFormat(virBufferPtr buf,\n                                    qemuMigrationCookieNetworkPtr optr)\n{\n    size_t i;\n    bool empty = true;\n\n    for (i = 0; i < optr->nnets; i++) {\n        /* If optr->net[i].vporttype is not set, there is nothing to transfer */\n        if (optr->net[i].vporttype != VIR_NETDEV_VPORT_PROFILE_NONE) {\n            if (empty) {\n                virBufferAddLit(buf, \"<network>\\n\");\n                virBufferAdjustIndent(buf, 2);\n                empty = false;\n            }\n            virBufferAsprintf(buf, \"<interface index='%zu' vporttype='%s'\",\n                              i, virNetDevVPortTypeToString(optr->net[i].vporttype));\n            if (optr->net[i].portdata) {\n                virBufferAddLit(buf, \">\\n\");\n                virBufferAdjustIndent(buf, 2);\n                virBufferEscapeString(buf, \"<portdata>%s</portdata>\\n\",\n                                      optr->net[i].portdata);\n                virBufferAdjustIndent(buf, -2);\n                virBufferAddLit(buf, \"</interface>\\n\");\n            } else {\n                virBufferAddLit(buf, \"/>\\n\");\n            }\n        }\n    }\n    if (!empty) {\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</network>\\n\");\n    }\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</network>\\n\""
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</interface>\\n\""
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<portdata>%s</portdata>\\n\"",
            "optr->net[i].portdata"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\">\\n\""
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<interface index='%zu' vporttype='%s'\"",
            "i",
            "virNetDevVPortTypeToString(optr->net[i].vporttype)"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVPortTypeToString",
          "args": [
            "optr->net[i].vporttype"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<network>\\n\""
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieNetworkXMLFormat(virBufferPtr buf,\n                                    qemuMigrationCookieNetworkPtr optr)\n{\n    size_t i;\n    bool empty = true;\n\n    for (i = 0; i < optr->nnets; i++) {\n        /* If optr->net[i].vporttype is not set, there is nothing to transfer */\n        if (optr->net[i].vporttype != VIR_NETDEV_VPORT_PROFILE_NONE) {\n            if (empty) {\n                virBufferAddLit(buf, \"<network>\\n\");\n                virBufferAdjustIndent(buf, 2);\n                empty = false;\n            }\n            virBufferAsprintf(buf, \"<interface index='%zu' vporttype='%s'\",\n                              i, virNetDevVPortTypeToString(optr->net[i].vporttype));\n            if (optr->net[i].portdata) {\n                virBufferAddLit(buf, \">\\n\");\n                virBufferAdjustIndent(buf, 2);\n                virBufferEscapeString(buf, \"<portdata>%s</portdata>\\n\",\n                                      optr->net[i].portdata);\n                virBufferAdjustIndent(buf, -2);\n                virBufferAddLit(buf, \"</interface>\\n\");\n            } else {\n                virBufferAddLit(buf, \"/>\\n\");\n            }\n        }\n    }\n    if (!empty) {\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</network>\\n\");\n    }\n}"
  },
  {
    "function_name": "qemuMigrationCookieGraphicsXMLFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "584-602",
    "snippet": "static void\nqemuMigrationCookieGraphicsXMLFormat(virBufferPtr buf,\n                                     qemuMigrationCookieGraphicsPtr grap)\n{\n    virBufferAsprintf(buf, \"<graphics type='%s' port='%d' listen='%s'\",\n                      virDomainGraphicsTypeToString(grap->type),\n                      grap->port, grap->listen);\n    if (grap->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE)\n        virBufferAsprintf(buf, \" tlsPort='%d'\", grap->tlsPort);\n    if (grap->tlsSubject) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferEscapeString(buf, \"<cert info='subject' value='%s'/>\\n\", grap->tlsSubject);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</graphics>\\n\");\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</graphics>\\n\""
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<cert info='subject' value='%s'/>\\n\"",
            "grap->tlsSubject"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\">\\n\""
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\" tlsPort='%d'\"",
            "grap->tlsPort"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsTypeToString",
          "args": [
            "grap->type"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieGraphicsXMLFormat(virBufferPtr buf,\n                                     qemuMigrationCookieGraphicsPtr grap)\n{\n    virBufferAsprintf(buf, \"<graphics type='%s' port='%d' listen='%s'\",\n                      virDomainGraphicsTypeToString(grap->type),\n                      grap->port, grap->listen);\n    if (grap->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE)\n        virBufferAsprintf(buf, \" tlsPort='%d'\", grap->tlsPort);\n    if (grap->tlsSubject) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferEscapeString(buf, \"<cert info='subject' value='%s'/>\\n\", grap->tlsSubject);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</graphics>\\n\");\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n}"
  },
  {
    "function_name": "qemuMigrationCookieAddCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "557-581",
    "snippet": "static int\nqemuMigrationCookieAddCaps(qemuMigrationCookiePtr mig,\n                           virDomainObjPtr vm,\n                           qemuMigrationParty party)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    qemuMigrationCookieCapsFree(mig->caps);\n    if (VIR_ALLOC(mig->caps) < 0)\n        return -1;\n\n    if (priv->migrationCaps)\n        mig->caps->supported = virBitmapNewCopy(priv->migrationCaps);\n    else\n        mig->caps->supported = virBitmapNew(0);\n\n    mig->caps->automatic = qemuMigrationParamsGetAlwaysOnCaps(party);\n\n    if (!mig->caps->supported || !mig->caps->automatic)\n        return -1;\n\n    mig->flags |= QEMU_MIGRATION_COOKIE_CAPS;\n\n    return 0;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMigrationParamsGetAlwaysOnCaps",
          "args": [
            "party"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationParamsGetAlwaysOnCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_params.c",
          "lines": "224-241",
          "snippet": "virBitmapPtr\nqemuMigrationParamsGetAlwaysOnCaps(qemuMigrationParty party)\n{\n    virBitmapPtr caps = NULL;\n    size_t i;\n\n    if (!(caps = virBitmapNew(QEMU_MIGRATION_CAP_LAST)))\n        return NULL;\n\n    for (i = 0; i < G_N_ELEMENTS(qemuMigrationParamsAlwaysOn); i++) {\n        if (!(qemuMigrationParamsAlwaysOn[i].party & party))\n            continue;\n\n        ignore_value(virBitmapSetBit(caps, qemuMigrationParamsAlwaysOn[i].cap));\n    }\n\n    return caps;\n}",
          "includes": [
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_paramspriv.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const qemuMigrationParamsAlwaysOnItem qemuMigrationParamsAlwaysOn[] = {\n    {QEMU_MIGRATION_CAP_PAUSE_BEFORE_SWITCHOVER,\n     QEMU_MIGRATION_SOURCE},\n\n    {QEMU_MIGRATION_CAP_LATE_BLOCK_ACTIVATE,\n     QEMU_MIGRATION_DESTINATION},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor.h\"\n#include \"qemu_migration_paramspriv.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_alias.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic const qemuMigrationParamsAlwaysOnItem qemuMigrationParamsAlwaysOn[] = {\n    {QEMU_MIGRATION_CAP_PAUSE_BEFORE_SWITCHOVER,\n     QEMU_MIGRATION_SOURCE},\n\n    {QEMU_MIGRATION_CAP_LATE_BLOCK_ACTIVATE,\n     QEMU_MIGRATION_DESTINATION},\n};\n\nvirBitmapPtr\nqemuMigrationParamsGetAlwaysOnCaps(qemuMigrationParty party)\n{\n    virBitmapPtr caps = NULL;\n    size_t i;\n\n    if (!(caps = virBitmapNew(QEMU_MIGRATION_CAP_LAST)))\n        return NULL;\n\n    for (i = 0; i < G_N_ELEMENTS(qemuMigrationParamsAlwaysOn); i++) {\n        if (!(qemuMigrationParamsAlwaysOn[i].party & party))\n            continue;\n\n        ignore_value(virBitmapSetBit(caps, qemuMigrationParamsAlwaysOn[i].cap));\n    }\n\n    return caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "0"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNewCopy",
          "args": [
            "priv->migrationCaps"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "707-721",
          "snippet": "virBitmapPtr\nvirBitmapNewCopy(virBitmapPtr src)\n{\n    virBitmapPtr dst;\n\n    if ((dst = virBitmapNew(src->nbits)) == NULL)\n        return NULL;\n\n    if (virBitmapCopy(dst, src) != 0) {\n        virBitmapFree(dst);\n        return NULL;\n    }\n\n    return dst;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewCopy(virBitmapPtr src)\n{\n    virBitmapPtr dst;\n\n    if ((dst = virBitmapNew(src->nbits)) == NULL)\n        return NULL;\n\n    if (virBitmapCopy(dst, src) != 0) {\n        virBitmapFree(dst);\n        return NULL;\n    }\n\n    return dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "mig->caps"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieCapsFree",
          "args": [
            "mig->caps"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieCapsFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "98-107",
          "snippet": "static void\nqemuMigrationCookieCapsFree(qemuMigrationCookieCapsPtr caps)\n{\n    if (!caps)\n        return;\n\n    virBitmapFree(caps->supported);\n    virBitmapFree(caps->automatic);\n    VIR_FREE(caps);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieCapsFree(qemuMigrationCookieCapsPtr caps)\n{\n    if (!caps)\n        return;\n\n    virBitmapFree(caps->supported);\n    virBitmapFree(caps->automatic);\n    VIR_FREE(caps);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieAddCaps(qemuMigrationCookiePtr mig,\n                           virDomainObjPtr vm,\n                           qemuMigrationParty party)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    qemuMigrationCookieCapsFree(mig->caps);\n    if (VIR_ALLOC(mig->caps) < 0)\n        return -1;\n\n    if (priv->migrationCaps)\n        mig->caps->supported = virBitmapNewCopy(priv->migrationCaps);\n    else\n        mig->caps->supported = virBitmapNew(0);\n\n    mig->caps->automatic = qemuMigrationParamsGetAlwaysOnCaps(party);\n\n    if (!mig->caps->supported || !mig->caps->automatic)\n        return -1;\n\n    mig->flags |= QEMU_MIGRATION_COOKIE_CAPS;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationCookieAddAllowReboot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "545-554",
    "snippet": "static void\nqemuMigrationCookieAddAllowReboot(qemuMigrationCookiePtr mig,\n                                  virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    mig->allowReboot = priv->allowReboot;\n\n    mig->flags |= QEMU_MIGRATION_COOKIE_ALLOW_REBOOT;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieAddAllowReboot(qemuMigrationCookiePtr mig,\n                                  virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    mig->allowReboot = priv->allowReboot;\n\n    mig->flags |= QEMU_MIGRATION_COOKIE_ALLOW_REBOOT;\n}"
  },
  {
    "function_name": "qemuMigrationCookieAddCPU",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "526-542",
    "snippet": "static int\nqemuMigrationCookieAddCPU(qemuMigrationCookiePtr mig,\n                          virDomainObjPtr vm)\n{\n    if (mig->cpu)\n        return 0;\n\n    if (!(mig->cpu = virCPUDefCopy(vm->def->cpu)))\n        return -1;\n\n    if (qemuDomainMakeCPUMigratable(mig->cpu) < 0)\n        return -1;\n\n    mig->flags |= QEMU_MIGRATION_COOKIE_CPU;\n\n    return 0;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainMakeCPUMigratable",
          "args": [
            "mig->cpu"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainMakeCPUMigratable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10326-10343",
          "snippet": "int\nqemuDomainMakeCPUMigratable(virCPUDefPtr cpu)\n{\n    if (cpu->mode == VIR_CPU_MODE_CUSTOM &&\n        STREQ_NULLABLE(cpu->model, \"Icelake-Server\")) {\n        /* Originally Icelake-Server CPU model contained pconfig CPU feature.\n         * It was never actually enabled and thus it was removed. To enable\n         * migration to QEMU 3.1.0 (with both new and old libvirt), we\n         * explicitly disable pconfig in migration XML (otherwise old libvirt\n         * would think it was implicitly enabled on the source). New libvirt\n         * will drop it from the XML before starting the domain on new QEMU.\n         */\n        if (virCPUDefUpdateFeature(cpu, \"pconfig\", VIR_CPU_FEATURE_DISABLE) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainMakeCPUMigratable(virCPUDefPtr cpu)\n{\n    if (cpu->mode == VIR_CPU_MODE_CUSTOM &&\n        STREQ_NULLABLE(cpu->model, \"Icelake-Server\")) {\n        /* Originally Icelake-Server CPU model contained pconfig CPU feature.\n         * It was never actually enabled and thus it was removed. To enable\n         * migration to QEMU 3.1.0 (with both new and old libvirt), we\n         * explicitly disable pconfig in migration XML (otherwise old libvirt\n         * would think it was implicitly enabled on the source). New libvirt\n         * will drop it from the XML before starting the domain on new QEMU.\n         */\n        if (virCPUDefUpdateFeature(cpu, \"pconfig\", VIR_CPU_FEATURE_DISABLE) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefCopy",
          "args": [
            "vm->def->cpu"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "269-285",
          "snippet": "virCPUDefPtr\nvirCPUDefCopy(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!(copy = virCPUDefCopyWithoutModel(cpu)))\n        return NULL;\n\n    if (virCPUDefCopyModel(copy, cpu, false) < 0)\n        goto error;\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUDefCopy(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!(copy = virCPUDefCopyWithoutModel(cpu)))\n        return NULL;\n\n    if (virCPUDefCopyModel(copy, cpu, false) < 0)\n        goto error;\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieAddCPU(qemuMigrationCookiePtr mig,\n                          virDomainObjPtr vm)\n{\n    if (mig->cpu)\n        return 0;\n\n    if (!(mig->cpu = virCPUDefCopy(vm->def->cpu)))\n        return -1;\n\n    if (qemuDomainMakeCPUMigratable(mig->cpu) < 0)\n        return -1;\n\n    mig->flags |= QEMU_MIGRATION_COOKIE_CPU;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationCookieAddStatistics",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "507-523",
    "snippet": "static int\nqemuMigrationCookieAddStatistics(qemuMigrationCookiePtr mig,\n                                 virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!priv->job.completed)\n        return 0;\n\n    if (!mig->jobInfo && VIR_ALLOC(mig->jobInfo) < 0)\n        return -1;\n\n    *mig->jobInfo = *priv->job.completed;\n    mig->flags |= QEMU_MIGRATION_COOKIE_STATS;\n\n    return 0;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "mig->jobInfo"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieAddStatistics(qemuMigrationCookiePtr mig,\n                                 virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!priv->job.completed)\n        return 0;\n\n    if (!mig->jobInfo && VIR_ALLOC(mig->jobInfo) < 0)\n        return -1;\n\n    *mig->jobInfo = *priv->job.completed;\n    mig->flags |= QEMU_MIGRATION_COOKIE_STATS;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationCookieAddNBD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "451-504",
    "snippet": "static int\nqemuMigrationCookieAddNBD(qemuMigrationCookiePtr mig,\n                          virQEMUDriverPtr driver,\n                          virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virHashTable) stats = virHashNew(virHashValueFree);\n    bool blockdev = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV);\n    size_t i;\n    int rc;\n\n    /* It is not a bug if there already is a NBD data */\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    mig->nbd = g_new0(qemuMigrationCookieNBD, 1);\n\n    mig->nbd->port = priv->nbdPort;\n    mig->flags |= QEMU_MIGRATION_COOKIE_NBD;\n\n    if (vm->def->ndisks == 0)\n        return 0;\n\n    mig->nbd->disks = g_new0(struct qemuMigrationCookieNBDDisk, vm->def->ndisks);\n    mig->nbd->ndisks = 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, priv->job.asyncJob) < 0)\n        return -1;\n    if (blockdev)\n        rc = qemuMonitorBlockStatsUpdateCapacityBlockdev(priv->mon, stats);\n    else\n        rc = qemuMonitorBlockStatsUpdateCapacity(priv->mon, stats, false);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        return -1;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuBlockStats *entry;\n\n        if (blockdev) {\n            if (!(entry = virHashLookup(stats, disk->src->nodeformat)))\n                continue;\n        } else {\n            if (!disk->info.alias ||\n                !(entry = virHashLookup(stats, disk->info.alias)))\n                continue;\n        }\n\n        mig->nbd->disks[mig->nbd->ndisks].target = g_strdup(disk->dst);\n        mig->nbd->disks[mig->nbd->ndisks].capacity = entry->capacity;\n        mig->nbd->ndisks++;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "disk->dst"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "stats",
            "disk->info.alias"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorBlockStatsUpdateCapacity",
          "args": [
            "priv->mon",
            "stats",
            "false"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorBlockStatsUpdateCapacity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2149-2159",
          "snippet": "int\nqemuMonitorBlockStatsUpdateCapacity(qemuMonitorPtr mon,\n                                    virHashTablePtr stats,\n                                    bool backingChain)\n{\n    VIR_DEBUG(\"stats=%p, backing=%d\", stats, backingChain);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockStatsUpdateCapacity(mon, stats, backingChain);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockStatsUpdateCapacity(qemuMonitorPtr mon,\n                                    virHashTablePtr stats,\n                                    bool backingChain)\n{\n    VIR_DEBUG(\"stats=%p, backing=%d\", stats, backingChain);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockStatsUpdateCapacity(mon, stats, backingChain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorBlockStatsUpdateCapacityBlockdev",
          "args": [
            "priv->mon",
            "stats"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorBlockStatsUpdateCapacityBlockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2162-2171",
          "snippet": "int\nqemuMonitorBlockStatsUpdateCapacityBlockdev(qemuMonitorPtr mon,\n                                            virHashTablePtr stats)\n{\n    VIR_DEBUG(\"stats=%p\", stats);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockStatsUpdateCapacityBlockdev(mon, stats);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockStatsUpdateCapacityBlockdev(qemuMonitorPtr mon,\n                                            virHashTablePtr stats)\n{\n    VIR_DEBUG(\"stats=%p\", stats);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockStatsUpdateCapacityBlockdev(mon, stats);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "driver",
            "vm",
            "priv->job.asyncJob"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "structqemuMigrationCookieNBDDisk",
            "vm->def->ndisks"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "qemuMigrationCookieNBD",
            "1"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieNBDFree",
          "args": [
            "mig->nbd"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieNBDFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "85-95",
          "snippet": "static void\nqemuMigrationCookieNBDFree(qemuMigrationCookieNBDPtr nbd)\n{\n    if (!nbd)\n        return;\n\n    while (nbd->ndisks)\n        VIR_FREE(nbd->disks[--nbd->ndisks].target);\n    VIR_FREE(nbd->disks);\n    VIR_FREE(nbd);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieNBDFree(qemuMigrationCookieNBDPtr nbd)\n{\n    if (!nbd)\n        return;\n\n    while (nbd->ndisks)\n        VIR_FREE(nbd->disks[--nbd->ndisks].target);\n    VIR_FREE(nbd->disks);\n    VIR_FREE(nbd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "priv->qemuCaps",
            "QEMU_CAPS_BLOCKDEV"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashNew",
          "args": [
            "virHashValueFree"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "virHashNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "180-190",
          "snippet": "virHashTablePtr\nvirHashNew(virHashDataFree dataFree)\n{\n    return virHashCreateFull(32,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr\nvirHashNew(virHashDataFree dataFree)\n{\n    return virHashCreateFull(32,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieAddNBD(qemuMigrationCookiePtr mig,\n                          virQEMUDriverPtr driver,\n                          virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virHashTable) stats = virHashNew(virHashValueFree);\n    bool blockdev = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV);\n    size_t i;\n    int rc;\n\n    /* It is not a bug if there already is a NBD data */\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    mig->nbd = g_new0(qemuMigrationCookieNBD, 1);\n\n    mig->nbd->port = priv->nbdPort;\n    mig->flags |= QEMU_MIGRATION_COOKIE_NBD;\n\n    if (vm->def->ndisks == 0)\n        return 0;\n\n    mig->nbd->disks = g_new0(struct qemuMigrationCookieNBDDisk, vm->def->ndisks);\n    mig->nbd->ndisks = 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, priv->job.asyncJob) < 0)\n        return -1;\n    if (blockdev)\n        rc = qemuMonitorBlockStatsUpdateCapacityBlockdev(priv->mon, stats);\n    else\n        rc = qemuMonitorBlockStatsUpdateCapacity(priv->mon, stats, false);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        return -1;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuBlockStats *entry;\n\n        if (blockdev) {\n            if (!(entry = virHashLookup(stats, disk->src->nodeformat)))\n                continue;\n        } else {\n            if (!disk->info.alias ||\n                !(entry = virHashLookup(stats, disk->info.alias)))\n                continue;\n        }\n\n        mig->nbd->disks[mig->nbd->ndisks].target = g_strdup(disk->dst);\n        mig->nbd->disks[mig->nbd->ndisks].capacity = entry->capacity;\n        mig->nbd->ndisks++;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationCookieAddNetwork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "429-448",
    "snippet": "static int\nqemuMigrationCookieAddNetwork(qemuMigrationCookiePtr mig,\n                              virQEMUDriverPtr driver,\n                              virDomainObjPtr dom)\n{\n    if (mig->flags & QEMU_MIGRATION_COOKIE_NETWORK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Network migration data already present\"));\n        return -1;\n    }\n\n    if (dom->def->nnets > 0) {\n        mig->network = qemuMigrationCookieNetworkAlloc(driver, dom->def);\n        if (!mig->network)\n            return -1;\n        mig->flags |= QEMU_MIGRATION_COOKIE_NETWORK;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMigrationCookieNetworkAlloc",
          "args": [
            "driver",
            "dom->def"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieNetworkAlloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "228-277",
          "snippet": "static qemuMigrationCookieNetworkPtr\nqemuMigrationCookieNetworkAlloc(virQEMUDriverPtr driver G_GNUC_UNUSED,\n                                virDomainDefPtr def)\n{\n    qemuMigrationCookieNetworkPtr mig;\n    size_t i;\n\n    if (VIR_ALLOC(mig) < 0)\n        goto error;\n\n    mig->nnets = def->nnets;\n\n    if (VIR_ALLOC_N(mig->net, def->nnets) <0)\n        goto error;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr netptr;\n        const virNetDevVPortProfile *vport;\n\n        netptr = def->nets[i];\n        vport = virDomainNetGetActualVirtPortProfile(netptr);\n\n        if (vport) {\n            mig->net[i].vporttype = vport->virtPortType;\n\n            switch (vport->virtPortType) {\n            case VIR_NETDEV_VPORT_PROFILE_NONE:\n            case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n            case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n               break;\n            case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n                if (virNetDevOpenvswitchGetMigrateData(&mig->net[i].portdata,\n                                                       netptr->ifname) != 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"Unable to run command to get OVS port data for \"\n                                         \"interface %s\"), netptr->ifname);\n                        goto error;\n                }\n                break;\n            default:\n                break;\n            }\n        }\n    }\n    return mig;\n\n error:\n    qemuMigrationCookieNetworkFree(mig);\n    return NULL;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic qemuMigrationCookieNetworkPtr\nqemuMigrationCookieNetworkAlloc(virQEMUDriverPtr driver G_GNUC_UNUSED,\n                                virDomainDefPtr def)\n{\n    qemuMigrationCookieNetworkPtr mig;\n    size_t i;\n\n    if (VIR_ALLOC(mig) < 0)\n        goto error;\n\n    mig->nnets = def->nnets;\n\n    if (VIR_ALLOC_N(mig->net, def->nnets) <0)\n        goto error;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr netptr;\n        const virNetDevVPortProfile *vport;\n\n        netptr = def->nets[i];\n        vport = virDomainNetGetActualVirtPortProfile(netptr);\n\n        if (vport) {\n            mig->net[i].vporttype = vport->virtPortType;\n\n            switch (vport->virtPortType) {\n            case VIR_NETDEV_VPORT_PROFILE_NONE:\n            case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n            case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n               break;\n            case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n                if (virNetDevOpenvswitchGetMigrateData(&mig->net[i].portdata,\n                                                       netptr->ifname) != 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"Unable to run command to get OVS port data for \"\n                                         \"interface %s\"), netptr->ifname);\n                        goto error;\n                }\n                break;\n            default:\n                break;\n            }\n        }\n    }\n    return mig;\n\n error:\n    qemuMigrationCookieNetworkFree(mig);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Network migration data already present\")"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Network migration data already present\""
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieAddNetwork(qemuMigrationCookiePtr mig,\n                              virQEMUDriverPtr driver,\n                              virDomainObjPtr dom)\n{\n    if (mig->flags & QEMU_MIGRATION_COOKIE_NETWORK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Network migration data already present\"));\n        return -1;\n    }\n\n    if (dom->def->nnets > 0) {\n        mig->network = qemuMigrationCookieNetworkAlloc(driver, dom->def);\n        if (!mig->network)\n            return -1;\n        mig->flags |= QEMU_MIGRATION_COOKIE_NETWORK;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationCookieGetPersistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "416-426",
    "snippet": "virDomainDefPtr\nqemuMigrationCookieGetPersistent(qemuMigrationCookiePtr mig)\n{\n    virDomainDefPtr def = mig->persistent;\n\n    mig->persistent = NULL;\n    mig->flags &= ~QEMU_MIGRATION_COOKIE_PERSISTENT;\n    mig->flagsMandatory &= ~QEMU_MIGRATION_COOKIE_PERSISTENT;\n\n    return def;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nvirDomainDefPtr\nqemuMigrationCookieGetPersistent(qemuMigrationCookiePtr mig)\n{\n    virDomainDefPtr def = mig->persistent;\n\n    mig->persistent = NULL;\n    mig->flags &= ~QEMU_MIGRATION_COOKIE_PERSISTENT;\n    mig->flagsMandatory &= ~QEMU_MIGRATION_COOKIE_PERSISTENT;\n\n    return def;\n}"
  },
  {
    "function_name": "qemuMigrationCookieAddPersistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "395-413",
    "snippet": "int\nqemuMigrationCookieAddPersistent(qemuMigrationCookiePtr mig,\n                                 virDomainDefPtr *def)\n{\n    if (mig->flags & QEMU_MIGRATION_COOKIE_PERSISTENT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration persistent data already present\"));\n        return -1;\n    }\n\n    if (!def || !*def)\n        return 0;\n\n    mig->persistent = *def;\n    *def = NULL;\n    mig->flags |= QEMU_MIGRATION_COOKIE_PERSISTENT;\n    mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_PERSISTENT;\n    return 0;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Migration persistent data already present\")"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Migration persistent data already present\""
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nint\nqemuMigrationCookieAddPersistent(qemuMigrationCookiePtr mig,\n                                 virDomainDefPtr *def)\n{\n    if (mig->flags & QEMU_MIGRATION_COOKIE_PERSISTENT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration persistent data already present\"));\n        return -1;\n    }\n\n    if (!def || !*def)\n        return 0;\n\n    mig->persistent = *def;\n    *def = NULL;\n    mig->flags |= QEMU_MIGRATION_COOKIE_PERSISTENT;\n    mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_PERSISTENT;\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationCookieAddLockstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "366-392",
    "snippet": "static int\nqemuMigrationCookieAddLockstate(qemuMigrationCookiePtr mig,\n                                virQEMUDriverPtr driver,\n                                virDomainObjPtr dom)\n{\n    qemuDomainObjPrivatePtr priv = dom->privateData;\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration lockstate data already present\"));\n        return -1;\n    }\n\n    if (virDomainObjGetState(dom, NULL) == VIR_DOMAIN_PAUSED) {\n        mig->lockState = g_strdup(priv->lockState);\n    } else {\n        if (virDomainLockProcessInquire(driver->lockManager, dom, &mig->lockState) < 0)\n            return -1;\n    }\n\n    mig->lockDriver = g_strdup(virLockManagerPluginGetName(driver->lockManager));\n\n    mig->flags |= QEMU_MIGRATION_COOKIE_LOCKSTATE;\n    mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_LOCKSTATE;\n\n    return 0;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "virLockManagerPluginGetName(driver->lockManager)"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockManagerPluginGetName",
          "args": [
            "driver->lockManager"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerPluginGetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_manager.c",
          "lines": "259-264",
          "snippet": "const char *virLockManagerPluginGetName(virLockManagerPluginPtr plugin)\n{\n    VIR_DEBUG(\"plugin=%p\", plugin);\n\n    return plugin->name;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "# include <dlfcn.h>",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"lock_driver_nop.h\"",
            "#include \"lock_manager.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include <unistd.h>\n# include <dlfcn.h>\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lock_driver_nop.h\"\n#include \"lock_manager.h\"\n#include <config.h>\n\nconst char *virLockManagerPluginGetName(virLockManagerPluginPtr plugin)\n{\n    VIR_DEBUG(\"plugin=%p\", plugin);\n\n    return plugin->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainLockProcessInquire",
          "args": [
            "driver->lockManager",
            "dom",
            "&mig->lockState"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainLockProcessInquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/domain_lock.c",
          "lines": "235-252",
          "snippet": "int virDomainLockProcessInquire(virLockManagerPluginPtr plugin,\n                                virDomainObjPtr dom,\n                                char **state)\n{\n    virLockManagerPtr lock;\n    int ret;\n\n    VIR_DEBUG(\"plugin=%p dom=%p state=%p\",\n              plugin, dom, state);\n\n    if (!(lock = virDomainLockManagerNew(plugin, NULL, dom, true, 0)))\n        return -1;\n\n    ret = virLockManagerInquire(lock, state, 0);\n    virLockManagerFree(lock);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_lock.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"domain_lock.h\"\n#include <config.h>\n\nint virDomainLockProcessInquire(virLockManagerPluginPtr plugin,\n                                virDomainObjPtr dom,\n                                char **state)\n{\n    virLockManagerPtr lock;\n    int ret;\n\n    VIR_DEBUG(\"plugin=%p dom=%p state=%p\",\n              plugin, dom, state);\n\n    if (!(lock = virDomainLockManagerNew(plugin, NULL, dom, true, 0)))\n        return -1;\n\n    ret = virLockManagerInquire(lock, state, 0);\n    virLockManagerFree(lock);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "dom",
            "NULL"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Migration lockstate data already present\")"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Migration lockstate data already present\""
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieAddLockstate(qemuMigrationCookiePtr mig,\n                                virQEMUDriverPtr driver,\n                                virDomainObjPtr dom)\n{\n    qemuDomainObjPrivatePtr priv = dom->privateData;\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration lockstate data already present\"));\n        return -1;\n    }\n\n    if (virDomainObjGetState(dom, NULL) == VIR_DOMAIN_PAUSED) {\n        mig->lockState = g_strdup(priv->lockState);\n    } else {\n        if (virDomainLockProcessInquire(driver->lockManager, dom, &mig->lockState) < 0)\n            return -1;\n    }\n\n    mig->lockDriver = g_strdup(virLockManagerPluginGetName(driver->lockManager));\n\n    mig->flags |= QEMU_MIGRATION_COOKIE_LOCKSTATE;\n    mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_LOCKSTATE;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationCookieAddGraphics",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "313-363",
    "snippet": "static int\nqemuMigrationCookieAddGraphics(qemuMigrationCookiePtr mig,\n                               virQEMUDriverPtr driver,\n                               virDomainObjPtr dom)\n{\n    size_t i = 0;\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_GRAPHICS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration graphics data already present\"));\n        return -1;\n    }\n\n    for (i = 0; i < dom->def->ngraphics; i++) {\n        if (dom->def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            virDomainGraphicsListenDefPtr glisten =\n                virDomainGraphicsGetListen(dom->def->graphics[i], 0);\n\n            if (!glisten) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing listen element\"));\n                return -1;\n            }\n\n            switch (glisten->type) {\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS:\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NETWORK:\n                /* Seamless migration is supported only for listen types\n                 * 'address and 'network'. */\n                if (!(mig->graphics =\n                      qemuMigrationCookieGraphicsSpiceAlloc(driver,\n                                                            dom->def->graphics[i],\n                                                            glisten)))\n                    return -1;\n                mig->flags |= QEMU_MIGRATION_COOKIE_GRAPHICS;\n                break;\n\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET:\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NONE:\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_LAST:\n                break;\n            }\n\n            /* Seamless migration is supported only for one graphics. */\n            if (mig->graphics)\n                break;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMigrationCookieGraphicsSpiceAlloc",
          "args": [
            "driver",
            "dom->def->graphics[i]",
            "glisten"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieGraphicsSpiceAlloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "190-225",
          "snippet": "static qemuMigrationCookieGraphicsPtr\nqemuMigrationCookieGraphicsSpiceAlloc(virQEMUDriverPtr driver,\n                                      virDomainGraphicsDefPtr def,\n                                      virDomainGraphicsListenDefPtr glisten)\n{\n    qemuMigrationCookieGraphicsPtr mig = NULL;\n    const char *listenAddr;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n\n    if (VIR_ALLOC(mig) < 0)\n        goto error;\n\n    mig->type = VIR_DOMAIN_GRAPHICS_TYPE_SPICE;\n    mig->port = def->data.spice.port;\n    if (cfg->spiceTLS)\n        mig->tlsPort = def->data.spice.tlsPort;\n    else\n        mig->tlsPort = -1;\n\n    if (!glisten || !(listenAddr = glisten->address))\n        listenAddr = cfg->spiceListen;\n\n    if (cfg->spiceTLS &&\n        !(mig->tlsSubject = qemuDomainExtractTLSSubject(cfg->spiceTLSx509certdir)))\n        goto error;\n\n    mig->listen = g_strdup(listenAddr);\n\n    virObjectUnref(cfg);\n    return mig;\n\n error:\n    qemuMigrationCookieGraphicsFree(mig);\n    virObjectUnref(cfg);\n    return NULL;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic qemuMigrationCookieGraphicsPtr\nqemuMigrationCookieGraphicsSpiceAlloc(virQEMUDriverPtr driver,\n                                      virDomainGraphicsDefPtr def,\n                                      virDomainGraphicsListenDefPtr glisten)\n{\n    qemuMigrationCookieGraphicsPtr mig = NULL;\n    const char *listenAddr;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n\n    if (VIR_ALLOC(mig) < 0)\n        goto error;\n\n    mig->type = VIR_DOMAIN_GRAPHICS_TYPE_SPICE;\n    mig->port = def->data.spice.port;\n    if (cfg->spiceTLS)\n        mig->tlsPort = def->data.spice.tlsPort;\n    else\n        mig->tlsPort = -1;\n\n    if (!glisten || !(listenAddr = glisten->address))\n        listenAddr = cfg->spiceListen;\n\n    if (cfg->spiceTLS &&\n        !(mig->tlsSubject = qemuDomainExtractTLSSubject(cfg->spiceTLSx509certdir)))\n        goto error;\n\n    mig->listen = g_strdup(listenAddr);\n\n    virObjectUnref(cfg);\n    return mig;\n\n error:\n    qemuMigrationCookieGraphicsFree(mig);\n    virObjectUnref(cfg);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing listen element\")"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing listen element\""
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsGetListen",
          "args": [
            "dom->def->graphics[i]",
            "0"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsGetListen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30357-30364",
          "snippet": "virDomainGraphicsListenDefPtr\nvirDomainGraphicsGetListen(virDomainGraphicsDefPtr def, size_t i)\n{\n    if (!def->listens || (def->nListens <= i))\n        return NULL;\n\n    return &def->listens[i];\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainGraphicsListenDefPtr\nvirDomainGraphicsGetListen(virDomainGraphicsDefPtr def, size_t i)\n{\n    if (!def->listens || (def->nListens <= i))\n        return NULL;\n\n    return &def->listens[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Migration graphics data already present\")"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic int\nqemuMigrationCookieAddGraphics(qemuMigrationCookiePtr mig,\n                               virQEMUDriverPtr driver,\n                               virDomainObjPtr dom)\n{\n    size_t i = 0;\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_GRAPHICS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration graphics data already present\"));\n        return -1;\n    }\n\n    for (i = 0; i < dom->def->ngraphics; i++) {\n        if (dom->def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            virDomainGraphicsListenDefPtr glisten =\n                virDomainGraphicsGetListen(dom->def->graphics[i], 0);\n\n            if (!glisten) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing listen element\"));\n                return -1;\n            }\n\n            switch (glisten->type) {\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS:\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NETWORK:\n                /* Seamless migration is supported only for listen types\n                 * 'address and 'network'. */\n                if (!(mig->graphics =\n                      qemuMigrationCookieGraphicsSpiceAlloc(driver,\n                                                            dom->def->graphics[i],\n                                                            glisten)))\n                    return -1;\n                mig->flags |= QEMU_MIGRATION_COOKIE_GRAPHICS;\n                break;\n\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET:\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NONE:\n            case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_LAST:\n                break;\n            }\n\n            /* Seamless migration is supported only for one graphics. */\n            if (mig->graphics)\n                break;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationCookieNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "280-310",
    "snippet": "static qemuMigrationCookiePtr\nqemuMigrationCookieNew(const virDomainDef *def,\n                       const char *origname)\n{\n    qemuMigrationCookiePtr mig = NULL;\n    const char *name;\n\n    if (VIR_ALLOC(mig) < 0)\n        goto error;\n\n    if (origname)\n        name = origname;\n    else\n        name = def->name;\n    mig->name = g_strdup(name);\n    memcpy(mig->uuid, def->uuid, VIR_UUID_BUFLEN);\n\n    if (!(mig->localHostname = virGetHostname()))\n        goto error;\n    if (virGetHostUUID(mig->localHostuuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to obtain host UUID\"));\n        goto error;\n    }\n\n    return mig;\n\n error:\n    qemuMigrationCookieFree(mig);\n    return NULL;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMigrationCookieFree",
          "args": [
            "mig"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "110-130",
          "snippet": "void\nqemuMigrationCookieFree(qemuMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    qemuMigrationCookieGraphicsFree(mig->graphics);\n    virDomainDefFree(mig->persistent);\n    qemuMigrationCookieNetworkFree(mig->network);\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    VIR_FREE(mig->localHostname);\n    VIR_FREE(mig->remoteHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig->lockState);\n    VIR_FREE(mig->lockDriver);\n    VIR_FREE(mig->jobInfo);\n    virCPUDefFree(mig->cpu);\n    qemuMigrationCookieCapsFree(mig->caps);\n    VIR_FREE(mig);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nvoid\nqemuMigrationCookieFree(qemuMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    qemuMigrationCookieGraphicsFree(mig->graphics);\n    virDomainDefFree(mig->persistent);\n    qemuMigrationCookieNetworkFree(mig->network);\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    VIR_FREE(mig->localHostname);\n    VIR_FREE(mig->remoteHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig->lockState);\n    VIR_FREE(mig->lockDriver);\n    VIR_FREE(mig->jobInfo);\n    virCPUDefFree(mig->cpu);\n    qemuMigrationCookieCapsFree(mig->caps);\n    VIR_FREE(mig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to obtain host UUID\")"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to obtain host UUID\""
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetHostUUID",
          "args": [
            "mig->localHostuuid"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "virGetHostUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "258-268",
          "snippet": "int virGetHostUUID(unsigned char *uuid)\n{\n    int ret = 0;\n\n    if (!virUUIDIsValid(host_uuid))\n        ret = virSetHostUUIDStr(NULL);\n\n    memcpy(uuid, host_uuid, sizeof(host_uuid));\n\n    return ret;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char host_uuid[VIR_UUID_BUFLEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic unsigned char host_uuid[VIR_UUID_BUFLEN];\n\nint virGetHostUUID(unsigned char *uuid)\n{\n    int ret = 0;\n\n    if (!virUUIDIsValid(host_uuid))\n        ret = virSetHostUUIDStr(NULL);\n\n    memcpy(uuid, host_uuid, sizeof(host_uuid));\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetHostname",
          "args": [],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "virGetHostnameQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "560-564",
          "snippet": "char *\nvirGetHostnameQuiet(void)\n{\n    return virGetHostnameImpl(true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirGetHostnameQuiet(void)\n{\n    return virGetHostnameImpl(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mig->uuid",
            "def->uuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "name"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "mig"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic qemuMigrationCookiePtr\nqemuMigrationCookieNew(const virDomainDef *def,\n                       const char *origname)\n{\n    qemuMigrationCookiePtr mig = NULL;\n    const char *name;\n\n    if (VIR_ALLOC(mig) < 0)\n        goto error;\n\n    if (origname)\n        name = origname;\n    else\n        name = def->name;\n    mig->name = g_strdup(name);\n    memcpy(mig->uuid, def->uuid, VIR_UUID_BUFLEN);\n\n    if (!(mig->localHostname = virGetHostname()))\n        goto error;\n    if (virGetHostUUID(mig->localHostuuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to obtain host UUID\"));\n        goto error;\n    }\n\n    return mig;\n\n error:\n    qemuMigrationCookieFree(mig);\n    return NULL;\n}"
  },
  {
    "function_name": "qemuMigrationCookieNetworkAlloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "228-277",
    "snippet": "static qemuMigrationCookieNetworkPtr\nqemuMigrationCookieNetworkAlloc(virQEMUDriverPtr driver G_GNUC_UNUSED,\n                                virDomainDefPtr def)\n{\n    qemuMigrationCookieNetworkPtr mig;\n    size_t i;\n\n    if (VIR_ALLOC(mig) < 0)\n        goto error;\n\n    mig->nnets = def->nnets;\n\n    if (VIR_ALLOC_N(mig->net, def->nnets) <0)\n        goto error;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr netptr;\n        const virNetDevVPortProfile *vport;\n\n        netptr = def->nets[i];\n        vport = virDomainNetGetActualVirtPortProfile(netptr);\n\n        if (vport) {\n            mig->net[i].vporttype = vport->virtPortType;\n\n            switch (vport->virtPortType) {\n            case VIR_NETDEV_VPORT_PROFILE_NONE:\n            case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n            case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n               break;\n            case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n                if (virNetDevOpenvswitchGetMigrateData(&mig->net[i].portdata,\n                                                       netptr->ifname) != 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"Unable to run command to get OVS port data for \"\n                                         \"interface %s\"), netptr->ifname);\n                        goto error;\n                }\n                break;\n            default:\n                break;\n            }\n        }\n    }\n    return mig;\n\n error:\n    qemuMigrationCookieNetworkFree(mig);\n    return NULL;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMigrationCookieNetworkFree",
          "args": [
            "mig"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieNetworkFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "68-82",
          "snippet": "static void\nqemuMigrationCookieNetworkFree(qemuMigrationCookieNetworkPtr network)\n{\n    size_t i;\n\n    if (!network)\n        return;\n\n    if (network->net) {\n        for (i = 0; i < network->nnets; i++)\n            VIR_FREE(network->net[i].portdata);\n    }\n    VIR_FREE(network->net);\n    VIR_FREE(network);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieNetworkFree(qemuMigrationCookieNetworkPtr network)\n{\n    size_t i;\n\n    if (!network)\n        return;\n\n    if (network->net) {\n        for (i = 0; i < network->nnets; i++)\n            VIR_FREE(network->net[i].portdata);\n    }\n    VIR_FREE(network->net);\n    VIR_FREE(network);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to run command to get OVS port data for \"\n                                         \"interface %s\")",
            "netptr->ifname"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to run command to get OVS port data for \"\n                                         \"interface %s\""
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevOpenvswitchGetMigrateData",
          "args": [
            "&mig->net[i].portdata",
            "netptr->ifname"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevOpenvswitchGetMigrateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevopenvswitch.c",
          "lines": "231-257",
          "snippet": "int virNetDevOpenvswitchGetMigrateData(char **migrate, const char *ifname)\n{\n    size_t len;\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNew(OVSVSCTL);\n    virNetDevOpenvswitchAddTimeout(cmd);\n    virCommandAddArgList(cmd, \"--if-exists\", \"get\", \"Interface\",\n                         ifname, \"external_ids:PortData\", NULL);\n\n    virCommandSetOutputBuffer(cmd, migrate);\n\n    /* Run the command */\n    if (virCommandRun(cmd, NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to run command to get OVS port data for \"\n                         \"interface %s\"), ifname);\n        return -1;\n    }\n\n    /* Wipeout the newline, if it exists */\n    len = strlen(*migrate);\n    if (len > 0)\n        (*migrate)[len - 1] = '\\0';\n\n    return 0;\n}",
          "includes": [
            "#include \"virjson.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virjson.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virmacaddr.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevopenvswitch.h\"\n#include <config.h>\n\nint virNetDevOpenvswitchGetMigrateData(char **migrate, const char *ifname)\n{\n    size_t len;\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNew(OVSVSCTL);\n    virNetDevOpenvswitchAddTimeout(cmd);\n    virCommandAddArgList(cmd, \"--if-exists\", \"get\", \"Interface\",\n                         ifname, \"external_ids:PortData\", NULL);\n\n    virCommandSetOutputBuffer(cmd, migrate);\n\n    /* Run the command */\n    if (virCommandRun(cmd, NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to run command to get OVS port data for \"\n                         \"interface %s\"), ifname);\n        return -1;\n    }\n\n    /* Wipeout the newline, if it exists */\n    len = strlen(*migrate);\n    if (len > 0)\n        (*migrate)[len - 1] = '\\0';\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualVirtPortProfile",
          "args": [
            "netptr"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualVirtPortProfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30224-30255",
          "snippet": "const virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "mig->net",
            "def->nnets"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "mig"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic qemuMigrationCookieNetworkPtr\nqemuMigrationCookieNetworkAlloc(virQEMUDriverPtr driver G_GNUC_UNUSED,\n                                virDomainDefPtr def)\n{\n    qemuMigrationCookieNetworkPtr mig;\n    size_t i;\n\n    if (VIR_ALLOC(mig) < 0)\n        goto error;\n\n    mig->nnets = def->nnets;\n\n    if (VIR_ALLOC_N(mig->net, def->nnets) <0)\n        goto error;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr netptr;\n        const virNetDevVPortProfile *vport;\n\n        netptr = def->nets[i];\n        vport = virDomainNetGetActualVirtPortProfile(netptr);\n\n        if (vport) {\n            mig->net[i].vporttype = vport->virtPortType;\n\n            switch (vport->virtPortType) {\n            case VIR_NETDEV_VPORT_PROFILE_NONE:\n            case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n            case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n               break;\n            case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n                if (virNetDevOpenvswitchGetMigrateData(&mig->net[i].portdata,\n                                                       netptr->ifname) != 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"Unable to run command to get OVS port data for \"\n                                         \"interface %s\"), netptr->ifname);\n                        goto error;\n                }\n                break;\n            default:\n                break;\n            }\n        }\n    }\n    return mig;\n\n error:\n    qemuMigrationCookieNetworkFree(mig);\n    return NULL;\n}"
  },
  {
    "function_name": "qemuMigrationCookieGraphicsSpiceAlloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "190-225",
    "snippet": "static qemuMigrationCookieGraphicsPtr\nqemuMigrationCookieGraphicsSpiceAlloc(virQEMUDriverPtr driver,\n                                      virDomainGraphicsDefPtr def,\n                                      virDomainGraphicsListenDefPtr glisten)\n{\n    qemuMigrationCookieGraphicsPtr mig = NULL;\n    const char *listenAddr;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n\n    if (VIR_ALLOC(mig) < 0)\n        goto error;\n\n    mig->type = VIR_DOMAIN_GRAPHICS_TYPE_SPICE;\n    mig->port = def->data.spice.port;\n    if (cfg->spiceTLS)\n        mig->tlsPort = def->data.spice.tlsPort;\n    else\n        mig->tlsPort = -1;\n\n    if (!glisten || !(listenAddr = glisten->address))\n        listenAddr = cfg->spiceListen;\n\n    if (cfg->spiceTLS &&\n        !(mig->tlsSubject = qemuDomainExtractTLSSubject(cfg->spiceTLSx509certdir)))\n        goto error;\n\n    mig->listen = g_strdup(listenAddr);\n\n    virObjectUnref(cfg);\n    return mig;\n\n error:\n    qemuMigrationCookieGraphicsFree(mig);\n    virObjectUnref(cfg);\n    return NULL;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieGraphicsFree",
          "args": [
            "mig"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieGraphicsFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "57-65",
          "snippet": "static void\nqemuMigrationCookieGraphicsFree(qemuMigrationCookieGraphicsPtr grap)\n{\n    if (!grap)\n        return;\n    VIR_FREE(grap->listen);\n    VIR_FREE(grap->tlsSubject);\n    VIR_FREE(grap);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieGraphicsFree(qemuMigrationCookieGraphicsPtr grap)\n{\n    if (!grap)\n        return;\n    VIR_FREE(grap->listen);\n    VIR_FREE(grap->tlsSubject);\n    VIR_FREE(grap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "listenAddr"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainExtractTLSSubject",
          "args": [
            "cfg->spiceTLSx509certdir"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainExtractTLSSubject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "133-187",
          "snippet": "static char *\nqemuDomainExtractTLSSubject(const char *certdir)\n{\n    char *certfile = NULL;\n    char *subject = NULL;\n    char *pemdata = NULL;\n    gnutls_datum_t pemdatum;\n    gnutls_x509_crt_t cert;\n    int ret;\n    size_t subjectlen;\n\n    certfile = g_strdup_printf(\"%s/server-cert.pem\", certdir);\n\n    if (virFileReadAll(certfile, 8192, &pemdata) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to read server cert %s\"), certfile);\n        goto error;\n    }\n\n    ret = gnutls_x509_crt_init(&cert);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot initialize cert object: %s\"),\n                       gnutls_strerror(ret));\n        goto error;\n    }\n\n    pemdatum.data = (unsigned char *)pemdata;\n    pemdatum.size = strlen(pemdata);\n\n    ret = gnutls_x509_crt_import(cert, &pemdatum, GNUTLS_X509_FMT_PEM);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot load cert data from %s: %s\"),\n                       certfile, gnutls_strerror(ret));\n        goto error;\n    }\n\n    subjectlen = 1024;\n    if (VIR_ALLOC_N(subject, subjectlen+1) < 0)\n        goto error;\n\n    gnutls_x509_crt_get_dn(cert, subject, &subjectlen);\n    subject[subjectlen] = '\\0';\n\n    VIR_FREE(certfile);\n    VIR_FREE(pemdata);\n\n    return subject;\n\n error:\n    VIR_FREE(certfile);\n    VIR_FREE(pemdata);\n    return NULL;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic char *\nqemuDomainExtractTLSSubject(const char *certdir)\n{\n    char *certfile = NULL;\n    char *subject = NULL;\n    char *pemdata = NULL;\n    gnutls_datum_t pemdatum;\n    gnutls_x509_crt_t cert;\n    int ret;\n    size_t subjectlen;\n\n    certfile = g_strdup_printf(\"%s/server-cert.pem\", certdir);\n\n    if (virFileReadAll(certfile, 8192, &pemdata) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to read server cert %s\"), certfile);\n        goto error;\n    }\n\n    ret = gnutls_x509_crt_init(&cert);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot initialize cert object: %s\"),\n                       gnutls_strerror(ret));\n        goto error;\n    }\n\n    pemdatum.data = (unsigned char *)pemdata;\n    pemdatum.size = strlen(pemdata);\n\n    ret = gnutls_x509_crt_import(cert, &pemdatum, GNUTLS_X509_FMT_PEM);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot load cert data from %s: %s\"),\n                       certfile, gnutls_strerror(ret));\n        goto error;\n    }\n\n    subjectlen = 1024;\n    if (VIR_ALLOC_N(subject, subjectlen+1) < 0)\n        goto error;\n\n    gnutls_x509_crt_get_dn(cert, subject, &subjectlen);\n    subject[subjectlen] = '\\0';\n\n    VIR_FREE(certfile);\n    VIR_FREE(pemdata);\n\n    return subject;\n\n error:\n    VIR_FREE(certfile);\n    VIR_FREE(pemdata);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "mig"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic qemuMigrationCookieGraphicsPtr\nqemuMigrationCookieGraphicsSpiceAlloc(virQEMUDriverPtr driver,\n                                      virDomainGraphicsDefPtr def,\n                                      virDomainGraphicsListenDefPtr glisten)\n{\n    qemuMigrationCookieGraphicsPtr mig = NULL;\n    const char *listenAddr;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n\n    if (VIR_ALLOC(mig) < 0)\n        goto error;\n\n    mig->type = VIR_DOMAIN_GRAPHICS_TYPE_SPICE;\n    mig->port = def->data.spice.port;\n    if (cfg->spiceTLS)\n        mig->tlsPort = def->data.spice.tlsPort;\n    else\n        mig->tlsPort = -1;\n\n    if (!glisten || !(listenAddr = glisten->address))\n        listenAddr = cfg->spiceListen;\n\n    if (cfg->spiceTLS &&\n        !(mig->tlsSubject = qemuDomainExtractTLSSubject(cfg->spiceTLSx509certdir)))\n        goto error;\n\n    mig->listen = g_strdup(listenAddr);\n\n    virObjectUnref(cfg);\n    return mig;\n\n error:\n    qemuMigrationCookieGraphicsFree(mig);\n    virObjectUnref(cfg);\n    return NULL;\n}"
  },
  {
    "function_name": "qemuDomainExtractTLSSubject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "133-187",
    "snippet": "static char *\nqemuDomainExtractTLSSubject(const char *certdir)\n{\n    char *certfile = NULL;\n    char *subject = NULL;\n    char *pemdata = NULL;\n    gnutls_datum_t pemdatum;\n    gnutls_x509_crt_t cert;\n    int ret;\n    size_t subjectlen;\n\n    certfile = g_strdup_printf(\"%s/server-cert.pem\", certdir);\n\n    if (virFileReadAll(certfile, 8192, &pemdata) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to read server cert %s\"), certfile);\n        goto error;\n    }\n\n    ret = gnutls_x509_crt_init(&cert);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot initialize cert object: %s\"),\n                       gnutls_strerror(ret));\n        goto error;\n    }\n\n    pemdatum.data = (unsigned char *)pemdata;\n    pemdatum.size = strlen(pemdata);\n\n    ret = gnutls_x509_crt_import(cert, &pemdatum, GNUTLS_X509_FMT_PEM);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot load cert data from %s: %s\"),\n                       certfile, gnutls_strerror(ret));\n        goto error;\n    }\n\n    subjectlen = 1024;\n    if (VIR_ALLOC_N(subject, subjectlen+1) < 0)\n        goto error;\n\n    gnutls_x509_crt_get_dn(cert, subject, &subjectlen);\n    subject[subjectlen] = '\\0';\n\n    VIR_FREE(certfile);\n    VIR_FREE(pemdata);\n\n    return subject;\n\n error:\n    VIR_FREE(certfile);\n    VIR_FREE(pemdata);\n    return NULL;\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pemdata"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "certfile"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pemdata"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "certfile"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_get_dn",
          "args": [
            "cert",
            "subject",
            "&subjectlen"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "subject",
            "subjectlen+1"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"cannot load cert data from %s: %s\")",
            "certfile",
            "gnutls_strerror(ret)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "ret"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot load cert data from %s: %s\""
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_import",
          "args": [
            "cert",
            "&pemdatum",
            "GNUTLS_X509_FMT_PEM"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pemdata"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"cannot initialize cert object: %s\")",
            "gnutls_strerror(ret)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "ret"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_init",
          "args": [
            "&cert"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unable to read server cert %s\")",
            "certfile"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadAll",
          "args": [
            "certfile",
            "8192",
            "&pemdata"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/server-cert.pem\"",
            "certdir"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic char *\nqemuDomainExtractTLSSubject(const char *certdir)\n{\n    char *certfile = NULL;\n    char *subject = NULL;\n    char *pemdata = NULL;\n    gnutls_datum_t pemdatum;\n    gnutls_x509_crt_t cert;\n    int ret;\n    size_t subjectlen;\n\n    certfile = g_strdup_printf(\"%s/server-cert.pem\", certdir);\n\n    if (virFileReadAll(certfile, 8192, &pemdata) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to read server cert %s\"), certfile);\n        goto error;\n    }\n\n    ret = gnutls_x509_crt_init(&cert);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot initialize cert object: %s\"),\n                       gnutls_strerror(ret));\n        goto error;\n    }\n\n    pemdatum.data = (unsigned char *)pemdata;\n    pemdatum.size = strlen(pemdata);\n\n    ret = gnutls_x509_crt_import(cert, &pemdatum, GNUTLS_X509_FMT_PEM);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot load cert data from %s: %s\"),\n                       certfile, gnutls_strerror(ret));\n        goto error;\n    }\n\n    subjectlen = 1024;\n    if (VIR_ALLOC_N(subject, subjectlen+1) < 0)\n        goto error;\n\n    gnutls_x509_crt_get_dn(cert, subject, &subjectlen);\n    subject[subjectlen] = '\\0';\n\n    VIR_FREE(certfile);\n    VIR_FREE(pemdata);\n\n    return subject;\n\n error:\n    VIR_FREE(certfile);\n    VIR_FREE(pemdata);\n    return NULL;\n}"
  },
  {
    "function_name": "qemuMigrationCookieFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "110-130",
    "snippet": "void\nqemuMigrationCookieFree(qemuMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    qemuMigrationCookieGraphicsFree(mig->graphics);\n    virDomainDefFree(mig->persistent);\n    qemuMigrationCookieNetworkFree(mig->network);\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    VIR_FREE(mig->localHostname);\n    VIR_FREE(mig->remoteHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig->lockState);\n    VIR_FREE(mig->lockDriver);\n    VIR_FREE(mig->jobInfo);\n    virCPUDefFree(mig->cpu);\n    qemuMigrationCookieCapsFree(mig->caps);\n    VIR_FREE(mig);\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mig"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieCapsFree",
          "args": [
            "mig->caps"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieCapsFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "98-107",
          "snippet": "static void\nqemuMigrationCookieCapsFree(qemuMigrationCookieCapsPtr caps)\n{\n    if (!caps)\n        return;\n\n    virBitmapFree(caps->supported);\n    virBitmapFree(caps->automatic);\n    VIR_FREE(caps);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieCapsFree(qemuMigrationCookieCapsPtr caps)\n{\n    if (!caps)\n        return;\n\n    virBitmapFree(caps->supported);\n    virBitmapFree(caps->automatic);\n    VIR_FREE(caps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "mig->cpu"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mig->jobInfo"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mig->lockDriver"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mig->lockState"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mig->name"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mig->remoteHostname"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mig->localHostname"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieNBDFree",
          "args": [
            "mig->nbd"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieNBDFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "85-95",
          "snippet": "static void\nqemuMigrationCookieNBDFree(qemuMigrationCookieNBDPtr nbd)\n{\n    if (!nbd)\n        return;\n\n    while (nbd->ndisks)\n        VIR_FREE(nbd->disks[--nbd->ndisks].target);\n    VIR_FREE(nbd->disks);\n    VIR_FREE(nbd);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieNBDFree(qemuMigrationCookieNBDPtr nbd)\n{\n    if (!nbd)\n        return;\n\n    while (nbd->ndisks)\n        VIR_FREE(nbd->disks[--nbd->ndisks].target);\n    VIR_FREE(nbd->disks);\n    VIR_FREE(nbd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieNetworkFree",
          "args": [
            "mig->network"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieNetworkFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "68-82",
          "snippet": "static void\nqemuMigrationCookieNetworkFree(qemuMigrationCookieNetworkPtr network)\n{\n    size_t i;\n\n    if (!network)\n        return;\n\n    if (network->net) {\n        for (i = 0; i < network->nnets; i++)\n            VIR_FREE(network->net[i].portdata);\n    }\n    VIR_FREE(network->net);\n    VIR_FREE(network);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieNetworkFree(qemuMigrationCookieNetworkPtr network)\n{\n    size_t i;\n\n    if (!network)\n        return;\n\n    if (network->net) {\n        for (i = 0; i < network->nnets; i++)\n            VIR_FREE(network->net[i].portdata);\n    }\n    VIR_FREE(network->net);\n    VIR_FREE(network);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "mig->persistent"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieGraphicsFree",
          "args": [
            "mig->graphics"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieGraphicsFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "57-65",
          "snippet": "static void\nqemuMigrationCookieGraphicsFree(qemuMigrationCookieGraphicsPtr grap)\n{\n    if (!grap)\n        return;\n    VIR_FREE(grap->listen);\n    VIR_FREE(grap->tlsSubject);\n    VIR_FREE(grap);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieGraphicsFree(qemuMigrationCookieGraphicsPtr grap)\n{\n    if (!grap)\n        return;\n    VIR_FREE(grap->listen);\n    VIR_FREE(grap->tlsSubject);\n    VIR_FREE(grap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nvoid\nqemuMigrationCookieFree(qemuMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    qemuMigrationCookieGraphicsFree(mig->graphics);\n    virDomainDefFree(mig->persistent);\n    qemuMigrationCookieNetworkFree(mig->network);\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    VIR_FREE(mig->localHostname);\n    VIR_FREE(mig->remoteHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig->lockState);\n    VIR_FREE(mig->lockDriver);\n    VIR_FREE(mig->jobInfo);\n    virCPUDefFree(mig->cpu);\n    qemuMigrationCookieCapsFree(mig->caps);\n    VIR_FREE(mig);\n}"
  },
  {
    "function_name": "qemuMigrationCookieCapsFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "98-107",
    "snippet": "static void\nqemuMigrationCookieCapsFree(qemuMigrationCookieCapsPtr caps)\n{\n    if (!caps)\n        return;\n\n    virBitmapFree(caps->supported);\n    virBitmapFree(caps->automatic);\n    VIR_FREE(caps);\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "caps"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "caps->automatic"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieCapsFree(qemuMigrationCookieCapsPtr caps)\n{\n    if (!caps)\n        return;\n\n    virBitmapFree(caps->supported);\n    virBitmapFree(caps->automatic);\n    VIR_FREE(caps);\n}"
  },
  {
    "function_name": "qemuMigrationCookieNBDFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "85-95",
    "snippet": "static void\nqemuMigrationCookieNBDFree(qemuMigrationCookieNBDPtr nbd)\n{\n    if (!nbd)\n        return;\n\n    while (nbd->ndisks)\n        VIR_FREE(nbd->disks[--nbd->ndisks].target);\n    VIR_FREE(nbd->disks);\n    VIR_FREE(nbd);\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nbd"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nbd->disks"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nbd->disks[--nbd->ndisks].target"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieNBDFree(qemuMigrationCookieNBDPtr nbd)\n{\n    if (!nbd)\n        return;\n\n    while (nbd->ndisks)\n        VIR_FREE(nbd->disks[--nbd->ndisks].target);\n    VIR_FREE(nbd->disks);\n    VIR_FREE(nbd);\n}"
  },
  {
    "function_name": "qemuMigrationCookieNetworkFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "68-82",
    "snippet": "static void\nqemuMigrationCookieNetworkFree(qemuMigrationCookieNetworkPtr network)\n{\n    size_t i;\n\n    if (!network)\n        return;\n\n    if (network->net) {\n        for (i = 0; i < network->nnets; i++)\n            VIR_FREE(network->net[i].portdata);\n    }\n    VIR_FREE(network->net);\n    VIR_FREE(network);\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "network"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "network->net"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "network->net[i].portdata"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieNetworkFree(qemuMigrationCookieNetworkPtr network)\n{\n    size_t i;\n\n    if (!network)\n        return;\n\n    if (network->net) {\n        for (i = 0; i < network->nnets; i++)\n            VIR_FREE(network->net[i].portdata);\n    }\n    VIR_FREE(network->net);\n    VIR_FREE(network);\n}"
  },
  {
    "function_name": "qemuMigrationCookieGraphicsFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
    "lines": "57-65",
    "snippet": "static void\nqemuMigrationCookieGraphicsFree(qemuMigrationCookieGraphicsPtr grap)\n{\n    if (!grap)\n        return;\n    VIR_FREE(grap->listen);\n    VIR_FREE(grap->tlsSubject);\n    VIR_FREE(grap);\n}",
    "includes": [
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/gnutls.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "grap"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "grap->tlsSubject"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "grap->listen"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nstatic void\nqemuMigrationCookieGraphicsFree(qemuMigrationCookieGraphicsPtr grap)\n{\n    if (!grap)\n        return;\n    VIR_FREE(grap->listen);\n    VIR_FREE(grap->tlsSubject);\n    VIR_FREE(grap);\n}"
  }
]