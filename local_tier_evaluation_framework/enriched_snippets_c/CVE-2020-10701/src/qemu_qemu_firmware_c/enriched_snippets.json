[
  {
    "function_name": "qemuFirmwareGetSupported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "1328-1445",
    "snippet": "int\nqemuFirmwareGetSupported(const char *machine,\n                         virArch arch,\n                         bool privileged,\n                         uint64_t *supported,\n                         bool *secure,\n                         virFirmwarePtr **fws,\n                         size_t *nfws)\n{\n    qemuFirmwarePtr *firmwares = NULL;\n    ssize_t nfirmwares = 0;\n    size_t i;\n\n    *supported = VIR_DOMAIN_OS_DEF_FIRMWARE_NONE;\n    *secure = false;\n\n    if (fws) {\n        *fws = NULL;\n        *nfws = 0;\n    }\n\n    if ((nfirmwares = qemuFirmwareFetchParsedConfigs(privileged,\n                                                     &firmwares, NULL)) < 0)\n        return -1;\n\n    for (i = 0; i < nfirmwares; i++) {\n        qemuFirmwarePtr fw = firmwares[i];\n        const qemuFirmwareMappingFlash *flash = &fw->mapping.data.flash;\n        const qemuFirmwareMappingMemory *memory = &fw->mapping.data.memory;\n        const char *fwpath = NULL;\n        const char *nvrampath = NULL;\n        size_t j;\n\n        if (!qemuFirmwareMatchesMachineArch(fw, machine, arch))\n            continue;\n\n        for (j = 0; j < fw->ninterfaces; j++) {\n            switch (fw->interfaces[j]) {\n            case QEMU_FIRMWARE_OS_INTERFACE_UEFI:\n                *supported |= 1ULL << VIR_DOMAIN_OS_DEF_FIRMWARE_EFI;\n                break;\n            case QEMU_FIRMWARE_OS_INTERFACE_BIOS:\n                *supported |= 1ULL << VIR_DOMAIN_OS_DEF_FIRMWARE_BIOS;\n                break;\n            case QEMU_FIRMWARE_OS_INTERFACE_NONE:\n            case QEMU_FIRMWARE_OS_INTERFACE_OPENFIRMWARE:\n            case QEMU_FIRMWARE_OS_INTERFACE_UBOOT:\n            case QEMU_FIRMWARE_OS_INTERFACE_LAST:\n            default:\n                break;\n            }\n        }\n\n        for (j = 0; j < fw->nfeatures; j++) {\n            switch (fw->features[j]) {\n            case QEMU_FIRMWARE_FEATURE_REQUIRES_SMM:\n                *secure = true;\n                break;\n            case QEMU_FIRMWARE_FEATURE_NONE:\n            case QEMU_FIRMWARE_FEATURE_ACPI_S3:\n            case QEMU_FIRMWARE_FEATURE_ACPI_S4:\n            case QEMU_FIRMWARE_FEATURE_AMD_SEV:\n            case QEMU_FIRMWARE_FEATURE_ENROLLED_KEYS:\n            case QEMU_FIRMWARE_FEATURE_SECURE_BOOT:\n            case QEMU_FIRMWARE_FEATURE_VERBOSE_DYNAMIC:\n            case QEMU_FIRMWARE_FEATURE_VERBOSE_STATIC:\n            case QEMU_FIRMWARE_FEATURE_LAST:\n                break;\n            }\n        }\n\n        switch (fw->mapping.device) {\n        case QEMU_FIRMWARE_DEVICE_FLASH:\n            fwpath = flash->executable.filename;\n            nvrampath = flash->nvram_template.filename;\n            break;\n\n        case QEMU_FIRMWARE_DEVICE_MEMORY:\n            fwpath = memory->filename;\n            break;\n\n        case QEMU_FIRMWARE_DEVICE_KERNEL:\n        case QEMU_FIRMWARE_DEVICE_NONE:\n        case QEMU_FIRMWARE_DEVICE_LAST:\n            break;\n        }\n\n        if (fws && fwpath) {\n            g_autoptr(virFirmware) tmp = NULL;\n\n            /* Append only unique pairs. */\n            for (j = 0; j < *nfws; j++) {\n                if (STREQ((*fws)[j]->name, fwpath) &&\n                    STREQ_NULLABLE((*fws)[j]->nvram, nvrampath))\n                    break;\n            }\n\n            if (j == *nfws) {\n                if (VIR_ALLOC(tmp) < 0)\n                    return -1;\n\n                tmp->name = g_strdup(fwpath);\n                tmp->nvram = g_strdup(nvrampath);\n                if (VIR_APPEND_ELEMENT(*fws, *nfws, tmp) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    if (fws && !*fws && nfirmwares &&\n        VIR_REALLOC_N(*fws, 0) < 0)\n        return -1;\n\n    for (i = 0; i < nfirmwares; i++)\n        qemuFirmwareFree(firmwares[i]);\n    VIR_FREE(firmwares);\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "firmwares"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuFirmwareFree",
          "args": [
            "firmwares[i]"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "265-281",
          "snippet": "void\nqemuFirmwareFree(qemuFirmwarePtr fw)\n{\n    size_t i;\n\n    if (!fw)\n        return;\n\n    qemuFirmwareOSInterfaceFree(fw->interfaces);\n    qemuFirmwareMappingFree(fw->mapping);\n    for (i = 0; i < fw->ntargets; i++)\n        qemuFirmwareTargetFree(fw->targets[i]);\n    VIR_FREE(fw->targets);\n    qemuFirmwareFeatureFree(fw->features);\n\n    VIR_FREE(fw);\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nvoid\nqemuFirmwareFree(qemuFirmwarePtr fw)\n{\n    size_t i;\n\n    if (!fw)\n        return;\n\n    qemuFirmwareOSInterfaceFree(fw->interfaces);\n    qemuFirmwareMappingFree(fw->mapping);\n    for (i = 0; i < fw->ntargets; i++)\n        qemuFirmwareTargetFree(fw->targets[i]);\n    VIR_FREE(fw->targets);\n    qemuFirmwareFeatureFree(fw->features);\n\n    VIR_FREE(fw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "*fws",
            "0"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "*fws",
            "*nfws",
            "tmp"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "nvrampath"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "tmp"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "(*fws)[j]->nvram",
            "nvrampath"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "(*fws)[j]->name",
            "fwpath"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuFirmwareMatchesMachineArch",
          "args": [
            "fw",
            "machine",
            "arch"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareMatchesMachineArch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "892-912",
          "snippet": "static bool\nqemuFirmwareMatchesMachineArch(const qemuFirmware *fw,\n                               const char *machine,\n                               virArch arch)\n{\n    size_t i;\n\n    for (i = 0; i < fw->ntargets; i++) {\n        size_t j;\n\n        if (arch != fw->targets[i]->architecture)\n            continue;\n\n        for (j = 0; j < fw->targets[i]->nmachines; j++) {\n            if (g_pattern_match_simple(fw->targets[i]->machines[j], machine))\n                return true;\n        }\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic bool\nqemuFirmwareMatchesMachineArch(const qemuFirmware *fw,\n                               const char *machine,\n                               virArch arch)\n{\n    size_t i;\n\n    for (i = 0; i < fw->ntargets; i++) {\n        size_t j;\n\n        if (arch != fw->targets[i]->architecture)\n            continue;\n\n        for (j = 0; j < fw->targets[i]->nmachines; j++) {\n            if (g_pattern_match_simple(fw->targets[i]->machines[j], machine))\n                return true;\n        }\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareFetchParsedConfigs",
          "args": [
            "privileged",
            "&firmwares",
            "NULL"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareFetchParsedConfigs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "1183-1216",
          "snippet": "static ssize_t\nqemuFirmwareFetchParsedConfigs(bool privileged,\n                               qemuFirmwarePtr **firmwaresRet,\n                               char ***pathsRet)\n{\n    VIR_AUTOSTRINGLIST paths = NULL;\n    size_t npaths;\n    qemuFirmwarePtr *firmwares = NULL;\n    size_t i;\n\n    if (qemuFirmwareFetchConfigs(&paths, privileged) < 0)\n        return -1;\n\n    npaths = virStringListLength((const char **)paths);\n\n    if (VIR_ALLOC_N(firmwares, npaths) < 0)\n        return -1;\n\n    for (i = 0; i < npaths; i++) {\n        if (!(firmwares[i] = qemuFirmwareParse(paths[i])))\n            goto error;\n    }\n\n    *firmwaresRet = g_steal_pointer(&firmwares);\n    if (pathsRet)\n        *pathsRet = g_steal_pointer(&paths);\n    return npaths;\n\n error:\n    while (i > 0)\n        qemuFirmwareFree(firmwares[--i]);\n    VIR_FREE(firmwares);\n    return -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic ssize_t\nqemuFirmwareFetchParsedConfigs(bool privileged,\n                               qemuFirmwarePtr **firmwaresRet,\n                               char ***pathsRet)\n{\n    VIR_AUTOSTRINGLIST paths = NULL;\n    size_t npaths;\n    qemuFirmwarePtr *firmwares = NULL;\n    size_t i;\n\n    if (qemuFirmwareFetchConfigs(&paths, privileged) < 0)\n        return -1;\n\n    npaths = virStringListLength((const char **)paths);\n\n    if (VIR_ALLOC_N(firmwares, npaths) < 0)\n        return -1;\n\n    for (i = 0; i < npaths; i++) {\n        if (!(firmwares[i] = qemuFirmwareParse(paths[i])))\n            goto error;\n    }\n\n    *firmwaresRet = g_steal_pointer(&firmwares);\n    if (pathsRet)\n        *pathsRet = g_steal_pointer(&paths);\n    return npaths;\n\n error:\n    while (i > 0)\n        qemuFirmwareFree(firmwares[--i]);\n    VIR_FREE(firmwares);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nint\nqemuFirmwareGetSupported(const char *machine,\n                         virArch arch,\n                         bool privileged,\n                         uint64_t *supported,\n                         bool *secure,\n                         virFirmwarePtr **fws,\n                         size_t *nfws)\n{\n    qemuFirmwarePtr *firmwares = NULL;\n    ssize_t nfirmwares = 0;\n    size_t i;\n\n    *supported = VIR_DOMAIN_OS_DEF_FIRMWARE_NONE;\n    *secure = false;\n\n    if (fws) {\n        *fws = NULL;\n        *nfws = 0;\n    }\n\n    if ((nfirmwares = qemuFirmwareFetchParsedConfigs(privileged,\n                                                     &firmwares, NULL)) < 0)\n        return -1;\n\n    for (i = 0; i < nfirmwares; i++) {\n        qemuFirmwarePtr fw = firmwares[i];\n        const qemuFirmwareMappingFlash *flash = &fw->mapping.data.flash;\n        const qemuFirmwareMappingMemory *memory = &fw->mapping.data.memory;\n        const char *fwpath = NULL;\n        const char *nvrampath = NULL;\n        size_t j;\n\n        if (!qemuFirmwareMatchesMachineArch(fw, machine, arch))\n            continue;\n\n        for (j = 0; j < fw->ninterfaces; j++) {\n            switch (fw->interfaces[j]) {\n            case QEMU_FIRMWARE_OS_INTERFACE_UEFI:\n                *supported |= 1ULL << VIR_DOMAIN_OS_DEF_FIRMWARE_EFI;\n                break;\n            case QEMU_FIRMWARE_OS_INTERFACE_BIOS:\n                *supported |= 1ULL << VIR_DOMAIN_OS_DEF_FIRMWARE_BIOS;\n                break;\n            case QEMU_FIRMWARE_OS_INTERFACE_NONE:\n            case QEMU_FIRMWARE_OS_INTERFACE_OPENFIRMWARE:\n            case QEMU_FIRMWARE_OS_INTERFACE_UBOOT:\n            case QEMU_FIRMWARE_OS_INTERFACE_LAST:\n            default:\n                break;\n            }\n        }\n\n        for (j = 0; j < fw->nfeatures; j++) {\n            switch (fw->features[j]) {\n            case QEMU_FIRMWARE_FEATURE_REQUIRES_SMM:\n                *secure = true;\n                break;\n            case QEMU_FIRMWARE_FEATURE_NONE:\n            case QEMU_FIRMWARE_FEATURE_ACPI_S3:\n            case QEMU_FIRMWARE_FEATURE_ACPI_S4:\n            case QEMU_FIRMWARE_FEATURE_AMD_SEV:\n            case QEMU_FIRMWARE_FEATURE_ENROLLED_KEYS:\n            case QEMU_FIRMWARE_FEATURE_SECURE_BOOT:\n            case QEMU_FIRMWARE_FEATURE_VERBOSE_DYNAMIC:\n            case QEMU_FIRMWARE_FEATURE_VERBOSE_STATIC:\n            case QEMU_FIRMWARE_FEATURE_LAST:\n                break;\n            }\n        }\n\n        switch (fw->mapping.device) {\n        case QEMU_FIRMWARE_DEVICE_FLASH:\n            fwpath = flash->executable.filename;\n            nvrampath = flash->nvram_template.filename;\n            break;\n\n        case QEMU_FIRMWARE_DEVICE_MEMORY:\n            fwpath = memory->filename;\n            break;\n\n        case QEMU_FIRMWARE_DEVICE_KERNEL:\n        case QEMU_FIRMWARE_DEVICE_NONE:\n        case QEMU_FIRMWARE_DEVICE_LAST:\n            break;\n        }\n\n        if (fws && fwpath) {\n            g_autoptr(virFirmware) tmp = NULL;\n\n            /* Append only unique pairs. */\n            for (j = 0; j < *nfws; j++) {\n                if (STREQ((*fws)[j]->name, fwpath) &&\n                    STREQ_NULLABLE((*fws)[j]->nvram, nvrampath))\n                    break;\n            }\n\n            if (j == *nfws) {\n                if (VIR_ALLOC(tmp) < 0)\n                    return -1;\n\n                tmp->name = g_strdup(fwpath);\n                tmp->nvram = g_strdup(nvrampath);\n                if (VIR_APPEND_ELEMENT(*fws, *nfws, tmp) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    if (fws && !*fws && nfirmwares &&\n        VIR_REALLOC_N(*fws, 0) < 0)\n        return -1;\n\n    for (i = 0; i < nfirmwares; i++)\n        qemuFirmwareFree(firmwares[i]);\n    VIR_FREE(firmwares);\n    return 0;\n}"
  },
  {
    "function_name": "qemuFirmwareFillDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "1219-1295",
    "snippet": "int\nqemuFirmwareFillDomain(virQEMUDriverPtr driver,\n                       virDomainDefPtr def,\n                       unsigned int flags)\n{\n    VIR_AUTOSTRINGLIST paths = NULL;\n    qemuFirmwarePtr *firmwares = NULL;\n    ssize_t nfirmwares = 0;\n    const qemuFirmware *theone = NULL;\n    bool needResult = true;\n    size_t i;\n    int ret = -1;\n\n    if (!(flags & VIR_QEMU_PROCESS_START_NEW))\n        return 0;\n\n    /* Fill in FW paths if either os.firmware is enabled, or\n     * loader path was provided with no nvram varstore. */\n    if (def->os.firmware == VIR_DOMAIN_OS_DEF_FIRMWARE_NONE) {\n        /* This is horrific check, but loosely said, if UEFI\n         * image was provided by the old method (by specifying\n         * its path in domain XML) but no template for NVRAM was\n         * specified and the varstore doesn't exist ... */\n        if (!virDomainDefHasOldStyleROUEFI(def) ||\n            def->os.loader->templt ||\n            virFileExists(def->os.loader->nvram))\n            return 0;\n\n        /* ... then we want to consult JSON FW descriptors first,\n         * but we don't want to fail if we haven't found a match. */\n        needResult = false;\n    }\n\n    if ((nfirmwares = qemuFirmwareFetchParsedConfigs(driver->privileged,\n                                                     &firmwares, &paths)) < 0)\n        return -1;\n\n    for (i = 0; i < nfirmwares; i++) {\n        if (qemuFirmwareMatchDomain(def, firmwares[i], paths[i])) {\n            theone = firmwares[i];\n            VIR_DEBUG(\"Found matching firmware (description path '%s')\",\n                      paths[i]);\n            break;\n        }\n    }\n\n    if (!theone) {\n        if (needResult) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Unable to find any firmware to satisfy '%s'\"),\n                           virDomainOsDefFirmwareTypeToString(def->os.firmware));\n        } else {\n            VIR_DEBUG(\"Unable to find NVRAM template for '%s', \"\n                      \"falling back to old style\",\n                      NULLSTR(def->os.loader ? def->os.loader->path : NULL));\n            ret = 0;\n        }\n        goto cleanup;\n    }\n\n    /* Firstly, let's do some sanity checks. If either of these\n     * fail we can still start the domain successfully, but it's\n     * likely that admin/FW manufacturer messed up. */\n    qemuFirmwareSanityCheck(theone, paths[i]);\n\n    if (qemuFirmwareEnableFeatures(driver, def, theone) < 0)\n        goto cleanup;\n\n    def->os.firmware = VIR_DOMAIN_OS_DEF_FIRMWARE_NONE;\n\n    ret = 0;\n cleanup:\n    for (i = 0; i < nfirmwares; i++)\n        qemuFirmwareFree(firmwares[i]);\n    VIR_FREE(firmwares);\n    return ret;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "firmwares"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuFirmwareFree",
          "args": [
            "firmwares[i]"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "265-281",
          "snippet": "void\nqemuFirmwareFree(qemuFirmwarePtr fw)\n{\n    size_t i;\n\n    if (!fw)\n        return;\n\n    qemuFirmwareOSInterfaceFree(fw->interfaces);\n    qemuFirmwareMappingFree(fw->mapping);\n    for (i = 0; i < fw->ntargets; i++)\n        qemuFirmwareTargetFree(fw->targets[i]);\n    VIR_FREE(fw->targets);\n    qemuFirmwareFeatureFree(fw->features);\n\n    VIR_FREE(fw);\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nvoid\nqemuFirmwareFree(qemuFirmwarePtr fw)\n{\n    size_t i;\n\n    if (!fw)\n        return;\n\n    qemuFirmwareOSInterfaceFree(fw->interfaces);\n    qemuFirmwareMappingFree(fw->mapping);\n    for (i = 0; i < fw->ntargets; i++)\n        qemuFirmwareTargetFree(fw->targets[i]);\n    VIR_FREE(fw->targets);\n    qemuFirmwareFeatureFree(fw->features);\n\n    VIR_FREE(fw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareEnableFeatures",
          "args": [
            "driver",
            "def",
            "theone"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareEnableFeatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "1033-1140",
          "snippet": "static int\nqemuFirmwareEnableFeatures(virQEMUDriverPtr driver,\n                           virDomainDefPtr def,\n                           const qemuFirmware *fw)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    const qemuFirmwareMappingFlash *flash = &fw->mapping.data.flash;\n    const qemuFirmwareMappingKernel *kernel = &fw->mapping.data.kernel;\n    const qemuFirmwareMappingMemory *memory = &fw->mapping.data.memory;\n    size_t i;\n\n    switch (fw->mapping.device) {\n    case QEMU_FIRMWARE_DEVICE_FLASH:\n        if (!def->os.loader &&\n            VIR_ALLOC(def->os.loader) < 0)\n            return -1;\n\n        def->os.loader->type = VIR_DOMAIN_LOADER_TYPE_PFLASH;\n        def->os.loader->readonly = VIR_TRISTATE_BOOL_YES;\n\n        if (STRNEQ(flash->executable.format, \"raw\")) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                           _(\"unsupported flash format '%s'\"),\n                           flash->executable.format);\n            return -1;\n        }\n\n        VIR_FREE(def->os.loader->path);\n        def->os.loader->path = g_strdup(flash->executable.filename);\n\n        if (STRNEQ(flash->nvram_template.format, \"raw\")) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                           _(\"unsupported nvram template format '%s'\"),\n                           flash->nvram_template.format);\n            return -1;\n        }\n\n        VIR_FREE(def->os.loader->templt);\n        def->os.loader->templt = g_strdup(flash->nvram_template.filename);\n\n        qemuDomainNVRAMPathGenerate(cfg, def);\n\n        VIR_DEBUG(\"decided on firmware '%s' varstore template '%s'\",\n                  def->os.loader->path,\n                  def->os.loader->templt);\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_KERNEL:\n        VIR_FREE(def->os.kernel);\n        def->os.kernel = g_strdup(kernel->filename);\n\n        VIR_DEBUG(\"decided on kernel '%s'\",\n                  def->os.kernel);\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_MEMORY:\n        if (!def->os.loader &&\n            VIR_ALLOC(def->os.loader) < 0)\n            return -1;\n\n        def->os.loader->type = VIR_DOMAIN_LOADER_TYPE_ROM;\n        def->os.loader->path = g_strdup(memory->filename);\n\n        VIR_DEBUG(\"decided on loader '%s'\",\n                  def->os.loader->path);\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_NONE:\n    case QEMU_FIRMWARE_DEVICE_LAST:\n        break;\n    }\n\n    for (i = 0; i < fw->nfeatures; i++) {\n        switch (fw->features[i]) {\n        case QEMU_FIRMWARE_FEATURE_REQUIRES_SMM:\n            switch (def->features[VIR_DOMAIN_FEATURE_SMM]) {\n            case VIR_TRISTATE_SWITCH_OFF:\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"domain has SMM turned off \"\n                                 \"but chosen firmware requires it\"));\n                return -1;\n                break;\n            case VIR_TRISTATE_SWITCH_ABSENT:\n                VIR_DEBUG(\"Enabling SMM feature\");\n                def->features[VIR_DOMAIN_FEATURE_SMM] = VIR_TRISTATE_SWITCH_ON;\n                break;\n\n            case VIR_TRISTATE_SWITCH_ON:\n            case VIR_TRISTATE_SWITCH_LAST:\n                break;\n            }\n            break;\n\n        case QEMU_FIRMWARE_FEATURE_NONE:\n        case QEMU_FIRMWARE_FEATURE_ACPI_S3:\n        case QEMU_FIRMWARE_FEATURE_ACPI_S4:\n        case QEMU_FIRMWARE_FEATURE_AMD_SEV:\n        case QEMU_FIRMWARE_FEATURE_ENROLLED_KEYS:\n        case QEMU_FIRMWARE_FEATURE_SECURE_BOOT:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_DYNAMIC:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_STATIC:\n        case QEMU_FIRMWARE_FEATURE_LAST:\n            break;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareEnableFeatures(virQEMUDriverPtr driver,\n                           virDomainDefPtr def,\n                           const qemuFirmware *fw)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    const qemuFirmwareMappingFlash *flash = &fw->mapping.data.flash;\n    const qemuFirmwareMappingKernel *kernel = &fw->mapping.data.kernel;\n    const qemuFirmwareMappingMemory *memory = &fw->mapping.data.memory;\n    size_t i;\n\n    switch (fw->mapping.device) {\n    case QEMU_FIRMWARE_DEVICE_FLASH:\n        if (!def->os.loader &&\n            VIR_ALLOC(def->os.loader) < 0)\n            return -1;\n\n        def->os.loader->type = VIR_DOMAIN_LOADER_TYPE_PFLASH;\n        def->os.loader->readonly = VIR_TRISTATE_BOOL_YES;\n\n        if (STRNEQ(flash->executable.format, \"raw\")) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                           _(\"unsupported flash format '%s'\"),\n                           flash->executable.format);\n            return -1;\n        }\n\n        VIR_FREE(def->os.loader->path);\n        def->os.loader->path = g_strdup(flash->executable.filename);\n\n        if (STRNEQ(flash->nvram_template.format, \"raw\")) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                           _(\"unsupported nvram template format '%s'\"),\n                           flash->nvram_template.format);\n            return -1;\n        }\n\n        VIR_FREE(def->os.loader->templt);\n        def->os.loader->templt = g_strdup(flash->nvram_template.filename);\n\n        qemuDomainNVRAMPathGenerate(cfg, def);\n\n        VIR_DEBUG(\"decided on firmware '%s' varstore template '%s'\",\n                  def->os.loader->path,\n                  def->os.loader->templt);\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_KERNEL:\n        VIR_FREE(def->os.kernel);\n        def->os.kernel = g_strdup(kernel->filename);\n\n        VIR_DEBUG(\"decided on kernel '%s'\",\n                  def->os.kernel);\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_MEMORY:\n        if (!def->os.loader &&\n            VIR_ALLOC(def->os.loader) < 0)\n            return -1;\n\n        def->os.loader->type = VIR_DOMAIN_LOADER_TYPE_ROM;\n        def->os.loader->path = g_strdup(memory->filename);\n\n        VIR_DEBUG(\"decided on loader '%s'\",\n                  def->os.loader->path);\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_NONE:\n    case QEMU_FIRMWARE_DEVICE_LAST:\n        break;\n    }\n\n    for (i = 0; i < fw->nfeatures; i++) {\n        switch (fw->features[i]) {\n        case QEMU_FIRMWARE_FEATURE_REQUIRES_SMM:\n            switch (def->features[VIR_DOMAIN_FEATURE_SMM]) {\n            case VIR_TRISTATE_SWITCH_OFF:\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"domain has SMM turned off \"\n                                 \"but chosen firmware requires it\"));\n                return -1;\n                break;\n            case VIR_TRISTATE_SWITCH_ABSENT:\n                VIR_DEBUG(\"Enabling SMM feature\");\n                def->features[VIR_DOMAIN_FEATURE_SMM] = VIR_TRISTATE_SWITCH_ON;\n                break;\n\n            case VIR_TRISTATE_SWITCH_ON:\n            case VIR_TRISTATE_SWITCH_LAST:\n                break;\n            }\n            break;\n\n        case QEMU_FIRMWARE_FEATURE_NONE:\n        case QEMU_FIRMWARE_FEATURE_ACPI_S3:\n        case QEMU_FIRMWARE_FEATURE_ACPI_S4:\n        case QEMU_FIRMWARE_FEATURE_AMD_SEV:\n        case QEMU_FIRMWARE_FEATURE_ENROLLED_KEYS:\n        case QEMU_FIRMWARE_FEATURE_SECURE_BOOT:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_DYNAMIC:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_STATIC:\n        case QEMU_FIRMWARE_FEATURE_LAST:\n            break;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareSanityCheck",
          "args": [
            "theone",
            "paths[i]"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareSanityCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "1143-1180",
          "snippet": "static void\nqemuFirmwareSanityCheck(const qemuFirmware *fw,\n                        const char *filename)\n{\n    size_t i;\n    bool requiresSMM = false;\n    bool supportsSecureBoot = false;\n\n    for (i = 0; i < fw->nfeatures; i++) {\n        switch (fw->features[i]) {\n        case QEMU_FIRMWARE_FEATURE_REQUIRES_SMM:\n            requiresSMM = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_SECURE_BOOT:\n            supportsSecureBoot = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_NONE:\n        case QEMU_FIRMWARE_FEATURE_ACPI_S3:\n        case QEMU_FIRMWARE_FEATURE_ACPI_S4:\n        case QEMU_FIRMWARE_FEATURE_AMD_SEV:\n        case QEMU_FIRMWARE_FEATURE_ENROLLED_KEYS:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_DYNAMIC:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_STATIC:\n        case QEMU_FIRMWARE_FEATURE_LAST:\n            break;\n        }\n    }\n\n    if (supportsSecureBoot != requiresSMM) {\n        VIR_WARN(\"Firmware description '%s' has invalid set of features: \"\n                 \"%s = %d, %s = %d\",\n                 filename,\n                 qemuFirmwareFeatureTypeToString(QEMU_FIRMWARE_FEATURE_REQUIRES_SMM),\n                 requiresSMM,\n                 qemuFirmwareFeatureTypeToString(QEMU_FIRMWARE_FEATURE_SECURE_BOOT),\n                 supportsSecureBoot);\n    }\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareSanityCheck(const qemuFirmware *fw,\n                        const char *filename)\n{\n    size_t i;\n    bool requiresSMM = false;\n    bool supportsSecureBoot = false;\n\n    for (i = 0; i < fw->nfeatures; i++) {\n        switch (fw->features[i]) {\n        case QEMU_FIRMWARE_FEATURE_REQUIRES_SMM:\n            requiresSMM = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_SECURE_BOOT:\n            supportsSecureBoot = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_NONE:\n        case QEMU_FIRMWARE_FEATURE_ACPI_S3:\n        case QEMU_FIRMWARE_FEATURE_ACPI_S4:\n        case QEMU_FIRMWARE_FEATURE_AMD_SEV:\n        case QEMU_FIRMWARE_FEATURE_ENROLLED_KEYS:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_DYNAMIC:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_STATIC:\n        case QEMU_FIRMWARE_FEATURE_LAST:\n            break;\n        }\n    }\n\n    if (supportsSecureBoot != requiresSMM) {\n        VIR_WARN(\"Firmware description '%s' has invalid set of features: \"\n                 \"%s = %d, %s = %d\",\n                 filename,\n                 qemuFirmwareFeatureTypeToString(QEMU_FIRMWARE_FEATURE_REQUIRES_SMM),\n                 requiresSMM,\n                 qemuFirmwareFeatureTypeToString(QEMU_FIRMWARE_FEATURE_SECURE_BOOT),\n                 supportsSecureBoot);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Unable to find NVRAM template for '%s', \"\n                      \"falling back to old style\"",
            "NULLSTR(def->os.loader ? def->os.loader->path : NULL)"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "def->os.loader ? def->os.loader->path : NULL"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Unable to find any firmware to satisfy '%s'\")",
            "virDomainOsDefFirmwareTypeToString(def->os.firmware)"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainOsDefFirmwareTypeToString",
          "args": [
            "def->os.firmware"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to find any firmware to satisfy '%s'\""
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Found matching firmware (description path '%s')\"",
            "paths[i]"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuFirmwareMatchDomain",
          "args": [
            "def",
            "firmwares[i]",
            "paths[i]"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareMatchDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "932-1030",
          "snippet": "static bool\nqemuFirmwareMatchDomain(const virDomainDef *def,\n                        const qemuFirmware *fw,\n                        const char *path)\n{\n    size_t i;\n    qemuFirmwareOSInterface want;\n    bool supportsS3 = false;\n    bool supportsS4 = false;\n    bool requiresSMM = false;\n    bool supportsSEV = false;\n\n    want = qemuFirmwareOSInterfaceTypeFromOsDefFirmware(def->os.firmware);\n\n    if (want == QEMU_FIRMWARE_OS_INTERFACE_NONE &&\n        def->os.loader) {\n        want = qemuFirmwareOSInterfaceTypeFromOsDefFirmware(def->os.loader->type);\n\n        if (fw->mapping.device != QEMU_FIRMWARE_DEVICE_FLASH ||\n            STRNEQ(def->os.loader->path, fw->mapping.data.flash.executable.filename)) {\n            VIR_DEBUG(\"Not matching FW interface %s or loader \"\n                      \"path '%s' for user provided path '%s'\",\n                      qemuFirmwareDeviceTypeToString(fw->mapping.device),\n                      fw->mapping.data.flash.executable.filename,\n                      def->os.loader->path);\n            return false;\n        }\n    }\n\n    for (i = 0; i < fw->ninterfaces; i++) {\n        if (fw->interfaces[i] == want)\n            break;\n    }\n\n    if (i == fw->ninterfaces) {\n        VIR_DEBUG(\"No matching interface in '%s'\", path);\n        return false;\n    }\n\n    if (!qemuFirmwareMatchesMachineArch(fw, def->os.machine, def->os.arch)) {\n        VIR_DEBUG(\"No matching machine type in '%s'\", path);\n        return false;\n    }\n\n    for (i = 0; i < fw->nfeatures; i++) {\n        switch (fw->features[i]) {\n        case QEMU_FIRMWARE_FEATURE_ACPI_S3:\n            supportsS3 = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_ACPI_S4:\n            supportsS4 = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_AMD_SEV:\n            supportsSEV = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_REQUIRES_SMM:\n            requiresSMM = true;\n            break;\n\n        case QEMU_FIRMWARE_FEATURE_SECURE_BOOT:\n        case QEMU_FIRMWARE_FEATURE_ENROLLED_KEYS:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_DYNAMIC:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_STATIC:\n        case QEMU_FIRMWARE_FEATURE_NONE:\n        case QEMU_FIRMWARE_FEATURE_LAST:\n            break;\n        }\n    }\n\n    if (def->pm.s3 == VIR_TRISTATE_BOOL_YES &&\n        !supportsS3) {\n        VIR_DEBUG(\"Domain requires S3, firmware '%s' doesn't support it\", path);\n        return false;\n    }\n\n    if (def->pm.s4 == VIR_TRISTATE_BOOL_YES &&\n        !supportsS4) {\n        VIR_DEBUG(\"Domain requires S4, firmware '%s' doesn't support it\", path);\n        return false;\n    }\n\n    if (def->os.loader &&\n        def->os.loader->secure == VIR_TRISTATE_BOOL_YES &&\n        !requiresSMM) {\n        VIR_DEBUG(\"Domain restricts pflash programming to SMM, \"\n                  \"but firmware '%s' doesn't support SMM\", path);\n        return false;\n    }\n\n    if (def->sev &&\n        def->sev->sectype == VIR_DOMAIN_LAUNCH_SECURITY_SEV &&\n        !supportsSEV) {\n        VIR_DEBUG(\"Domain requires SEV, firmware '%s' doesn't support it\", path);\n        return false;\n    }\n\n    VIR_DEBUG(\"Firmware '%s' matches domain requirements\", path);\n    return true;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic bool\nqemuFirmwareMatchDomain(const virDomainDef *def,\n                        const qemuFirmware *fw,\n                        const char *path)\n{\n    size_t i;\n    qemuFirmwareOSInterface want;\n    bool supportsS3 = false;\n    bool supportsS4 = false;\n    bool requiresSMM = false;\n    bool supportsSEV = false;\n\n    want = qemuFirmwareOSInterfaceTypeFromOsDefFirmware(def->os.firmware);\n\n    if (want == QEMU_FIRMWARE_OS_INTERFACE_NONE &&\n        def->os.loader) {\n        want = qemuFirmwareOSInterfaceTypeFromOsDefFirmware(def->os.loader->type);\n\n        if (fw->mapping.device != QEMU_FIRMWARE_DEVICE_FLASH ||\n            STRNEQ(def->os.loader->path, fw->mapping.data.flash.executable.filename)) {\n            VIR_DEBUG(\"Not matching FW interface %s or loader \"\n                      \"path '%s' for user provided path '%s'\",\n                      qemuFirmwareDeviceTypeToString(fw->mapping.device),\n                      fw->mapping.data.flash.executable.filename,\n                      def->os.loader->path);\n            return false;\n        }\n    }\n\n    for (i = 0; i < fw->ninterfaces; i++) {\n        if (fw->interfaces[i] == want)\n            break;\n    }\n\n    if (i == fw->ninterfaces) {\n        VIR_DEBUG(\"No matching interface in '%s'\", path);\n        return false;\n    }\n\n    if (!qemuFirmwareMatchesMachineArch(fw, def->os.machine, def->os.arch)) {\n        VIR_DEBUG(\"No matching machine type in '%s'\", path);\n        return false;\n    }\n\n    for (i = 0; i < fw->nfeatures; i++) {\n        switch (fw->features[i]) {\n        case QEMU_FIRMWARE_FEATURE_ACPI_S3:\n            supportsS3 = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_ACPI_S4:\n            supportsS4 = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_AMD_SEV:\n            supportsSEV = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_REQUIRES_SMM:\n            requiresSMM = true;\n            break;\n\n        case QEMU_FIRMWARE_FEATURE_SECURE_BOOT:\n        case QEMU_FIRMWARE_FEATURE_ENROLLED_KEYS:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_DYNAMIC:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_STATIC:\n        case QEMU_FIRMWARE_FEATURE_NONE:\n        case QEMU_FIRMWARE_FEATURE_LAST:\n            break;\n        }\n    }\n\n    if (def->pm.s3 == VIR_TRISTATE_BOOL_YES &&\n        !supportsS3) {\n        VIR_DEBUG(\"Domain requires S3, firmware '%s' doesn't support it\", path);\n        return false;\n    }\n\n    if (def->pm.s4 == VIR_TRISTATE_BOOL_YES &&\n        !supportsS4) {\n        VIR_DEBUG(\"Domain requires S4, firmware '%s' doesn't support it\", path);\n        return false;\n    }\n\n    if (def->os.loader &&\n        def->os.loader->secure == VIR_TRISTATE_BOOL_YES &&\n        !requiresSMM) {\n        VIR_DEBUG(\"Domain restricts pflash programming to SMM, \"\n                  \"but firmware '%s' doesn't support SMM\", path);\n        return false;\n    }\n\n    if (def->sev &&\n        def->sev->sectype == VIR_DOMAIN_LAUNCH_SECURITY_SEV &&\n        !supportsSEV) {\n        VIR_DEBUG(\"Domain requires SEV, firmware '%s' doesn't support it\", path);\n        return false;\n    }\n\n    VIR_DEBUG(\"Firmware '%s' matches domain requirements\", path);\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareFetchParsedConfigs",
          "args": [
            "driver->privileged",
            "&firmwares",
            "&paths"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareFetchParsedConfigs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "1183-1216",
          "snippet": "static ssize_t\nqemuFirmwareFetchParsedConfigs(bool privileged,\n                               qemuFirmwarePtr **firmwaresRet,\n                               char ***pathsRet)\n{\n    VIR_AUTOSTRINGLIST paths = NULL;\n    size_t npaths;\n    qemuFirmwarePtr *firmwares = NULL;\n    size_t i;\n\n    if (qemuFirmwareFetchConfigs(&paths, privileged) < 0)\n        return -1;\n\n    npaths = virStringListLength((const char **)paths);\n\n    if (VIR_ALLOC_N(firmwares, npaths) < 0)\n        return -1;\n\n    for (i = 0; i < npaths; i++) {\n        if (!(firmwares[i] = qemuFirmwareParse(paths[i])))\n            goto error;\n    }\n\n    *firmwaresRet = g_steal_pointer(&firmwares);\n    if (pathsRet)\n        *pathsRet = g_steal_pointer(&paths);\n    return npaths;\n\n error:\n    while (i > 0)\n        qemuFirmwareFree(firmwares[--i]);\n    VIR_FREE(firmwares);\n    return -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic ssize_t\nqemuFirmwareFetchParsedConfigs(bool privileged,\n                               qemuFirmwarePtr **firmwaresRet,\n                               char ***pathsRet)\n{\n    VIR_AUTOSTRINGLIST paths = NULL;\n    size_t npaths;\n    qemuFirmwarePtr *firmwares = NULL;\n    size_t i;\n\n    if (qemuFirmwareFetchConfigs(&paths, privileged) < 0)\n        return -1;\n\n    npaths = virStringListLength((const char **)paths);\n\n    if (VIR_ALLOC_N(firmwares, npaths) < 0)\n        return -1;\n\n    for (i = 0; i < npaths; i++) {\n        if (!(firmwares[i] = qemuFirmwareParse(paths[i])))\n            goto error;\n    }\n\n    *firmwaresRet = g_steal_pointer(&firmwares);\n    if (pathsRet)\n        *pathsRet = g_steal_pointer(&paths);\n    return npaths;\n\n error:\n    while (i > 0)\n        qemuFirmwareFree(firmwares[--i]);\n    VIR_FREE(firmwares);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "def->os.loader->nvram"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefHasOldStyleROUEFI",
          "args": [
            "def"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefHasOldStyleROUEFI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "32090-32095",
          "snippet": "bool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def)\n{\n    return virDomainDefHasOldStyleUEFI(def) &&\n           def->os.loader->readonly == VIR_TRISTATE_BOOL_YES;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def)\n{\n    return virDomainDefHasOldStyleUEFI(def) &&\n           def->os.loader->readonly == VIR_TRISTATE_BOOL_YES;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nint\nqemuFirmwareFillDomain(virQEMUDriverPtr driver,\n                       virDomainDefPtr def,\n                       unsigned int flags)\n{\n    VIR_AUTOSTRINGLIST paths = NULL;\n    qemuFirmwarePtr *firmwares = NULL;\n    ssize_t nfirmwares = 0;\n    const qemuFirmware *theone = NULL;\n    bool needResult = true;\n    size_t i;\n    int ret = -1;\n\n    if (!(flags & VIR_QEMU_PROCESS_START_NEW))\n        return 0;\n\n    /* Fill in FW paths if either os.firmware is enabled, or\n     * loader path was provided with no nvram varstore. */\n    if (def->os.firmware == VIR_DOMAIN_OS_DEF_FIRMWARE_NONE) {\n        /* This is horrific check, but loosely said, if UEFI\n         * image was provided by the old method (by specifying\n         * its path in domain XML) but no template for NVRAM was\n         * specified and the varstore doesn't exist ... */\n        if (!virDomainDefHasOldStyleROUEFI(def) ||\n            def->os.loader->templt ||\n            virFileExists(def->os.loader->nvram))\n            return 0;\n\n        /* ... then we want to consult JSON FW descriptors first,\n         * but we don't want to fail if we haven't found a match. */\n        needResult = false;\n    }\n\n    if ((nfirmwares = qemuFirmwareFetchParsedConfigs(driver->privileged,\n                                                     &firmwares, &paths)) < 0)\n        return -1;\n\n    for (i = 0; i < nfirmwares; i++) {\n        if (qemuFirmwareMatchDomain(def, firmwares[i], paths[i])) {\n            theone = firmwares[i];\n            VIR_DEBUG(\"Found matching firmware (description path '%s')\",\n                      paths[i]);\n            break;\n        }\n    }\n\n    if (!theone) {\n        if (needResult) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Unable to find any firmware to satisfy '%s'\"),\n                           virDomainOsDefFirmwareTypeToString(def->os.firmware));\n        } else {\n            VIR_DEBUG(\"Unable to find NVRAM template for '%s', \"\n                      \"falling back to old style\",\n                      NULLSTR(def->os.loader ? def->os.loader->path : NULL));\n            ret = 0;\n        }\n        goto cleanup;\n    }\n\n    /* Firstly, let's do some sanity checks. If either of these\n     * fail we can still start the domain successfully, but it's\n     * likely that admin/FW manufacturer messed up. */\n    qemuFirmwareSanityCheck(theone, paths[i]);\n\n    if (qemuFirmwareEnableFeatures(driver, def, theone) < 0)\n        goto cleanup;\n\n    def->os.firmware = VIR_DOMAIN_OS_DEF_FIRMWARE_NONE;\n\n    ret = 0;\n cleanup:\n    for (i = 0; i < nfirmwares; i++)\n        qemuFirmwareFree(firmwares[i]);\n    VIR_FREE(firmwares);\n    return ret;\n}"
  },
  {
    "function_name": "qemuFirmwareFetchParsedConfigs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "1183-1216",
    "snippet": "static ssize_t\nqemuFirmwareFetchParsedConfigs(bool privileged,\n                               qemuFirmwarePtr **firmwaresRet,\n                               char ***pathsRet)\n{\n    VIR_AUTOSTRINGLIST paths = NULL;\n    size_t npaths;\n    qemuFirmwarePtr *firmwares = NULL;\n    size_t i;\n\n    if (qemuFirmwareFetchConfigs(&paths, privileged) < 0)\n        return -1;\n\n    npaths = virStringListLength((const char **)paths);\n\n    if (VIR_ALLOC_N(firmwares, npaths) < 0)\n        return -1;\n\n    for (i = 0; i < npaths; i++) {\n        if (!(firmwares[i] = qemuFirmwareParse(paths[i])))\n            goto error;\n    }\n\n    *firmwaresRet = g_steal_pointer(&firmwares);\n    if (pathsRet)\n        *pathsRet = g_steal_pointer(&paths);\n    return npaths;\n\n error:\n    while (i > 0)\n        qemuFirmwareFree(firmwares[--i]);\n    VIR_FREE(firmwares);\n    return -1;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "firmwares"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuFirmwareFree",
          "args": [
            "firmwares[--i]"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "265-281",
          "snippet": "void\nqemuFirmwareFree(qemuFirmwarePtr fw)\n{\n    size_t i;\n\n    if (!fw)\n        return;\n\n    qemuFirmwareOSInterfaceFree(fw->interfaces);\n    qemuFirmwareMappingFree(fw->mapping);\n    for (i = 0; i < fw->ntargets; i++)\n        qemuFirmwareTargetFree(fw->targets[i]);\n    VIR_FREE(fw->targets);\n    qemuFirmwareFeatureFree(fw->features);\n\n    VIR_FREE(fw);\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nvoid\nqemuFirmwareFree(qemuFirmwarePtr fw)\n{\n    size_t i;\n\n    if (!fw)\n        return;\n\n    qemuFirmwareOSInterfaceFree(fw->interfaces);\n    qemuFirmwareMappingFree(fw->mapping);\n    for (i = 0; i < fw->ntargets; i++)\n        qemuFirmwareTargetFree(fw->targets[i]);\n    VIR_FREE(fw->targets);\n    qemuFirmwareFeatureFree(fw->features);\n\n    VIR_FREE(fw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&paths"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&firmwares"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuFirmwareParse",
          "args": [
            "paths[i]"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "611-644",
          "snippet": "qemuFirmwarePtr\nqemuFirmwareParse(const char *path)\n{\n    g_autofree char *cont = NULL;\n    g_autoptr(virJSONValue) doc = NULL;\n    g_autoptr(qemuFirmware) fw = NULL;\n\n    if (virFileReadAll(path, DOCUMENT_SIZE, &cont) < 0)\n        return NULL;\n\n    if (!(doc = virJSONValueFromString(cont))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to parse json file '%s'\"),\n                       path);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareInterfaceParse(path, doc, fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareMappingParse(path, doc, fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareTargetParse(path, doc, fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareFeatureParse(path, doc, fw) < 0)\n        return NULL;\n\n    return g_steal_pointer(&fw);\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define DOCUMENT_SIZE (1024 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\n#define DOCUMENT_SIZE (1024 * 1024)\n\nqemuFirmwarePtr\nqemuFirmwareParse(const char *path)\n{\n    g_autofree char *cont = NULL;\n    g_autoptr(virJSONValue) doc = NULL;\n    g_autoptr(qemuFirmware) fw = NULL;\n\n    if (virFileReadAll(path, DOCUMENT_SIZE, &cont) < 0)\n        return NULL;\n\n    if (!(doc = virJSONValueFromString(cont))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to parse json file '%s'\"),\n                       path);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareInterfaceParse(path, doc, fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareMappingParse(path, doc, fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareTargetParse(path, doc, fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareFeatureParse(path, doc, fw) < 0)\n        return NULL;\n\n    return g_steal_pointer(&fw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "firmwares",
            "npaths"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListLength",
          "args": [
            "(const char **)paths"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "893-901",
          "snippet": "size_t virStringListLength(const char * const *strings)\n{\n    size_t i = 0;\n\n    while (strings && strings[i])\n        i++;\n\n    return i;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nsize_t virStringListLength(const char * const *strings)\n{\n    size_t i = 0;\n\n    while (strings && strings[i])\n        i++;\n\n    return i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareFetchConfigs",
          "args": [
            "&paths",
            "privileged"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareFetchConfigs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "884-889",
          "snippet": "int\nqemuFirmwareFetchConfigs(char ***firmwares,\n                         bool privileged)\n{\n    return qemuInteropFetchConfigs(\"firmware\", firmwares, privileged);\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nint\nqemuFirmwareFetchConfigs(char ***firmwares,\n                         bool privileged)\n{\n    return qemuInteropFetchConfigs(\"firmware\", firmwares, privileged);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic ssize_t\nqemuFirmwareFetchParsedConfigs(bool privileged,\n                               qemuFirmwarePtr **firmwaresRet,\n                               char ***pathsRet)\n{\n    VIR_AUTOSTRINGLIST paths = NULL;\n    size_t npaths;\n    qemuFirmwarePtr *firmwares = NULL;\n    size_t i;\n\n    if (qemuFirmwareFetchConfigs(&paths, privileged) < 0)\n        return -1;\n\n    npaths = virStringListLength((const char **)paths);\n\n    if (VIR_ALLOC_N(firmwares, npaths) < 0)\n        return -1;\n\n    for (i = 0; i < npaths; i++) {\n        if (!(firmwares[i] = qemuFirmwareParse(paths[i])))\n            goto error;\n    }\n\n    *firmwaresRet = g_steal_pointer(&firmwares);\n    if (pathsRet)\n        *pathsRet = g_steal_pointer(&paths);\n    return npaths;\n\n error:\n    while (i > 0)\n        qemuFirmwareFree(firmwares[--i]);\n    VIR_FREE(firmwares);\n    return -1;\n}"
  },
  {
    "function_name": "qemuFirmwareSanityCheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "1143-1180",
    "snippet": "static void\nqemuFirmwareSanityCheck(const qemuFirmware *fw,\n                        const char *filename)\n{\n    size_t i;\n    bool requiresSMM = false;\n    bool supportsSecureBoot = false;\n\n    for (i = 0; i < fw->nfeatures; i++) {\n        switch (fw->features[i]) {\n        case QEMU_FIRMWARE_FEATURE_REQUIRES_SMM:\n            requiresSMM = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_SECURE_BOOT:\n            supportsSecureBoot = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_NONE:\n        case QEMU_FIRMWARE_FEATURE_ACPI_S3:\n        case QEMU_FIRMWARE_FEATURE_ACPI_S4:\n        case QEMU_FIRMWARE_FEATURE_AMD_SEV:\n        case QEMU_FIRMWARE_FEATURE_ENROLLED_KEYS:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_DYNAMIC:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_STATIC:\n        case QEMU_FIRMWARE_FEATURE_LAST:\n            break;\n        }\n    }\n\n    if (supportsSecureBoot != requiresSMM) {\n        VIR_WARN(\"Firmware description '%s' has invalid set of features: \"\n                 \"%s = %d, %s = %d\",\n                 filename,\n                 qemuFirmwareFeatureTypeToString(QEMU_FIRMWARE_FEATURE_REQUIRES_SMM),\n                 requiresSMM,\n                 qemuFirmwareFeatureTypeToString(QEMU_FIRMWARE_FEATURE_SECURE_BOOT),\n                 supportsSecureBoot);\n    }\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Firmware description '%s' has invalid set of features: \"\n                 \"%s = %d, %s = %d\"",
            "filename",
            "qemuFirmwareFeatureTypeToString(QEMU_FIRMWARE_FEATURE_REQUIRES_SMM)",
            "requiresSMM",
            "qemuFirmwareFeatureTypeToString(QEMU_FIRMWARE_FEATURE_SECURE_BOOT)",
            "supportsSecureBoot"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuFirmwareFeatureTypeToString",
          "args": [
            "QEMU_FIRMWARE_FEATURE_SECURE_BOOT"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuFirmwareFeatureTypeToString",
          "args": [
            "QEMU_FIRMWARE_FEATURE_REQUIRES_SMM"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareSanityCheck(const qemuFirmware *fw,\n                        const char *filename)\n{\n    size_t i;\n    bool requiresSMM = false;\n    bool supportsSecureBoot = false;\n\n    for (i = 0; i < fw->nfeatures; i++) {\n        switch (fw->features[i]) {\n        case QEMU_FIRMWARE_FEATURE_REQUIRES_SMM:\n            requiresSMM = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_SECURE_BOOT:\n            supportsSecureBoot = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_NONE:\n        case QEMU_FIRMWARE_FEATURE_ACPI_S3:\n        case QEMU_FIRMWARE_FEATURE_ACPI_S4:\n        case QEMU_FIRMWARE_FEATURE_AMD_SEV:\n        case QEMU_FIRMWARE_FEATURE_ENROLLED_KEYS:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_DYNAMIC:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_STATIC:\n        case QEMU_FIRMWARE_FEATURE_LAST:\n            break;\n        }\n    }\n\n    if (supportsSecureBoot != requiresSMM) {\n        VIR_WARN(\"Firmware description '%s' has invalid set of features: \"\n                 \"%s = %d, %s = %d\",\n                 filename,\n                 qemuFirmwareFeatureTypeToString(QEMU_FIRMWARE_FEATURE_REQUIRES_SMM),\n                 requiresSMM,\n                 qemuFirmwareFeatureTypeToString(QEMU_FIRMWARE_FEATURE_SECURE_BOOT),\n                 supportsSecureBoot);\n    }\n}"
  },
  {
    "function_name": "qemuFirmwareEnableFeatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "1033-1140",
    "snippet": "static int\nqemuFirmwareEnableFeatures(virQEMUDriverPtr driver,\n                           virDomainDefPtr def,\n                           const qemuFirmware *fw)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    const qemuFirmwareMappingFlash *flash = &fw->mapping.data.flash;\n    const qemuFirmwareMappingKernel *kernel = &fw->mapping.data.kernel;\n    const qemuFirmwareMappingMemory *memory = &fw->mapping.data.memory;\n    size_t i;\n\n    switch (fw->mapping.device) {\n    case QEMU_FIRMWARE_DEVICE_FLASH:\n        if (!def->os.loader &&\n            VIR_ALLOC(def->os.loader) < 0)\n            return -1;\n\n        def->os.loader->type = VIR_DOMAIN_LOADER_TYPE_PFLASH;\n        def->os.loader->readonly = VIR_TRISTATE_BOOL_YES;\n\n        if (STRNEQ(flash->executable.format, \"raw\")) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                           _(\"unsupported flash format '%s'\"),\n                           flash->executable.format);\n            return -1;\n        }\n\n        VIR_FREE(def->os.loader->path);\n        def->os.loader->path = g_strdup(flash->executable.filename);\n\n        if (STRNEQ(flash->nvram_template.format, \"raw\")) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                           _(\"unsupported nvram template format '%s'\"),\n                           flash->nvram_template.format);\n            return -1;\n        }\n\n        VIR_FREE(def->os.loader->templt);\n        def->os.loader->templt = g_strdup(flash->nvram_template.filename);\n\n        qemuDomainNVRAMPathGenerate(cfg, def);\n\n        VIR_DEBUG(\"decided on firmware '%s' varstore template '%s'\",\n                  def->os.loader->path,\n                  def->os.loader->templt);\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_KERNEL:\n        VIR_FREE(def->os.kernel);\n        def->os.kernel = g_strdup(kernel->filename);\n\n        VIR_DEBUG(\"decided on kernel '%s'\",\n                  def->os.kernel);\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_MEMORY:\n        if (!def->os.loader &&\n            VIR_ALLOC(def->os.loader) < 0)\n            return -1;\n\n        def->os.loader->type = VIR_DOMAIN_LOADER_TYPE_ROM;\n        def->os.loader->path = g_strdup(memory->filename);\n\n        VIR_DEBUG(\"decided on loader '%s'\",\n                  def->os.loader->path);\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_NONE:\n    case QEMU_FIRMWARE_DEVICE_LAST:\n        break;\n    }\n\n    for (i = 0; i < fw->nfeatures; i++) {\n        switch (fw->features[i]) {\n        case QEMU_FIRMWARE_FEATURE_REQUIRES_SMM:\n            switch (def->features[VIR_DOMAIN_FEATURE_SMM]) {\n            case VIR_TRISTATE_SWITCH_OFF:\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"domain has SMM turned off \"\n                                 \"but chosen firmware requires it\"));\n                return -1;\n                break;\n            case VIR_TRISTATE_SWITCH_ABSENT:\n                VIR_DEBUG(\"Enabling SMM feature\");\n                def->features[VIR_DOMAIN_FEATURE_SMM] = VIR_TRISTATE_SWITCH_ON;\n                break;\n\n            case VIR_TRISTATE_SWITCH_ON:\n            case VIR_TRISTATE_SWITCH_LAST:\n                break;\n            }\n            break;\n\n        case QEMU_FIRMWARE_FEATURE_NONE:\n        case QEMU_FIRMWARE_FEATURE_ACPI_S3:\n        case QEMU_FIRMWARE_FEATURE_ACPI_S4:\n        case QEMU_FIRMWARE_FEATURE_AMD_SEV:\n        case QEMU_FIRMWARE_FEATURE_ENROLLED_KEYS:\n        case QEMU_FIRMWARE_FEATURE_SECURE_BOOT:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_DYNAMIC:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_STATIC:\n        case QEMU_FIRMWARE_FEATURE_LAST:\n            break;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Enabling SMM feature\""
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"domain has SMM turned off \"\n                                 \"but chosen firmware requires it\")"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"domain has SMM turned off \"\n                                 \"but chosen firmware requires it\""
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"decided on loader '%s'\"",
            "def->os.loader->path"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "memory->filename"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def->os.loader"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"decided on kernel '%s'\"",
            "def->os.kernel"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->os.kernel"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"decided on firmware '%s' varstore template '%s'\"",
            "def->os.loader->path",
            "def->os.loader->templt"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainNVRAMPathGenerate",
          "args": [
            "cfg",
            "def"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainNVRAMPathGenerate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "16886-16893",
          "snippet": "void\nqemuDomainNVRAMPathGenerate(virQEMUDriverConfigPtr cfg,\n                            virDomainDefPtr def)\n{\n    if (virDomainDefHasOldStyleROUEFI(def) &&\n        !def->os.loader->nvram)\n        qemuDomainNVRAMPathFormat(cfg, def, &def->os.loader->nvram);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nvoid\nqemuDomainNVRAMPathGenerate(virQEMUDriverConfigPtr cfg,\n                            virDomainDefPtr def)\n{\n    if (virDomainDefHasOldStyleROUEFI(def) &&\n        !def->os.loader->nvram)\n        qemuDomainNVRAMPathFormat(cfg, def, &def->os.loader->nvram);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->os.loader->templt"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "_(\"unsupported nvram template format '%s'\")",
            "flash->nvram_template.format"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "flash->nvram_template.format",
            "\"raw\""
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->os.loader->path"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "_(\"unsupported flash format '%s'\")",
            "flash->executable.format"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "flash->executable.format",
            "\"raw\""
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def->os.loader"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareEnableFeatures(virQEMUDriverPtr driver,\n                           virDomainDefPtr def,\n                           const qemuFirmware *fw)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    const qemuFirmwareMappingFlash *flash = &fw->mapping.data.flash;\n    const qemuFirmwareMappingKernel *kernel = &fw->mapping.data.kernel;\n    const qemuFirmwareMappingMemory *memory = &fw->mapping.data.memory;\n    size_t i;\n\n    switch (fw->mapping.device) {\n    case QEMU_FIRMWARE_DEVICE_FLASH:\n        if (!def->os.loader &&\n            VIR_ALLOC(def->os.loader) < 0)\n            return -1;\n\n        def->os.loader->type = VIR_DOMAIN_LOADER_TYPE_PFLASH;\n        def->os.loader->readonly = VIR_TRISTATE_BOOL_YES;\n\n        if (STRNEQ(flash->executable.format, \"raw\")) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                           _(\"unsupported flash format '%s'\"),\n                           flash->executable.format);\n            return -1;\n        }\n\n        VIR_FREE(def->os.loader->path);\n        def->os.loader->path = g_strdup(flash->executable.filename);\n\n        if (STRNEQ(flash->nvram_template.format, \"raw\")) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                           _(\"unsupported nvram template format '%s'\"),\n                           flash->nvram_template.format);\n            return -1;\n        }\n\n        VIR_FREE(def->os.loader->templt);\n        def->os.loader->templt = g_strdup(flash->nvram_template.filename);\n\n        qemuDomainNVRAMPathGenerate(cfg, def);\n\n        VIR_DEBUG(\"decided on firmware '%s' varstore template '%s'\",\n                  def->os.loader->path,\n                  def->os.loader->templt);\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_KERNEL:\n        VIR_FREE(def->os.kernel);\n        def->os.kernel = g_strdup(kernel->filename);\n\n        VIR_DEBUG(\"decided on kernel '%s'\",\n                  def->os.kernel);\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_MEMORY:\n        if (!def->os.loader &&\n            VIR_ALLOC(def->os.loader) < 0)\n            return -1;\n\n        def->os.loader->type = VIR_DOMAIN_LOADER_TYPE_ROM;\n        def->os.loader->path = g_strdup(memory->filename);\n\n        VIR_DEBUG(\"decided on loader '%s'\",\n                  def->os.loader->path);\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_NONE:\n    case QEMU_FIRMWARE_DEVICE_LAST:\n        break;\n    }\n\n    for (i = 0; i < fw->nfeatures; i++) {\n        switch (fw->features[i]) {\n        case QEMU_FIRMWARE_FEATURE_REQUIRES_SMM:\n            switch (def->features[VIR_DOMAIN_FEATURE_SMM]) {\n            case VIR_TRISTATE_SWITCH_OFF:\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"domain has SMM turned off \"\n                                 \"but chosen firmware requires it\"));\n                return -1;\n                break;\n            case VIR_TRISTATE_SWITCH_ABSENT:\n                VIR_DEBUG(\"Enabling SMM feature\");\n                def->features[VIR_DOMAIN_FEATURE_SMM] = VIR_TRISTATE_SWITCH_ON;\n                break;\n\n            case VIR_TRISTATE_SWITCH_ON:\n            case VIR_TRISTATE_SWITCH_LAST:\n                break;\n            }\n            break;\n\n        case QEMU_FIRMWARE_FEATURE_NONE:\n        case QEMU_FIRMWARE_FEATURE_ACPI_S3:\n        case QEMU_FIRMWARE_FEATURE_ACPI_S4:\n        case QEMU_FIRMWARE_FEATURE_AMD_SEV:\n        case QEMU_FIRMWARE_FEATURE_ENROLLED_KEYS:\n        case QEMU_FIRMWARE_FEATURE_SECURE_BOOT:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_DYNAMIC:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_STATIC:\n        case QEMU_FIRMWARE_FEATURE_LAST:\n            break;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuFirmwareMatchDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "932-1030",
    "snippet": "static bool\nqemuFirmwareMatchDomain(const virDomainDef *def,\n                        const qemuFirmware *fw,\n                        const char *path)\n{\n    size_t i;\n    qemuFirmwareOSInterface want;\n    bool supportsS3 = false;\n    bool supportsS4 = false;\n    bool requiresSMM = false;\n    bool supportsSEV = false;\n\n    want = qemuFirmwareOSInterfaceTypeFromOsDefFirmware(def->os.firmware);\n\n    if (want == QEMU_FIRMWARE_OS_INTERFACE_NONE &&\n        def->os.loader) {\n        want = qemuFirmwareOSInterfaceTypeFromOsDefFirmware(def->os.loader->type);\n\n        if (fw->mapping.device != QEMU_FIRMWARE_DEVICE_FLASH ||\n            STRNEQ(def->os.loader->path, fw->mapping.data.flash.executable.filename)) {\n            VIR_DEBUG(\"Not matching FW interface %s or loader \"\n                      \"path '%s' for user provided path '%s'\",\n                      qemuFirmwareDeviceTypeToString(fw->mapping.device),\n                      fw->mapping.data.flash.executable.filename,\n                      def->os.loader->path);\n            return false;\n        }\n    }\n\n    for (i = 0; i < fw->ninterfaces; i++) {\n        if (fw->interfaces[i] == want)\n            break;\n    }\n\n    if (i == fw->ninterfaces) {\n        VIR_DEBUG(\"No matching interface in '%s'\", path);\n        return false;\n    }\n\n    if (!qemuFirmwareMatchesMachineArch(fw, def->os.machine, def->os.arch)) {\n        VIR_DEBUG(\"No matching machine type in '%s'\", path);\n        return false;\n    }\n\n    for (i = 0; i < fw->nfeatures; i++) {\n        switch (fw->features[i]) {\n        case QEMU_FIRMWARE_FEATURE_ACPI_S3:\n            supportsS3 = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_ACPI_S4:\n            supportsS4 = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_AMD_SEV:\n            supportsSEV = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_REQUIRES_SMM:\n            requiresSMM = true;\n            break;\n\n        case QEMU_FIRMWARE_FEATURE_SECURE_BOOT:\n        case QEMU_FIRMWARE_FEATURE_ENROLLED_KEYS:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_DYNAMIC:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_STATIC:\n        case QEMU_FIRMWARE_FEATURE_NONE:\n        case QEMU_FIRMWARE_FEATURE_LAST:\n            break;\n        }\n    }\n\n    if (def->pm.s3 == VIR_TRISTATE_BOOL_YES &&\n        !supportsS3) {\n        VIR_DEBUG(\"Domain requires S3, firmware '%s' doesn't support it\", path);\n        return false;\n    }\n\n    if (def->pm.s4 == VIR_TRISTATE_BOOL_YES &&\n        !supportsS4) {\n        VIR_DEBUG(\"Domain requires S4, firmware '%s' doesn't support it\", path);\n        return false;\n    }\n\n    if (def->os.loader &&\n        def->os.loader->secure == VIR_TRISTATE_BOOL_YES &&\n        !requiresSMM) {\n        VIR_DEBUG(\"Domain restricts pflash programming to SMM, \"\n                  \"but firmware '%s' doesn't support SMM\", path);\n        return false;\n    }\n\n    if (def->sev &&\n        def->sev->sectype == VIR_DOMAIN_LAUNCH_SECURITY_SEV &&\n        !supportsSEV) {\n        VIR_DEBUG(\"Domain requires SEV, firmware '%s' doesn't support it\", path);\n        return false;\n    }\n\n    VIR_DEBUG(\"Firmware '%s' matches domain requirements\", path);\n    return true;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Firmware '%s' matches domain requirements\"",
            "path"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Domain requires SEV, firmware '%s' doesn't support it\"",
            "path"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Domain restricts pflash programming to SMM, \"\n                  \"but firmware '%s' doesn't support SMM\"",
            "path"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Domain requires S4, firmware '%s' doesn't support it\"",
            "path"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Domain requires S3, firmware '%s' doesn't support it\"",
            "path"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"No matching machine type in '%s'\"",
            "path"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuFirmwareMatchesMachineArch",
          "args": [
            "fw",
            "def->os.machine",
            "def->os.arch"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareMatchesMachineArch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "892-912",
          "snippet": "static bool\nqemuFirmwareMatchesMachineArch(const qemuFirmware *fw,\n                               const char *machine,\n                               virArch arch)\n{\n    size_t i;\n\n    for (i = 0; i < fw->ntargets; i++) {\n        size_t j;\n\n        if (arch != fw->targets[i]->architecture)\n            continue;\n\n        for (j = 0; j < fw->targets[i]->nmachines; j++) {\n            if (g_pattern_match_simple(fw->targets[i]->machines[j], machine))\n                return true;\n        }\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic bool\nqemuFirmwareMatchesMachineArch(const qemuFirmware *fw,\n                               const char *machine,\n                               virArch arch)\n{\n    size_t i;\n\n    for (i = 0; i < fw->ntargets; i++) {\n        size_t j;\n\n        if (arch != fw->targets[i]->architecture)\n            continue;\n\n        for (j = 0; j < fw->targets[i]->nmachines; j++) {\n            if (g_pattern_match_simple(fw->targets[i]->machines[j], machine))\n                return true;\n        }\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"No matching interface in '%s'\"",
            "path"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Not matching FW interface %s or loader \"\n                      \"path '%s' for user provided path '%s'\"",
            "qemuFirmwareDeviceTypeToString(fw->mapping.device)",
            "fw->mapping.data.flash.executable.filename",
            "def->os.loader->path"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuFirmwareDeviceTypeToString",
          "args": [
            "fw->mapping.device"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "def->os.loader->path",
            "fw->mapping.data.flash.executable.filename"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuFirmwareOSInterfaceTypeFromOsDefFirmware",
          "args": [
            "def->os.loader->type"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareOSInterfaceTypeFromOsDefFirmware",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "915-929",
          "snippet": "static qemuFirmwareOSInterface\nqemuFirmwareOSInterfaceTypeFromOsDefFirmware(int fw)\n{\n    switch (fw) {\n    case VIR_DOMAIN_OS_DEF_FIRMWARE_BIOS:\n        return QEMU_FIRMWARE_OS_INTERFACE_BIOS;\n    case VIR_DOMAIN_OS_DEF_FIRMWARE_EFI:\n        return QEMU_FIRMWARE_OS_INTERFACE_UEFI;\n    case VIR_DOMAIN_OS_DEF_FIRMWARE_NONE:\n    case VIR_DOMAIN_OS_DEF_FIRMWARE_LAST:\n        break;\n    }\n\n    return QEMU_FIRMWARE_OS_INTERFACE_NONE;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic qemuFirmwareOSInterface\nqemuFirmwareOSInterfaceTypeFromOsDefFirmware(int fw)\n{\n    switch (fw) {\n    case VIR_DOMAIN_OS_DEF_FIRMWARE_BIOS:\n        return QEMU_FIRMWARE_OS_INTERFACE_BIOS;\n    case VIR_DOMAIN_OS_DEF_FIRMWARE_EFI:\n        return QEMU_FIRMWARE_OS_INTERFACE_UEFI;\n    case VIR_DOMAIN_OS_DEF_FIRMWARE_NONE:\n    case VIR_DOMAIN_OS_DEF_FIRMWARE_LAST:\n        break;\n    }\n\n    return QEMU_FIRMWARE_OS_INTERFACE_NONE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic bool\nqemuFirmwareMatchDomain(const virDomainDef *def,\n                        const qemuFirmware *fw,\n                        const char *path)\n{\n    size_t i;\n    qemuFirmwareOSInterface want;\n    bool supportsS3 = false;\n    bool supportsS4 = false;\n    bool requiresSMM = false;\n    bool supportsSEV = false;\n\n    want = qemuFirmwareOSInterfaceTypeFromOsDefFirmware(def->os.firmware);\n\n    if (want == QEMU_FIRMWARE_OS_INTERFACE_NONE &&\n        def->os.loader) {\n        want = qemuFirmwareOSInterfaceTypeFromOsDefFirmware(def->os.loader->type);\n\n        if (fw->mapping.device != QEMU_FIRMWARE_DEVICE_FLASH ||\n            STRNEQ(def->os.loader->path, fw->mapping.data.flash.executable.filename)) {\n            VIR_DEBUG(\"Not matching FW interface %s or loader \"\n                      \"path '%s' for user provided path '%s'\",\n                      qemuFirmwareDeviceTypeToString(fw->mapping.device),\n                      fw->mapping.data.flash.executable.filename,\n                      def->os.loader->path);\n            return false;\n        }\n    }\n\n    for (i = 0; i < fw->ninterfaces; i++) {\n        if (fw->interfaces[i] == want)\n            break;\n    }\n\n    if (i == fw->ninterfaces) {\n        VIR_DEBUG(\"No matching interface in '%s'\", path);\n        return false;\n    }\n\n    if (!qemuFirmwareMatchesMachineArch(fw, def->os.machine, def->os.arch)) {\n        VIR_DEBUG(\"No matching machine type in '%s'\", path);\n        return false;\n    }\n\n    for (i = 0; i < fw->nfeatures; i++) {\n        switch (fw->features[i]) {\n        case QEMU_FIRMWARE_FEATURE_ACPI_S3:\n            supportsS3 = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_ACPI_S4:\n            supportsS4 = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_AMD_SEV:\n            supportsSEV = true;\n            break;\n        case QEMU_FIRMWARE_FEATURE_REQUIRES_SMM:\n            requiresSMM = true;\n            break;\n\n        case QEMU_FIRMWARE_FEATURE_SECURE_BOOT:\n        case QEMU_FIRMWARE_FEATURE_ENROLLED_KEYS:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_DYNAMIC:\n        case QEMU_FIRMWARE_FEATURE_VERBOSE_STATIC:\n        case QEMU_FIRMWARE_FEATURE_NONE:\n        case QEMU_FIRMWARE_FEATURE_LAST:\n            break;\n        }\n    }\n\n    if (def->pm.s3 == VIR_TRISTATE_BOOL_YES &&\n        !supportsS3) {\n        VIR_DEBUG(\"Domain requires S3, firmware '%s' doesn't support it\", path);\n        return false;\n    }\n\n    if (def->pm.s4 == VIR_TRISTATE_BOOL_YES &&\n        !supportsS4) {\n        VIR_DEBUG(\"Domain requires S4, firmware '%s' doesn't support it\", path);\n        return false;\n    }\n\n    if (def->os.loader &&\n        def->os.loader->secure == VIR_TRISTATE_BOOL_YES &&\n        !requiresSMM) {\n        VIR_DEBUG(\"Domain restricts pflash programming to SMM, \"\n                  \"but firmware '%s' doesn't support SMM\", path);\n        return false;\n    }\n\n    if (def->sev &&\n        def->sev->sectype == VIR_DOMAIN_LAUNCH_SECURITY_SEV &&\n        !supportsSEV) {\n        VIR_DEBUG(\"Domain requires SEV, firmware '%s' doesn't support it\", path);\n        return false;\n    }\n\n    VIR_DEBUG(\"Firmware '%s' matches domain requirements\", path);\n    return true;\n}"
  },
  {
    "function_name": "qemuFirmwareOSInterfaceTypeFromOsDefFirmware",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "915-929",
    "snippet": "static qemuFirmwareOSInterface\nqemuFirmwareOSInterfaceTypeFromOsDefFirmware(int fw)\n{\n    switch (fw) {\n    case VIR_DOMAIN_OS_DEF_FIRMWARE_BIOS:\n        return QEMU_FIRMWARE_OS_INTERFACE_BIOS;\n    case VIR_DOMAIN_OS_DEF_FIRMWARE_EFI:\n        return QEMU_FIRMWARE_OS_INTERFACE_UEFI;\n    case VIR_DOMAIN_OS_DEF_FIRMWARE_NONE:\n    case VIR_DOMAIN_OS_DEF_FIRMWARE_LAST:\n        break;\n    }\n\n    return QEMU_FIRMWARE_OS_INTERFACE_NONE;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic qemuFirmwareOSInterface\nqemuFirmwareOSInterfaceTypeFromOsDefFirmware(int fw)\n{\n    switch (fw) {\n    case VIR_DOMAIN_OS_DEF_FIRMWARE_BIOS:\n        return QEMU_FIRMWARE_OS_INTERFACE_BIOS;\n    case VIR_DOMAIN_OS_DEF_FIRMWARE_EFI:\n        return QEMU_FIRMWARE_OS_INTERFACE_UEFI;\n    case VIR_DOMAIN_OS_DEF_FIRMWARE_NONE:\n    case VIR_DOMAIN_OS_DEF_FIRMWARE_LAST:\n        break;\n    }\n\n    return QEMU_FIRMWARE_OS_INTERFACE_NONE;\n}"
  },
  {
    "function_name": "qemuFirmwareMatchesMachineArch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "892-912",
    "snippet": "static bool\nqemuFirmwareMatchesMachineArch(const qemuFirmware *fw,\n                               const char *machine,\n                               virArch arch)\n{\n    size_t i;\n\n    for (i = 0; i < fw->ntargets; i++) {\n        size_t j;\n\n        if (arch != fw->targets[i]->architecture)\n            continue;\n\n        for (j = 0; j < fw->targets[i]->nmachines; j++) {\n            if (g_pattern_match_simple(fw->targets[i]->machines[j], machine))\n                return true;\n        }\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_pattern_match_simple",
          "args": [
            "fw->targets[i]->machines[j]",
            "machine"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic bool\nqemuFirmwareMatchesMachineArch(const qemuFirmware *fw,\n                               const char *machine,\n                               virArch arch)\n{\n    size_t i;\n\n    for (i = 0; i < fw->ntargets; i++) {\n        size_t j;\n\n        if (arch != fw->targets[i]->architecture)\n            continue;\n\n        for (j = 0; j < fw->targets[i]->nmachines; j++) {\n            if (g_pattern_match_simple(fw->targets[i]->machines[j], machine))\n                return true;\n        }\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "qemuFirmwareFetchConfigs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "884-889",
    "snippet": "int\nqemuFirmwareFetchConfigs(char ***firmwares,\n                         bool privileged)\n{\n    return qemuInteropFetchConfigs(\"firmware\", firmwares, privileged);\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuInteropFetchConfigs",
          "args": [
            "\"firmware\"",
            "firmwares",
            "privileged"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "qemuInteropFetchConfigs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_interop_config.c",
          "lines": "96-176",
          "snippet": "int\nqemuInteropFetchConfigs(const char *name,\n                        char ***configs,\n                        bool privileged)\n{\n    g_autoptr(virHashTable) files = NULL;\n    g_autofree char *homeConfig = NULL;\n    g_autofree char *xdgConfig = NULL;\n    g_autofree char *sysLocation = virFileBuildPath(QEMU_SYSTEM_LOCATION, name, NULL);\n    g_autofree char *etcLocation = virFileBuildPath(QEMU_ETC_LOCATION, name, NULL);\n    g_autofree virHashKeyValuePairPtr pairs = NULL;\n    virHashKeyValuePairPtr tmp = NULL;\n\n    *configs = NULL;\n\n    if (!privileged) {\n        /* This is a slight divergence from the specification.\n         * Since the system daemon runs as root, it doesn't make\n         * much sense to parse files in root's home directory. It\n         * makes sense only for session daemon which runs under\n         * regular user. */\n        xdgConfig = g_strdup(getenv(\"XDG_CONFIG_HOME\"));\n\n        if (!xdgConfig) {\n            g_autofree char *home = virGetUserDirectory();\n\n            xdgConfig = g_strdup_printf(\"%s/.config\", home);\n        }\n\n        homeConfig = g_strdup_printf(\"%s/qemu/%s\", xdgConfig, name);\n    }\n\n    if (!(files = virHashCreate(10, virHashValueFree)))\n        return -1;\n\n    if (qemuBuildFileList(files, sysLocation) < 0)\n        return -1;\n\n    if (qemuBuildFileList(files, etcLocation) < 0)\n        return -1;\n\n    if (homeConfig &&\n        qemuBuildFileList(files, homeConfig) < 0)\n        return -1;\n\n    /* At this point, the @files hash table contains unique set of filenames\n     * where each filename (as key) has the highest priority full pathname\n     * associated with it. */\n\n    if (virHashSize(files) == 0)\n        return 0;\n\n    if (!(pairs = virHashGetItems(files, qemuConfigFilesSorter)))\n        return -1;\n\n    for (tmp = pairs; tmp->key; tmp++) {\n        const char *path = tmp->value;\n        off_t len;\n\n        if ((len = virFileLength(path, -1)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"unable to get size of '%s'\"),\n                                 path);\n            return -1;\n        }\n\n        VIR_DEBUG(\"%s description path '%s' len=%jd\",\n                  name, path, (intmax_t) len);\n\n        if (len == 0) {\n            /* Empty files are used to mask less specific instances\n             * of the same file. */\n            continue;\n        }\n\n        if (virStringListAdd(configs, path) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define QEMU_ETC_LOCATION SYSCONFDIR \"/qemu\"",
            "#define QEMU_SYSTEM_LOCATION PREFIX \"/share/qemu\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include <config.h>\n\n#define QEMU_ETC_LOCATION SYSCONFDIR \"/qemu\"\n#define QEMU_SYSTEM_LOCATION PREFIX \"/share/qemu\"\n\nint\nqemuInteropFetchConfigs(const char *name,\n                        char ***configs,\n                        bool privileged)\n{\n    g_autoptr(virHashTable) files = NULL;\n    g_autofree char *homeConfig = NULL;\n    g_autofree char *xdgConfig = NULL;\n    g_autofree char *sysLocation = virFileBuildPath(QEMU_SYSTEM_LOCATION, name, NULL);\n    g_autofree char *etcLocation = virFileBuildPath(QEMU_ETC_LOCATION, name, NULL);\n    g_autofree virHashKeyValuePairPtr pairs = NULL;\n    virHashKeyValuePairPtr tmp = NULL;\n\n    *configs = NULL;\n\n    if (!privileged) {\n        /* This is a slight divergence from the specification.\n         * Since the system daemon runs as root, it doesn't make\n         * much sense to parse files in root's home directory. It\n         * makes sense only for session daemon which runs under\n         * regular user. */\n        xdgConfig = g_strdup(getenv(\"XDG_CONFIG_HOME\"));\n\n        if (!xdgConfig) {\n            g_autofree char *home = virGetUserDirectory();\n\n            xdgConfig = g_strdup_printf(\"%s/.config\", home);\n        }\n\n        homeConfig = g_strdup_printf(\"%s/qemu/%s\", xdgConfig, name);\n    }\n\n    if (!(files = virHashCreate(10, virHashValueFree)))\n        return -1;\n\n    if (qemuBuildFileList(files, sysLocation) < 0)\n        return -1;\n\n    if (qemuBuildFileList(files, etcLocation) < 0)\n        return -1;\n\n    if (homeConfig &&\n        qemuBuildFileList(files, homeConfig) < 0)\n        return -1;\n\n    /* At this point, the @files hash table contains unique set of filenames\n     * where each filename (as key) has the highest priority full pathname\n     * associated with it. */\n\n    if (virHashSize(files) == 0)\n        return 0;\n\n    if (!(pairs = virHashGetItems(files, qemuConfigFilesSorter)))\n        return -1;\n\n    for (tmp = pairs; tmp->key; tmp++) {\n        const char *path = tmp->value;\n        off_t len;\n\n        if ((len = virFileLength(path, -1)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"unable to get size of '%s'\"),\n                                 path);\n            return -1;\n        }\n\n        VIR_DEBUG(\"%s description path '%s' len=%jd\",\n                  name, path, (intmax_t) len);\n\n        if (len == 0) {\n            /* Empty files are used to mask less specific instances\n             * of the same file. */\n            continue;\n        }\n\n        if (virStringListAdd(configs, path) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nint\nqemuFirmwareFetchConfigs(char ***firmwares,\n                         bool privileged)\n{\n    return qemuInteropFetchConfigs(\"firmware\", firmwares, privileged);\n}"
  },
  {
    "function_name": "qemuFirmwareFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "860-881",
    "snippet": "char *\nqemuFirmwareFormat(qemuFirmwarePtr fw)\n{\n    g_autoptr(virJSONValue) doc = virJSONValueNewObject();\n\n    if (!fw)\n        return NULL;\n\n    if (qemuFirmwareInterfaceFormat(doc, fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareMappingFormat(doc, fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareTargetFormat(doc, fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareFeatureFormat(doc, fw) < 0)\n        return NULL;\n\n    return virJSONValueToString(doc, true);\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueToString",
          "args": [
            "doc",
            "true"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "2014-2024",
          "snippet": "char *\nvirJSONValueToString(virJSONValuePtr object,\n                     bool pretty)\n{\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n\n    if (virJSONValueToBuffer(object, &buf, pretty) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nchar *\nvirJSONValueToString(virJSONValuePtr object,\n                     bool pretty)\n{\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n\n    if (virJSONValueToBuffer(object, &buf, pretty) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareFeatureFormat",
          "args": [
            "doc",
            "fw"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareFeatureFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "835-857",
          "snippet": "static int\nqemuFirmwareFeatureFormat(virJSONValuePtr doc,\n                          qemuFirmwarePtr fw)\n{\n    g_autoptr(virJSONValue) featuresJSON = NULL;\n    size_t i;\n\n    featuresJSON = virJSONValueNewArray();\n\n    for (i = 0; i < fw->nfeatures; i++) {\n        if (virJSONValueArrayAppendString(featuresJSON,\n                                          qemuFirmwareFeatureTypeToString(fw->features[i])) < 0)\n            return -1;\n    }\n\n    if (virJSONValueObjectAppend(doc,\n                                 \"features\",\n                                 featuresJSON) < 0)\n        return -1;\n\n    featuresJSON = NULL;\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareFeatureFormat(virJSONValuePtr doc,\n                          qemuFirmwarePtr fw)\n{\n    g_autoptr(virJSONValue) featuresJSON = NULL;\n    size_t i;\n\n    featuresJSON = virJSONValueNewArray();\n\n    for (i = 0; i < fw->nfeatures; i++) {\n        if (virJSONValueArrayAppendString(featuresJSON,\n                                          qemuFirmwareFeatureTypeToString(fw->features[i])) < 0)\n            return -1;\n    }\n\n    if (virJSONValueObjectAppend(doc,\n                                 \"features\",\n                                 featuresJSON) < 0)\n        return -1;\n\n    featuresJSON = NULL;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareTargetFormat",
          "args": [
            "doc",
            "fw"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareTargetFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "788-832",
          "snippet": "static int\nqemuFirmwareTargetFormat(virJSONValuePtr doc,\n                         qemuFirmwarePtr fw)\n{\n    g_autoptr(virJSONValue) targetsJSON = NULL;\n    size_t i;\n\n    targetsJSON = virJSONValueNewArray();\n\n    for (i = 0; i < fw->ntargets; i++) {\n        qemuFirmwareTargetPtr t = fw->targets[i];\n        g_autoptr(virJSONValue) target = virJSONValueNewObject();\n        g_autoptr(virJSONValue) machines = NULL;\n        size_t j;\n\n        if (virJSONValueObjectAppendString(target,\n                                           \"architecture\",\n                                           virQEMUCapsArchToString(t->architecture)) < 0)\n            return -1;\n\n        machines = virJSONValueNewArray();\n\n        for (j = 0; j < t->nmachines; j++) {\n            if (virJSONValueArrayAppendString(machines,\n                                              t->machines[j]) < 0)\n                return -1;\n        }\n\n        if (virJSONValueObjectAppend(target, \"machines\", machines) < 0)\n            return -1;\n\n        machines = NULL;\n\n        if (virJSONValueArrayAppend(targetsJSON, target) < 0)\n            return -1;\n\n        target = NULL;\n    }\n\n    if (virJSONValueObjectAppend(doc, \"targets\", targetsJSON) < 0)\n        return -1;\n\n    targetsJSON = NULL;\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareTargetFormat(virJSONValuePtr doc,\n                         qemuFirmwarePtr fw)\n{\n    g_autoptr(virJSONValue) targetsJSON = NULL;\n    size_t i;\n\n    targetsJSON = virJSONValueNewArray();\n\n    for (i = 0; i < fw->ntargets; i++) {\n        qemuFirmwareTargetPtr t = fw->targets[i];\n        g_autoptr(virJSONValue) target = virJSONValueNewObject();\n        g_autoptr(virJSONValue) machines = NULL;\n        size_t j;\n\n        if (virJSONValueObjectAppendString(target,\n                                           \"architecture\",\n                                           virQEMUCapsArchToString(t->architecture)) < 0)\n            return -1;\n\n        machines = virJSONValueNewArray();\n\n        for (j = 0; j < t->nmachines; j++) {\n            if (virJSONValueArrayAppendString(machines,\n                                              t->machines[j]) < 0)\n                return -1;\n        }\n\n        if (virJSONValueObjectAppend(target, \"machines\", machines) < 0)\n            return -1;\n\n        machines = NULL;\n\n        if (virJSONValueArrayAppend(targetsJSON, target) < 0)\n            return -1;\n\n        target = NULL;\n    }\n\n    if (virJSONValueObjectAppend(doc, \"targets\", targetsJSON) < 0)\n        return -1;\n\n    targetsJSON = NULL;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareMappingFormat",
          "args": [
            "doc",
            "fw"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareMappingFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "750-785",
          "snippet": "static int\nqemuFirmwareMappingFormat(virJSONValuePtr doc,\n                          qemuFirmwarePtr fw)\n{\n    g_autoptr(virJSONValue) mapping = virJSONValueNewObject();\n\n    if (virJSONValueObjectAppendString(mapping,\n                                       \"device\",\n                                       qemuFirmwareDeviceTypeToString(fw->mapping.device)) < 0)\n        return -1;\n\n    switch (fw->mapping.device) {\n    case QEMU_FIRMWARE_DEVICE_FLASH:\n        if (qemuFirmwareMappingFlashFormat(mapping, &fw->mapping.data.flash) < 0)\n            return -1;\n        break;\n    case QEMU_FIRMWARE_DEVICE_KERNEL:\n        if (qemuFirmwareMappingKernelFormat(mapping, &fw->mapping.data.kernel) < 0)\n            return -1;\n        break;\n    case QEMU_FIRMWARE_DEVICE_MEMORY:\n        if (qemuFirmwareMappingMemoryFormat(mapping, &fw->mapping.data.memory) < 0)\n            return -1;\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_NONE:\n    case QEMU_FIRMWARE_DEVICE_LAST:\n        break;\n    }\n\n    if (virJSONValueObjectAppend(doc, \"mapping\", mapping) < 0)\n        return -1;\n\n    mapping = NULL;\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareMappingFormat(virJSONValuePtr doc,\n                          qemuFirmwarePtr fw)\n{\n    g_autoptr(virJSONValue) mapping = virJSONValueNewObject();\n\n    if (virJSONValueObjectAppendString(mapping,\n                                       \"device\",\n                                       qemuFirmwareDeviceTypeToString(fw->mapping.device)) < 0)\n        return -1;\n\n    switch (fw->mapping.device) {\n    case QEMU_FIRMWARE_DEVICE_FLASH:\n        if (qemuFirmwareMappingFlashFormat(mapping, &fw->mapping.data.flash) < 0)\n            return -1;\n        break;\n    case QEMU_FIRMWARE_DEVICE_KERNEL:\n        if (qemuFirmwareMappingKernelFormat(mapping, &fw->mapping.data.kernel) < 0)\n            return -1;\n        break;\n    case QEMU_FIRMWARE_DEVICE_MEMORY:\n        if (qemuFirmwareMappingMemoryFormat(mapping, &fw->mapping.data.memory) < 0)\n            return -1;\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_NONE:\n    case QEMU_FIRMWARE_DEVICE_LAST:\n        break;\n    }\n\n    if (virJSONValueObjectAppend(doc, \"mapping\", mapping) < 0)\n        return -1;\n\n    mapping = NULL;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareInterfaceFormat",
          "args": [
            "doc",
            "fw"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareInterfaceFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "647-669",
          "snippet": "static int\nqemuFirmwareInterfaceFormat(virJSONValuePtr doc,\n                            qemuFirmwarePtr fw)\n{\n    g_autoptr(virJSONValue) interfacesJSON = NULL;\n    size_t i;\n\n    interfacesJSON = virJSONValueNewArray();\n\n    for (i = 0; i < fw->ninterfaces; i++) {\n        if (virJSONValueArrayAppendString(interfacesJSON,\n                                          qemuFirmwareOSInterfaceTypeToString(fw->interfaces[i])) < 0)\n            return -1;\n    }\n\n    if (virJSONValueObjectAppend(doc,\n                                 \"interface-types\",\n                                 interfacesJSON) < 0)\n        return -1;\n\n    interfacesJSON = NULL;\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareInterfaceFormat(virJSONValuePtr doc,\n                            qemuFirmwarePtr fw)\n{\n    g_autoptr(virJSONValue) interfacesJSON = NULL;\n    size_t i;\n\n    interfacesJSON = virJSONValueNewArray();\n\n    for (i = 0; i < fw->ninterfaces; i++) {\n        if (virJSONValueArrayAppendString(interfacesJSON,\n                                          qemuFirmwareOSInterfaceTypeToString(fw->interfaces[i])) < 0)\n            return -1;\n    }\n\n    if (virJSONValueObjectAppend(doc,\n                                 \"interface-types\",\n                                 interfacesJSON) < 0)\n        return -1;\n\n    interfacesJSON = NULL;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueNewObject",
          "args": [],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "571-579",
          "snippet": "virJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nchar *\nqemuFirmwareFormat(qemuFirmwarePtr fw)\n{\n    g_autoptr(virJSONValue) doc = virJSONValueNewObject();\n\n    if (!fw)\n        return NULL;\n\n    if (qemuFirmwareInterfaceFormat(doc, fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareMappingFormat(doc, fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareTargetFormat(doc, fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareFeatureFormat(doc, fw) < 0)\n        return NULL;\n\n    return virJSONValueToString(doc, true);\n}"
  },
  {
    "function_name": "qemuFirmwareFeatureFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "835-857",
    "snippet": "static int\nqemuFirmwareFeatureFormat(virJSONValuePtr doc,\n                          qemuFirmwarePtr fw)\n{\n    g_autoptr(virJSONValue) featuresJSON = NULL;\n    size_t i;\n\n    featuresJSON = virJSONValueNewArray();\n\n    for (i = 0; i < fw->nfeatures; i++) {\n        if (virJSONValueArrayAppendString(featuresJSON,\n                                          qemuFirmwareFeatureTypeToString(fw->features[i])) < 0)\n            return -1;\n    }\n\n    if (virJSONValueObjectAppend(doc,\n                                 \"features\",\n                                 featuresJSON) < 0)\n        return -1;\n\n    featuresJSON = NULL;\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueObjectAppend",
          "args": [
            "doc",
            "\"features\"",
            "featuresJSON"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "741-754",
          "snippet": "int\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayAppendString",
          "args": [
            "featuresJSON",
            "qemuFirmwareFeatureTypeToString(fw->features[i])"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayAppendString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "792-804",
          "snippet": "int\nvirJSONValueArrayAppendString(virJSONValuePtr object,\n                              const char *value)\n{\n    virJSONValuePtr jvalue = virJSONValueNewString(value);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueArrayAppend(object, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueArrayAppendString(virJSONValuePtr object,\n                              const char *value)\n{\n    virJSONValuePtr jvalue = virJSONValueNewString(value);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueArrayAppend(object, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareFeatureTypeToString",
          "args": [
            "fw->features[i]"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueNewArray",
          "args": [],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "560-568",
          "snippet": "virJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareFeatureFormat(virJSONValuePtr doc,\n                          qemuFirmwarePtr fw)\n{\n    g_autoptr(virJSONValue) featuresJSON = NULL;\n    size_t i;\n\n    featuresJSON = virJSONValueNewArray();\n\n    for (i = 0; i < fw->nfeatures; i++) {\n        if (virJSONValueArrayAppendString(featuresJSON,\n                                          qemuFirmwareFeatureTypeToString(fw->features[i])) < 0)\n            return -1;\n    }\n\n    if (virJSONValueObjectAppend(doc,\n                                 \"features\",\n                                 featuresJSON) < 0)\n        return -1;\n\n    featuresJSON = NULL;\n    return 0;\n}"
  },
  {
    "function_name": "qemuFirmwareTargetFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "788-832",
    "snippet": "static int\nqemuFirmwareTargetFormat(virJSONValuePtr doc,\n                         qemuFirmwarePtr fw)\n{\n    g_autoptr(virJSONValue) targetsJSON = NULL;\n    size_t i;\n\n    targetsJSON = virJSONValueNewArray();\n\n    for (i = 0; i < fw->ntargets; i++) {\n        qemuFirmwareTargetPtr t = fw->targets[i];\n        g_autoptr(virJSONValue) target = virJSONValueNewObject();\n        g_autoptr(virJSONValue) machines = NULL;\n        size_t j;\n\n        if (virJSONValueObjectAppendString(target,\n                                           \"architecture\",\n                                           virQEMUCapsArchToString(t->architecture)) < 0)\n            return -1;\n\n        machines = virJSONValueNewArray();\n\n        for (j = 0; j < t->nmachines; j++) {\n            if (virJSONValueArrayAppendString(machines,\n                                              t->machines[j]) < 0)\n                return -1;\n        }\n\n        if (virJSONValueObjectAppend(target, \"machines\", machines) < 0)\n            return -1;\n\n        machines = NULL;\n\n        if (virJSONValueArrayAppend(targetsJSON, target) < 0)\n            return -1;\n\n        target = NULL;\n    }\n\n    if (virJSONValueObjectAppend(doc, \"targets\", targetsJSON) < 0)\n        return -1;\n\n    targetsJSON = NULL;\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueObjectAppend",
          "args": [
            "doc",
            "\"targets\"",
            "targetsJSON"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "741-754",
          "snippet": "int\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayAppend",
          "args": [
            "targetsJSON",
            "target"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayAppendString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "792-804",
          "snippet": "int\nvirJSONValueArrayAppendString(virJSONValuePtr object,\n                              const char *value)\n{\n    virJSONValuePtr jvalue = virJSONValueNewString(value);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueArrayAppend(object, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueArrayAppendString(virJSONValuePtr object,\n                              const char *value)\n{\n    virJSONValuePtr jvalue = virJSONValueNewString(value);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueArrayAppend(object, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueNewArray",
          "args": [],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "560-568",
          "snippet": "virJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectAppendString",
          "args": [
            "target",
            "\"architecture\"",
            "virQEMUCapsArchToString(t->architecture)"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "643-649",
          "snippet": "int\nvirJSONValueObjectAppendString(virJSONValuePtr object,\n                               const char *key,\n                               const char *value)\n{\n    return virJSONValueObjectInsertString(object, key, value, false);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendString(virJSONValuePtr object,\n                               const char *key,\n                               const char *value)\n{\n    return virJSONValueObjectInsertString(object, key, value, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsArchToString",
          "args": [
            "t->architecture"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "708-718",
          "snippet": "const char *virQEMUCapsArchToString(virArch arch)\n{\n    if (arch == VIR_ARCH_I686)\n        return \"i386\";\n    else if (arch == VIR_ARCH_ARMV6L || arch == VIR_ARCH_ARMV7L)\n        return \"arm\";\n    else if (arch == VIR_ARCH_OR32)\n        return \"or32\";\n\n    return virArchToString(arch);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *virQEMUCapsArchToString(virArch arch)\n{\n    if (arch == VIR_ARCH_I686)\n        return \"i386\";\n    else if (arch == VIR_ARCH_ARMV6L || arch == VIR_ARCH_ARMV7L)\n        return \"arm\";\n    else if (arch == VIR_ARCH_OR32)\n        return \"or32\";\n\n    return virArchToString(arch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueNewObject",
          "args": [],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "571-579",
          "snippet": "virJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareTargetFormat(virJSONValuePtr doc,\n                         qemuFirmwarePtr fw)\n{\n    g_autoptr(virJSONValue) targetsJSON = NULL;\n    size_t i;\n\n    targetsJSON = virJSONValueNewArray();\n\n    for (i = 0; i < fw->ntargets; i++) {\n        qemuFirmwareTargetPtr t = fw->targets[i];\n        g_autoptr(virJSONValue) target = virJSONValueNewObject();\n        g_autoptr(virJSONValue) machines = NULL;\n        size_t j;\n\n        if (virJSONValueObjectAppendString(target,\n                                           \"architecture\",\n                                           virQEMUCapsArchToString(t->architecture)) < 0)\n            return -1;\n\n        machines = virJSONValueNewArray();\n\n        for (j = 0; j < t->nmachines; j++) {\n            if (virJSONValueArrayAppendString(machines,\n                                              t->machines[j]) < 0)\n                return -1;\n        }\n\n        if (virJSONValueObjectAppend(target, \"machines\", machines) < 0)\n            return -1;\n\n        machines = NULL;\n\n        if (virJSONValueArrayAppend(targetsJSON, target) < 0)\n            return -1;\n\n        target = NULL;\n    }\n\n    if (virJSONValueObjectAppend(doc, \"targets\", targetsJSON) < 0)\n        return -1;\n\n    targetsJSON = NULL;\n    return 0;\n}"
  },
  {
    "function_name": "qemuFirmwareMappingFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "750-785",
    "snippet": "static int\nqemuFirmwareMappingFormat(virJSONValuePtr doc,\n                          qemuFirmwarePtr fw)\n{\n    g_autoptr(virJSONValue) mapping = virJSONValueNewObject();\n\n    if (virJSONValueObjectAppendString(mapping,\n                                       \"device\",\n                                       qemuFirmwareDeviceTypeToString(fw->mapping.device)) < 0)\n        return -1;\n\n    switch (fw->mapping.device) {\n    case QEMU_FIRMWARE_DEVICE_FLASH:\n        if (qemuFirmwareMappingFlashFormat(mapping, &fw->mapping.data.flash) < 0)\n            return -1;\n        break;\n    case QEMU_FIRMWARE_DEVICE_KERNEL:\n        if (qemuFirmwareMappingKernelFormat(mapping, &fw->mapping.data.kernel) < 0)\n            return -1;\n        break;\n    case QEMU_FIRMWARE_DEVICE_MEMORY:\n        if (qemuFirmwareMappingMemoryFormat(mapping, &fw->mapping.data.memory) < 0)\n            return -1;\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_NONE:\n    case QEMU_FIRMWARE_DEVICE_LAST:\n        break;\n    }\n\n    if (virJSONValueObjectAppend(doc, \"mapping\", mapping) < 0)\n        return -1;\n\n    mapping = NULL;\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueObjectAppend",
          "args": [
            "doc",
            "\"mapping\"",
            "mapping"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "741-754",
          "snippet": "int\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareMappingMemoryFormat",
          "args": [
            "mapping",
            "&fw->mapping.data.memory"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareMappingMemoryFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "737-747",
          "snippet": "static int\nqemuFirmwareMappingMemoryFormat(virJSONValuePtr mapping,\n                                qemuFirmwareMappingMemoryPtr memory)\n{\n    if (virJSONValueObjectAppendString(mapping,\n                                       \"filename\",\n                                       memory->filename) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareMappingMemoryFormat(virJSONValuePtr mapping,\n                                qemuFirmwareMappingMemoryPtr memory)\n{\n    if (virJSONValueObjectAppendString(mapping,\n                                       \"filename\",\n                                       memory->filename) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareMappingKernelFormat",
          "args": [
            "mapping",
            "&fw->mapping.data.kernel"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareMappingKernelFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "724-734",
          "snippet": "static int\nqemuFirmwareMappingKernelFormat(virJSONValuePtr mapping,\n                                qemuFirmwareMappingKernelPtr kernel)\n{\n    if (virJSONValueObjectAppendString(mapping,\n                                       \"filename\",\n                                       kernel->filename) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareMappingKernelFormat(virJSONValuePtr mapping,\n                                qemuFirmwareMappingKernelPtr kernel)\n{\n    if (virJSONValueObjectAppendString(mapping,\n                                       \"filename\",\n                                       kernel->filename) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareMappingFlashFormat",
          "args": [
            "mapping",
            "&fw->mapping.data.flash"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareMappingFlashFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "693-721",
          "snippet": "static int\nqemuFirmwareMappingFlashFormat(virJSONValuePtr mapping,\n                               qemuFirmwareMappingFlashPtr flash)\n{\n    g_autoptr(virJSONValue) executable = NULL;\n    g_autoptr(virJSONValue) nvram_template = NULL;\n\n    if (!(executable = qemuFirmwareFlashFileFormat(flash->executable)))\n        return -1;\n\n    if (!(nvram_template = qemuFirmwareFlashFileFormat(flash->nvram_template)))\n        return -1;\n\n    if (virJSONValueObjectAppend(mapping,\n                                 \"executable\",\n                                 executable) < 0)\n        return -1;\n\n    executable = NULL;\n\n    if (virJSONValueObjectAppend(mapping,\n                                 \"nvram-template\",\n                                 nvram_template) < 0)\n        return -1;\n\n    nvram_template = NULL;\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareMappingFlashFormat(virJSONValuePtr mapping,\n                               qemuFirmwareMappingFlashPtr flash)\n{\n    g_autoptr(virJSONValue) executable = NULL;\n    g_autoptr(virJSONValue) nvram_template = NULL;\n\n    if (!(executable = qemuFirmwareFlashFileFormat(flash->executable)))\n        return -1;\n\n    if (!(nvram_template = qemuFirmwareFlashFileFormat(flash->nvram_template)))\n        return -1;\n\n    if (virJSONValueObjectAppend(mapping,\n                                 \"executable\",\n                                 executable) < 0)\n        return -1;\n\n    executable = NULL;\n\n    if (virJSONValueObjectAppend(mapping,\n                                 \"nvram-template\",\n                                 nvram_template) < 0)\n        return -1;\n\n    nvram_template = NULL;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectAppendString",
          "args": [
            "mapping",
            "\"device\"",
            "qemuFirmwareDeviceTypeToString(fw->mapping.device)"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "643-649",
          "snippet": "int\nvirJSONValueObjectAppendString(virJSONValuePtr object,\n                               const char *key,\n                               const char *value)\n{\n    return virJSONValueObjectInsertString(object, key, value, false);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendString(virJSONValuePtr object,\n                               const char *key,\n                               const char *value)\n{\n    return virJSONValueObjectInsertString(object, key, value, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareDeviceTypeToString",
          "args": [
            "fw->mapping.device"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueNewObject",
          "args": [],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "571-579",
          "snippet": "virJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareMappingFormat(virJSONValuePtr doc,\n                          qemuFirmwarePtr fw)\n{\n    g_autoptr(virJSONValue) mapping = virJSONValueNewObject();\n\n    if (virJSONValueObjectAppendString(mapping,\n                                       \"device\",\n                                       qemuFirmwareDeviceTypeToString(fw->mapping.device)) < 0)\n        return -1;\n\n    switch (fw->mapping.device) {\n    case QEMU_FIRMWARE_DEVICE_FLASH:\n        if (qemuFirmwareMappingFlashFormat(mapping, &fw->mapping.data.flash) < 0)\n            return -1;\n        break;\n    case QEMU_FIRMWARE_DEVICE_KERNEL:\n        if (qemuFirmwareMappingKernelFormat(mapping, &fw->mapping.data.kernel) < 0)\n            return -1;\n        break;\n    case QEMU_FIRMWARE_DEVICE_MEMORY:\n        if (qemuFirmwareMappingMemoryFormat(mapping, &fw->mapping.data.memory) < 0)\n            return -1;\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_NONE:\n    case QEMU_FIRMWARE_DEVICE_LAST:\n        break;\n    }\n\n    if (virJSONValueObjectAppend(doc, \"mapping\", mapping) < 0)\n        return -1;\n\n    mapping = NULL;\n    return 0;\n}"
  },
  {
    "function_name": "qemuFirmwareMappingMemoryFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "737-747",
    "snippet": "static int\nqemuFirmwareMappingMemoryFormat(virJSONValuePtr mapping,\n                                qemuFirmwareMappingMemoryPtr memory)\n{\n    if (virJSONValueObjectAppendString(mapping,\n                                       \"filename\",\n                                       memory->filename) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueObjectAppendString",
          "args": [
            "mapping",
            "\"filename\"",
            "memory->filename"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "643-649",
          "snippet": "int\nvirJSONValueObjectAppendString(virJSONValuePtr object,\n                               const char *key,\n                               const char *value)\n{\n    return virJSONValueObjectInsertString(object, key, value, false);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendString(virJSONValuePtr object,\n                               const char *key,\n                               const char *value)\n{\n    return virJSONValueObjectInsertString(object, key, value, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareMappingMemoryFormat(virJSONValuePtr mapping,\n                                qemuFirmwareMappingMemoryPtr memory)\n{\n    if (virJSONValueObjectAppendString(mapping,\n                                       \"filename\",\n                                       memory->filename) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuFirmwareMappingKernelFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "724-734",
    "snippet": "static int\nqemuFirmwareMappingKernelFormat(virJSONValuePtr mapping,\n                                qemuFirmwareMappingKernelPtr kernel)\n{\n    if (virJSONValueObjectAppendString(mapping,\n                                       \"filename\",\n                                       kernel->filename) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueObjectAppendString",
          "args": [
            "mapping",
            "\"filename\"",
            "kernel->filename"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "643-649",
          "snippet": "int\nvirJSONValueObjectAppendString(virJSONValuePtr object,\n                               const char *key,\n                               const char *value)\n{\n    return virJSONValueObjectInsertString(object, key, value, false);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendString(virJSONValuePtr object,\n                               const char *key,\n                               const char *value)\n{\n    return virJSONValueObjectInsertString(object, key, value, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareMappingKernelFormat(virJSONValuePtr mapping,\n                                qemuFirmwareMappingKernelPtr kernel)\n{\n    if (virJSONValueObjectAppendString(mapping,\n                                       \"filename\",\n                                       kernel->filename) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuFirmwareMappingFlashFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "693-721",
    "snippet": "static int\nqemuFirmwareMappingFlashFormat(virJSONValuePtr mapping,\n                               qemuFirmwareMappingFlashPtr flash)\n{\n    g_autoptr(virJSONValue) executable = NULL;\n    g_autoptr(virJSONValue) nvram_template = NULL;\n\n    if (!(executable = qemuFirmwareFlashFileFormat(flash->executable)))\n        return -1;\n\n    if (!(nvram_template = qemuFirmwareFlashFileFormat(flash->nvram_template)))\n        return -1;\n\n    if (virJSONValueObjectAppend(mapping,\n                                 \"executable\",\n                                 executable) < 0)\n        return -1;\n\n    executable = NULL;\n\n    if (virJSONValueObjectAppend(mapping,\n                                 \"nvram-template\",\n                                 nvram_template) < 0)\n        return -1;\n\n    nvram_template = NULL;\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueObjectAppend",
          "args": [
            "mapping",
            "\"nvram-template\"",
            "nvram_template"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "741-754",
          "snippet": "int\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareFlashFileFormat",
          "args": [
            "flash->nvram_template"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareFlashFileFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "672-690",
          "snippet": "static virJSONValuePtr\nqemuFirmwareFlashFileFormat(qemuFirmwareFlashFile flash)\n{\n    g_autoptr(virJSONValue) json = virJSONValueNewObject();\n    virJSONValuePtr ret;\n\n    if (virJSONValueObjectAppendString(json,\n                                       \"filename\",\n                                       flash.filename) < 0)\n        return NULL;\n\n    if (virJSONValueObjectAppendString(json,\n                                       \"format\",\n                                       flash.format) < 0)\n        return NULL;\n\n    ret = g_steal_pointer(&json);\n    return ret;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic virJSONValuePtr\nqemuFirmwareFlashFileFormat(qemuFirmwareFlashFile flash)\n{\n    g_autoptr(virJSONValue) json = virJSONValueNewObject();\n    virJSONValuePtr ret;\n\n    if (virJSONValueObjectAppendString(json,\n                                       \"filename\",\n                                       flash.filename) < 0)\n        return NULL;\n\n    if (virJSONValueObjectAppendString(json,\n                                       \"format\",\n                                       flash.format) < 0)\n        return NULL;\n\n    ret = g_steal_pointer(&json);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareMappingFlashFormat(virJSONValuePtr mapping,\n                               qemuFirmwareMappingFlashPtr flash)\n{\n    g_autoptr(virJSONValue) executable = NULL;\n    g_autoptr(virJSONValue) nvram_template = NULL;\n\n    if (!(executable = qemuFirmwareFlashFileFormat(flash->executable)))\n        return -1;\n\n    if (!(nvram_template = qemuFirmwareFlashFileFormat(flash->nvram_template)))\n        return -1;\n\n    if (virJSONValueObjectAppend(mapping,\n                                 \"executable\",\n                                 executable) < 0)\n        return -1;\n\n    executable = NULL;\n\n    if (virJSONValueObjectAppend(mapping,\n                                 \"nvram-template\",\n                                 nvram_template) < 0)\n        return -1;\n\n    nvram_template = NULL;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuFirmwareFlashFileFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "672-690",
    "snippet": "static virJSONValuePtr\nqemuFirmwareFlashFileFormat(qemuFirmwareFlashFile flash)\n{\n    g_autoptr(virJSONValue) json = virJSONValueNewObject();\n    virJSONValuePtr ret;\n\n    if (virJSONValueObjectAppendString(json,\n                                       \"filename\",\n                                       flash.filename) < 0)\n        return NULL;\n\n    if (virJSONValueObjectAppendString(json,\n                                       \"format\",\n                                       flash.format) < 0)\n        return NULL;\n\n    ret = g_steal_pointer(&json);\n    return ret;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&json"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectAppendString",
          "args": [
            "json",
            "\"format\"",
            "flash.format"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "643-649",
          "snippet": "int\nvirJSONValueObjectAppendString(virJSONValuePtr object,\n                               const char *key,\n                               const char *value)\n{\n    return virJSONValueObjectInsertString(object, key, value, false);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendString(virJSONValuePtr object,\n                               const char *key,\n                               const char *value)\n{\n    return virJSONValueObjectInsertString(object, key, value, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueNewObject",
          "args": [],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "571-579",
          "snippet": "virJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic virJSONValuePtr\nqemuFirmwareFlashFileFormat(qemuFirmwareFlashFile flash)\n{\n    g_autoptr(virJSONValue) json = virJSONValueNewObject();\n    virJSONValuePtr ret;\n\n    if (virJSONValueObjectAppendString(json,\n                                       \"filename\",\n                                       flash.filename) < 0)\n        return NULL;\n\n    if (virJSONValueObjectAppendString(json,\n                                       \"format\",\n                                       flash.format) < 0)\n        return NULL;\n\n    ret = g_steal_pointer(&json);\n    return ret;\n}"
  },
  {
    "function_name": "qemuFirmwareInterfaceFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "647-669",
    "snippet": "static int\nqemuFirmwareInterfaceFormat(virJSONValuePtr doc,\n                            qemuFirmwarePtr fw)\n{\n    g_autoptr(virJSONValue) interfacesJSON = NULL;\n    size_t i;\n\n    interfacesJSON = virJSONValueNewArray();\n\n    for (i = 0; i < fw->ninterfaces; i++) {\n        if (virJSONValueArrayAppendString(interfacesJSON,\n                                          qemuFirmwareOSInterfaceTypeToString(fw->interfaces[i])) < 0)\n            return -1;\n    }\n\n    if (virJSONValueObjectAppend(doc,\n                                 \"interface-types\",\n                                 interfacesJSON) < 0)\n        return -1;\n\n    interfacesJSON = NULL;\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueObjectAppend",
          "args": [
            "doc",
            "\"interface-types\"",
            "interfacesJSON"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "741-754",
          "snippet": "int\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayAppendString",
          "args": [
            "interfacesJSON",
            "qemuFirmwareOSInterfaceTypeToString(fw->interfaces[i])"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayAppendString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "792-804",
          "snippet": "int\nvirJSONValueArrayAppendString(virJSONValuePtr object,\n                              const char *value)\n{\n    virJSONValuePtr jvalue = virJSONValueNewString(value);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueArrayAppend(object, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueArrayAppendString(virJSONValuePtr object,\n                              const char *value)\n{\n    virJSONValuePtr jvalue = virJSONValueNewString(value);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueArrayAppend(object, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareOSInterfaceTypeToString",
          "args": [
            "fw->interfaces[i]"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueNewArray",
          "args": [],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "560-568",
          "snippet": "virJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareInterfaceFormat(virJSONValuePtr doc,\n                            qemuFirmwarePtr fw)\n{\n    g_autoptr(virJSONValue) interfacesJSON = NULL;\n    size_t i;\n\n    interfacesJSON = virJSONValueNewArray();\n\n    for (i = 0; i < fw->ninterfaces; i++) {\n        if (virJSONValueArrayAppendString(interfacesJSON,\n                                          qemuFirmwareOSInterfaceTypeToString(fw->interfaces[i])) < 0)\n            return -1;\n    }\n\n    if (virJSONValueObjectAppend(doc,\n                                 \"interface-types\",\n                                 interfacesJSON) < 0)\n        return -1;\n\n    interfacesJSON = NULL;\n    return 0;\n}"
  },
  {
    "function_name": "qemuFirmwareParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "611-644",
    "snippet": "qemuFirmwarePtr\nqemuFirmwareParse(const char *path)\n{\n    g_autofree char *cont = NULL;\n    g_autoptr(virJSONValue) doc = NULL;\n    g_autoptr(qemuFirmware) fw = NULL;\n\n    if (virFileReadAll(path, DOCUMENT_SIZE, &cont) < 0)\n        return NULL;\n\n    if (!(doc = virJSONValueFromString(cont))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to parse json file '%s'\"),\n                       path);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareInterfaceParse(path, doc, fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareMappingParse(path, doc, fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareTargetParse(path, doc, fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareFeatureParse(path, doc, fw) < 0)\n        return NULL;\n\n    return g_steal_pointer(&fw);\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define DOCUMENT_SIZE (1024 * 1024)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&fw"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuFirmwareFeatureParse",
          "args": [
            "path",
            "doc",
            "fw"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareFeatureParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "565-605",
          "snippet": "static int\nqemuFirmwareFeatureParse(const char *path,\n                         virJSONValuePtr doc,\n                         qemuFirmwarePtr fw)\n{\n    virJSONValuePtr featuresJSON;\n    g_autoptr(qemuFirmwareFeature) features = NULL;\n    size_t nfeatures;\n    size_t i;\n\n    if (!(featuresJSON = virJSONValueObjectGetArray(doc, \"features\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get features from '%s'\"),\n                       path);\n        return -1;\n    }\n\n    nfeatures = virJSONValueArraySize(featuresJSON);\n\n    if (VIR_ALLOC_N(features, nfeatures) < 0)\n        return -1;\n\n    for (i = 0; i < nfeatures; i++) {\n        virJSONValuePtr item = virJSONValueArrayGet(featuresJSON, i);\n        const char *tmpStr = virJSONValueGetString(item);\n        int tmp;\n\n        if ((tmp = qemuFirmwareFeatureTypeFromString(tmpStr)) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown feature %s\"),\n                           tmpStr);\n            return -1;\n        }\n\n        features[i] = tmp;\n    }\n\n    fw->features = g_steal_pointer(&features);\n    fw->nfeatures = nfeatures;\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareFeatureParse(const char *path,\n                         virJSONValuePtr doc,\n                         qemuFirmwarePtr fw)\n{\n    virJSONValuePtr featuresJSON;\n    g_autoptr(qemuFirmwareFeature) features = NULL;\n    size_t nfeatures;\n    size_t i;\n\n    if (!(featuresJSON = virJSONValueObjectGetArray(doc, \"features\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get features from '%s'\"),\n                       path);\n        return -1;\n    }\n\n    nfeatures = virJSONValueArraySize(featuresJSON);\n\n    if (VIR_ALLOC_N(features, nfeatures) < 0)\n        return -1;\n\n    for (i = 0; i < nfeatures; i++) {\n        virJSONValuePtr item = virJSONValueArrayGet(featuresJSON, i);\n        const char *tmpStr = virJSONValueGetString(item);\n        int tmp;\n\n        if ((tmp = qemuFirmwareFeatureTypeFromString(tmpStr)) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown feature %s\"),\n                           tmpStr);\n            return -1;\n        }\n\n        features[i] = tmp;\n    }\n\n    fw->features = g_steal_pointer(&features);\n    fw->nfeatures = nfeatures;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareTargetParse",
          "args": [
            "path",
            "doc",
            "fw"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareTargetParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "480-562",
          "snippet": "static int\nqemuFirmwareTargetParse(const char *path,\n                        virJSONValuePtr doc,\n                        qemuFirmwarePtr fw)\n{\n    virJSONValuePtr targetsJSON;\n    qemuFirmwareTargetPtr *targets = NULL;\n    size_t ntargets;\n    size_t i;\n    int ret = -1;\n\n    if (!(targetsJSON = virJSONValueObjectGetArray(doc, \"targets\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get targets from '%s'\"),\n                       path);\n        return -1;\n    }\n\n    ntargets = virJSONValueArraySize(targetsJSON);\n\n    if (VIR_ALLOC_N(targets, ntargets) < 0)\n        return -1;\n\n    for (i = 0; i < ntargets; i++) {\n        virJSONValuePtr item = virJSONValueArrayGet(targetsJSON, i);\n        virJSONValuePtr machines;\n        g_autoptr(qemuFirmwareTarget) t = NULL;\n        const char *architectureStr = NULL;\n        size_t nmachines;\n        size_t j;\n\n        if (VIR_ALLOC(t) < 0)\n            goto cleanup;\n\n        if (!(architectureStr = virJSONValueObjectGetString(item, \"architecture\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing 'architecture' in '%s'\"),\n                           path);\n            goto cleanup;\n        }\n\n        if ((t->architecture = virQEMUCapsArchFromString(architectureStr)) == VIR_ARCH_NONE) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown architecture '%s'\"),\n                           architectureStr);\n            goto cleanup;\n        }\n\n        if (!(machines = virJSONValueObjectGetArray(item, \"machines\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing 'machines' in '%s'\"),\n                           path);\n            goto cleanup;\n        }\n\n        nmachines = virJSONValueArraySize(machines);\n\n        if (VIR_ALLOC_N(t->machines, nmachines) < 0)\n            goto cleanup;\n\n        for (j = 0; j < nmachines; j++) {\n            virJSONValuePtr machine = virJSONValueArrayGet(machines, j);\n            g_autofree char *machineStr = NULL;\n\n            machineStr = g_strdup(virJSONValueGetString(machine));\n\n            VIR_APPEND_ELEMENT_INPLACE(t->machines, t->nmachines, machineStr);\n        }\n\n        targets[i] = g_steal_pointer(&t);\n    }\n\n    fw->targets = g_steal_pointer(&targets);\n    fw->ntargets = ntargets;\n    ntargets = 0;\n    ret = 0;\n\n cleanup:\n    for (i = 0; i < ntargets; i++)\n        qemuFirmwareTargetFree(targets[i]);\n    VIR_FREE(targets);\n    return ret;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareTargetParse(const char *path,\n                        virJSONValuePtr doc,\n                        qemuFirmwarePtr fw)\n{\n    virJSONValuePtr targetsJSON;\n    qemuFirmwareTargetPtr *targets = NULL;\n    size_t ntargets;\n    size_t i;\n    int ret = -1;\n\n    if (!(targetsJSON = virJSONValueObjectGetArray(doc, \"targets\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get targets from '%s'\"),\n                       path);\n        return -1;\n    }\n\n    ntargets = virJSONValueArraySize(targetsJSON);\n\n    if (VIR_ALLOC_N(targets, ntargets) < 0)\n        return -1;\n\n    for (i = 0; i < ntargets; i++) {\n        virJSONValuePtr item = virJSONValueArrayGet(targetsJSON, i);\n        virJSONValuePtr machines;\n        g_autoptr(qemuFirmwareTarget) t = NULL;\n        const char *architectureStr = NULL;\n        size_t nmachines;\n        size_t j;\n\n        if (VIR_ALLOC(t) < 0)\n            goto cleanup;\n\n        if (!(architectureStr = virJSONValueObjectGetString(item, \"architecture\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing 'architecture' in '%s'\"),\n                           path);\n            goto cleanup;\n        }\n\n        if ((t->architecture = virQEMUCapsArchFromString(architectureStr)) == VIR_ARCH_NONE) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown architecture '%s'\"),\n                           architectureStr);\n            goto cleanup;\n        }\n\n        if (!(machines = virJSONValueObjectGetArray(item, \"machines\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing 'machines' in '%s'\"),\n                           path);\n            goto cleanup;\n        }\n\n        nmachines = virJSONValueArraySize(machines);\n\n        if (VIR_ALLOC_N(t->machines, nmachines) < 0)\n            goto cleanup;\n\n        for (j = 0; j < nmachines; j++) {\n            virJSONValuePtr machine = virJSONValueArrayGet(machines, j);\n            g_autofree char *machineStr = NULL;\n\n            machineStr = g_strdup(virJSONValueGetString(machine));\n\n            VIR_APPEND_ELEMENT_INPLACE(t->machines, t->nmachines, machineStr);\n        }\n\n        targets[i] = g_steal_pointer(&t);\n    }\n\n    fw->targets = g_steal_pointer(&targets);\n    fw->ntargets = ntargets;\n    ntargets = 0;\n    ret = 0;\n\n cleanup:\n    for (i = 0; i < ntargets; i++)\n        qemuFirmwareTargetFree(targets[i]);\n    VIR_FREE(targets);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareMappingParse",
          "args": [
            "path",
            "doc",
            "fw"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareMappingParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "432-477",
          "snippet": "static int\nqemuFirmwareMappingParse(const char *path,\n                         virJSONValuePtr doc,\n                         qemuFirmwarePtr fw)\n{\n    virJSONValuePtr mapping = virJSONValueObjectGet(doc, \"mapping\");\n    const char *deviceStr;\n    int tmp;\n\n    if (!(deviceStr = virJSONValueObjectGetString(mapping, \"device\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing device type in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    if ((tmp = qemuFirmwareDeviceTypeFromString(deviceStr)) <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown device type in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    fw->mapping.device = tmp;\n\n    switch (fw->mapping.device) {\n    case QEMU_FIRMWARE_DEVICE_FLASH:\n        if (qemuFirmwareMappingFlashParse(path, mapping, &fw->mapping.data.flash) < 0)\n            return -1;\n        break;\n    case QEMU_FIRMWARE_DEVICE_KERNEL:\n        if (qemuFirmwareMappingKernelParse(path, mapping, &fw->mapping.data.kernel) < 0)\n            return -1;\n        break;\n    case QEMU_FIRMWARE_DEVICE_MEMORY:\n        if (qemuFirmwareMappingMemoryParse(path, mapping, &fw->mapping.data.memory) < 0)\n            return -1;\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_NONE:\n    case QEMU_FIRMWARE_DEVICE_LAST:\n        break;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareMappingParse(const char *path,\n                         virJSONValuePtr doc,\n                         qemuFirmwarePtr fw)\n{\n    virJSONValuePtr mapping = virJSONValueObjectGet(doc, \"mapping\");\n    const char *deviceStr;\n    int tmp;\n\n    if (!(deviceStr = virJSONValueObjectGetString(mapping, \"device\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing device type in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    if ((tmp = qemuFirmwareDeviceTypeFromString(deviceStr)) <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown device type in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    fw->mapping.device = tmp;\n\n    switch (fw->mapping.device) {\n    case QEMU_FIRMWARE_DEVICE_FLASH:\n        if (qemuFirmwareMappingFlashParse(path, mapping, &fw->mapping.data.flash) < 0)\n            return -1;\n        break;\n    case QEMU_FIRMWARE_DEVICE_KERNEL:\n        if (qemuFirmwareMappingKernelParse(path, mapping, &fw->mapping.data.kernel) < 0)\n            return -1;\n        break;\n    case QEMU_FIRMWARE_DEVICE_MEMORY:\n        if (qemuFirmwareMappingMemoryParse(path, mapping, &fw->mapping.data.memory) < 0)\n            return -1;\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_NONE:\n    case QEMU_FIRMWARE_DEVICE_LAST:\n        break;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareInterfaceParse",
          "args": [
            "path",
            "doc",
            "fw"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareInterfaceParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "284-329",
          "snippet": "static int\nqemuFirmwareInterfaceParse(const char *path,\n                           virJSONValuePtr doc,\n                           qemuFirmwarePtr fw)\n{\n    virJSONValuePtr interfacesJSON;\n    g_autoptr(qemuFirmwareOSInterface) interfaces = NULL;\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n    size_t ninterfaces;\n    size_t i;\n\n    if (!(interfacesJSON = virJSONValueObjectGetArray(doc, \"interface-types\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get interface-types from '%s'\"),\n                       path);\n        return -1;\n    }\n\n    ninterfaces = virJSONValueArraySize(interfacesJSON);\n\n    if (VIR_ALLOC_N(interfaces, ninterfaces) < 0)\n        return -1;\n\n    for (i = 0; i < ninterfaces; i++) {\n        virJSONValuePtr item = virJSONValueArrayGet(interfacesJSON, i);\n        const char *tmpStr = virJSONValueGetString(item);\n        int tmp;\n\n        if ((tmp = qemuFirmwareOSInterfaceTypeFromString(tmpStr)) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown interface type: '%s'\"),\n                           tmpStr);\n            return -1;\n        }\n\n        virBufferAsprintf(&buf, \" %s\", tmpStr);\n        interfaces[i] = tmp;\n    }\n\n    VIR_DEBUG(\"firmware description path '%s' supported interfaces: %s\",\n              path, NULLSTR_MINUS(virBufferCurrentContent(&buf)));\n\n    fw->interfaces = g_steal_pointer(&interfaces);\n    fw->ninterfaces = ninterfaces;\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareInterfaceParse(const char *path,\n                           virJSONValuePtr doc,\n                           qemuFirmwarePtr fw)\n{\n    virJSONValuePtr interfacesJSON;\n    g_autoptr(qemuFirmwareOSInterface) interfaces = NULL;\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n    size_t ninterfaces;\n    size_t i;\n\n    if (!(interfacesJSON = virJSONValueObjectGetArray(doc, \"interface-types\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get interface-types from '%s'\"),\n                       path);\n        return -1;\n    }\n\n    ninterfaces = virJSONValueArraySize(interfacesJSON);\n\n    if (VIR_ALLOC_N(interfaces, ninterfaces) < 0)\n        return -1;\n\n    for (i = 0; i < ninterfaces; i++) {\n        virJSONValuePtr item = virJSONValueArrayGet(interfacesJSON, i);\n        const char *tmpStr = virJSONValueGetString(item);\n        int tmp;\n\n        if ((tmp = qemuFirmwareOSInterfaceTypeFromString(tmpStr)) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown interface type: '%s'\"),\n                           tmpStr);\n            return -1;\n        }\n\n        virBufferAsprintf(&buf, \" %s\", tmpStr);\n        interfaces[i] = tmp;\n    }\n\n    VIR_DEBUG(\"firmware description path '%s' supported interfaces: %s\",\n              path, NULLSTR_MINUS(virBufferCurrentContent(&buf)));\n\n    fw->interfaces = g_steal_pointer(&interfaces);\n    fw->ninterfaces = ninterfaces;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "fw"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unable to parse json file '%s'\")",
            "path"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to parse json file '%s'\""
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueFromString",
          "args": [
            "cont"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFromString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1993-1999",
          "snippet": "virJSONValuePtr\nvirJSONValueFromString(const char *jsonstring G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"No JSON parser implementation is available\"));\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueFromString(const char *jsonstring G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"No JSON parser implementation is available\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadAll",
          "args": [
            "path",
            "DOCUMENT_SIZE",
            "&cont"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\n#define DOCUMENT_SIZE (1024 * 1024)\n\nqemuFirmwarePtr\nqemuFirmwareParse(const char *path)\n{\n    g_autofree char *cont = NULL;\n    g_autoptr(virJSONValue) doc = NULL;\n    g_autoptr(qemuFirmware) fw = NULL;\n\n    if (virFileReadAll(path, DOCUMENT_SIZE, &cont) < 0)\n        return NULL;\n\n    if (!(doc = virJSONValueFromString(cont))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to parse json file '%s'\"),\n                       path);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareInterfaceParse(path, doc, fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareMappingParse(path, doc, fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareTargetParse(path, doc, fw) < 0)\n        return NULL;\n\n    if (qemuFirmwareFeatureParse(path, doc, fw) < 0)\n        return NULL;\n\n    return g_steal_pointer(&fw);\n}"
  },
  {
    "function_name": "qemuFirmwareFeatureParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "565-605",
    "snippet": "static int\nqemuFirmwareFeatureParse(const char *path,\n                         virJSONValuePtr doc,\n                         qemuFirmwarePtr fw)\n{\n    virJSONValuePtr featuresJSON;\n    g_autoptr(qemuFirmwareFeature) features = NULL;\n    size_t nfeatures;\n    size_t i;\n\n    if (!(featuresJSON = virJSONValueObjectGetArray(doc, \"features\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get features from '%s'\"),\n                       path);\n        return -1;\n    }\n\n    nfeatures = virJSONValueArraySize(featuresJSON);\n\n    if (VIR_ALLOC_N(features, nfeatures) < 0)\n        return -1;\n\n    for (i = 0; i < nfeatures; i++) {\n        virJSONValuePtr item = virJSONValueArrayGet(featuresJSON, i);\n        const char *tmpStr = virJSONValueGetString(item);\n        int tmp;\n\n        if ((tmp = qemuFirmwareFeatureTypeFromString(tmpStr)) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown feature %s\"),\n                           tmpStr);\n            return -1;\n        }\n\n        features[i] = tmp;\n    }\n\n    fw->features = g_steal_pointer(&features);\n    fw->nfeatures = nfeatures;\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&features"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown feature %s\")",
            "tmpStr"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown feature %s\""
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareFeatureTypeFromString",
          "args": [
            "tmpStr"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueGetString",
          "args": [
            "item"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueGetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1115-1122",
          "snippet": "const char *\nvirJSONValueGetString(virJSONValuePtr string)\n{\n    if (string->type != VIR_JSON_TYPE_STRING)\n        return NULL;\n\n    return string->data.string;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueGetString(virJSONValuePtr string)\n{\n    if (string->type != VIR_JSON_TYPE_STRING)\n        return NULL;\n\n    return string->data.string;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayGet",
          "args": [
            "featuresJSON",
            "i"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1024-1035",
          "snippet": "virJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "features",
            "nfeatures"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueArraySize",
          "args": [
            "featuresJSON"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArraySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1017-1021",
          "snippet": "size_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nsize_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to get features from '%s'\")",
            "path"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetArray",
          "args": [
            "doc",
            "\"features\""
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1422-1426",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareFeatureParse(const char *path,\n                         virJSONValuePtr doc,\n                         qemuFirmwarePtr fw)\n{\n    virJSONValuePtr featuresJSON;\n    g_autoptr(qemuFirmwareFeature) features = NULL;\n    size_t nfeatures;\n    size_t i;\n\n    if (!(featuresJSON = virJSONValueObjectGetArray(doc, \"features\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get features from '%s'\"),\n                       path);\n        return -1;\n    }\n\n    nfeatures = virJSONValueArraySize(featuresJSON);\n\n    if (VIR_ALLOC_N(features, nfeatures) < 0)\n        return -1;\n\n    for (i = 0; i < nfeatures; i++) {\n        virJSONValuePtr item = virJSONValueArrayGet(featuresJSON, i);\n        const char *tmpStr = virJSONValueGetString(item);\n        int tmp;\n\n        if ((tmp = qemuFirmwareFeatureTypeFromString(tmpStr)) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown feature %s\"),\n                           tmpStr);\n            return -1;\n        }\n\n        features[i] = tmp;\n    }\n\n    fw->features = g_steal_pointer(&features);\n    fw->nfeatures = nfeatures;\n    return 0;\n}"
  },
  {
    "function_name": "qemuFirmwareTargetParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "480-562",
    "snippet": "static int\nqemuFirmwareTargetParse(const char *path,\n                        virJSONValuePtr doc,\n                        qemuFirmwarePtr fw)\n{\n    virJSONValuePtr targetsJSON;\n    qemuFirmwareTargetPtr *targets = NULL;\n    size_t ntargets;\n    size_t i;\n    int ret = -1;\n\n    if (!(targetsJSON = virJSONValueObjectGetArray(doc, \"targets\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get targets from '%s'\"),\n                       path);\n        return -1;\n    }\n\n    ntargets = virJSONValueArraySize(targetsJSON);\n\n    if (VIR_ALLOC_N(targets, ntargets) < 0)\n        return -1;\n\n    for (i = 0; i < ntargets; i++) {\n        virJSONValuePtr item = virJSONValueArrayGet(targetsJSON, i);\n        virJSONValuePtr machines;\n        g_autoptr(qemuFirmwareTarget) t = NULL;\n        const char *architectureStr = NULL;\n        size_t nmachines;\n        size_t j;\n\n        if (VIR_ALLOC(t) < 0)\n            goto cleanup;\n\n        if (!(architectureStr = virJSONValueObjectGetString(item, \"architecture\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing 'architecture' in '%s'\"),\n                           path);\n            goto cleanup;\n        }\n\n        if ((t->architecture = virQEMUCapsArchFromString(architectureStr)) == VIR_ARCH_NONE) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown architecture '%s'\"),\n                           architectureStr);\n            goto cleanup;\n        }\n\n        if (!(machines = virJSONValueObjectGetArray(item, \"machines\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing 'machines' in '%s'\"),\n                           path);\n            goto cleanup;\n        }\n\n        nmachines = virJSONValueArraySize(machines);\n\n        if (VIR_ALLOC_N(t->machines, nmachines) < 0)\n            goto cleanup;\n\n        for (j = 0; j < nmachines; j++) {\n            virJSONValuePtr machine = virJSONValueArrayGet(machines, j);\n            g_autofree char *machineStr = NULL;\n\n            machineStr = g_strdup(virJSONValueGetString(machine));\n\n            VIR_APPEND_ELEMENT_INPLACE(t->machines, t->nmachines, machineStr);\n        }\n\n        targets[i] = g_steal_pointer(&t);\n    }\n\n    fw->targets = g_steal_pointer(&targets);\n    fw->ntargets = ntargets;\n    ntargets = 0;\n    ret = 0;\n\n cleanup:\n    for (i = 0; i < ntargets; i++)\n        qemuFirmwareTargetFree(targets[i]);\n    VIR_FREE(targets);\n    return ret;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "targets"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuFirmwareTargetFree",
          "args": [
            "targets[i]"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareTargetFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "240-249",
          "snippet": "static void\nqemuFirmwareTargetFree(qemuFirmwareTargetPtr target)\n{\n    if (!target)\n        return;\n\n    virStringListFreeCount(target->machines, target->nmachines);\n\n    VIR_FREE(target);\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareTargetFree(qemuFirmwareTargetPtr target)\n{\n    if (!target)\n        return;\n\n    virStringListFreeCount(target->machines, target->nmachines);\n\n    VIR_FREE(target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&targets"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&t"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT_INPLACE",
          "args": [
            "t->machines",
            "t->nmachines",
            "machineStr"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "virJSONValueGetString(machine)"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueGetString",
          "args": [
            "machine"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueGetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1115-1122",
          "snippet": "const char *\nvirJSONValueGetString(virJSONValuePtr string)\n{\n    if (string->type != VIR_JSON_TYPE_STRING)\n        return NULL;\n\n    return string->data.string;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueGetString(virJSONValuePtr string)\n{\n    if (string->type != VIR_JSON_TYPE_STRING)\n        return NULL;\n\n    return string->data.string;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayGet",
          "args": [
            "machines",
            "j"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1024-1035",
          "snippet": "virJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "t->machines",
            "nmachines"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueArraySize",
          "args": [
            "machines"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArraySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1017-1021",
          "snippet": "size_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nsize_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing 'machines' in '%s'\")",
            "path"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing 'machines' in '%s'\""
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetArray",
          "args": [
            "item",
            "\"machines\""
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1422-1426",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown architecture '%s'\")",
            "architectureStr"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsArchFromString",
          "args": [
            "architectureStr"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsArchFromString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "695-705",
          "snippet": "virArch virQEMUCapsArchFromString(const char *arch)\n{\n    if (STREQ(arch, \"i386\"))\n        return VIR_ARCH_I686;\n    if (STREQ(arch, \"arm\"))\n        return VIR_ARCH_ARMV7L;\n    if (STREQ(arch, \"or32\"))\n        return VIR_ARCH_OR32;\n\n    return virArchFromString(arch);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirArch virQEMUCapsArchFromString(const char *arch)\n{\n    if (STREQ(arch, \"i386\"))\n        return VIR_ARCH_I686;\n    if (STREQ(arch, \"arm\"))\n        return VIR_ARCH_ARMV7L;\n    if (STREQ(arch, \"or32\"))\n        return VIR_ARCH_OR32;\n\n    return virArchFromString(arch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing 'architecture' in '%s'\")",
            "path"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "item",
            "\"architecture\""
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "t"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "targets",
            "ntargets"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to get targets from '%s'\")",
            "path"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareTargetParse(const char *path,\n                        virJSONValuePtr doc,\n                        qemuFirmwarePtr fw)\n{\n    virJSONValuePtr targetsJSON;\n    qemuFirmwareTargetPtr *targets = NULL;\n    size_t ntargets;\n    size_t i;\n    int ret = -1;\n\n    if (!(targetsJSON = virJSONValueObjectGetArray(doc, \"targets\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get targets from '%s'\"),\n                       path);\n        return -1;\n    }\n\n    ntargets = virJSONValueArraySize(targetsJSON);\n\n    if (VIR_ALLOC_N(targets, ntargets) < 0)\n        return -1;\n\n    for (i = 0; i < ntargets; i++) {\n        virJSONValuePtr item = virJSONValueArrayGet(targetsJSON, i);\n        virJSONValuePtr machines;\n        g_autoptr(qemuFirmwareTarget) t = NULL;\n        const char *architectureStr = NULL;\n        size_t nmachines;\n        size_t j;\n\n        if (VIR_ALLOC(t) < 0)\n            goto cleanup;\n\n        if (!(architectureStr = virJSONValueObjectGetString(item, \"architecture\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing 'architecture' in '%s'\"),\n                           path);\n            goto cleanup;\n        }\n\n        if ((t->architecture = virQEMUCapsArchFromString(architectureStr)) == VIR_ARCH_NONE) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown architecture '%s'\"),\n                           architectureStr);\n            goto cleanup;\n        }\n\n        if (!(machines = virJSONValueObjectGetArray(item, \"machines\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing 'machines' in '%s'\"),\n                           path);\n            goto cleanup;\n        }\n\n        nmachines = virJSONValueArraySize(machines);\n\n        if (VIR_ALLOC_N(t->machines, nmachines) < 0)\n            goto cleanup;\n\n        for (j = 0; j < nmachines; j++) {\n            virJSONValuePtr machine = virJSONValueArrayGet(machines, j);\n            g_autofree char *machineStr = NULL;\n\n            machineStr = g_strdup(virJSONValueGetString(machine));\n\n            VIR_APPEND_ELEMENT_INPLACE(t->machines, t->nmachines, machineStr);\n        }\n\n        targets[i] = g_steal_pointer(&t);\n    }\n\n    fw->targets = g_steal_pointer(&targets);\n    fw->ntargets = ntargets;\n    ntargets = 0;\n    ret = 0;\n\n cleanup:\n    for (i = 0; i < ntargets; i++)\n        qemuFirmwareTargetFree(targets[i]);\n    VIR_FREE(targets);\n    return ret;\n}"
  },
  {
    "function_name": "qemuFirmwareMappingParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "432-477",
    "snippet": "static int\nqemuFirmwareMappingParse(const char *path,\n                         virJSONValuePtr doc,\n                         qemuFirmwarePtr fw)\n{\n    virJSONValuePtr mapping = virJSONValueObjectGet(doc, \"mapping\");\n    const char *deviceStr;\n    int tmp;\n\n    if (!(deviceStr = virJSONValueObjectGetString(mapping, \"device\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing device type in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    if ((tmp = qemuFirmwareDeviceTypeFromString(deviceStr)) <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown device type in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    fw->mapping.device = tmp;\n\n    switch (fw->mapping.device) {\n    case QEMU_FIRMWARE_DEVICE_FLASH:\n        if (qemuFirmwareMappingFlashParse(path, mapping, &fw->mapping.data.flash) < 0)\n            return -1;\n        break;\n    case QEMU_FIRMWARE_DEVICE_KERNEL:\n        if (qemuFirmwareMappingKernelParse(path, mapping, &fw->mapping.data.kernel) < 0)\n            return -1;\n        break;\n    case QEMU_FIRMWARE_DEVICE_MEMORY:\n        if (qemuFirmwareMappingMemoryParse(path, mapping, &fw->mapping.data.memory) < 0)\n            return -1;\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_NONE:\n    case QEMU_FIRMWARE_DEVICE_LAST:\n        break;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuFirmwareMappingMemoryParse",
          "args": [
            "path",
            "mapping",
            "&fw->mapping.data.memory"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareMappingMemoryParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "413-429",
          "snippet": "static int\nqemuFirmwareMappingMemoryParse(const char *path,\n                               virJSONValuePtr doc,\n                               qemuFirmwareMappingMemoryPtr memory)\n{\n    const char *filename;\n\n    if (!(filename = virJSONValueObjectGetString(doc, \"filename\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'filename' in '%s'\"),\n                       path);\n    }\n\n    memory->filename = g_strdup(filename);\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareMappingMemoryParse(const char *path,\n                               virJSONValuePtr doc,\n                               qemuFirmwareMappingMemoryPtr memory)\n{\n    const char *filename;\n\n    if (!(filename = virJSONValueObjectGetString(doc, \"filename\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'filename' in '%s'\"),\n                       path);\n    }\n\n    memory->filename = g_strdup(filename);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareMappingKernelParse",
          "args": [
            "path",
            "mapping",
            "&fw->mapping.data.kernel"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareMappingKernelParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "394-410",
          "snippet": "static int\nqemuFirmwareMappingKernelParse(const char *path,\n                               virJSONValuePtr doc,\n                               qemuFirmwareMappingKernelPtr kernel)\n{\n    const char *filename;\n\n    if (!(filename = virJSONValueObjectGetString(doc, \"filename\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'filename' in '%s'\"),\n                       path);\n    }\n\n    kernel->filename = g_strdup(filename);\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareMappingKernelParse(const char *path,\n                               virJSONValuePtr doc,\n                               qemuFirmwareMappingKernelPtr kernel)\n{\n    const char *filename;\n\n    if (!(filename = virJSONValueObjectGetString(doc, \"filename\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'filename' in '%s'\"),\n                       path);\n    }\n\n    kernel->filename = g_strdup(filename);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareMappingFlashParse",
          "args": [
            "path",
            "mapping",
            "&fw->mapping.data.flash"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareMappingFlashParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "362-391",
          "snippet": "static int\nqemuFirmwareMappingFlashParse(const char *path,\n                              virJSONValuePtr doc,\n                              qemuFirmwareMappingFlashPtr flash)\n{\n    virJSONValuePtr executable;\n    virJSONValuePtr nvram_template;\n\n    if (!(executable = virJSONValueObjectGet(doc, \"executable\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'executable' in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    if (qemuFirmwareFlashFileParse(path, executable, &flash->executable) < 0)\n        return -1;\n\n    if (!(nvram_template = virJSONValueObjectGet(doc, \"nvram-template\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'nvram-template' in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    if (qemuFirmwareFlashFileParse(path, nvram_template, &flash->nvram_template) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareMappingFlashParse(const char *path,\n                              virJSONValuePtr doc,\n                              qemuFirmwareMappingFlashPtr flash)\n{\n    virJSONValuePtr executable;\n    virJSONValuePtr nvram_template;\n\n    if (!(executable = virJSONValueObjectGet(doc, \"executable\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'executable' in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    if (qemuFirmwareFlashFileParse(path, executable, &flash->executable) < 0)\n        return -1;\n\n    if (!(nvram_template = virJSONValueObjectGet(doc, \"nvram-template\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'nvram-template' in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    if (qemuFirmwareFlashFileParse(path, nvram_template, &flash->nvram_template) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown device type in '%s'\")",
            "path"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown device type in '%s'\""
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareDeviceTypeFromString",
          "args": [
            "deviceStr"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing device type in '%s'\")",
            "path"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "mapping",
            "\"device\""
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGet",
          "args": [
            "doc",
            "\"mapping\""
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1422-1426",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareMappingParse(const char *path,\n                         virJSONValuePtr doc,\n                         qemuFirmwarePtr fw)\n{\n    virJSONValuePtr mapping = virJSONValueObjectGet(doc, \"mapping\");\n    const char *deviceStr;\n    int tmp;\n\n    if (!(deviceStr = virJSONValueObjectGetString(mapping, \"device\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing device type in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    if ((tmp = qemuFirmwareDeviceTypeFromString(deviceStr)) <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown device type in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    fw->mapping.device = tmp;\n\n    switch (fw->mapping.device) {\n    case QEMU_FIRMWARE_DEVICE_FLASH:\n        if (qemuFirmwareMappingFlashParse(path, mapping, &fw->mapping.data.flash) < 0)\n            return -1;\n        break;\n    case QEMU_FIRMWARE_DEVICE_KERNEL:\n        if (qemuFirmwareMappingKernelParse(path, mapping, &fw->mapping.data.kernel) < 0)\n            return -1;\n        break;\n    case QEMU_FIRMWARE_DEVICE_MEMORY:\n        if (qemuFirmwareMappingMemoryParse(path, mapping, &fw->mapping.data.memory) < 0)\n            return -1;\n        break;\n\n    case QEMU_FIRMWARE_DEVICE_NONE:\n    case QEMU_FIRMWARE_DEVICE_LAST:\n        break;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuFirmwareMappingMemoryParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "413-429",
    "snippet": "static int\nqemuFirmwareMappingMemoryParse(const char *path,\n                               virJSONValuePtr doc,\n                               qemuFirmwareMappingMemoryPtr memory)\n{\n    const char *filename;\n\n    if (!(filename = virJSONValueObjectGetString(doc, \"filename\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'filename' in '%s'\"),\n                       path);\n    }\n\n    memory->filename = g_strdup(filename);\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "filename"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing 'filename' in '%s'\")",
            "path"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing 'filename' in '%s'\""
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "doc",
            "\"filename\""
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareMappingMemoryParse(const char *path,\n                               virJSONValuePtr doc,\n                               qemuFirmwareMappingMemoryPtr memory)\n{\n    const char *filename;\n\n    if (!(filename = virJSONValueObjectGetString(doc, \"filename\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'filename' in '%s'\"),\n                       path);\n    }\n\n    memory->filename = g_strdup(filename);\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuFirmwareMappingKernelParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "394-410",
    "snippet": "static int\nqemuFirmwareMappingKernelParse(const char *path,\n                               virJSONValuePtr doc,\n                               qemuFirmwareMappingKernelPtr kernel)\n{\n    const char *filename;\n\n    if (!(filename = virJSONValueObjectGetString(doc, \"filename\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'filename' in '%s'\"),\n                       path);\n    }\n\n    kernel->filename = g_strdup(filename);\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "filename"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing 'filename' in '%s'\")",
            "path"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing 'filename' in '%s'\""
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "doc",
            "\"filename\""
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareMappingKernelParse(const char *path,\n                               virJSONValuePtr doc,\n                               qemuFirmwareMappingKernelPtr kernel)\n{\n    const char *filename;\n\n    if (!(filename = virJSONValueObjectGetString(doc, \"filename\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'filename' in '%s'\"),\n                       path);\n    }\n\n    kernel->filename = g_strdup(filename);\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuFirmwareMappingFlashParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "362-391",
    "snippet": "static int\nqemuFirmwareMappingFlashParse(const char *path,\n                              virJSONValuePtr doc,\n                              qemuFirmwareMappingFlashPtr flash)\n{\n    virJSONValuePtr executable;\n    virJSONValuePtr nvram_template;\n\n    if (!(executable = virJSONValueObjectGet(doc, \"executable\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'executable' in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    if (qemuFirmwareFlashFileParse(path, executable, &flash->executable) < 0)\n        return -1;\n\n    if (!(nvram_template = virJSONValueObjectGet(doc, \"nvram-template\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'nvram-template' in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    if (qemuFirmwareFlashFileParse(path, nvram_template, &flash->nvram_template) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuFirmwareFlashFileParse",
          "args": [
            "path",
            "nvram_template",
            "&flash->nvram_template"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareFlashFileParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "332-359",
          "snippet": "static int\nqemuFirmwareFlashFileParse(const char *path,\n                           virJSONValuePtr doc,\n                           qemuFirmwareFlashFilePtr flash)\n{\n    const char *filename;\n    const char *format;\n\n    if (!(filename = virJSONValueObjectGetString(doc, \"filename\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'filename' in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    flash->filename = g_strdup(filename);\n\n    if (!(format = virJSONValueObjectGetString(doc, \"format\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'format' in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    flash->format = g_strdup(format);\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareFlashFileParse(const char *path,\n                           virJSONValuePtr doc,\n                           qemuFirmwareFlashFilePtr flash)\n{\n    const char *filename;\n    const char *format;\n\n    if (!(filename = virJSONValueObjectGetString(doc, \"filename\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'filename' in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    flash->filename = g_strdup(filename);\n\n    if (!(format = virJSONValueObjectGetString(doc, \"format\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'format' in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    flash->format = g_strdup(format);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing 'nvram-template' in '%s'\")",
            "path"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing 'nvram-template' in '%s'\""
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGet",
          "args": [
            "doc",
            "\"nvram-template\""
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1422-1426",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing 'executable' in '%s'\")",
            "path"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareMappingFlashParse(const char *path,\n                              virJSONValuePtr doc,\n                              qemuFirmwareMappingFlashPtr flash)\n{\n    virJSONValuePtr executable;\n    virJSONValuePtr nvram_template;\n\n    if (!(executable = virJSONValueObjectGet(doc, \"executable\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'executable' in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    if (qemuFirmwareFlashFileParse(path, executable, &flash->executable) < 0)\n        return -1;\n\n    if (!(nvram_template = virJSONValueObjectGet(doc, \"nvram-template\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'nvram-template' in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    if (qemuFirmwareFlashFileParse(path, nvram_template, &flash->nvram_template) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuFirmwareFlashFileParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "332-359",
    "snippet": "static int\nqemuFirmwareFlashFileParse(const char *path,\n                           virJSONValuePtr doc,\n                           qemuFirmwareFlashFilePtr flash)\n{\n    const char *filename;\n    const char *format;\n\n    if (!(filename = virJSONValueObjectGetString(doc, \"filename\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'filename' in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    flash->filename = g_strdup(filename);\n\n    if (!(format = virJSONValueObjectGetString(doc, \"format\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'format' in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    flash->format = g_strdup(format);\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "format"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing 'format' in '%s'\")",
            "path"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing 'format' in '%s'\""
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "doc",
            "\"format\""
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing 'filename' in '%s'\")",
            "path"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareFlashFileParse(const char *path,\n                           virJSONValuePtr doc,\n                           qemuFirmwareFlashFilePtr flash)\n{\n    const char *filename;\n    const char *format;\n\n    if (!(filename = virJSONValueObjectGetString(doc, \"filename\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'filename' in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    flash->filename = g_strdup(filename);\n\n    if (!(format = virJSONValueObjectGetString(doc, \"format\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'format' in '%s'\"),\n                       path);\n        return -1;\n    }\n\n    flash->format = g_strdup(format);\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuFirmwareInterfaceParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "284-329",
    "snippet": "static int\nqemuFirmwareInterfaceParse(const char *path,\n                           virJSONValuePtr doc,\n                           qemuFirmwarePtr fw)\n{\n    virJSONValuePtr interfacesJSON;\n    g_autoptr(qemuFirmwareOSInterface) interfaces = NULL;\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n    size_t ninterfaces;\n    size_t i;\n\n    if (!(interfacesJSON = virJSONValueObjectGetArray(doc, \"interface-types\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get interface-types from '%s'\"),\n                       path);\n        return -1;\n    }\n\n    ninterfaces = virJSONValueArraySize(interfacesJSON);\n\n    if (VIR_ALLOC_N(interfaces, ninterfaces) < 0)\n        return -1;\n\n    for (i = 0; i < ninterfaces; i++) {\n        virJSONValuePtr item = virJSONValueArrayGet(interfacesJSON, i);\n        const char *tmpStr = virJSONValueGetString(item);\n        int tmp;\n\n        if ((tmp = qemuFirmwareOSInterfaceTypeFromString(tmpStr)) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown interface type: '%s'\"),\n                           tmpStr);\n            return -1;\n        }\n\n        virBufferAsprintf(&buf, \" %s\", tmpStr);\n        interfaces[i] = tmp;\n    }\n\n    VIR_DEBUG(\"firmware description path '%s' supported interfaces: %s\",\n              path, NULLSTR_MINUS(virBufferCurrentContent(&buf)));\n\n    fw->interfaces = g_steal_pointer(&interfaces);\n    fw->ninterfaces = ninterfaces;\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&interfaces"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"firmware description path '%s' supported interfaces: %s\"",
            "path",
            "NULLSTR_MINUS(virBufferCurrentContent(&buf))"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR_MINUS",
          "args": [
            "virBufferCurrentContent(&buf)"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferCurrentContent",
          "args": [
            "&buf"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferCurrentContent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "222-233",
          "snippet": "const char *\nvirBufferCurrentContent(virBufferPtr buf)\n{\n    if (!buf)\n        return NULL;\n\n    if (!buf->str ||\n        buf->str->len == 0)\n        return \"\";\n\n    return buf->str->str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirBufferCurrentContent(virBufferPtr buf)\n{\n    if (!buf)\n        return NULL;\n\n    if (!buf->str ||\n        buf->str->len == 0)\n        return \"\";\n\n    return buf->str->str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\" %s\"",
            "tmpStr"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown interface type: '%s'\")",
            "tmpStr"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown interface type: '%s'\""
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareOSInterfaceTypeFromString",
          "args": [
            "tmpStr"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueGetString",
          "args": [
            "item"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueGetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1115-1122",
          "snippet": "const char *\nvirJSONValueGetString(virJSONValuePtr string)\n{\n    if (string->type != VIR_JSON_TYPE_STRING)\n        return NULL;\n\n    return string->data.string;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueGetString(virJSONValuePtr string)\n{\n    if (string->type != VIR_JSON_TYPE_STRING)\n        return NULL;\n\n    return string->data.string;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayGet",
          "args": [
            "interfacesJSON",
            "i"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1024-1035",
          "snippet": "virJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "interfaces",
            "ninterfaces"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueArraySize",
          "args": [
            "interfacesJSON"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArraySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1017-1021",
          "snippet": "size_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nsize_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to get interface-types from '%s'\")",
            "path"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetArray",
          "args": [
            "doc",
            "\"interface-types\""
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1422-1426",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic int\nqemuFirmwareInterfaceParse(const char *path,\n                           virJSONValuePtr doc,\n                           qemuFirmwarePtr fw)\n{\n    virJSONValuePtr interfacesJSON;\n    g_autoptr(qemuFirmwareOSInterface) interfaces = NULL;\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n    size_t ninterfaces;\n    size_t i;\n\n    if (!(interfacesJSON = virJSONValueObjectGetArray(doc, \"interface-types\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to get interface-types from '%s'\"),\n                       path);\n        return -1;\n    }\n\n    ninterfaces = virJSONValueArraySize(interfacesJSON);\n\n    if (VIR_ALLOC_N(interfaces, ninterfaces) < 0)\n        return -1;\n\n    for (i = 0; i < ninterfaces; i++) {\n        virJSONValuePtr item = virJSONValueArrayGet(interfacesJSON, i);\n        const char *tmpStr = virJSONValueGetString(item);\n        int tmp;\n\n        if ((tmp = qemuFirmwareOSInterfaceTypeFromString(tmpStr)) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown interface type: '%s'\"),\n                           tmpStr);\n            return -1;\n        }\n\n        virBufferAsprintf(&buf, \" %s\", tmpStr);\n        interfaces[i] = tmp;\n    }\n\n    VIR_DEBUG(\"firmware description path '%s' supported interfaces: %s\",\n              path, NULLSTR_MINUS(virBufferCurrentContent(&buf)));\n\n    fw->interfaces = g_steal_pointer(&interfaces);\n    fw->ninterfaces = ninterfaces;\n    return 0;\n}"
  },
  {
    "function_name": "qemuFirmwareFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "265-281",
    "snippet": "void\nqemuFirmwareFree(qemuFirmwarePtr fw)\n{\n    size_t i;\n\n    if (!fw)\n        return;\n\n    qemuFirmwareOSInterfaceFree(fw->interfaces);\n    qemuFirmwareMappingFree(fw->mapping);\n    for (i = 0; i < fw->ntargets; i++)\n        qemuFirmwareTargetFree(fw->targets[i]);\n    VIR_FREE(fw->targets);\n    qemuFirmwareFeatureFree(fw->features);\n\n    VIR_FREE(fw);\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fw"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuFirmwareFeatureFree",
          "args": [
            "fw->features"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareFeatureFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "255-259",
          "snippet": "static void\nqemuFirmwareFeatureFree(qemuFirmwareFeature *features)\n{\n    VIR_FREE(features);\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareFeatureFree(qemuFirmwareFeature *features)\n{\n    VIR_FREE(features);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fw->targets"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuFirmwareTargetFree",
          "args": [
            "fw->targets[i]"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareTargetFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "240-249",
          "snippet": "static void\nqemuFirmwareTargetFree(qemuFirmwareTargetPtr target)\n{\n    if (!target)\n        return;\n\n    virStringListFreeCount(target->machines, target->nmachines);\n\n    VIR_FREE(target);\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareTargetFree(qemuFirmwareTargetPtr target)\n{\n    if (!target)\n        return;\n\n    virStringListFreeCount(target->machines, target->nmachines);\n\n    VIR_FREE(target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareMappingFree",
          "args": [
            "fw->mapping"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareMappingFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "220-237",
          "snippet": "static void\nqemuFirmwareMappingFree(qemuFirmwareMapping mapping)\n{\n    switch (mapping.device) {\n    case QEMU_FIRMWARE_DEVICE_FLASH:\n        qemuFirmwareMappingFlashFree(mapping.data.flash);\n        break;\n    case QEMU_FIRMWARE_DEVICE_KERNEL:\n        qemuFirmwareMappingKernelFree(mapping.data.kernel);\n        break;\n    case QEMU_FIRMWARE_DEVICE_MEMORY:\n        qemuFirmwareMappingMemoryFree(mapping.data.memory);\n        break;\n    case QEMU_FIRMWARE_DEVICE_NONE:\n    case QEMU_FIRMWARE_DEVICE_LAST:\n        break;\n    }\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareMappingFree(qemuFirmwareMapping mapping)\n{\n    switch (mapping.device) {\n    case QEMU_FIRMWARE_DEVICE_FLASH:\n        qemuFirmwareMappingFlashFree(mapping.data.flash);\n        break;\n    case QEMU_FIRMWARE_DEVICE_KERNEL:\n        qemuFirmwareMappingKernelFree(mapping.data.kernel);\n        break;\n    case QEMU_FIRMWARE_DEVICE_MEMORY:\n        qemuFirmwareMappingMemoryFree(mapping.data.memory);\n        break;\n    case QEMU_FIRMWARE_DEVICE_NONE:\n    case QEMU_FIRMWARE_DEVICE_LAST:\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareOSInterfaceFree",
          "args": [
            "fw->interfaces"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareOSInterfaceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "180-184",
          "snippet": "static void\nqemuFirmwareOSInterfaceFree(qemuFirmwareOSInterface *interfaces)\n{\n    VIR_FREE(interfaces);\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareOSInterfaceFree(qemuFirmwareOSInterface *interfaces)\n{\n    VIR_FREE(interfaces);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nvoid\nqemuFirmwareFree(qemuFirmwarePtr fw)\n{\n    size_t i;\n\n    if (!fw)\n        return;\n\n    qemuFirmwareOSInterfaceFree(fw->interfaces);\n    qemuFirmwareMappingFree(fw->mapping);\n    for (i = 0; i < fw->ntargets; i++)\n        qemuFirmwareTargetFree(fw->targets[i]);\n    VIR_FREE(fw->targets);\n    qemuFirmwareFeatureFree(fw->features);\n\n    VIR_FREE(fw);\n}"
  },
  {
    "function_name": "qemuFirmwareFeatureFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "255-259",
    "snippet": "static void\nqemuFirmwareFeatureFree(qemuFirmwareFeature *features)\n{\n    VIR_FREE(features);\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "features"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareFeatureFree(qemuFirmwareFeature *features)\n{\n    VIR_FREE(features);\n}"
  },
  {
    "function_name": "qemuFirmwareTargetFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "240-249",
    "snippet": "static void\nqemuFirmwareTargetFree(qemuFirmwareTargetPtr target)\n{\n    if (!target)\n        return;\n\n    virStringListFreeCount(target->machines, target->nmachines);\n\n    VIR_FREE(target);\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "target"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListFreeCount",
          "args": [
            "target->machines",
            "target->nmachines"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFreeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "334-347",
          "snippet": "void\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareTargetFree(qemuFirmwareTargetPtr target)\n{\n    if (!target)\n        return;\n\n    virStringListFreeCount(target->machines, target->nmachines);\n\n    VIR_FREE(target);\n}"
  },
  {
    "function_name": "qemuFirmwareMappingFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "220-237",
    "snippet": "static void\nqemuFirmwareMappingFree(qemuFirmwareMapping mapping)\n{\n    switch (mapping.device) {\n    case QEMU_FIRMWARE_DEVICE_FLASH:\n        qemuFirmwareMappingFlashFree(mapping.data.flash);\n        break;\n    case QEMU_FIRMWARE_DEVICE_KERNEL:\n        qemuFirmwareMappingKernelFree(mapping.data.kernel);\n        break;\n    case QEMU_FIRMWARE_DEVICE_MEMORY:\n        qemuFirmwareMappingMemoryFree(mapping.data.memory);\n        break;\n    case QEMU_FIRMWARE_DEVICE_NONE:\n    case QEMU_FIRMWARE_DEVICE_LAST:\n        break;\n    }\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuFirmwareMappingMemoryFree",
          "args": [
            "mapping.data.memory"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareMappingMemoryFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "213-217",
          "snippet": "static void\nqemuFirmwareMappingMemoryFree(qemuFirmwareMappingMemory memory)\n{\n    VIR_FREE(memory.filename);\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareMappingMemoryFree(qemuFirmwareMappingMemory memory)\n{\n    VIR_FREE(memory.filename);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareMappingKernelFree",
          "args": [
            "mapping.data.kernel"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareMappingKernelFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "206-210",
          "snippet": "static void\nqemuFirmwareMappingKernelFree(qemuFirmwareMappingKernel kernel)\n{\n    VIR_FREE(kernel.filename);\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareMappingKernelFree(qemuFirmwareMappingKernel kernel)\n{\n    VIR_FREE(kernel.filename);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuFirmwareMappingFlashFree",
          "args": [
            "mapping.data.flash"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareMappingFlashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "198-203",
          "snippet": "static void\nqemuFirmwareMappingFlashFree(qemuFirmwareMappingFlash flash)\n{\n    qemuFirmwareFlashFileFree(flash.executable);\n    qemuFirmwareFlashFileFree(flash.nvram_template);\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareMappingFlashFree(qemuFirmwareMappingFlash flash)\n{\n    qemuFirmwareFlashFileFree(flash.executable);\n    qemuFirmwareFlashFileFree(flash.nvram_template);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareMappingFree(qemuFirmwareMapping mapping)\n{\n    switch (mapping.device) {\n    case QEMU_FIRMWARE_DEVICE_FLASH:\n        qemuFirmwareMappingFlashFree(mapping.data.flash);\n        break;\n    case QEMU_FIRMWARE_DEVICE_KERNEL:\n        qemuFirmwareMappingKernelFree(mapping.data.kernel);\n        break;\n    case QEMU_FIRMWARE_DEVICE_MEMORY:\n        qemuFirmwareMappingMemoryFree(mapping.data.memory);\n        break;\n    case QEMU_FIRMWARE_DEVICE_NONE:\n    case QEMU_FIRMWARE_DEVICE_LAST:\n        break;\n    }\n}"
  },
  {
    "function_name": "qemuFirmwareMappingMemoryFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "213-217",
    "snippet": "static void\nqemuFirmwareMappingMemoryFree(qemuFirmwareMappingMemory memory)\n{\n    VIR_FREE(memory.filename);\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "memory.filename"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareMappingMemoryFree(qemuFirmwareMappingMemory memory)\n{\n    VIR_FREE(memory.filename);\n}"
  },
  {
    "function_name": "qemuFirmwareMappingKernelFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "206-210",
    "snippet": "static void\nqemuFirmwareMappingKernelFree(qemuFirmwareMappingKernel kernel)\n{\n    VIR_FREE(kernel.filename);\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "kernel.filename"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareMappingKernelFree(qemuFirmwareMappingKernel kernel)\n{\n    VIR_FREE(kernel.filename);\n}"
  },
  {
    "function_name": "qemuFirmwareMappingFlashFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "198-203",
    "snippet": "static void\nqemuFirmwareMappingFlashFree(qemuFirmwareMappingFlash flash)\n{\n    qemuFirmwareFlashFileFree(flash.executable);\n    qemuFirmwareFlashFileFree(flash.nvram_template);\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuFirmwareFlashFileFree",
          "args": [
            "flash.nvram_template"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareFlashFileFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "190-195",
          "snippet": "static void\nqemuFirmwareFlashFileFree(qemuFirmwareFlashFile flash)\n{\n    VIR_FREE(flash.filename);\n    VIR_FREE(flash.format);\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareFlashFileFree(qemuFirmwareFlashFile flash)\n{\n    VIR_FREE(flash.filename);\n    VIR_FREE(flash.format);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareMappingFlashFree(qemuFirmwareMappingFlash flash)\n{\n    qemuFirmwareFlashFileFree(flash.executable);\n    qemuFirmwareFlashFileFree(flash.nvram_template);\n}"
  },
  {
    "function_name": "qemuFirmwareFlashFileFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "190-195",
    "snippet": "static void\nqemuFirmwareFlashFileFree(qemuFirmwareFlashFile flash)\n{\n    VIR_FREE(flash.filename);\n    VIR_FREE(flash.format);\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "flash.format"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "flash.filename"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareFlashFileFree(qemuFirmwareFlashFile flash)\n{\n    VIR_FREE(flash.filename);\n    VIR_FREE(flash.format);\n}"
  },
  {
    "function_name": "qemuFirmwareOSInterfaceFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
    "lines": "180-184",
    "snippet": "static void\nqemuFirmwareOSInterfaceFree(qemuFirmwareOSInterface *interfaces)\n{\n    VIR_FREE(interfaces);\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virarch.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"configmake.h\"",
      "#include \"qemu_interop_config.h\"",
      "#include \"qemu_firmware.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "interfaces"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nstatic void\nqemuFirmwareOSInterfaceFree(qemuFirmwareOSInterface *interfaces)\n{\n    VIR_FREE(interfaces);\n}"
  }
]