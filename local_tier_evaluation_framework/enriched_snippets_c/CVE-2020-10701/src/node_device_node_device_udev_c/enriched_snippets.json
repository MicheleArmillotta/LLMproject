[
  {
    "function_name": "udevNodeRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1976-1987",
    "snippet": "int\nudevNodeRegister(void)\n{\n    VIR_DEBUG(\"Registering udev node device backend\");\n\n    if (virRegisterConnectDriver(&udevConnectDriver, false) < 0)\n        return -1;\n    if (virSetSharedNodeDeviceDriver(&udevNodeDeviceDriver) < 0)\n        return -1;\n\n    return virRegisterStateDriver(&udevStateDriver);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNodeDeviceDriver udevNodeDeviceDriver = {\n    .name = \"udev\",\n    .nodeNumOfDevices = nodeNumOfDevices, /* 0.7.3 */\n    .nodeListDevices = nodeListDevices, /* 0.7.3 */\n    .connectListAllNodeDevices = nodeConnectListAllNodeDevices, /* 0.10.2 */\n    .connectNodeDeviceEventRegisterAny = nodeConnectNodeDeviceEventRegisterAny, /* 2.2.0 */\n    .connectNodeDeviceEventDeregisterAny = nodeConnectNodeDeviceEventDeregisterAny, /* 2.2.0 */\n    .nodeDeviceLookupByName = nodeDeviceLookupByName, /* 0.7.3 */\n    .nodeDeviceLookupSCSIHostByWWN = nodeDeviceLookupSCSIHostByWWN, /* 1.0.2 */\n    .nodeDeviceGetXMLDesc = nodeDeviceGetXMLDesc, /* 0.7.3 */\n    .nodeDeviceGetParent = nodeDeviceGetParent, /* 0.7.3 */\n    .nodeDeviceNumOfCaps = nodeDeviceNumOfCaps, /* 0.7.3 */\n    .nodeDeviceListCaps = nodeDeviceListCaps, /* 0.7.3 */\n    .nodeDeviceCreateXML = nodeDeviceCreateXML, /* 0.7.3 */\n    .nodeDeviceDestroy = nodeDeviceDestroy, /* 0.7.3 */\n};",
      "static virConnectDriver udevConnectDriver = {\n    .localOnly = true,\n    .uriSchemes = (const char *[]){ \"nodedev\", NULL },\n    .hypervisorDriver = &udevHypervisorDriver,\n    .nodeDeviceDriver = &udevNodeDeviceDriver,\n};",
      "static virStateDriver udevStateDriver = {\n    .name = \"udev\",\n    .stateInitialize = nodeStateInitialize, /* 0.7.3 */\n    .stateCleanup = nodeStateCleanup, /* 0.7.3 */\n    .stateReload = nodeStateReload, /* 0.7.3 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virRegisterStateDriver",
          "args": [
            "&udevStateDriver"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "virRegisterStateDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "588-602",
          "snippet": "int\nvirRegisterStateDriver(virStateDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virStateDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->name);\n        return -1;\n    }\n\n    virStateDriverTab[virStateDriverTabCount] = driver;\n    return virStateDriverTabCount++;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_DRIVERS 21"
          ],
          "globals_used": [
            "static virStateDriverPtr virStateDriverTab[MAX_DRIVERS];",
            "static int virStateDriverTabCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define MAX_DRIVERS 21\n\nstatic virStateDriverPtr virStateDriverTab[MAX_DRIVERS];\nstatic int virStateDriverTabCount;\n\nint\nvirRegisterStateDriver(virStateDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virStateDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->name);\n        return -1;\n    }\n\n    virStateDriverTab[virStateDriverTabCount] = driver;\n    return virStateDriverTabCount++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetSharedNodeDeviceDriver",
          "args": [
            "&udevNodeDeviceDriver"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "virSetSharedNodeDeviceDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "435-450",
          "snippet": "int\nvirSetSharedNodeDeviceDriver(virNodeDeviceDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedNodeDeviceDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A node device driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as device driver\", driver->name);\n\n    virSharedNodeDeviceDriver = driver;\n    return 0;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNodeDeviceDriverPtr virSharedNodeDeviceDriver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNodeDeviceDriverPtr virSharedNodeDeviceDriver;\n\nint\nvirSetSharedNodeDeviceDriver(virNodeDeviceDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedNodeDeviceDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A node device driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as device driver\", driver->name);\n\n    virSharedNodeDeviceDriver = driver;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virRegisterConnectDriver",
          "args": [
            "&udevConnectDriver",
            "false"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "virRegisterConnectDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "515-550",
          "snippet": "int\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_DRIVERS 21"
          ],
          "globals_used": [
            "static virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];",
            "static int virConnectDriverTabCount;",
            "static virNetworkDriverPtr virSharedNetworkDriver;",
            "static virInterfaceDriverPtr virSharedInterfaceDriver;",
            "static virStorageDriverPtr virSharedStorageDriver;",
            "static virNodeDeviceDriverPtr virSharedNodeDeviceDriver;",
            "static virSecretDriverPtr virSharedSecretDriver;",
            "static virNWFilterDriverPtr virSharedNWFilterDriver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define MAX_DRIVERS 21\n\nstatic virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];\nstatic int virConnectDriverTabCount;\nstatic virNetworkDriverPtr virSharedNetworkDriver;\nstatic virInterfaceDriverPtr virSharedInterfaceDriver;\nstatic virStorageDriverPtr virSharedStorageDriver;\nstatic virNodeDeviceDriverPtr virSharedNodeDeviceDriver;\nstatic virSecretDriverPtr virSharedSecretDriver;\nstatic virNWFilterDriverPtr virSharedNWFilterDriver;\n\nint\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Registering udev node device backend\""
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic virNodeDeviceDriver udevNodeDeviceDriver = {\n    .name = \"udev\",\n    .nodeNumOfDevices = nodeNumOfDevices, /* 0.7.3 */\n    .nodeListDevices = nodeListDevices, /* 0.7.3 */\n    .connectListAllNodeDevices = nodeConnectListAllNodeDevices, /* 0.10.2 */\n    .connectNodeDeviceEventRegisterAny = nodeConnectNodeDeviceEventRegisterAny, /* 2.2.0 */\n    .connectNodeDeviceEventDeregisterAny = nodeConnectNodeDeviceEventDeregisterAny, /* 2.2.0 */\n    .nodeDeviceLookupByName = nodeDeviceLookupByName, /* 0.7.3 */\n    .nodeDeviceLookupSCSIHostByWWN = nodeDeviceLookupSCSIHostByWWN, /* 1.0.2 */\n    .nodeDeviceGetXMLDesc = nodeDeviceGetXMLDesc, /* 0.7.3 */\n    .nodeDeviceGetParent = nodeDeviceGetParent, /* 0.7.3 */\n    .nodeDeviceNumOfCaps = nodeDeviceNumOfCaps, /* 0.7.3 */\n    .nodeDeviceListCaps = nodeDeviceListCaps, /* 0.7.3 */\n    .nodeDeviceCreateXML = nodeDeviceCreateXML, /* 0.7.3 */\n    .nodeDeviceDestroy = nodeDeviceDestroy, /* 0.7.3 */\n};\nstatic virConnectDriver udevConnectDriver = {\n    .localOnly = true,\n    .uriSchemes = (const char *[]){ \"nodedev\", NULL },\n    .hypervisorDriver = &udevHypervisorDriver,\n    .nodeDeviceDriver = &udevNodeDeviceDriver,\n};\nstatic virStateDriver udevStateDriver = {\n    .name = \"udev\",\n    .stateInitialize = nodeStateInitialize, /* 0.7.3 */\n    .stateCleanup = nodeStateCleanup, /* 0.7.3 */\n    .stateReload = nodeStateReload, /* 0.7.3 */\n};\n\nint\nudevNodeRegister(void)\n{\n    VIR_DEBUG(\"Registering udev node device backend\");\n\n    if (virRegisterConnectDriver(&udevConnectDriver, false) < 0)\n        return -1;\n    if (virSetSharedNodeDeviceDriver(&udevNodeDeviceDriver) < 0)\n        return -1;\n\n    return virRegisterStateDriver(&udevStateDriver);\n}"
  },
  {
    "function_name": "nodeStateReload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1925-1929",
    "snippet": "static int\nnodeStateReload(void)\n{\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nnodeStateReload(void)\n{\n    return 0;\n}"
  },
  {
    "function_name": "nodeStateInitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1789-1922",
    "snippet": "static int\nnodeStateInitialize(bool privileged,\n                    const char *root,\n                    virStateInhibitCallback callback G_GNUC_UNUSED,\n                    void *opaque G_GNUC_UNUSED)\n{\n    udevEventDataPtr priv = NULL;\n    struct udev *udev = NULL;\n    virThread enumThread;\n\n    if (root != NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Driver does not support embedded mode\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(driver) < 0)\n        return VIR_DRV_STATE_INIT_ERROR;\n\n    driver->lockFD = -1;\n    if (virMutexInit(&driver->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        VIR_FREE(driver);\n        return VIR_DRV_STATE_INIT_ERROR;\n    }\n    if (virCondInit(&driver->initCond) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to initialize condition variable\"));\n        virMutexDestroy(&driver->lock);\n        VIR_FREE(driver);\n        return VIR_DRV_STATE_INIT_ERROR;\n    }\n\n    driver->privileged = privileged;\n\n    if (privileged) {\n        driver->stateDir = g_strdup_printf(\"%s/libvirt/nodedev\", RUNSTATEDIR);\n    } else {\n        g_autofree char *rundir = NULL;\n\n        rundir = virGetUserRuntimeDirectory();\n        driver->stateDir = g_strdup_printf(\"%s/nodedev/run\", rundir);\n    }\n\n    if (virFileMakePathWithMode(driver->stateDir, S_IRWXU) < 0) {\n        virReportSystemError(errno, _(\"cannot create state directory '%s'\"),\n                             driver->stateDir);\n        goto cleanup;\n    }\n\n    if ((driver->lockFD =\n         virPidFileAcquire(driver->stateDir, \"driver\", false, getpid())) < 0)\n        goto cleanup;\n\n    if (!(driver->devs = virNodeDeviceObjListNew()) ||\n        !(priv = udevEventDataNew()))\n        goto cleanup;\n\n    driver->privateData = priv;\n    driver->nodeDeviceEventState = virObjectEventStateNew();\n\n    if (udevPCITranslateInit(privileged) < 0)\n        goto cleanup;\n\n    udev = udev_new();\n    if (!udev) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to create udev context\"));\n        goto cleanup;\n    }\n\n    virObjectLock(priv);\n\n    priv->udev_monitor = udev_monitor_new_from_netlink(udev, \"udev\");\n    if (!priv->udev_monitor) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"udev_monitor_new_from_netlink returned NULL\"));\n        goto unlock;\n    }\n\n    udev_monitor_enable_receiving(priv->udev_monitor);\n\n    /* mimic udevd's behaviour and override the systems rmem_max limit in case\n     * there's a significant number of device 'add' events\n     */\n    if (geteuid() == 0)\n        udev_monitor_set_receive_buffer_size(priv->udev_monitor,\n                                             128 * 1024 * 1024);\n\n    if (virThreadCreateFull(&priv->th, true, udevEventHandleThread,\n                            \"udev-event\", false, NULL) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to create udev handler thread\"));\n        goto unlock;\n    }\n\n    /* We register the monitor with the event callback so we are\n     * notified by udev of device changes before we enumerate existing\n     * devices because libvirt will simply recreate the device if we\n     * try to register it twice, i.e., if the device appears between\n     * the time we register the callback and the time we begin\n     * enumeration.  The alternative is to register the callback after\n     * we enumerate, in which case we will fail to create any devices\n     * that appear while the enumeration is taking place.  */\n    priv->watch = virEventAddHandle(udev_monitor_get_fd(priv->udev_monitor),\n                                    VIR_EVENT_HANDLE_READABLE,\n                                    udevEventHandleCallback, NULL, NULL);\n    if (priv->watch == -1)\n        goto unlock;\n\n    virObjectUnlock(priv);\n\n    /* Create a fictional 'computer' device to root the device tree. */\n    if (udevSetupSystemDev() != 0)\n        goto cleanup;\n\n    if (virThreadCreateFull(&enumThread, false, nodeStateInitializeEnumerate,\n                            \"nodedev-init\", false, udev) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to create udev enumerate thread\"));\n        goto cleanup;\n    }\n\n    return VIR_DRV_STATE_INIT_COMPLETE;\n\n cleanup:\n    nodeStateCleanup();\n    return VIR_DRV_STATE_INIT_ERROR;\n\n unlock:\n    virObjectUnlock(priv);\n    goto cleanup;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "priv"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodeStateCleanup",
          "args": [],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "nodeStateCleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1454-1486",
          "snippet": "static int\nnodeStateCleanup(void)\n{\n    udevEventDataPtr priv = NULL;\n\n    if (!driver)\n        return -1;\n\n    priv = driver->privateData;\n    if (priv) {\n        virObjectLock(priv);\n        priv->threadQuit = true;\n        virCondSignal(&priv->threadCond);\n        virObjectUnlock(priv);\n        virThreadJoin(&priv->th);\n    }\n\n    virObjectUnref(priv);\n    virObjectUnref(driver->nodeDeviceEventState);\n\n    virNodeDeviceObjListFree(driver->devs);\n\n    if (driver->lockFD != -1)\n        virPidFileRelease(driver->stateDir, \"driver\", driver->lockFD);\n\n    VIR_FREE(driver->stateDir);\n    virCondDestroy(&driver->initCond);\n    virMutexDestroy(&driver->lock);\n    VIR_FREE(driver);\n\n    udevPCITranslateDeinit();\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nnodeStateCleanup(void)\n{\n    udevEventDataPtr priv = NULL;\n\n    if (!driver)\n        return -1;\n\n    priv = driver->privateData;\n    if (priv) {\n        virObjectLock(priv);\n        priv->threadQuit = true;\n        virCondSignal(&priv->threadCond);\n        virObjectUnlock(priv);\n        virThreadJoin(&priv->th);\n    }\n\n    virObjectUnref(priv);\n    virObjectUnref(driver->nodeDeviceEventState);\n\n    virNodeDeviceObjListFree(driver->devs);\n\n    if (driver->lockFD != -1)\n        virPidFileRelease(driver->stateDir, \"driver\", driver->lockFD);\n\n    VIR_FREE(driver->stateDir);\n    virCondDestroy(&driver->initCond);\n    virMutexDestroy(&driver->lock);\n    VIR_FREE(driver);\n\n    udevPCITranslateDeinit();\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"failed to create udev enumerate thread\")"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to create udev enumerate thread\""
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadCreateFull",
          "args": [
            "&enumThread",
            "false",
            "nodeStateInitializeEnumerate",
            "\"nodedev-init\"",
            "false",
            "udev"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadCreateFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "242-283",
          "snippet": "int virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevSetupSystemDev",
          "args": [],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "udevSetupSystemDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1704-1735",
          "snippet": "static int\nudevSetupSystemDev(void)\n{\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    int ret = -1;\n\n    if (VIR_ALLOC(def) < 0)\n        return -1;\n\n    def->name = g_strdup(\"computer\");\n\n    if (VIR_ALLOC(def->caps) != 0)\n        goto cleanup;\n\n#if defined(__x86_64__) || defined(__i386__) || defined(__amd64__)\n    udevGetDMIData(&def->caps->data.system);\n#endif\n\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def)))\n        goto cleanup;\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    ret = 0;\n\n cleanup:\n    if (ret == -1)\n        virNodeDeviceDefFree(def);\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevSetupSystemDev(void)\n{\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    int ret = -1;\n\n    if (VIR_ALLOC(def) < 0)\n        return -1;\n\n    def->name = g_strdup(\"computer\");\n\n    if (VIR_ALLOC(def->caps) != 0)\n        goto cleanup;\n\n#if defined(__x86_64__) || defined(__i386__) || defined(__amd64__)\n    udevGetDMIData(&def->caps->data.system);\n#endif\n\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def)))\n        goto cleanup;\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    ret = 0;\n\n cleanup:\n    if (ret == -1)\n        virNodeDeviceDefFree(def);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virEventAddHandle",
          "args": [
            "udev_monitor_get_fd(priv->udev_monitor)",
            "VIR_EVENT_HANDLE_READABLE",
            "udevEventHandleCallback",
            "NULL",
            "NULL"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "virEventAddHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "73-84",
          "snippet": "int\nvirEventAddHandle(int fd,\n                  int events,\n                  virEventHandleCallback cb,\n                  void *opaque,\n                  virFreeCallback ff)\n{\n    if (!addHandleImpl)\n        return -1;\n\n    return addHandleImpl(fd, events, cb, opaque, ff);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventAddHandleFunc addHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventAddHandleFunc addHandleImpl;\n\nint\nvirEventAddHandle(int fd,\n                  int events,\n                  virEventHandleCallback cb,\n                  void *opaque,\n                  virFreeCallback ff)\n{\n    if (!addHandleImpl)\n        return -1;\n\n    return addHandleImpl(fd, events, cb, opaque, ff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_monitor_get_fd",
          "args": [
            "priv->udev_monitor"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"failed to create udev handler thread\")"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_monitor_set_receive_buffer_size",
          "args": [
            "priv->udev_monitor",
            "128 * 1024 * 1024"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "udev_monitor_enable_receiving",
          "args": [
            "priv->udev_monitor"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"udev_monitor_new_from_netlink returned NULL\")"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_monitor_new_from_netlink",
          "args": [
            "udev",
            "\"udev\""
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "priv"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to create udev context\")"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_new",
          "args": [],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevPCITranslateInit",
          "args": [
            "privileged"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "udevPCITranslateInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1765-1786",
          "snippet": "static int\nudevPCITranslateInit(bool privileged G_GNUC_UNUSED)\n{\n#if defined __s390__ || defined __s390x_\n    /* On s390(x) system there is no PCI bus.\n     * Therefore there is nothing to initialize here. */\n#else\n    int rc;\n\n    if ((rc = pci_system_init()) != 0) {\n        /* Ignore failure as non-root; udev is not as helpful in that\n         * situation, but a non-privileged user won't benefit much\n         * from udev in the first place.  */\n        if (errno != ENOENT && (privileged  || errno != EACCES)) {\n            virReportSystemError(rc, \"%s\",\n                                 _(\"Failed to initialize libpciaccess\"));\n            return -1;\n        }\n    }\n#endif\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevPCITranslateInit(bool privileged G_GNUC_UNUSED)\n{\n#if defined __s390__ || defined __s390x_\n    /* On s390(x) system there is no PCI bus.\n     * Therefore there is nothing to initialize here. */\n#else\n    int rc;\n\n    if ((rc = pci_system_init()) != 0) {\n        /* Ignore failure as non-root; udev is not as helpful in that\n         * situation, but a non-privileged user won't benefit much\n         * from udev in the first place.  */\n        if (errno != ENOENT && (privileged  || errno != EACCES)) {\n            virReportSystemError(rc, \"%s\",\n                                 _(\"Failed to initialize libpciaccess\"));\n            return -1;\n        }\n    }\n#endif\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectEventStateNew",
          "args": [],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "558-582",
          "snippet": "virObjectEventStatePtr\nvirObjectEventStateNew(void)\n{\n    virObjectEventStatePtr state = NULL;\n\n    if (virObjectEventInitialize() < 0)\n        return NULL;\n\n    if (!(state = virObjectLockableNew(virObjectEventStateClass)))\n        return NULL;\n\n    if (VIR_ALLOC(state->callbacks) < 0)\n        goto error;\n\n    if (!(state->queue = virObjectEventQueueNew()))\n        goto error;\n\n    state->timer = -1;\n\n    return state;\n\n error:\n    virObjectUnref(state);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectEventStateClass;",
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectEventStateClass;\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvirObjectEventStatePtr\nvirObjectEventStateNew(void)\n{\n    virObjectEventStatePtr state = NULL;\n\n    if (virObjectEventInitialize() < 0)\n        return NULL;\n\n    if (!(state = virObjectLockableNew(virObjectEventStateClass)))\n        return NULL;\n\n    if (VIR_ALLOC(state->callbacks) < 0)\n        goto error;\n\n    if (!(state->queue = virObjectEventQueueNew()))\n        goto error;\n\n    state->timer = -1;\n\n    return state;\n\n error:\n    virObjectUnref(state);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevEventDataNew",
          "args": [],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "udevEventDataNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "104-122",
          "snippet": "static udevEventDataPtr\nudevEventDataNew(void)\n{\n    udevEventDataPtr ret = NULL;\n\n    if (udevEventDataInitialize() < 0)\n        return NULL;\n\n    if (!(ret = virObjectLockableNew(udevEventDataClass)))\n        return NULL;\n\n    if (virCondInit(&ret->threadCond) < 0) {\n        virObjectUnref(ret);\n        return NULL;\n    }\n\n    ret->watch = -1;\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr udevEventDataClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic virClassPtr udevEventDataClass;\n\nstatic udevEventDataPtr\nudevEventDataNew(void)\n{\n    udevEventDataPtr ret = NULL;\n\n    if (udevEventDataInitialize() < 0)\n        return NULL;\n\n    if (!(ret = virObjectLockableNew(udevEventDataClass)))\n        return NULL;\n\n    if (virCondInit(&ret->threadCond) < 0) {\n        virObjectUnref(ret);\n        return NULL;\n    }\n\n    ret->watch = -1;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjListNew",
          "args": [],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "412-429",
          "snippet": "virNodeDeviceObjListPtr\nvirNodeDeviceObjListNew(void)\n{\n    virNodeDeviceObjListPtr devs;\n\n    if (virNodeDeviceObjInitialize() < 0)\n        return NULL;\n\n    if (!(devs = virObjectRWLockableNew(virNodeDeviceObjListClass)))\n        return NULL;\n\n    if (!(devs->objs = virHashCreate(50, virObjectFreeHashData))) {\n        virObjectUnref(devs);\n        return NULL;\n    }\n\n    return devs;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNodeDeviceObjListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nstatic virClassPtr virNodeDeviceObjListClass;\n\nvirNodeDeviceObjListPtr\nvirNodeDeviceObjListNew(void)\n{\n    virNodeDeviceObjListPtr devs;\n\n    if (virNodeDeviceObjInitialize() < 0)\n        return NULL;\n\n    if (!(devs = virObjectRWLockableNew(virNodeDeviceObjListClass)))\n        return NULL;\n\n    if (!(devs->objs = virHashCreate(50, virObjectFreeHashData))) {\n        virObjectUnref(devs);\n        return NULL;\n    }\n\n    return devs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileAcquire",
          "args": [
            "driver->stateDir",
            "\"driver\"",
            "false",
            "getpid()"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileAcquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "413-427",
          "snippet": "int virPidFileAcquire(const char *dir,\n                      const char *name,\n                      bool waitForLock,\n                      pid_t pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileAcquirePath(pidfile, waitForLock, pid);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileAcquire(const char *dir,\n                      const char *name,\n                      bool waitForLock,\n                      pid_t pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileAcquirePath(pidfile, waitForLock, pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot create state directory '%s'\")",
            "driver->stateDir"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileMakePathWithMode",
          "args": [
            "driver->stateDir",
            "S_IRWXU"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePathWithMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3082-3091",
          "snippet": "int\nvirFileMakePathWithMode(const char *path,\n                        mode_t mode)\n{\n    g_autofree char *tmp = NULL;\n\n    tmp = g_strdup(path);\n\n    return virFileMakePathHelper(tmp, mode);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePathWithMode(const char *path,\n                        mode_t mode)\n{\n    g_autofree char *tmp = NULL;\n\n    tmp = g_strdup(path);\n\n    return virFileMakePathHelper(tmp, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/nodedev/run\"",
            "rundir"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetUserRuntimeDirectory",
          "args": [],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserRuntimeDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "594-601",
          "snippet": "char *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexDestroy",
          "args": [
            "&driver->lock"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "76-79",
          "snippet": "void virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to initialize condition variable\")"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCondInit",
          "args": [
            "&driver->initCond"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "virCondInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "125-133",
          "snippet": "int virCondInit(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_init(&c->cond, NULL)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondInit(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_init(&c->cond, NULL)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to initialize mutex\")"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexInit",
          "args": [
            "&driver->lock"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexInitRecursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "61-74",
          "snippet": "int virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "driver"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Driver does not support embedded mode\")"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nnodeStateInitialize(bool privileged,\n                    const char *root,\n                    virStateInhibitCallback callback G_GNUC_UNUSED,\n                    void *opaque G_GNUC_UNUSED)\n{\n    udevEventDataPtr priv = NULL;\n    struct udev *udev = NULL;\n    virThread enumThread;\n\n    if (root != NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Driver does not support embedded mode\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(driver) < 0)\n        return VIR_DRV_STATE_INIT_ERROR;\n\n    driver->lockFD = -1;\n    if (virMutexInit(&driver->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        VIR_FREE(driver);\n        return VIR_DRV_STATE_INIT_ERROR;\n    }\n    if (virCondInit(&driver->initCond) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to initialize condition variable\"));\n        virMutexDestroy(&driver->lock);\n        VIR_FREE(driver);\n        return VIR_DRV_STATE_INIT_ERROR;\n    }\n\n    driver->privileged = privileged;\n\n    if (privileged) {\n        driver->stateDir = g_strdup_printf(\"%s/libvirt/nodedev\", RUNSTATEDIR);\n    } else {\n        g_autofree char *rundir = NULL;\n\n        rundir = virGetUserRuntimeDirectory();\n        driver->stateDir = g_strdup_printf(\"%s/nodedev/run\", rundir);\n    }\n\n    if (virFileMakePathWithMode(driver->stateDir, S_IRWXU) < 0) {\n        virReportSystemError(errno, _(\"cannot create state directory '%s'\"),\n                             driver->stateDir);\n        goto cleanup;\n    }\n\n    if ((driver->lockFD =\n         virPidFileAcquire(driver->stateDir, \"driver\", false, getpid())) < 0)\n        goto cleanup;\n\n    if (!(driver->devs = virNodeDeviceObjListNew()) ||\n        !(priv = udevEventDataNew()))\n        goto cleanup;\n\n    driver->privateData = priv;\n    driver->nodeDeviceEventState = virObjectEventStateNew();\n\n    if (udevPCITranslateInit(privileged) < 0)\n        goto cleanup;\n\n    udev = udev_new();\n    if (!udev) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to create udev context\"));\n        goto cleanup;\n    }\n\n    virObjectLock(priv);\n\n    priv->udev_monitor = udev_monitor_new_from_netlink(udev, \"udev\");\n    if (!priv->udev_monitor) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"udev_monitor_new_from_netlink returned NULL\"));\n        goto unlock;\n    }\n\n    udev_monitor_enable_receiving(priv->udev_monitor);\n\n    /* mimic udevd's behaviour and override the systems rmem_max limit in case\n     * there's a significant number of device 'add' events\n     */\n    if (geteuid() == 0)\n        udev_monitor_set_receive_buffer_size(priv->udev_monitor,\n                                             128 * 1024 * 1024);\n\n    if (virThreadCreateFull(&priv->th, true, udevEventHandleThread,\n                            \"udev-event\", false, NULL) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to create udev handler thread\"));\n        goto unlock;\n    }\n\n    /* We register the monitor with the event callback so we are\n     * notified by udev of device changes before we enumerate existing\n     * devices because libvirt will simply recreate the device if we\n     * try to register it twice, i.e., if the device appears between\n     * the time we register the callback and the time we begin\n     * enumeration.  The alternative is to register the callback after\n     * we enumerate, in which case we will fail to create any devices\n     * that appear while the enumeration is taking place.  */\n    priv->watch = virEventAddHandle(udev_monitor_get_fd(priv->udev_monitor),\n                                    VIR_EVENT_HANDLE_READABLE,\n                                    udevEventHandleCallback, NULL, NULL);\n    if (priv->watch == -1)\n        goto unlock;\n\n    virObjectUnlock(priv);\n\n    /* Create a fictional 'computer' device to root the device tree. */\n    if (udevSetupSystemDev() != 0)\n        goto cleanup;\n\n    if (virThreadCreateFull(&enumThread, false, nodeStateInitializeEnumerate,\n                            \"nodedev-init\", false, udev) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to create udev enumerate thread\"));\n        goto cleanup;\n    }\n\n    return VIR_DRV_STATE_INIT_COMPLETE;\n\n cleanup:\n    nodeStateCleanup();\n    return VIR_DRV_STATE_INIT_ERROR;\n\n unlock:\n    virObjectUnlock(priv);\n    goto cleanup;\n}"
  },
  {
    "function_name": "udevPCITranslateInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1765-1786",
    "snippet": "static int\nudevPCITranslateInit(bool privileged G_GNUC_UNUSED)\n{\n#if defined __s390__ || defined __s390x_\n    /* On s390(x) system there is no PCI bus.\n     * Therefore there is nothing to initialize here. */\n#else\n    int rc;\n\n    if ((rc = pci_system_init()) != 0) {\n        /* Ignore failure as non-root; udev is not as helpful in that\n         * situation, but a non-privileged user won't benefit much\n         * from udev in the first place.  */\n        if (errno != ENOENT && (privileged  || errno != EACCES)) {\n            virReportSystemError(rc, \"%s\",\n                                 _(\"Failed to initialize libpciaccess\"));\n            return -1;\n        }\n    }\n#endif\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "rc",
            "\"%s\"",
            "_(\"Failed to initialize libpciaccess\")"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to initialize libpciaccess\""
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_system_init",
          "args": [],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevPCITranslateInit(bool privileged G_GNUC_UNUSED)\n{\n#if defined __s390__ || defined __s390x_\n    /* On s390(x) system there is no PCI bus.\n     * Therefore there is nothing to initialize here. */\n#else\n    int rc;\n\n    if ((rc = pci_system_init()) != 0) {\n        /* Ignore failure as non-root; udev is not as helpful in that\n         * situation, but a non-privileged user won't benefit much\n         * from udev in the first place.  */\n        if (errno != ENOENT && (privileged  || errno != EACCES)) {\n            virReportSystemError(rc, \"%s\",\n                                 _(\"Failed to initialize libpciaccess\"));\n            return -1;\n        }\n    }\n#endif\n    return 0;\n}"
  },
  {
    "function_name": "nodeStateInitializeEnumerate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1738-1762",
    "snippet": "static void\nnodeStateInitializeEnumerate(void *opaque)\n{\n    struct udev *udev = opaque;\n    udevEventDataPtr priv = driver->privateData;\n\n    /* Populate with known devices */\n    if (udevEnumerateDevices(udev) != 0)\n        goto error;\n\n    nodeDeviceLock();\n    driver->initialized = true;\n    nodeDeviceUnlock();\n    virCondBroadcast(&driver->initCond);\n\n    return;\n\n error:\n    virObjectLock(priv);\n    ignore_value(virEventRemoveHandle(priv->watch));\n    priv->watch = -1;\n    priv->threadQuit = true;\n    virCondSignal(&priv->threadCond);\n    virObjectUnlock(priv);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "priv"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondSignal",
          "args": [
            "&priv->threadCond"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "virCondSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "170-173",
          "snippet": "void virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virEventRemoveHandle(priv->watch)"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventRemoveHandle",
          "args": [
            "priv->watch"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "virEventRemoveHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "116-123",
          "snippet": "int\nvirEventRemoveHandle(int watch)\n{\n    if (!removeHandleImpl)\n        return -1;\n\n    return removeHandleImpl(watch);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventRemoveHandleFunc removeHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventRemoveHandleFunc removeHandleImpl;\n\nint\nvirEventRemoveHandle(int watch)\n{\n    if (!removeHandleImpl)\n        return -1;\n\n    return removeHandleImpl(watch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "priv"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondBroadcast",
          "args": [
            "&driver->initCond"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "virCondBroadcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "175-178",
          "snippet": "void virCondBroadcast(virCondPtr c)\n{\n    pthread_cond_broadcast(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondBroadcast(virCondPtr c)\n{\n    pthread_cond_broadcast(&c->cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodeDeviceUnlock",
          "args": [],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "nodeDeviceUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_driver.c",
          "lines": "152-156",
          "snippet": "void\nnodeDeviceUnlock(void)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virvhba.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virNodeDeviceDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"viraccessapicheck.h\"\n#include \"virvhba.h\"\n#include \"node_device_util.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <time.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNodeDeviceDriverStatePtr driver;\n\nvoid\nnodeDeviceUnlock(void)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodeDeviceLock",
          "args": [],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "nodeDeviceLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_driver.c",
          "lines": "145-149",
          "snippet": "void\nnodeDeviceLock(void)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virvhba.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virNodeDeviceDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"viraccessapicheck.h\"\n#include \"virvhba.h\"\n#include \"node_device_util.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <time.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNodeDeviceDriverStatePtr driver;\n\nvoid\nnodeDeviceLock(void)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevEnumerateDevices",
          "args": [
            "udev"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "udevEnumerateDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1414-1438",
          "snippet": "static int\nudevEnumerateDevices(struct udev *udev)\n{\n    struct udev_enumerate *udev_enumerate = NULL;\n    struct udev_list_entry *list_entry = NULL;\n    int ret = -1;\n\n    udev_enumerate = udev_enumerate_new(udev);\n    if (udevEnumerateAddMatches(udev_enumerate) < 0)\n        goto cleanup;\n\n    if (udev_enumerate_scan_devices(udev_enumerate) < 0)\n        VIR_WARN(\"udev scan devices failed\");\n\n    udev_list_entry_foreach(list_entry,\n                            udev_enumerate_get_list_entry(udev_enumerate)) {\n\n        udevProcessDeviceListEntry(udev, list_entry);\n    }\n\n    ret = 0;\n cleanup:\n    udev_enumerate_unref(udev_enumerate);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevEnumerateDevices(struct udev *udev)\n{\n    struct udev_enumerate *udev_enumerate = NULL;\n    struct udev_list_entry *list_entry = NULL;\n    int ret = -1;\n\n    udev_enumerate = udev_enumerate_new(udev);\n    if (udevEnumerateAddMatches(udev_enumerate) < 0)\n        goto cleanup;\n\n    if (udev_enumerate_scan_devices(udev_enumerate) < 0)\n        VIR_WARN(\"udev scan devices failed\");\n\n    udev_list_entry_foreach(list_entry,\n                            udev_enumerate_get_list_entry(udev_enumerate)) {\n\n        udevProcessDeviceListEntry(udev, list_entry);\n    }\n\n    ret = 0;\n cleanup:\n    udev_enumerate_unref(udev_enumerate);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic void\nnodeStateInitializeEnumerate(void *opaque)\n{\n    struct udev *udev = opaque;\n    udevEventDataPtr priv = driver->privateData;\n\n    /* Populate with known devices */\n    if (udevEnumerateDevices(udev) != 0)\n        goto error;\n\n    nodeDeviceLock();\n    driver->initialized = true;\n    nodeDeviceUnlock();\n    virCondBroadcast(&driver->initCond);\n\n    return;\n\n error:\n    virObjectLock(priv);\n    ignore_value(virEventRemoveHandle(priv->watch));\n    priv->watch = -1;\n    priv->threadQuit = true;\n    virCondSignal(&priv->threadCond);\n    virObjectUnlock(priv);\n}"
  },
  {
    "function_name": "udevSetupSystemDev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1704-1735",
    "snippet": "static int\nudevSetupSystemDev(void)\n{\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    int ret = -1;\n\n    if (VIR_ALLOC(def) < 0)\n        return -1;\n\n    def->name = g_strdup(\"computer\");\n\n    if (VIR_ALLOC(def->caps) != 0)\n        goto cleanup;\n\n#if defined(__x86_64__) || defined(__i386__) || defined(__amd64__)\n    udevGetDMIData(&def->caps->data.system);\n#endif\n\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def)))\n        goto cleanup;\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    ret = 0;\n\n cleanup:\n    if (ret == -1)\n        virNodeDeviceDefFree(def);\n\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNodeDeviceDefFree",
          "args": [
            "def"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "98-125",
          "snippet": "void\nvirNodeDeviceDefFree(virNodeDeviceDefPtr def)\n{\n    virNodeDevCapsDefPtr caps;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->parent);\n    VIR_FREE(def->parent_wwnn);\n    VIR_FREE(def->parent_wwpn);\n    VIR_FREE(def->parent_fabric_wwn);\n    VIR_FREE(def->driver);\n    VIR_FREE(def->sysfs_path);\n    VIR_FREE(def->parent_sysfs_path);\n    VIR_FREE(def->devnode);\n    virStringListFree(def->devlinks);\n\n    caps = def->caps;\n    while (caps) {\n        virNodeDevCapsDefPtr next = caps->next;\n        virNodeDevCapsDefFree(caps);\n        caps = next;\n    }\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNodeDeviceDefFree(virNodeDeviceDefPtr def)\n{\n    virNodeDevCapsDefPtr caps;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->parent);\n    VIR_FREE(def->parent_wwnn);\n    VIR_FREE(def->parent_wwpn);\n    VIR_FREE(def->parent_fabric_wwn);\n    VIR_FREE(def->driver);\n    VIR_FREE(def->sysfs_path);\n    VIR_FREE(def->parent_sysfs_path);\n    VIR_FREE(def->devnode);\n    virStringListFree(def->devlinks);\n\n    caps = def->caps;\n    while (caps) {\n        virNodeDevCapsDefPtr next = caps->next;\n        virNodeDevCapsDefFree(caps);\n        caps = next;\n    }\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "101-110",
          "snippet": "void\nvirNodeDeviceObjEndAPI(virNodeDeviceObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirNodeDeviceObjEndAPI(virNodeDeviceObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjListAssignDef",
          "args": [
            "driver->devs",
            "def"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjListAssignDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "439-467",
          "snippet": "virNodeDeviceObjPtr\nvirNodeDeviceObjListAssignDef(virNodeDeviceObjListPtr devs,\n                              virNodeDeviceDefPtr def)\n{\n    virNodeDeviceObjPtr obj;\n\n    virObjectRWLockWrite(devs);\n\n    if ((obj = virNodeDeviceObjListFindByNameLocked(devs, def->name))) {\n        virObjectLock(obj);\n        virNodeDeviceDefFree(obj->def);\n        obj->def = def;\n    } else {\n        if (!(obj = virNodeDeviceObjNew()))\n            goto cleanup;\n\n        if (virHashAddEntry(devs->objs, def->name, obj) < 0) {\n            virNodeDeviceObjEndAPI(&obj);\n            goto cleanup;\n        }\n\n        obj->def = def;\n        virObjectRef(obj);\n    }\n\n cleanup:\n    virObjectRWUnlock(devs);\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirNodeDeviceObjPtr\nvirNodeDeviceObjListAssignDef(virNodeDeviceObjListPtr devs,\n                              virNodeDeviceDefPtr def)\n{\n    virNodeDeviceObjPtr obj;\n\n    virObjectRWLockWrite(devs);\n\n    if ((obj = virNodeDeviceObjListFindByNameLocked(devs, def->name))) {\n        virObjectLock(obj);\n        virNodeDeviceDefFree(obj->def);\n        obj->def = def;\n    } else {\n        if (!(obj = virNodeDeviceObjNew()))\n            goto cleanup;\n\n        if (virHashAddEntry(devs->objs, def->name, obj) < 0) {\n            virNodeDeviceObjEndAPI(&obj);\n            goto cleanup;\n        }\n\n        obj->def = def;\n        virObjectRef(obj);\n    }\n\n cleanup:\n    virObjectRWUnlock(devs);\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetDMIData",
          "args": [
            "&def->caps->data.system"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetDMIData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1645-1700",
          "snippet": "static void\nudevGetDMIData(virNodeDevCapSystemPtr syscap)\n{\n    udevEventDataPtr priv = driver->privateData;\n    struct udev *udev = NULL;\n    struct udev_device *device = NULL;\n    virNodeDevCapSystemHardwarePtr hardware = &syscap->hardware;\n    virNodeDevCapSystemFirmwarePtr firmware = &syscap->firmware;\n\n    virObjectLock(priv);\n    udev = udev_monitor_get_udev(priv->udev_monitor);\n\n    device = udev_device_new_from_syspath(udev, DMI_DEVPATH);\n    if (device == NULL) {\n        device = udev_device_new_from_syspath(udev, DMI_DEVPATH_FALLBACK);\n        if (device == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to get udev device for syspath '%s' or '%s'\"),\n                           DMI_DEVPATH, DMI_DEVPATH_FALLBACK);\n            virObjectUnlock(priv);\n            return;\n        }\n    }\n    virObjectUnlock(priv);\n\n    if (udevGetStringSysfsAttr(device, \"product_name\",\n                               &syscap->product_name) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"sys_vendor\",\n                               &hardware->vendor_name) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"product_version\",\n                               &hardware->version) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"product_serial\",\n                               &hardware->serial) < 0)\n        goto cleanup;\n\n    if (virGetHostUUID(hardware->uuid))\n        goto cleanup;\n\n    if (udevGetStringSysfsAttr(device, \"bios_vendor\",\n                               &firmware->vendor_name) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"bios_version\",\n                               &firmware->version) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"bios_date\",\n                               &firmware->release_date) < 0)\n        goto cleanup;\n\n cleanup:\n    if (device != NULL)\n        udev_device_unref(device);\n    return;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic void\nudevGetDMIData(virNodeDevCapSystemPtr syscap)\n{\n    udevEventDataPtr priv = driver->privateData;\n    struct udev *udev = NULL;\n    struct udev_device *device = NULL;\n    virNodeDevCapSystemHardwarePtr hardware = &syscap->hardware;\n    virNodeDevCapSystemFirmwarePtr firmware = &syscap->firmware;\n\n    virObjectLock(priv);\n    udev = udev_monitor_get_udev(priv->udev_monitor);\n\n    device = udev_device_new_from_syspath(udev, DMI_DEVPATH);\n    if (device == NULL) {\n        device = udev_device_new_from_syspath(udev, DMI_DEVPATH_FALLBACK);\n        if (device == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to get udev device for syspath '%s' or '%s'\"),\n                           DMI_DEVPATH, DMI_DEVPATH_FALLBACK);\n            virObjectUnlock(priv);\n            return;\n        }\n    }\n    virObjectUnlock(priv);\n\n    if (udevGetStringSysfsAttr(device, \"product_name\",\n                               &syscap->product_name) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"sys_vendor\",\n                               &hardware->vendor_name) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"product_version\",\n                               &hardware->version) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"product_serial\",\n                               &hardware->serial) < 0)\n        goto cleanup;\n\n    if (virGetHostUUID(hardware->uuid))\n        goto cleanup;\n\n    if (udevGetStringSysfsAttr(device, \"bios_vendor\",\n                               &firmware->vendor_name) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"bios_version\",\n                               &firmware->version) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"bios_date\",\n                               &firmware->release_date) < 0)\n        goto cleanup;\n\n cleanup:\n    if (device != NULL)\n        udev_device_unref(device);\n    return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def->caps"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"computer\""
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevSetupSystemDev(void)\n{\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    int ret = -1;\n\n    if (VIR_ALLOC(def) < 0)\n        return -1;\n\n    def->name = g_strdup(\"computer\");\n\n    if (VIR_ALLOC(def->caps) != 0)\n        goto cleanup;\n\n#if defined(__x86_64__) || defined(__i386__) || defined(__amd64__)\n    udevGetDMIData(&def->caps->data.system);\n#endif\n\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def)))\n        goto cleanup;\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    ret = 0;\n\n cleanup:\n    if (ret == -1)\n        virNodeDeviceDefFree(def);\n\n    return ret;\n}"
  },
  {
    "function_name": "udevGetDMIData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1645-1700",
    "snippet": "static void\nudevGetDMIData(virNodeDevCapSystemPtr syscap)\n{\n    udevEventDataPtr priv = driver->privateData;\n    struct udev *udev = NULL;\n    struct udev_device *device = NULL;\n    virNodeDevCapSystemHardwarePtr hardware = &syscap->hardware;\n    virNodeDevCapSystemFirmwarePtr firmware = &syscap->firmware;\n\n    virObjectLock(priv);\n    udev = udev_monitor_get_udev(priv->udev_monitor);\n\n    device = udev_device_new_from_syspath(udev, DMI_DEVPATH);\n    if (device == NULL) {\n        device = udev_device_new_from_syspath(udev, DMI_DEVPATH_FALLBACK);\n        if (device == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to get udev device for syspath '%s' or '%s'\"),\n                           DMI_DEVPATH, DMI_DEVPATH_FALLBACK);\n            virObjectUnlock(priv);\n            return;\n        }\n    }\n    virObjectUnlock(priv);\n\n    if (udevGetStringSysfsAttr(device, \"product_name\",\n                               &syscap->product_name) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"sys_vendor\",\n                               &hardware->vendor_name) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"product_version\",\n                               &hardware->version) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"product_serial\",\n                               &hardware->serial) < 0)\n        goto cleanup;\n\n    if (virGetHostUUID(hardware->uuid))\n        goto cleanup;\n\n    if (udevGetStringSysfsAttr(device, \"bios_vendor\",\n                               &firmware->vendor_name) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"bios_version\",\n                               &firmware->version) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"bios_date\",\n                               &firmware->release_date) < 0)\n        goto cleanup;\n\n cleanup:\n    if (device != NULL)\n        udev_device_unref(device);\n    return;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udev_device_unref",
          "args": [
            "device"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetStringSysfsAttr",
          "args": [
            "device",
            "\"bios_date\"",
            "&firmware->release_date"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetStringSysfsAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "216-229",
          "snippet": "static int\nudevGetStringSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name,\n                       char **value)\n{\n    *value = g_strdup(udevGetDeviceSysfsAttr(udev_device, attr_name));\n\n    virStringStripControlChars(*value);\n\n    if (*value != NULL && (STREQ(*value, \"\")))\n        VIR_FREE(*value);\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetStringSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name,\n                       char **value)\n{\n    *value = g_strdup(udevGetDeviceSysfsAttr(udev_device, attr_name));\n\n    virStringStripControlChars(*value);\n\n    if (*value != NULL && (STREQ(*value, \"\")))\n        VIR_FREE(*value);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetHostUUID",
          "args": [
            "hardware->uuid"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "virGetHostUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "258-268",
          "snippet": "int virGetHostUUID(unsigned char *uuid)\n{\n    int ret = 0;\n\n    if (!virUUIDIsValid(host_uuid))\n        ret = virSetHostUUIDStr(NULL);\n\n    memcpy(uuid, host_uuid, sizeof(host_uuid));\n\n    return ret;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char host_uuid[VIR_UUID_BUFLEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic unsigned char host_uuid[VIR_UUID_BUFLEN];\n\nint virGetHostUUID(unsigned char *uuid)\n{\n    int ret = 0;\n\n    if (!virUUIDIsValid(host_uuid))\n        ret = virSetHostUUIDStr(NULL);\n\n    memcpy(uuid, host_uuid, sizeof(host_uuid));\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "priv"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to get udev device for syspath '%s' or '%s'\")",
            "DMI_DEVPATH",
            "DMI_DEVPATH_FALLBACK"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to get udev device for syspath '%s' or '%s'\""
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_new_from_syspath",
          "args": [
            "udev",
            "DMI_DEVPATH_FALLBACK"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_new_from_syspath",
          "args": [
            "udev",
            "DMI_DEVPATH"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_monitor_get_udev",
          "args": [
            "priv->udev_monitor"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "priv"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic void\nudevGetDMIData(virNodeDevCapSystemPtr syscap)\n{\n    udevEventDataPtr priv = driver->privateData;\n    struct udev *udev = NULL;\n    struct udev_device *device = NULL;\n    virNodeDevCapSystemHardwarePtr hardware = &syscap->hardware;\n    virNodeDevCapSystemFirmwarePtr firmware = &syscap->firmware;\n\n    virObjectLock(priv);\n    udev = udev_monitor_get_udev(priv->udev_monitor);\n\n    device = udev_device_new_from_syspath(udev, DMI_DEVPATH);\n    if (device == NULL) {\n        device = udev_device_new_from_syspath(udev, DMI_DEVPATH_FALLBACK);\n        if (device == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to get udev device for syspath '%s' or '%s'\"),\n                           DMI_DEVPATH, DMI_DEVPATH_FALLBACK);\n            virObjectUnlock(priv);\n            return;\n        }\n    }\n    virObjectUnlock(priv);\n\n    if (udevGetStringSysfsAttr(device, \"product_name\",\n                               &syscap->product_name) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"sys_vendor\",\n                               &hardware->vendor_name) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"product_version\",\n                               &hardware->version) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"product_serial\",\n                               &hardware->serial) < 0)\n        goto cleanup;\n\n    if (virGetHostUUID(hardware->uuid))\n        goto cleanup;\n\n    if (udevGetStringSysfsAttr(device, \"bios_vendor\",\n                               &firmware->vendor_name) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"bios_version\",\n                               &firmware->version) < 0)\n        goto cleanup;\n    if (udevGetStringSysfsAttr(device, \"bios_date\",\n                               &firmware->release_date) < 0)\n        goto cleanup;\n\n cleanup:\n    if (device != NULL)\n        udev_device_unref(device);\n    return;\n}"
  },
  {
    "function_name": "udevEventHandleCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1623-1640",
    "snippet": "static void\nudevEventHandleCallback(int watch G_GNUC_UNUSED,\n                        int fd,\n                        int events G_GNUC_UNUSED,\n                        void *data G_GNUC_UNUSED)\n{\n    udevEventDataPtr priv = driver->privateData;\n\n    virObjectLock(priv);\n\n    if (!udevEventMonitorSanityCheck(priv, fd))\n        priv->threadQuit = true;\n    else\n        priv->dataReady = true;\n\n    virCondSignal(&priv->threadCond);\n    virObjectUnlock(priv);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "priv"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondSignal",
          "args": [
            "&priv->threadCond"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "virCondSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "170-173",
          "snippet": "void virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevEventMonitorSanityCheck",
          "args": [
            "priv",
            "fd"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "udevEventMonitorSanityCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1509-1533",
          "snippet": "static bool\nudevEventMonitorSanityCheck(udevEventDataPtr priv,\n                            int fd)\n{\n    int rc = -1;\n\n    rc = udev_monitor_get_fd(priv->udev_monitor);\n    if (fd != rc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"File descriptor returned by udev %d does not \"\n                         \"match node device file descriptor %d\"),\n                       fd, rc);\n\n        /* this is a non-recoverable error, let's remove the handle, so that we\n         * don't get in here again because of some spurious behaviour and report\n         * the same error multiple times\n         */\n        virEventRemoveHandle(priv->watch);\n        priv->watch = -1;\n\n        return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic bool\nudevEventMonitorSanityCheck(udevEventDataPtr priv,\n                            int fd)\n{\n    int rc = -1;\n\n    rc = udev_monitor_get_fd(priv->udev_monitor);\n    if (fd != rc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"File descriptor returned by udev %d does not \"\n                         \"match node device file descriptor %d\"),\n                       fd, rc);\n\n        /* this is a non-recoverable error, let's remove the handle, so that we\n         * don't get in here again because of some spurious behaviour and report\n         * the same error multiple times\n         */\n        virEventRemoveHandle(priv->watch);\n        priv->watch = -1;\n\n        return false;\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "priv"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic void\nudevEventHandleCallback(int watch G_GNUC_UNUSED,\n                        int fd,\n                        int events G_GNUC_UNUSED,\n                        void *data G_GNUC_UNUSED)\n{\n    udevEventDataPtr priv = driver->privateData;\n\n    virObjectLock(priv);\n\n    if (!udevEventMonitorSanityCheck(priv, fd))\n        priv->threadQuit = true;\n    else\n        priv->dataReady = true;\n\n    virCondSignal(&priv->threadCond);\n    virObjectUnlock(priv);\n}"
  },
  {
    "function_name": "udevEventHandleThread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1556-1620",
    "snippet": "static void\nudevEventHandleThread(void *opaque G_GNUC_UNUSED)\n{\n    udevEventDataPtr priv = driver->privateData;\n    struct udev_device *device = NULL;\n\n    /* continue rather than break from the loop on non-fatal errors */\n    while (1) {\n        virObjectLock(priv);\n        while (!priv->dataReady && !priv->threadQuit) {\n            if (virCondWait(&priv->threadCond, &priv->parent.lock)) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"handler failed to wait on condition\"));\n                virObjectUnlock(priv);\n                return;\n            }\n        }\n\n        if (priv->threadQuit) {\n            virObjectUnlock(priv);\n            return;\n        }\n\n        errno = 0;\n        device = udev_monitor_receive_device(priv->udev_monitor);\n        virObjectUnlock(priv);\n\n        if (!device) {\n            if (errno == 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"failed to receive device from udev monitor\"));\n                return;\n            }\n\n            /* POSIX allows both EAGAIN and EWOULDBLOCK to be used\n             * interchangeably when the read would block or timeout was fired\n             */\n            VIR_WARNINGS_NO_WLOGICALOP_EQUAL_EXPR\n            if (errno != EAGAIN && errno != EWOULDBLOCK) {\n            VIR_WARNINGS_RESET\n                virReportSystemError(errno, \"%s\",\n                                     _(\"failed to receive device from udev \"\n                                       \"monitor\"));\n                return;\n            }\n\n            /* Trying to move the reset of the @priv->dataReady flag to\n             * after the udev_monitor_receive_device wouldn't help much\n             * due to event mgmt and scheduler timing. */\n            virObjectLock(priv);\n            priv->dataReady = false;\n            virObjectUnlock(priv);\n\n            continue;\n        }\n\n        udevHandleOneDevice(device);\n        udev_device_unref(device);\n\n        /* Instead of waiting for the next event after processing @device\n         * data, let's keep reading from the udev monitor and only wait\n         * for the next event once either a EAGAIN or a EWOULDBLOCK error\n         * is encountered. */\n    }\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udev_device_unref",
          "args": [
            "device"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevHandleOneDevice",
          "args": [
            "device"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "udevHandleOneDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1489-1503",
          "snippet": "static int\nudevHandleOneDevice(struct udev_device *device)\n{\n    const char *action = udev_device_get_action(device);\n\n    VIR_DEBUG(\"udev action: '%s'\", action);\n\n    if (STREQ(action, \"add\") || STREQ(action, \"change\"))\n        return udevAddOneDevice(device);\n\n    if (STREQ(action, \"remove\"))\n        return udevRemoveOneDevice(device);\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevHandleOneDevice(struct udev_device *device)\n{\n    const char *action = udev_device_get_action(device);\n\n    VIR_DEBUG(\"udev action: '%s'\", action);\n\n    if (STREQ(action, \"add\") || STREQ(action, \"change\"))\n        return udevAddOneDevice(device);\n\n    if (STREQ(action, \"remove\"))\n        return udevRemoveOneDevice(device);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "priv"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "priv"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to receive device from udev \"\n                                       \"monitor\""
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to receive device from udev monitor\")"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_monitor_receive_device",
          "args": [
            "priv->udev_monitor"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"handler failed to wait on condition\")"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCondWait",
          "args": [
            "&priv->threadCond",
            "&priv->parent.lock"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "virCondWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "145-153",
          "snippet": "int virCondWait(virCondPtr c, virMutexPtr m)\n{\n    int ret;\n    if ((ret = pthread_cond_wait(&c->cond, &m->lock)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondWait(virCondPtr c, virMutexPtr m)\n{\n    int ret;\n    if ((ret = pthread_cond_wait(&c->cond, &m->lock)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic void\nudevEventHandleThread(void *opaque G_GNUC_UNUSED)\n{\n    udevEventDataPtr priv = driver->privateData;\n    struct udev_device *device = NULL;\n\n    /* continue rather than break from the loop on non-fatal errors */\n    while (1) {\n        virObjectLock(priv);\n        while (!priv->dataReady && !priv->threadQuit) {\n            if (virCondWait(&priv->threadCond, &priv->parent.lock)) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"handler failed to wait on condition\"));\n                virObjectUnlock(priv);\n                return;\n            }\n        }\n\n        if (priv->threadQuit) {\n            virObjectUnlock(priv);\n            return;\n        }\n\n        errno = 0;\n        device = udev_monitor_receive_device(priv->udev_monitor);\n        virObjectUnlock(priv);\n\n        if (!device) {\n            if (errno == 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"failed to receive device from udev monitor\"));\n                return;\n            }\n\n            /* POSIX allows both EAGAIN and EWOULDBLOCK to be used\n             * interchangeably when the read would block or timeout was fired\n             */\n            VIR_WARNINGS_NO_WLOGICALOP_EQUAL_EXPR\n            if (errno != EAGAIN && errno != EWOULDBLOCK) {\n            VIR_WARNINGS_RESET\n                virReportSystemError(errno, \"%s\",\n                                     _(\"failed to receive device from udev \"\n                                       \"monitor\"));\n                return;\n            }\n\n            /* Trying to move the reset of the @priv->dataReady flag to\n             * after the udev_monitor_receive_device wouldn't help much\n             * due to event mgmt and scheduler timing. */\n            virObjectLock(priv);\n            priv->dataReady = false;\n            virObjectUnlock(priv);\n\n            continue;\n        }\n\n        udevHandleOneDevice(device);\n        udev_device_unref(device);\n\n        /* Instead of waiting for the next event after processing @device\n         * data, let's keep reading from the udev monitor and only wait\n         * for the next event once either a EAGAIN or a EWOULDBLOCK error\n         * is encountered. */\n    }\n}"
  },
  {
    "function_name": "udevEventMonitorSanityCheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1509-1533",
    "snippet": "static bool\nudevEventMonitorSanityCheck(udevEventDataPtr priv,\n                            int fd)\n{\n    int rc = -1;\n\n    rc = udev_monitor_get_fd(priv->udev_monitor);\n    if (fd != rc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"File descriptor returned by udev %d does not \"\n                         \"match node device file descriptor %d\"),\n                       fd, rc);\n\n        /* this is a non-recoverable error, let's remove the handle, so that we\n         * don't get in here again because of some spurious behaviour and report\n         * the same error multiple times\n         */\n        virEventRemoveHandle(priv->watch);\n        priv->watch = -1;\n\n        return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virEventRemoveHandle",
          "args": [
            "priv->watch"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "virEventRemoveHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "116-123",
          "snippet": "int\nvirEventRemoveHandle(int watch)\n{\n    if (!removeHandleImpl)\n        return -1;\n\n    return removeHandleImpl(watch);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventRemoveHandleFunc removeHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventRemoveHandleFunc removeHandleImpl;\n\nint\nvirEventRemoveHandle(int watch)\n{\n    if (!removeHandleImpl)\n        return -1;\n\n    return removeHandleImpl(watch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"File descriptor returned by udev %d does not \"\n                         \"match node device file descriptor %d\")",
            "fd",
            "rc"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"File descriptor returned by udev %d does not \"\n                         \"match node device file descriptor %d\""
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_monitor_get_fd",
          "args": [
            "priv->udev_monitor"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic bool\nudevEventMonitorSanityCheck(udevEventDataPtr priv,\n                            int fd)\n{\n    int rc = -1;\n\n    rc = udev_monitor_get_fd(priv->udev_monitor);\n    if (fd != rc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"File descriptor returned by udev %d does not \"\n                         \"match node device file descriptor %d\"),\n                       fd, rc);\n\n        /* this is a non-recoverable error, let's remove the handle, so that we\n         * don't get in here again because of some spurious behaviour and report\n         * the same error multiple times\n         */\n        virEventRemoveHandle(priv->watch);\n        priv->watch = -1;\n\n        return false;\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "udevHandleOneDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1489-1503",
    "snippet": "static int\nudevHandleOneDevice(struct udev_device *device)\n{\n    const char *action = udev_device_get_action(device);\n\n    VIR_DEBUG(\"udev action: '%s'\", action);\n\n    if (STREQ(action, \"add\") || STREQ(action, \"change\"))\n        return udevAddOneDevice(device);\n\n    if (STREQ(action, \"remove\"))\n        return udevRemoveOneDevice(device);\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevRemoveOneDevice",
          "args": [
            "device"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "udevRemoveOneDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1224-1251",
          "snippet": "static int\nudevRemoveOneDevice(struct udev_device *device)\n{\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr def;\n    virObjectEventPtr event = NULL;\n    const char *name = NULL;\n\n    name = udev_device_get_syspath(device);\n    if (!(obj = virNodeDeviceObjListFindBySysfsPath(driver->devs, name))) {\n        VIR_DEBUG(\"Failed to find device to remove that has udev name '%s'\",\n                  name);\n        return -1;\n    }\n    def = virNodeDeviceObjGetDef(obj);\n\n    event = virNodeDeviceEventLifecycleNew(def->name,\n                                           VIR_NODE_DEVICE_EVENT_DELETED,\n                                           0);\n\n    VIR_DEBUG(\"Removing device '%s' with sysfs path '%s'\",\n              def->name, name);\n    virNodeDeviceObjListRemove(driver->devs, obj);\n    virObjectUnref(obj);\n\n    virObjectEventStateQueue(driver->nodeDeviceEventState, event);\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevRemoveOneDevice(struct udev_device *device)\n{\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr def;\n    virObjectEventPtr event = NULL;\n    const char *name = NULL;\n\n    name = udev_device_get_syspath(device);\n    if (!(obj = virNodeDeviceObjListFindBySysfsPath(driver->devs, name))) {\n        VIR_DEBUG(\"Failed to find device to remove that has udev name '%s'\",\n                  name);\n        return -1;\n    }\n    def = virNodeDeviceObjGetDef(obj);\n\n    event = virNodeDeviceEventLifecycleNew(def->name,\n                                           VIR_NODE_DEVICE_EVENT_DELETED,\n                                           0);\n\n    VIR_DEBUG(\"Removing device '%s' with sysfs path '%s'\",\n              def->name, name);\n    virNodeDeviceObjListRemove(driver->devs, obj);\n    virObjectUnref(obj);\n\n    virObjectEventStateQueue(driver->nodeDeviceEventState, event);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "action",
            "\"remove\""
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevAddOneDevice",
          "args": [
            "device"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "udevAddOneDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1296-1361",
          "snippet": "static int\nudevAddOneDevice(struct udev_device *device)\n{\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr objdef;\n    virObjectEventPtr event = NULL;\n    bool new_device = true;\n    int ret = -1;\n\n    if (VIR_ALLOC(def) != 0)\n        goto cleanup;\n\n    def->sysfs_path = g_strdup(udev_device_get_syspath(device));\n\n    if (udevGetStringProperty(device, \"DRIVER\", &def->driver) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC(def->caps) != 0)\n        goto cleanup;\n\n    if (udevGetDeviceType(device, &def->caps->data.type) != 0)\n        goto cleanup;\n\n    if (udevGetDeviceNodes(device, def) != 0)\n        goto cleanup;\n\n    if (udevGetDeviceDetails(device, def) != 0)\n        goto cleanup;\n\n    if (udevSetParent(device, def) != 0)\n        goto cleanup;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, def->name))) {\n        virNodeDeviceObjEndAPI(&obj);\n        new_device = false;\n    }\n\n    /* If this is a device change, the old definition will be freed\n     * and the current definition will take its place. */\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def)))\n        goto cleanup;\n    objdef = virNodeDeviceObjGetDef(obj);\n\n    if (new_device)\n        event = virNodeDeviceEventLifecycleNew(objdef->name,\n                                               VIR_NODE_DEVICE_EVENT_CREATED,\n                                               0);\n    else\n        event = virNodeDeviceEventUpdateNew(objdef->name);\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    ret = 0;\n\n cleanup:\n    virObjectEventStateQueue(driver->nodeDeviceEventState, event);\n\n    if (ret != 0) {\n        VIR_DEBUG(\"Discarding device %d %p %s\", ret, def,\n                  def ? NULLSTR(def->sysfs_path) : \"\");\n        virNodeDeviceDefFree(def);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevAddOneDevice(struct udev_device *device)\n{\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr objdef;\n    virObjectEventPtr event = NULL;\n    bool new_device = true;\n    int ret = -1;\n\n    if (VIR_ALLOC(def) != 0)\n        goto cleanup;\n\n    def->sysfs_path = g_strdup(udev_device_get_syspath(device));\n\n    if (udevGetStringProperty(device, \"DRIVER\", &def->driver) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC(def->caps) != 0)\n        goto cleanup;\n\n    if (udevGetDeviceType(device, &def->caps->data.type) != 0)\n        goto cleanup;\n\n    if (udevGetDeviceNodes(device, def) != 0)\n        goto cleanup;\n\n    if (udevGetDeviceDetails(device, def) != 0)\n        goto cleanup;\n\n    if (udevSetParent(device, def) != 0)\n        goto cleanup;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, def->name))) {\n        virNodeDeviceObjEndAPI(&obj);\n        new_device = false;\n    }\n\n    /* If this is a device change, the old definition will be freed\n     * and the current definition will take its place. */\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def)))\n        goto cleanup;\n    objdef = virNodeDeviceObjGetDef(obj);\n\n    if (new_device)\n        event = virNodeDeviceEventLifecycleNew(objdef->name,\n                                               VIR_NODE_DEVICE_EVENT_CREATED,\n                                               0);\n    else\n        event = virNodeDeviceEventUpdateNew(objdef->name);\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    ret = 0;\n\n cleanup:\n    virObjectEventStateQueue(driver->nodeDeviceEventState, event);\n\n    if (ret != 0) {\n        VIR_DEBUG(\"Discarding device %d %p %s\", ret, def,\n                  def ? NULLSTR(def->sysfs_path) : \"\");\n        virNodeDeviceDefFree(def);\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "action",
            "\"change\""
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "action",
            "\"add\""
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"udev action: '%s'\"",
            "action"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_action",
          "args": [
            "device"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevHandleOneDevice(struct udev_device *device)\n{\n    const char *action = udev_device_get_action(device);\n\n    VIR_DEBUG(\"udev action: '%s'\", action);\n\n    if (STREQ(action, \"add\") || STREQ(action, \"change\"))\n        return udevAddOneDevice(device);\n\n    if (STREQ(action, \"remove\"))\n        return udevRemoveOneDevice(device);\n\n    return 0;\n}"
  },
  {
    "function_name": "nodeStateCleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1454-1486",
    "snippet": "static int\nnodeStateCleanup(void)\n{\n    udevEventDataPtr priv = NULL;\n\n    if (!driver)\n        return -1;\n\n    priv = driver->privateData;\n    if (priv) {\n        virObjectLock(priv);\n        priv->threadQuit = true;\n        virCondSignal(&priv->threadCond);\n        virObjectUnlock(priv);\n        virThreadJoin(&priv->th);\n    }\n\n    virObjectUnref(priv);\n    virObjectUnref(driver->nodeDeviceEventState);\n\n    virNodeDeviceObjListFree(driver->devs);\n\n    if (driver->lockFD != -1)\n        virPidFileRelease(driver->stateDir, \"driver\", driver->lockFD);\n\n    VIR_FREE(driver->stateDir);\n    virCondDestroy(&driver->initCond);\n    virMutexDestroy(&driver->lock);\n    VIR_FREE(driver);\n\n    udevPCITranslateDeinit();\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevPCITranslateDeinit",
          "args": [],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "udevPCITranslateDeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1441-1451",
          "snippet": "static void\nudevPCITranslateDeinit(void)\n{\n#if defined __s390__ || defined __s390x_\n    /* Nothing was initialized, nothing needs to be cleaned up */\n#else\n    /* pci_system_cleanup returns void */\n    pci_system_cleanup();\n#endif\n    return;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic void\nudevPCITranslateDeinit(void)\n{\n#if defined __s390__ || defined __s390x_\n    /* Nothing was initialized, nothing needs to be cleaned up */\n#else\n    /* pci_system_cleanup returns void */\n    pci_system_cleanup();\n#endif\n    return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexDestroy",
          "args": [
            "&driver->lock"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "76-79",
          "snippet": "void virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondDestroy",
          "args": [
            "&driver->initCond"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "virCondDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "135-143",
          "snippet": "int virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver->stateDir"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileRelease",
          "args": [
            "driver->stateDir",
            "\"driver\"",
            "driver->lockFD"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "453-466",
          "snippet": "int virPidFileRelease(const char *dir,\n                      const char *name,\n                      int fd)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileReleasePath(pidfile, fd);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileRelease(const char *dir,\n                      const char *name,\n                      int fd)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileReleasePath(pidfile, fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjListFree",
          "args": [
            "driver->devs"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "432-436",
          "snippet": "void\nvirNodeDeviceObjListFree(virNodeDeviceObjListPtr devs)\n{\n    virObjectUnref(devs);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirNodeDeviceObjListFree(virNodeDeviceObjListPtr devs)\n{\n    virObjectUnref(devs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "driver->nodeDeviceEventState"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadJoin",
          "args": [
            "&priv->th"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadJoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "326-329",
          "snippet": "void virThreadJoin(virThreadPtr thread)\n{\n    pthread_join(thread->thread, NULL);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virThreadJoin(virThreadPtr thread)\n{\n    pthread_join(thread->thread, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "priv"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondSignal",
          "args": [
            "&priv->threadCond"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "virCondSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "170-173",
          "snippet": "void virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "priv"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nnodeStateCleanup(void)\n{\n    udevEventDataPtr priv = NULL;\n\n    if (!driver)\n        return -1;\n\n    priv = driver->privateData;\n    if (priv) {\n        virObjectLock(priv);\n        priv->threadQuit = true;\n        virCondSignal(&priv->threadCond);\n        virObjectUnlock(priv);\n        virThreadJoin(&priv->th);\n    }\n\n    virObjectUnref(priv);\n    virObjectUnref(driver->nodeDeviceEventState);\n\n    virNodeDeviceObjListFree(driver->devs);\n\n    if (driver->lockFD != -1)\n        virPidFileRelease(driver->stateDir, \"driver\", driver->lockFD);\n\n    VIR_FREE(driver->stateDir);\n    virCondDestroy(&driver->initCond);\n    virMutexDestroy(&driver->lock);\n    VIR_FREE(driver);\n\n    udevPCITranslateDeinit();\n    return 0;\n}"
  },
  {
    "function_name": "udevPCITranslateDeinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1441-1451",
    "snippet": "static void\nudevPCITranslateDeinit(void)\n{\n#if defined __s390__ || defined __s390x_\n    /* Nothing was initialized, nothing needs to be cleaned up */\n#else\n    /* pci_system_cleanup returns void */\n    pci_system_cleanup();\n#endif\n    return;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_system_cleanup",
          "args": [],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic void\nudevPCITranslateDeinit(void)\n{\n#if defined __s390__ || defined __s390x_\n    /* Nothing was initialized, nothing needs to be cleaned up */\n#else\n    /* pci_system_cleanup returns void */\n    pci_system_cleanup();\n#endif\n    return;\n}"
  },
  {
    "function_name": "udevEnumerateDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1414-1438",
    "snippet": "static int\nudevEnumerateDevices(struct udev *udev)\n{\n    struct udev_enumerate *udev_enumerate = NULL;\n    struct udev_list_entry *list_entry = NULL;\n    int ret = -1;\n\n    udev_enumerate = udev_enumerate_new(udev);\n    if (udevEnumerateAddMatches(udev_enumerate) < 0)\n        goto cleanup;\n\n    if (udev_enumerate_scan_devices(udev_enumerate) < 0)\n        VIR_WARN(\"udev scan devices failed\");\n\n    udev_list_entry_foreach(list_entry,\n                            udev_enumerate_get_list_entry(udev_enumerate)) {\n\n        udevProcessDeviceListEntry(udev, list_entry);\n    }\n\n    ret = 0;\n cleanup:\n    udev_enumerate_unref(udev_enumerate);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udev_enumerate_unref",
          "args": [
            "udev_enumerate"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevProcessDeviceListEntry",
          "args": [
            "udev",
            "list_entry"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessDeviceListEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1364-1387",
          "snippet": "static int\nudevProcessDeviceListEntry(struct udev *udev,\n                           struct udev_list_entry *list_entry)\n{\n    struct udev_device *device;\n    const char *name = NULL;\n    int ret = -1;\n\n    name = udev_list_entry_get_name(list_entry);\n\n    device = udev_device_new_from_syspath(udev, name);\n\n    if (device != NULL) {\n        if (udevAddOneDevice(device) != 0) {\n            VIR_DEBUG(\"Failed to create node device for udev device '%s'\",\n                      name);\n        }\n        ret = 0;\n    }\n\n    udev_device_unref(device);\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessDeviceListEntry(struct udev *udev,\n                           struct udev_list_entry *list_entry)\n{\n    struct udev_device *device;\n    const char *name = NULL;\n    int ret = -1;\n\n    name = udev_list_entry_get_name(list_entry);\n\n    device = udev_device_new_from_syspath(udev, name);\n\n    if (device != NULL) {\n        if (udevAddOneDevice(device) != 0) {\n            VIR_DEBUG(\"Failed to create node device for udev device '%s'\",\n                      name);\n        }\n        ret = 0;\n    }\n\n    udev_device_unref(device);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_list_entry_foreach",
          "args": [
            "list_entry",
            "udev_enumerate_get_list_entry(udev_enumerate)"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_get_list_entry",
          "args": [
            "udev_enumerate"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"udev scan devices failed\""
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_enumerate_scan_devices",
          "args": [
            "udev_enumerate"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevEnumerateAddMatches",
          "args": [
            "udev_enumerate"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "udevEnumerateAddMatches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1398-1411",
          "snippet": "static int\nudevEnumerateAddMatches(struct udev_enumerate *udev_enumerate)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(subsystem_blacklist); i++) {\n        const char *s = subsystem_blacklist[i];\n        if (udev_enumerate_add_nomatch_subsystem(udev_enumerate, s) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"failed to add susbsystem filter\"));\n            return -1;\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const char *subsystem_blacklist[] = {\n    \"acpi\", \"tty\", \"vc\", \"i2c\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nconst char *subsystem_blacklist[] = {\n    \"acpi\", \"tty\", \"vc\", \"i2c\",\n};\n\nstatic int\nudevEnumerateAddMatches(struct udev_enumerate *udev_enumerate)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(subsystem_blacklist); i++) {\n        const char *s = subsystem_blacklist[i];\n        if (udev_enumerate_add_nomatch_subsystem(udev_enumerate, s) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"failed to add susbsystem filter\"));\n            return -1;\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_enumerate_new",
          "args": [
            "udev"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevEnumerateDevices(struct udev *udev)\n{\n    struct udev_enumerate *udev_enumerate = NULL;\n    struct udev_list_entry *list_entry = NULL;\n    int ret = -1;\n\n    udev_enumerate = udev_enumerate_new(udev);\n    if (udevEnumerateAddMatches(udev_enumerate) < 0)\n        goto cleanup;\n\n    if (udev_enumerate_scan_devices(udev_enumerate) < 0)\n        VIR_WARN(\"udev scan devices failed\");\n\n    udev_list_entry_foreach(list_entry,\n                            udev_enumerate_get_list_entry(udev_enumerate)) {\n\n        udevProcessDeviceListEntry(udev, list_entry);\n    }\n\n    ret = 0;\n cleanup:\n    udev_enumerate_unref(udev_enumerate);\n    return ret;\n}"
  },
  {
    "function_name": "udevEnumerateAddMatches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1398-1411",
    "snippet": "static int\nudevEnumerateAddMatches(struct udev_enumerate *udev_enumerate)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(subsystem_blacklist); i++) {\n        const char *s = subsystem_blacklist[i];\n        if (udev_enumerate_add_nomatch_subsystem(udev_enumerate, s) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"failed to add susbsystem filter\"));\n            return -1;\n        }\n    }\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const char *subsystem_blacklist[] = {\n    \"acpi\", \"tty\", \"vc\", \"i2c\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"failed to add susbsystem filter\")"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to add susbsystem filter\""
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_enumerate_add_nomatch_subsystem",
          "args": [
            "udev_enumerate",
            "s"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "subsystem_blacklist"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nconst char *subsystem_blacklist[] = {\n    \"acpi\", \"tty\", \"vc\", \"i2c\",\n};\n\nstatic int\nudevEnumerateAddMatches(struct udev_enumerate *udev_enumerate)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(subsystem_blacklist); i++) {\n        const char *s = subsystem_blacklist[i];\n        if (udev_enumerate_add_nomatch_subsystem(udev_enumerate, s) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"failed to add susbsystem filter\"));\n            return -1;\n        }\n    }\n    return 0;\n}"
  },
  {
    "function_name": "udevProcessDeviceListEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1364-1387",
    "snippet": "static int\nudevProcessDeviceListEntry(struct udev *udev,\n                           struct udev_list_entry *list_entry)\n{\n    struct udev_device *device;\n    const char *name = NULL;\n    int ret = -1;\n\n    name = udev_list_entry_get_name(list_entry);\n\n    device = udev_device_new_from_syspath(udev, name);\n\n    if (device != NULL) {\n        if (udevAddOneDevice(device) != 0) {\n            VIR_DEBUG(\"Failed to create node device for udev device '%s'\",\n                      name);\n        }\n        ret = 0;\n    }\n\n    udev_device_unref(device);\n\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udev_device_unref",
          "args": [
            "device"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed to create node device for udev device '%s'\"",
            "name"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevAddOneDevice",
          "args": [
            "device"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "udevAddOneDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1296-1361",
          "snippet": "static int\nudevAddOneDevice(struct udev_device *device)\n{\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr objdef;\n    virObjectEventPtr event = NULL;\n    bool new_device = true;\n    int ret = -1;\n\n    if (VIR_ALLOC(def) != 0)\n        goto cleanup;\n\n    def->sysfs_path = g_strdup(udev_device_get_syspath(device));\n\n    if (udevGetStringProperty(device, \"DRIVER\", &def->driver) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC(def->caps) != 0)\n        goto cleanup;\n\n    if (udevGetDeviceType(device, &def->caps->data.type) != 0)\n        goto cleanup;\n\n    if (udevGetDeviceNodes(device, def) != 0)\n        goto cleanup;\n\n    if (udevGetDeviceDetails(device, def) != 0)\n        goto cleanup;\n\n    if (udevSetParent(device, def) != 0)\n        goto cleanup;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, def->name))) {\n        virNodeDeviceObjEndAPI(&obj);\n        new_device = false;\n    }\n\n    /* If this is a device change, the old definition will be freed\n     * and the current definition will take its place. */\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def)))\n        goto cleanup;\n    objdef = virNodeDeviceObjGetDef(obj);\n\n    if (new_device)\n        event = virNodeDeviceEventLifecycleNew(objdef->name,\n                                               VIR_NODE_DEVICE_EVENT_CREATED,\n                                               0);\n    else\n        event = virNodeDeviceEventUpdateNew(objdef->name);\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    ret = 0;\n\n cleanup:\n    virObjectEventStateQueue(driver->nodeDeviceEventState, event);\n\n    if (ret != 0) {\n        VIR_DEBUG(\"Discarding device %d %p %s\", ret, def,\n                  def ? NULLSTR(def->sysfs_path) : \"\");\n        virNodeDeviceDefFree(def);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevAddOneDevice(struct udev_device *device)\n{\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr objdef;\n    virObjectEventPtr event = NULL;\n    bool new_device = true;\n    int ret = -1;\n\n    if (VIR_ALLOC(def) != 0)\n        goto cleanup;\n\n    def->sysfs_path = g_strdup(udev_device_get_syspath(device));\n\n    if (udevGetStringProperty(device, \"DRIVER\", &def->driver) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC(def->caps) != 0)\n        goto cleanup;\n\n    if (udevGetDeviceType(device, &def->caps->data.type) != 0)\n        goto cleanup;\n\n    if (udevGetDeviceNodes(device, def) != 0)\n        goto cleanup;\n\n    if (udevGetDeviceDetails(device, def) != 0)\n        goto cleanup;\n\n    if (udevSetParent(device, def) != 0)\n        goto cleanup;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, def->name))) {\n        virNodeDeviceObjEndAPI(&obj);\n        new_device = false;\n    }\n\n    /* If this is a device change, the old definition will be freed\n     * and the current definition will take its place. */\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def)))\n        goto cleanup;\n    objdef = virNodeDeviceObjGetDef(obj);\n\n    if (new_device)\n        event = virNodeDeviceEventLifecycleNew(objdef->name,\n                                               VIR_NODE_DEVICE_EVENT_CREATED,\n                                               0);\n    else\n        event = virNodeDeviceEventUpdateNew(objdef->name);\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    ret = 0;\n\n cleanup:\n    virObjectEventStateQueue(driver->nodeDeviceEventState, event);\n\n    if (ret != 0) {\n        VIR_DEBUG(\"Discarding device %d %p %s\", ret, def,\n                  def ? NULLSTR(def->sysfs_path) : \"\");\n        virNodeDeviceDefFree(def);\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_new_from_syspath",
          "args": [
            "udev",
            "name"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_list_entry_get_name",
          "args": [
            "list_entry"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessDeviceListEntry(struct udev *udev,\n                           struct udev_list_entry *list_entry)\n{\n    struct udev_device *device;\n    const char *name = NULL;\n    int ret = -1;\n\n    name = udev_list_entry_get_name(list_entry);\n\n    device = udev_device_new_from_syspath(udev, name);\n\n    if (device != NULL) {\n        if (udevAddOneDevice(device) != 0) {\n            VIR_DEBUG(\"Failed to create node device for udev device '%s'\",\n                      name);\n        }\n        ret = 0;\n    }\n\n    udev_device_unref(device);\n\n    return ret;\n}"
  },
  {
    "function_name": "udevAddOneDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1296-1361",
    "snippet": "static int\nudevAddOneDevice(struct udev_device *device)\n{\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr objdef;\n    virObjectEventPtr event = NULL;\n    bool new_device = true;\n    int ret = -1;\n\n    if (VIR_ALLOC(def) != 0)\n        goto cleanup;\n\n    def->sysfs_path = g_strdup(udev_device_get_syspath(device));\n\n    if (udevGetStringProperty(device, \"DRIVER\", &def->driver) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC(def->caps) != 0)\n        goto cleanup;\n\n    if (udevGetDeviceType(device, &def->caps->data.type) != 0)\n        goto cleanup;\n\n    if (udevGetDeviceNodes(device, def) != 0)\n        goto cleanup;\n\n    if (udevGetDeviceDetails(device, def) != 0)\n        goto cleanup;\n\n    if (udevSetParent(device, def) != 0)\n        goto cleanup;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, def->name))) {\n        virNodeDeviceObjEndAPI(&obj);\n        new_device = false;\n    }\n\n    /* If this is a device change, the old definition will be freed\n     * and the current definition will take its place. */\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def)))\n        goto cleanup;\n    objdef = virNodeDeviceObjGetDef(obj);\n\n    if (new_device)\n        event = virNodeDeviceEventLifecycleNew(objdef->name,\n                                               VIR_NODE_DEVICE_EVENT_CREATED,\n                                               0);\n    else\n        event = virNodeDeviceEventUpdateNew(objdef->name);\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    ret = 0;\n\n cleanup:\n    virObjectEventStateQueue(driver->nodeDeviceEventState, event);\n\n    if (ret != 0) {\n        VIR_DEBUG(\"Discarding device %d %p %s\", ret, def,\n                  def ? NULLSTR(def->sysfs_path) : \"\");\n        virNodeDeviceDefFree(def);\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNodeDeviceDefFree",
          "args": [
            "def"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "98-125",
          "snippet": "void\nvirNodeDeviceDefFree(virNodeDeviceDefPtr def)\n{\n    virNodeDevCapsDefPtr caps;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->parent);\n    VIR_FREE(def->parent_wwnn);\n    VIR_FREE(def->parent_wwpn);\n    VIR_FREE(def->parent_fabric_wwn);\n    VIR_FREE(def->driver);\n    VIR_FREE(def->sysfs_path);\n    VIR_FREE(def->parent_sysfs_path);\n    VIR_FREE(def->devnode);\n    virStringListFree(def->devlinks);\n\n    caps = def->caps;\n    while (caps) {\n        virNodeDevCapsDefPtr next = caps->next;\n        virNodeDevCapsDefFree(caps);\n        caps = next;\n    }\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNodeDeviceDefFree(virNodeDeviceDefPtr def)\n{\n    virNodeDevCapsDefPtr caps;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->parent);\n    VIR_FREE(def->parent_wwnn);\n    VIR_FREE(def->parent_wwpn);\n    VIR_FREE(def->parent_fabric_wwn);\n    VIR_FREE(def->driver);\n    VIR_FREE(def->sysfs_path);\n    VIR_FREE(def->parent_sysfs_path);\n    VIR_FREE(def->devnode);\n    virStringListFree(def->devlinks);\n\n    caps = def->caps;\n    while (caps) {\n        virNodeDevCapsDefPtr next = caps->next;\n        virNodeDevCapsDefFree(caps);\n        caps = next;\n    }\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Discarding device %d %p %s\"",
            "ret",
            "def",
            "def ? NULLSTR(def->sysfs_path) : \"\""
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "def->sysfs_path"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->nodeDeviceEventState",
            "event"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "101-110",
          "snippet": "void\nvirNodeDeviceObjEndAPI(virNodeDeviceObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirNodeDeviceObjEndAPI(virNodeDeviceObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceEventUpdateNew",
          "args": [
            "objdef->name"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceEventUpdateNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_event.c",
          "lines": "265-280",
          "snippet": "virObjectEventPtr\nvirNodeDeviceEventUpdateNew(const char *name)\n{\n    virNodeDeviceEventUpdatePtr event;\n\n    if (virNodeDeviceEventsInitialize() < 0)\n        return NULL;\n\n    if (!(event = virObjectEventNew(virNodeDeviceEventUpdateClass,\n                                    virNodeDeviceEventDispatchDefaultFunc,\n                                    VIR_NODE_DEVICE_EVENT_ID_UPDATE,\n                                    0, name, NULL, name)))\n        return NULL;\n\n    return (virObjectEventPtr)event;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"node_device_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNodeDeviceEventUpdateClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"node_device_event.h\"\n#include <config.h>\n\nstatic virClassPtr virNodeDeviceEventUpdateClass;\n\nvirObjectEventPtr\nvirNodeDeviceEventUpdateNew(const char *name)\n{\n    virNodeDeviceEventUpdatePtr event;\n\n    if (virNodeDeviceEventsInitialize() < 0)\n        return NULL;\n\n    if (!(event = virObjectEventNew(virNodeDeviceEventUpdateClass,\n                                    virNodeDeviceEventDispatchDefaultFunc,\n                                    VIR_NODE_DEVICE_EVENT_ID_UPDATE,\n                                    0, name, NULL, name)))\n        return NULL;\n\n    return (virObjectEventPtr)event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceEventLifecycleNew",
          "args": [
            "objdef->name",
            "VIR_NODE_DEVICE_EVENT_CREATED",
            "0"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceEventLifecycleNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_event.c",
          "lines": "236-256",
          "snippet": "virObjectEventPtr\nvirNodeDeviceEventLifecycleNew(const char *name,\n                               int type,\n                               int detail)\n{\n    virNodeDeviceEventLifecyclePtr event;\n\n    if (virNodeDeviceEventsInitialize() < 0)\n        return NULL;\n\n    if (!(event = virObjectEventNew(virNodeDeviceEventLifecycleClass,\n                                    virNodeDeviceEventDispatchDefaultFunc,\n                                    VIR_NODE_DEVICE_EVENT_ID_LIFECYCLE,\n                                    0, name, NULL, name)))\n        return NULL;\n\n    event->type = type;\n    event->detail = detail;\n\n    return (virObjectEventPtr)event;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"node_device_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNodeDeviceEventLifecycleClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"node_device_event.h\"\n#include <config.h>\n\nstatic virClassPtr virNodeDeviceEventLifecycleClass;\n\nvirObjectEventPtr\nvirNodeDeviceEventLifecycleNew(const char *name,\n                               int type,\n                               int detail)\n{\n    virNodeDeviceEventLifecyclePtr event;\n\n    if (virNodeDeviceEventsInitialize() < 0)\n        return NULL;\n\n    if (!(event = virObjectEventNew(virNodeDeviceEventLifecycleClass,\n                                    virNodeDeviceEventDispatchDefaultFunc,\n                                    VIR_NODE_DEVICE_EVENT_ID_LIFECYCLE,\n                                    0, name, NULL, name)))\n        return NULL;\n\n    event->type = type;\n    event->detail = detail;\n\n    return (virObjectEventPtr)event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjGetDef",
          "args": [
            "obj"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "113-117",
          "snippet": "virNodeDeviceDefPtr\nvirNodeDeviceObjGetDef(virNodeDeviceObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirNodeDeviceDefPtr\nvirNodeDeviceObjGetDef(virNodeDeviceObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjListAssignDef",
          "args": [
            "driver->devs",
            "def"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjListAssignDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "439-467",
          "snippet": "virNodeDeviceObjPtr\nvirNodeDeviceObjListAssignDef(virNodeDeviceObjListPtr devs,\n                              virNodeDeviceDefPtr def)\n{\n    virNodeDeviceObjPtr obj;\n\n    virObjectRWLockWrite(devs);\n\n    if ((obj = virNodeDeviceObjListFindByNameLocked(devs, def->name))) {\n        virObjectLock(obj);\n        virNodeDeviceDefFree(obj->def);\n        obj->def = def;\n    } else {\n        if (!(obj = virNodeDeviceObjNew()))\n            goto cleanup;\n\n        if (virHashAddEntry(devs->objs, def->name, obj) < 0) {\n            virNodeDeviceObjEndAPI(&obj);\n            goto cleanup;\n        }\n\n        obj->def = def;\n        virObjectRef(obj);\n    }\n\n cleanup:\n    virObjectRWUnlock(devs);\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirNodeDeviceObjPtr\nvirNodeDeviceObjListAssignDef(virNodeDeviceObjListPtr devs,\n                              virNodeDeviceDefPtr def)\n{\n    virNodeDeviceObjPtr obj;\n\n    virObjectRWLockWrite(devs);\n\n    if ((obj = virNodeDeviceObjListFindByNameLocked(devs, def->name))) {\n        virObjectLock(obj);\n        virNodeDeviceDefFree(obj->def);\n        obj->def = def;\n    } else {\n        if (!(obj = virNodeDeviceObjNew()))\n            goto cleanup;\n\n        if (virHashAddEntry(devs->objs, def->name, obj) < 0) {\n            virNodeDeviceObjEndAPI(&obj);\n            goto cleanup;\n        }\n\n        obj->def = def;\n        virObjectRef(obj);\n    }\n\n cleanup:\n    virObjectRWUnlock(devs);\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjListFindByName",
          "args": [
            "driver->devs",
            "def->name"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjListFindByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "236-249",
          "snippet": "virNodeDeviceObjPtr\nvirNodeDeviceObjListFindByName(virNodeDeviceObjListPtr devs,\n                               const char *name)\n{\n    virNodeDeviceObjPtr obj;\n\n    virObjectRWLockRead(devs);\n    obj = virNodeDeviceObjListFindByNameLocked(devs, name);\n    virObjectRWUnlock(devs);\n    if (obj)\n        virObjectLock(obj);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirNodeDeviceObjPtr\nvirNodeDeviceObjListFindByName(virNodeDeviceObjListPtr devs,\n                               const char *name)\n{\n    virNodeDeviceObjPtr obj;\n\n    virObjectRWLockRead(devs);\n    obj = virNodeDeviceObjListFindByNameLocked(devs, name);\n    virObjectRWUnlock(devs);\n    if (obj)\n        virObjectLock(obj);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevSetParent",
          "args": [
            "device",
            "def"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "udevSetParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1254-1293",
          "snippet": "static int\nudevSetParent(struct udev_device *device,\n              virNodeDeviceDefPtr def)\n{\n    struct udev_device *parent_device = NULL;\n    const char *parent_sysfs_path = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr objdef;\n\n    parent_device = device;\n    do {\n\n        parent_device = udev_device_get_parent(parent_device);\n        if (parent_device == NULL)\n            break;\n\n        parent_sysfs_path = udev_device_get_syspath(parent_device);\n        if (parent_sysfs_path == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get syspath for parent of '%s'\"),\n                           udev_device_get_syspath(parent_device));\n            return -1;\n        }\n\n        if ((obj = virNodeDeviceObjListFindBySysfsPath(driver->devs,\n                                                       parent_sysfs_path))) {\n            objdef = virNodeDeviceObjGetDef(obj);\n            def->parent = g_strdup(objdef->name);\n            virNodeDeviceObjEndAPI(&obj);\n\n            def->parent_sysfs_path = g_strdup(parent_sysfs_path);\n        }\n\n    } while (def->parent == NULL && parent_device != NULL);\n\n    if (!def->parent)\n        def->parent = g_strdup(\"computer\");\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevSetParent(struct udev_device *device,\n              virNodeDeviceDefPtr def)\n{\n    struct udev_device *parent_device = NULL;\n    const char *parent_sysfs_path = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr objdef;\n\n    parent_device = device;\n    do {\n\n        parent_device = udev_device_get_parent(parent_device);\n        if (parent_device == NULL)\n            break;\n\n        parent_sysfs_path = udev_device_get_syspath(parent_device);\n        if (parent_sysfs_path == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get syspath for parent of '%s'\"),\n                           udev_device_get_syspath(parent_device));\n            return -1;\n        }\n\n        if ((obj = virNodeDeviceObjListFindBySysfsPath(driver->devs,\n                                                       parent_sysfs_path))) {\n            objdef = virNodeDeviceObjGetDef(obj);\n            def->parent = g_strdup(objdef->name);\n            virNodeDeviceObjEndAPI(&obj);\n\n            def->parent_sysfs_path = g_strdup(parent_sysfs_path);\n        }\n\n    } while (def->parent == NULL && parent_device != NULL);\n\n    if (!def->parent)\n        def->parent = g_strdup(\"computer\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetDeviceDetails",
          "args": [
            "device",
            "def"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetDeviceDetails",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1183-1221",
          "snippet": "static int\nudevGetDeviceDetails(struct udev_device *device,\n                     virNodeDeviceDefPtr def)\n{\n    switch (def->caps->data.type) {\n    case VIR_NODE_DEV_CAP_PCI_DEV:\n        return udevProcessPCI(device, def);\n    case VIR_NODE_DEV_CAP_USB_DEV:\n        return udevProcessUSBDevice(device, def);\n    case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        return udevProcessUSBInterface(device, def);\n    case VIR_NODE_DEV_CAP_NET:\n        return udevProcessNetworkInterface(device, def);\n    case VIR_NODE_DEV_CAP_SCSI_HOST:\n        return udevProcessSCSIHost(device, def);\n    case VIR_NODE_DEV_CAP_SCSI_TARGET:\n        return udevProcessSCSITarget(device, def);\n    case VIR_NODE_DEV_CAP_SCSI:\n        return udevProcessSCSIDevice(device, def);\n    case VIR_NODE_DEV_CAP_STORAGE:\n        return udevProcessStorage(device, def);\n    case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n        return udevProcessSCSIGeneric(device, def);\n    case VIR_NODE_DEV_CAP_DRM:\n        return udevProcessDRMDevice(device, def);\n    case VIR_NODE_DEV_CAP_MDEV:\n        return udevProcessMediatedDevice(device, def);\n    case VIR_NODE_DEV_CAP_CCW_DEV:\n        return udevProcessCCW(device, def);\n    case VIR_NODE_DEV_CAP_MDEV_TYPES:\n    case VIR_NODE_DEV_CAP_SYSTEM:\n    case VIR_NODE_DEV_CAP_FC_HOST:\n    case VIR_NODE_DEV_CAP_VPORTS:\n    case VIR_NODE_DEV_CAP_LAST:\n        break;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetDeviceDetails(struct udev_device *device,\n                     virNodeDeviceDefPtr def)\n{\n    switch (def->caps->data.type) {\n    case VIR_NODE_DEV_CAP_PCI_DEV:\n        return udevProcessPCI(device, def);\n    case VIR_NODE_DEV_CAP_USB_DEV:\n        return udevProcessUSBDevice(device, def);\n    case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        return udevProcessUSBInterface(device, def);\n    case VIR_NODE_DEV_CAP_NET:\n        return udevProcessNetworkInterface(device, def);\n    case VIR_NODE_DEV_CAP_SCSI_HOST:\n        return udevProcessSCSIHost(device, def);\n    case VIR_NODE_DEV_CAP_SCSI_TARGET:\n        return udevProcessSCSITarget(device, def);\n    case VIR_NODE_DEV_CAP_SCSI:\n        return udevProcessSCSIDevice(device, def);\n    case VIR_NODE_DEV_CAP_STORAGE:\n        return udevProcessStorage(device, def);\n    case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n        return udevProcessSCSIGeneric(device, def);\n    case VIR_NODE_DEV_CAP_DRM:\n        return udevProcessDRMDevice(device, def);\n    case VIR_NODE_DEV_CAP_MDEV:\n        return udevProcessMediatedDevice(device, def);\n    case VIR_NODE_DEV_CAP_CCW_DEV:\n        return udevProcessCCW(device, def);\n    case VIR_NODE_DEV_CAP_MDEV_TYPES:\n    case VIR_NODE_DEV_CAP_SYSTEM:\n    case VIR_NODE_DEV_CAP_FC_HOST:\n    case VIR_NODE_DEV_CAP_VPORTS:\n    case VIR_NODE_DEV_CAP_LAST:\n        break;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetDeviceNodes",
          "args": [
            "device",
            "def"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetDeviceNodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1090-1114",
          "snippet": "static int\nudevGetDeviceNodes(struct udev_device *device,\n                   virNodeDeviceDefPtr def)\n{\n    const char *devnode = NULL;\n    struct udev_list_entry *list_entry = NULL;\n    int n = 0;\n\n    devnode = udev_device_get_devnode(device);\n\n    def->devnode = g_strdup(devnode);\n\n    udev_list_entry_foreach(list_entry, udev_device_get_devlinks_list_entry(device))\n        n++;\n\n    if (VIR_ALLOC_N(def->devlinks, n + 1) < 0)\n        return -1;\n\n    n = 0;\n    udev_list_entry_foreach(list_entry, udev_device_get_devlinks_list_entry(device)) {\n        def->devlinks[n++] = g_strdup(udev_list_entry_get_name(list_entry));\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetDeviceNodes(struct udev_device *device,\n                   virNodeDeviceDefPtr def)\n{\n    const char *devnode = NULL;\n    struct udev_list_entry *list_entry = NULL;\n    int n = 0;\n\n    devnode = udev_device_get_devnode(device);\n\n    def->devnode = g_strdup(devnode);\n\n    udev_list_entry_foreach(list_entry, udev_device_get_devlinks_list_entry(device))\n        n++;\n\n    if (VIR_ALLOC_N(def->devlinks, n + 1) < 0)\n        return -1;\n\n    n = 0;\n    udev_list_entry_foreach(list_entry, udev_device_get_devlinks_list_entry(device)) {\n        def->devlinks[n++] = g_strdup(udev_list_entry_get_name(list_entry));\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetDeviceType",
          "args": [
            "device",
            "&def->caps->data.type"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetDeviceType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1117-1180",
          "snippet": "static int\nudevGetDeviceType(struct udev_device *device,\n                  virNodeDevCapType *type)\n{\n    const char *devtype = NULL;\n    char *subsystem = NULL;\n    int ret = -1;\n\n    devtype = udev_device_get_devtype(device);\n    *type = 0;\n\n    if (devtype) {\n        if (STREQ(devtype, \"usb_device\"))\n            *type = VIR_NODE_DEV_CAP_USB_DEV;\n        else if (STREQ(devtype, \"usb_interface\"))\n            *type = VIR_NODE_DEV_CAP_USB_INTERFACE;\n        else if (STREQ(devtype, \"scsi_host\"))\n            *type = VIR_NODE_DEV_CAP_SCSI_HOST;\n        else if (STREQ(devtype, \"scsi_target\"))\n            *type = VIR_NODE_DEV_CAP_SCSI_TARGET;\n        else if (STREQ(devtype, \"scsi_device\"))\n            *type = VIR_NODE_DEV_CAP_SCSI;\n        else if (STREQ(devtype, \"disk\"))\n            *type = VIR_NODE_DEV_CAP_STORAGE;\n        else if (STREQ(devtype, \"wlan\"))\n            *type = VIR_NODE_DEV_CAP_NET;\n        else if (STREQ(devtype, \"drm_minor\"))\n            *type = VIR_NODE_DEV_CAP_DRM;\n    } else {\n        /* PCI devices don't set the DEVTYPE property. */\n        if (udevHasDeviceProperty(device, \"PCI_CLASS\"))\n            *type = VIR_NODE_DEV_CAP_PCI_DEV;\n\n        /* Wired network interfaces don't set the DEVTYPE property,\n         * USB devices also have an INTERFACE property, but they do\n         * set DEVTYPE, so if devtype is NULL and the INTERFACE\n         * property exists, we have a network device. */\n        if (udevHasDeviceProperty(device, \"INTERFACE\"))\n            *type = VIR_NODE_DEV_CAP_NET;\n\n        /* The following devices do not set the DEVTYPE property, therefore\n         * we need to rely on the SUBSYSTEM property */\n        if (udevGetStringProperty(device, \"SUBSYSTEM\", &subsystem) < 0)\n            return -1;\n\n        if (STREQ_NULLABLE(subsystem, \"scsi_generic\"))\n            *type = VIR_NODE_DEV_CAP_SCSI_GENERIC;\n        else if (STREQ_NULLABLE(subsystem, \"mdev\"))\n            *type = VIR_NODE_DEV_CAP_MDEV;\n        else if (STREQ_NULLABLE(subsystem, \"ccw\"))\n            *type = VIR_NODE_DEV_CAP_CCW_DEV;\n\n        VIR_FREE(subsystem);\n    }\n\n    if (!*type)\n        VIR_DEBUG(\"Could not determine device type for device \"\n                  \"with sysfs name '%s'\",\n                  udev_device_get_sysname(device));\n    else\n        ret = 0;\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetDeviceType(struct udev_device *device,\n                  virNodeDevCapType *type)\n{\n    const char *devtype = NULL;\n    char *subsystem = NULL;\n    int ret = -1;\n\n    devtype = udev_device_get_devtype(device);\n    *type = 0;\n\n    if (devtype) {\n        if (STREQ(devtype, \"usb_device\"))\n            *type = VIR_NODE_DEV_CAP_USB_DEV;\n        else if (STREQ(devtype, \"usb_interface\"))\n            *type = VIR_NODE_DEV_CAP_USB_INTERFACE;\n        else if (STREQ(devtype, \"scsi_host\"))\n            *type = VIR_NODE_DEV_CAP_SCSI_HOST;\n        else if (STREQ(devtype, \"scsi_target\"))\n            *type = VIR_NODE_DEV_CAP_SCSI_TARGET;\n        else if (STREQ(devtype, \"scsi_device\"))\n            *type = VIR_NODE_DEV_CAP_SCSI;\n        else if (STREQ(devtype, \"disk\"))\n            *type = VIR_NODE_DEV_CAP_STORAGE;\n        else if (STREQ(devtype, \"wlan\"))\n            *type = VIR_NODE_DEV_CAP_NET;\n        else if (STREQ(devtype, \"drm_minor\"))\n            *type = VIR_NODE_DEV_CAP_DRM;\n    } else {\n        /* PCI devices don't set the DEVTYPE property. */\n        if (udevHasDeviceProperty(device, \"PCI_CLASS\"))\n            *type = VIR_NODE_DEV_CAP_PCI_DEV;\n\n        /* Wired network interfaces don't set the DEVTYPE property,\n         * USB devices also have an INTERFACE property, but they do\n         * set DEVTYPE, so if devtype is NULL and the INTERFACE\n         * property exists, we have a network device. */\n        if (udevHasDeviceProperty(device, \"INTERFACE\"))\n            *type = VIR_NODE_DEV_CAP_NET;\n\n        /* The following devices do not set the DEVTYPE property, therefore\n         * we need to rely on the SUBSYSTEM property */\n        if (udevGetStringProperty(device, \"SUBSYSTEM\", &subsystem) < 0)\n            return -1;\n\n        if (STREQ_NULLABLE(subsystem, \"scsi_generic\"))\n            *type = VIR_NODE_DEV_CAP_SCSI_GENERIC;\n        else if (STREQ_NULLABLE(subsystem, \"mdev\"))\n            *type = VIR_NODE_DEV_CAP_MDEV;\n        else if (STREQ_NULLABLE(subsystem, \"ccw\"))\n            *type = VIR_NODE_DEV_CAP_CCW_DEV;\n\n        VIR_FREE(subsystem);\n    }\n\n    if (!*type)\n        VIR_DEBUG(\"Could not determine device type for device \"\n                  \"with sysfs name '%s'\",\n                  udev_device_get_sysname(device));\n    else\n        ret = 0;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def->caps"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetStringProperty",
          "args": [
            "device",
            "\"DRIVER\"",
            "&def->driver"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetStringProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "151-159",
          "snippet": "static int\nudevGetStringProperty(struct udev_device *udev_device,\n                      const char *property_key,\n                      char **value)\n{\n    *value = g_strdup(udevGetDeviceProperty(udev_device, property_key));\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetStringProperty(struct udev_device *udev_device,\n                      const char *property_key,\n                      char **value)\n{\n    *value = g_strdup(udevGetDeviceProperty(udev_device, property_key));\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "udev_device_get_syspath(device)"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_get_syspath",
          "args": [
            "device"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevAddOneDevice(struct udev_device *device)\n{\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr objdef;\n    virObjectEventPtr event = NULL;\n    bool new_device = true;\n    int ret = -1;\n\n    if (VIR_ALLOC(def) != 0)\n        goto cleanup;\n\n    def->sysfs_path = g_strdup(udev_device_get_syspath(device));\n\n    if (udevGetStringProperty(device, \"DRIVER\", &def->driver) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC(def->caps) != 0)\n        goto cleanup;\n\n    if (udevGetDeviceType(device, &def->caps->data.type) != 0)\n        goto cleanup;\n\n    if (udevGetDeviceNodes(device, def) != 0)\n        goto cleanup;\n\n    if (udevGetDeviceDetails(device, def) != 0)\n        goto cleanup;\n\n    if (udevSetParent(device, def) != 0)\n        goto cleanup;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, def->name))) {\n        virNodeDeviceObjEndAPI(&obj);\n        new_device = false;\n    }\n\n    /* If this is a device change, the old definition will be freed\n     * and the current definition will take its place. */\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def)))\n        goto cleanup;\n    objdef = virNodeDeviceObjGetDef(obj);\n\n    if (new_device)\n        event = virNodeDeviceEventLifecycleNew(objdef->name,\n                                               VIR_NODE_DEVICE_EVENT_CREATED,\n                                               0);\n    else\n        event = virNodeDeviceEventUpdateNew(objdef->name);\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    ret = 0;\n\n cleanup:\n    virObjectEventStateQueue(driver->nodeDeviceEventState, event);\n\n    if (ret != 0) {\n        VIR_DEBUG(\"Discarding device %d %p %s\", ret, def,\n                  def ? NULLSTR(def->sysfs_path) : \"\");\n        virNodeDeviceDefFree(def);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "udevSetParent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1254-1293",
    "snippet": "static int\nudevSetParent(struct udev_device *device,\n              virNodeDeviceDefPtr def)\n{\n    struct udev_device *parent_device = NULL;\n    const char *parent_sysfs_path = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr objdef;\n\n    parent_device = device;\n    do {\n\n        parent_device = udev_device_get_parent(parent_device);\n        if (parent_device == NULL)\n            break;\n\n        parent_sysfs_path = udev_device_get_syspath(parent_device);\n        if (parent_sysfs_path == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get syspath for parent of '%s'\"),\n                           udev_device_get_syspath(parent_device));\n            return -1;\n        }\n\n        if ((obj = virNodeDeviceObjListFindBySysfsPath(driver->devs,\n                                                       parent_sysfs_path))) {\n            objdef = virNodeDeviceObjGetDef(obj);\n            def->parent = g_strdup(objdef->name);\n            virNodeDeviceObjEndAPI(&obj);\n\n            def->parent_sysfs_path = g_strdup(parent_sysfs_path);\n        }\n\n    } while (def->parent == NULL && parent_device != NULL);\n\n    if (!def->parent)\n        def->parent = g_strdup(\"computer\");\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"computer\""
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "101-110",
          "snippet": "void\nvirNodeDeviceObjEndAPI(virNodeDeviceObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirNodeDeviceObjEndAPI(virNodeDeviceObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjGetDef",
          "args": [
            "obj"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "113-117",
          "snippet": "virNodeDeviceDefPtr\nvirNodeDeviceObjGetDef(virNodeDeviceObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirNodeDeviceDefPtr\nvirNodeDeviceObjGetDef(virNodeDeviceObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjListFindBySysfsPath",
          "args": [
            "driver->devs",
            "parent_sysfs_path"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjListFindBySysfsPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "218-225",
          "snippet": "virNodeDeviceObjPtr\nvirNodeDeviceObjListFindBySysfsPath(virNodeDeviceObjListPtr devs,\n                                    const char *sysfs_path)\n{\n    return virNodeDeviceObjListSearch(devs,\n                                      virNodeDeviceObjListFindBySysfsPathCallback,\n                                      sysfs_path);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirNodeDeviceObjPtr\nvirNodeDeviceObjListFindBySysfsPath(virNodeDeviceObjListPtr devs,\n                                    const char *sysfs_path)\n{\n    return virNodeDeviceObjListSearch(devs,\n                                      virNodeDeviceObjListFindBySysfsPathCallback,\n                                      sysfs_path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get syspath for parent of '%s'\")",
            "udev_device_get_syspath(parent_device)"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_syspath",
          "args": [
            "parent_device"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not get syspath for parent of '%s'\""
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_get_syspath",
          "args": [
            "parent_device"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_parent",
          "args": [
            "parent_device"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevSetParent(struct udev_device *device,\n              virNodeDeviceDefPtr def)\n{\n    struct udev_device *parent_device = NULL;\n    const char *parent_sysfs_path = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr objdef;\n\n    parent_device = device;\n    do {\n\n        parent_device = udev_device_get_parent(parent_device);\n        if (parent_device == NULL)\n            break;\n\n        parent_sysfs_path = udev_device_get_syspath(parent_device);\n        if (parent_sysfs_path == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get syspath for parent of '%s'\"),\n                           udev_device_get_syspath(parent_device));\n            return -1;\n        }\n\n        if ((obj = virNodeDeviceObjListFindBySysfsPath(driver->devs,\n                                                       parent_sysfs_path))) {\n            objdef = virNodeDeviceObjGetDef(obj);\n            def->parent = g_strdup(objdef->name);\n            virNodeDeviceObjEndAPI(&obj);\n\n            def->parent_sysfs_path = g_strdup(parent_sysfs_path);\n        }\n\n    } while (def->parent == NULL && parent_device != NULL);\n\n    if (!def->parent)\n        def->parent = g_strdup(\"computer\");\n\n    return 0;\n}"
  },
  {
    "function_name": "udevRemoveOneDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1224-1251",
    "snippet": "static int\nudevRemoveOneDevice(struct udev_device *device)\n{\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr def;\n    virObjectEventPtr event = NULL;\n    const char *name = NULL;\n\n    name = udev_device_get_syspath(device);\n    if (!(obj = virNodeDeviceObjListFindBySysfsPath(driver->devs, name))) {\n        VIR_DEBUG(\"Failed to find device to remove that has udev name '%s'\",\n                  name);\n        return -1;\n    }\n    def = virNodeDeviceObjGetDef(obj);\n\n    event = virNodeDeviceEventLifecycleNew(def->name,\n                                           VIR_NODE_DEVICE_EVENT_DELETED,\n                                           0);\n\n    VIR_DEBUG(\"Removing device '%s' with sysfs path '%s'\",\n              def->name, name);\n    virNodeDeviceObjListRemove(driver->devs, obj);\n    virObjectUnref(obj);\n\n    virObjectEventStateQueue(driver->nodeDeviceEventState, event);\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->nodeDeviceEventState",
            "event"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "obj"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjListRemove",
          "args": [
            "driver->devs",
            "obj"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjListRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "470-488",
          "snippet": "void\nvirNodeDeviceObjListRemove(virNodeDeviceObjListPtr devs,\n                           virNodeDeviceObjPtr obj)\n{\n    virNodeDeviceDefPtr def;\n\n    if (!obj)\n        return;\n    def = obj->def;\n\n    virObjectRef(obj);\n    virObjectUnlock(obj);\n    virObjectRWLockWrite(devs);\n    virObjectLock(obj);\n    virHashRemoveEntry(devs->objs, def->name);\n    virObjectUnlock(obj);\n    virObjectUnref(obj);\n    virObjectRWUnlock(devs);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirNodeDeviceObjListRemove(virNodeDeviceObjListPtr devs,\n                           virNodeDeviceObjPtr obj)\n{\n    virNodeDeviceDefPtr def;\n\n    if (!obj)\n        return;\n    def = obj->def;\n\n    virObjectRef(obj);\n    virObjectUnlock(obj);\n    virObjectRWLockWrite(devs);\n    virObjectLock(obj);\n    virHashRemoveEntry(devs->objs, def->name);\n    virObjectUnlock(obj);\n    virObjectUnref(obj);\n    virObjectRWUnlock(devs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Removing device '%s' with sysfs path '%s'\"",
            "def->name",
            "name"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDeviceEventLifecycleNew",
          "args": [
            "def->name",
            "VIR_NODE_DEVICE_EVENT_DELETED",
            "0"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceEventLifecycleNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_event.c",
          "lines": "236-256",
          "snippet": "virObjectEventPtr\nvirNodeDeviceEventLifecycleNew(const char *name,\n                               int type,\n                               int detail)\n{\n    virNodeDeviceEventLifecyclePtr event;\n\n    if (virNodeDeviceEventsInitialize() < 0)\n        return NULL;\n\n    if (!(event = virObjectEventNew(virNodeDeviceEventLifecycleClass,\n                                    virNodeDeviceEventDispatchDefaultFunc,\n                                    VIR_NODE_DEVICE_EVENT_ID_LIFECYCLE,\n                                    0, name, NULL, name)))\n        return NULL;\n\n    event->type = type;\n    event->detail = detail;\n\n    return (virObjectEventPtr)event;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"node_device_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNodeDeviceEventLifecycleClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"node_device_event.h\"\n#include <config.h>\n\nstatic virClassPtr virNodeDeviceEventLifecycleClass;\n\nvirObjectEventPtr\nvirNodeDeviceEventLifecycleNew(const char *name,\n                               int type,\n                               int detail)\n{\n    virNodeDeviceEventLifecyclePtr event;\n\n    if (virNodeDeviceEventsInitialize() < 0)\n        return NULL;\n\n    if (!(event = virObjectEventNew(virNodeDeviceEventLifecycleClass,\n                                    virNodeDeviceEventDispatchDefaultFunc,\n                                    VIR_NODE_DEVICE_EVENT_ID_LIFECYCLE,\n                                    0, name, NULL, name)))\n        return NULL;\n\n    event->type = type;\n    event->detail = detail;\n\n    return (virObjectEventPtr)event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjGetDef",
          "args": [
            "obj"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "113-117",
          "snippet": "virNodeDeviceDefPtr\nvirNodeDeviceObjGetDef(virNodeDeviceObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirNodeDeviceDefPtr\nvirNodeDeviceObjGetDef(virNodeDeviceObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed to find device to remove that has udev name '%s'\"",
            "name"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjListFindBySysfsPath",
          "args": [
            "driver->devs",
            "name"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjListFindBySysfsPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "218-225",
          "snippet": "virNodeDeviceObjPtr\nvirNodeDeviceObjListFindBySysfsPath(virNodeDeviceObjListPtr devs,\n                                    const char *sysfs_path)\n{\n    return virNodeDeviceObjListSearch(devs,\n                                      virNodeDeviceObjListFindBySysfsPathCallback,\n                                      sysfs_path);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirNodeDeviceObjPtr\nvirNodeDeviceObjListFindBySysfsPath(virNodeDeviceObjListPtr devs,\n                                    const char *sysfs_path)\n{\n    return virNodeDeviceObjListSearch(devs,\n                                      virNodeDeviceObjListFindBySysfsPathCallback,\n                                      sysfs_path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_get_syspath",
          "args": [
            "device"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevRemoveOneDevice(struct udev_device *device)\n{\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr def;\n    virObjectEventPtr event = NULL;\n    const char *name = NULL;\n\n    name = udev_device_get_syspath(device);\n    if (!(obj = virNodeDeviceObjListFindBySysfsPath(driver->devs, name))) {\n        VIR_DEBUG(\"Failed to find device to remove that has udev name '%s'\",\n                  name);\n        return -1;\n    }\n    def = virNodeDeviceObjGetDef(obj);\n\n    event = virNodeDeviceEventLifecycleNew(def->name,\n                                           VIR_NODE_DEVICE_EVENT_DELETED,\n                                           0);\n\n    VIR_DEBUG(\"Removing device '%s' with sysfs path '%s'\",\n              def->name, name);\n    virNodeDeviceObjListRemove(driver->devs, obj);\n    virObjectUnref(obj);\n\n    virObjectEventStateQueue(driver->nodeDeviceEventState, event);\n    return 0;\n}"
  },
  {
    "function_name": "udevGetDeviceDetails",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1183-1221",
    "snippet": "static int\nudevGetDeviceDetails(struct udev_device *device,\n                     virNodeDeviceDefPtr def)\n{\n    switch (def->caps->data.type) {\n    case VIR_NODE_DEV_CAP_PCI_DEV:\n        return udevProcessPCI(device, def);\n    case VIR_NODE_DEV_CAP_USB_DEV:\n        return udevProcessUSBDevice(device, def);\n    case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        return udevProcessUSBInterface(device, def);\n    case VIR_NODE_DEV_CAP_NET:\n        return udevProcessNetworkInterface(device, def);\n    case VIR_NODE_DEV_CAP_SCSI_HOST:\n        return udevProcessSCSIHost(device, def);\n    case VIR_NODE_DEV_CAP_SCSI_TARGET:\n        return udevProcessSCSITarget(device, def);\n    case VIR_NODE_DEV_CAP_SCSI:\n        return udevProcessSCSIDevice(device, def);\n    case VIR_NODE_DEV_CAP_STORAGE:\n        return udevProcessStorage(device, def);\n    case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n        return udevProcessSCSIGeneric(device, def);\n    case VIR_NODE_DEV_CAP_DRM:\n        return udevProcessDRMDevice(device, def);\n    case VIR_NODE_DEV_CAP_MDEV:\n        return udevProcessMediatedDevice(device, def);\n    case VIR_NODE_DEV_CAP_CCW_DEV:\n        return udevProcessCCW(device, def);\n    case VIR_NODE_DEV_CAP_MDEV_TYPES:\n    case VIR_NODE_DEV_CAP_SYSTEM:\n    case VIR_NODE_DEV_CAP_FC_HOST:\n    case VIR_NODE_DEV_CAP_VPORTS:\n    case VIR_NODE_DEV_CAP_LAST:\n        break;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevProcessCCW",
          "args": [
            "device",
            "def"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessCCW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1061-1087",
          "snippet": "static int\nudevProcessCCW(struct udev_device *device,\n               virNodeDeviceDefPtr def)\n{\n    int online;\n    char *p;\n    virNodeDevCapDataPtr data = &def->caps->data;\n\n    /* process only online devices to keep the list sane */\n    if (udevGetIntSysfsAttr(device, \"online\", &online, 0) < 0 || online != 1)\n        return -1;\n\n    if ((p = strrchr(def->sysfs_path, '/')) == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &data->ccw_dev.cssid) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &data->ccw_dev.ssid) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &data->ccw_dev.devno) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse the CCW address from sysfs path: '%s'\"),\n                       def->sysfs_path);\n        return -1;\n    }\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessCCW(struct udev_device *device,\n               virNodeDeviceDefPtr def)\n{\n    int online;\n    char *p;\n    virNodeDevCapDataPtr data = &def->caps->data;\n\n    /* process only online devices to keep the list sane */\n    if (udevGetIntSysfsAttr(device, \"online\", &online, 0) < 0 || online != 1)\n        return -1;\n\n    if ((p = strrchr(def->sysfs_path, '/')) == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &data->ccw_dev.cssid) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &data->ccw_dev.ssid) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &data->ccw_dev.devno) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse the CCW address from sysfs path: '%s'\"),\n                       def->sysfs_path);\n        return -1;\n    }\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevProcessMediatedDevice",
          "args": [
            "device",
            "def"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessMediatedDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "1011-1058",
          "snippet": "static int\nudevProcessMediatedDevice(struct udev_device *dev,\n                          virNodeDeviceDefPtr def)\n{\n    int ret = -1;\n    const char *uuidstr = NULL;\n    int iommugrp = -1;\n    char *linkpath = NULL;\n    char *canonicalpath = NULL;\n    virNodeDevCapMdevPtr data = &def->caps->data.mdev;\n\n    /* Because of a kernel uevent race, we might get the 'add' event prior to\n     * the sysfs tree being ready, so any attempt to access any sysfs attribute\n     * would result in ENOENT and us dropping the device, so let's work around\n     * it by waiting for the attributes to become available.\n     */\n\n    linkpath = g_strdup_printf(\"%s/mdev_type\", udev_device_get_syspath(dev));\n\n    if (virFileWaitForExists(linkpath, 1, 100) < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to wait for file '%s' to appear\"),\n                             linkpath);\n        goto cleanup;\n    }\n\n    if (virFileResolveLink(linkpath, &canonicalpath) < 0) {\n        virReportSystemError(errno, _(\"failed to resolve '%s'\"), linkpath);\n        goto cleanup;\n    }\n\n    data->type = g_path_get_basename(canonicalpath);\n\n    uuidstr = udev_device_get_sysname(dev);\n    if ((iommugrp = virMediatedDeviceGetIOMMUGroupNum(uuidstr)) < 0)\n        goto cleanup;\n\n    if (udevGenerateDeviceName(dev, def, NULL) != 0)\n        goto cleanup;\n\n    data->iommuGroupNumber = iommugrp;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(linkpath);\n    VIR_FREE(canonicalpath);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessMediatedDevice(struct udev_device *dev,\n                          virNodeDeviceDefPtr def)\n{\n    int ret = -1;\n    const char *uuidstr = NULL;\n    int iommugrp = -1;\n    char *linkpath = NULL;\n    char *canonicalpath = NULL;\n    virNodeDevCapMdevPtr data = &def->caps->data.mdev;\n\n    /* Because of a kernel uevent race, we might get the 'add' event prior to\n     * the sysfs tree being ready, so any attempt to access any sysfs attribute\n     * would result in ENOENT and us dropping the device, so let's work around\n     * it by waiting for the attributes to become available.\n     */\n\n    linkpath = g_strdup_printf(\"%s/mdev_type\", udev_device_get_syspath(dev));\n\n    if (virFileWaitForExists(linkpath, 1, 100) < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to wait for file '%s' to appear\"),\n                             linkpath);\n        goto cleanup;\n    }\n\n    if (virFileResolveLink(linkpath, &canonicalpath) < 0) {\n        virReportSystemError(errno, _(\"failed to resolve '%s'\"), linkpath);\n        goto cleanup;\n    }\n\n    data->type = g_path_get_basename(canonicalpath);\n\n    uuidstr = udev_device_get_sysname(dev);\n    if ((iommugrp = virMediatedDeviceGetIOMMUGroupNum(uuidstr)) < 0)\n        goto cleanup;\n\n    if (udevGenerateDeviceName(dev, def, NULL) != 0)\n        goto cleanup;\n\n    data->iommuGroupNumber = iommugrp;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(linkpath);\n    VIR_FREE(canonicalpath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevProcessDRMDevice",
          "args": [
            "device",
            "def"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessDRMDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "468-487",
          "snippet": "static int\nudevProcessDRMDevice(struct udev_device *device,\n                     virNodeDeviceDefPtr def)\n{\n    virNodeDevCapDRMPtr drm = &def->caps->data.drm;\n    int minor;\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    if (udevGetIntProperty(device, \"MINOR\", &minor, 10) < 0)\n        return -1;\n\n    if ((minor = drmGetMinorType(minor)) == -1)\n        return -1;\n\n    drm->type = minor;\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessDRMDevice(struct udev_device *device,\n                     virNodeDeviceDefPtr def)\n{\n    virNodeDevCapDRMPtr drm = &def->caps->data.drm;\n    int minor;\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    if (udevGetIntProperty(device, \"MINOR\", &minor, 10) < 0)\n        return -1;\n\n    if ((minor = drmGetMinorType(minor)) == -1)\n        return -1;\n\n    drm->type = minor;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevProcessSCSIGeneric",
          "args": [
            "device",
            "def"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessSCSIGeneric",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "996-1008",
          "snippet": "static int\nudevProcessSCSIGeneric(struct udev_device *dev,\n                       virNodeDeviceDefPtr def)\n{\n    if (udevGetStringProperty(dev, \"DEVNAME\", &def->caps->data.sg.path) < 0 ||\n        !def->caps->data.sg.path)\n        return -1;\n\n    if (udevGenerateDeviceName(dev, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessSCSIGeneric(struct udev_device *dev,\n                       virNodeDeviceDefPtr def)\n{\n    if (udevGetStringProperty(dev, \"DEVNAME\", &def->caps->data.sg.path) < 0 ||\n        !def->caps->data.sg.path)\n        return -1;\n\n    if (udevGenerateDeviceName(dev, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevProcessStorage",
          "args": [
            "device",
            "def"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "900-993",
          "snippet": "static int\nudevProcessStorage(struct udev_device *device,\n                   virNodeDeviceDefPtr def)\n{\n    virNodeDevCapStoragePtr storage = &def->caps->data.storage;\n    int ret = -1;\n    const char* devnode;\n\n    devnode = udev_device_get_devnode(device);\n    if (!devnode) {\n        VIR_DEBUG(\"No devnode for '%s'\", udev_device_get_devpath(device));\n        goto cleanup;\n    }\n\n    storage->block = g_strdup(devnode);\n\n    if (udevGetStringProperty(device, \"ID_BUS\", &storage->bus) < 0)\n        goto cleanup;\n    if (udevGetStringProperty(device, \"ID_SERIAL\", &storage->serial) < 0)\n        goto cleanup;\n\n    if (udevGetStringSysfsAttr(device, \"device/vendor\", &storage->vendor) < 0)\n        goto cleanup;\n    if (def->caps->data.storage.vendor)\n        virTrimSpaces(def->caps->data.storage.vendor, NULL);\n\n    if (udevGetStringSysfsAttr(device, \"device/model\", &storage->model) < 0)\n        goto cleanup;\n    if (def->caps->data.storage.model)\n        virTrimSpaces(def->caps->data.storage.model, NULL);\n    /* There is no equivalent of the hotpluggable property in libudev,\n     * but storage is going toward a world in which hotpluggable is\n     * expected, so I don't see a problem with not having a property\n     * for it. */\n\n    if (udevGetStringProperty(device, \"ID_TYPE\", &storage->drive_type) < 0)\n        goto cleanup;\n\n    if (!storage->drive_type ||\n        STREQ(def->caps->data.storage.drive_type, \"generic\")) {\n        int val = 0;\n        const char *str = NULL;\n\n        /* All floppy drives have the ID_DRIVE_FLOPPY prop. This is\n         * needed since legacy floppies don't have a drive_type */\n        if (udevGetIntProperty(device, \"ID_DRIVE_FLOPPY\", &val, 0) < 0)\n            goto cleanup;\n        else if (val == 1)\n            str = \"floppy\";\n\n        if (!str) {\n            if (udevGetIntProperty(device, \"ID_CDROM\", &val, 0) < 0)\n                goto cleanup;\n            else if (val == 1)\n                str = \"cd\";\n        }\n\n        if (!str) {\n            if (udevGetIntProperty(device, \"ID_DRIVE_FLASH_SD\", &val, 0) < 0)\n                goto cleanup;\n            if (val == 1)\n                str = \"sd\";\n        }\n\n        if (str) {\n            storage->drive_type = g_strdup(str);\n        } else {\n            /* If udev doesn't have it, perhaps we can guess it. */\n            if (udevKludgeStorageType(def) != 0)\n                goto cleanup;\n        }\n    }\n\n    if (STREQ(def->caps->data.storage.drive_type, \"cd\")) {\n        ret = udevProcessCDROM(device, def);\n    } else if (STREQ(def->caps->data.storage.drive_type, \"disk\")) {\n        ret = udevProcessDisk(device, def);\n    } else if (STREQ(def->caps->data.storage.drive_type, \"floppy\")) {\n        ret = udevProcessFloppy(device, def);\n    } else if (STREQ(def->caps->data.storage.drive_type, \"sd\")) {\n        ret = udevProcessSD(device, def);\n    } else {\n        VIR_DEBUG(\"Unsupported storage type '%s'\",\n                  def->caps->data.storage.drive_type);\n        goto cleanup;\n    }\n\n    if (udevGenerateDeviceName(device, def, storage->serial) != 0)\n        goto cleanup;\n\n cleanup:\n    VIR_DEBUG(\"Storage ret=%d\", ret);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessStorage(struct udev_device *device,\n                   virNodeDeviceDefPtr def)\n{\n    virNodeDevCapStoragePtr storage = &def->caps->data.storage;\n    int ret = -1;\n    const char* devnode;\n\n    devnode = udev_device_get_devnode(device);\n    if (!devnode) {\n        VIR_DEBUG(\"No devnode for '%s'\", udev_device_get_devpath(device));\n        goto cleanup;\n    }\n\n    storage->block = g_strdup(devnode);\n\n    if (udevGetStringProperty(device, \"ID_BUS\", &storage->bus) < 0)\n        goto cleanup;\n    if (udevGetStringProperty(device, \"ID_SERIAL\", &storage->serial) < 0)\n        goto cleanup;\n\n    if (udevGetStringSysfsAttr(device, \"device/vendor\", &storage->vendor) < 0)\n        goto cleanup;\n    if (def->caps->data.storage.vendor)\n        virTrimSpaces(def->caps->data.storage.vendor, NULL);\n\n    if (udevGetStringSysfsAttr(device, \"device/model\", &storage->model) < 0)\n        goto cleanup;\n    if (def->caps->data.storage.model)\n        virTrimSpaces(def->caps->data.storage.model, NULL);\n    /* There is no equivalent of the hotpluggable property in libudev,\n     * but storage is going toward a world in which hotpluggable is\n     * expected, so I don't see a problem with not having a property\n     * for it. */\n\n    if (udevGetStringProperty(device, \"ID_TYPE\", &storage->drive_type) < 0)\n        goto cleanup;\n\n    if (!storage->drive_type ||\n        STREQ(def->caps->data.storage.drive_type, \"generic\")) {\n        int val = 0;\n        const char *str = NULL;\n\n        /* All floppy drives have the ID_DRIVE_FLOPPY prop. This is\n         * needed since legacy floppies don't have a drive_type */\n        if (udevGetIntProperty(device, \"ID_DRIVE_FLOPPY\", &val, 0) < 0)\n            goto cleanup;\n        else if (val == 1)\n            str = \"floppy\";\n\n        if (!str) {\n            if (udevGetIntProperty(device, \"ID_CDROM\", &val, 0) < 0)\n                goto cleanup;\n            else if (val == 1)\n                str = \"cd\";\n        }\n\n        if (!str) {\n            if (udevGetIntProperty(device, \"ID_DRIVE_FLASH_SD\", &val, 0) < 0)\n                goto cleanup;\n            if (val == 1)\n                str = \"sd\";\n        }\n\n        if (str) {\n            storage->drive_type = g_strdup(str);\n        } else {\n            /* If udev doesn't have it, perhaps we can guess it. */\n            if (udevKludgeStorageType(def) != 0)\n                goto cleanup;\n        }\n    }\n\n    if (STREQ(def->caps->data.storage.drive_type, \"cd\")) {\n        ret = udevProcessCDROM(device, def);\n    } else if (STREQ(def->caps->data.storage.drive_type, \"disk\")) {\n        ret = udevProcessDisk(device, def);\n    } else if (STREQ(def->caps->data.storage.drive_type, \"floppy\")) {\n        ret = udevProcessFloppy(device, def);\n    } else if (STREQ(def->caps->data.storage.drive_type, \"sd\")) {\n        ret = udevProcessSD(device, def);\n    } else {\n        VIR_DEBUG(\"Unsupported storage type '%s'\",\n                  def->caps->data.storage.drive_type);\n        goto cleanup;\n    }\n\n    if (udevGenerateDeviceName(device, def, storage->serial) != 0)\n        goto cleanup;\n\n cleanup:\n    VIR_DEBUG(\"Storage ret=%d\", ret);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevProcessSCSIDevice",
          "args": [
            "device",
            "def"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessSCSIDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "707-749",
          "snippet": "static int\nudevProcessSCSIDevice(struct udev_device *device G_GNUC_UNUSED,\n                      virNodeDeviceDefPtr def)\n{\n    int ret = -1;\n    unsigned int tmp = 0;\n    virNodeDevCapSCSIPtr scsi = &def->caps->data.scsi;\n    g_autofree char *filename = NULL;\n    char *p = NULL;\n\n    filename = g_path_get_basename(def->sysfs_path);\n\n    if (virStrToLong_ui(filename, &p, 10, &scsi->host) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 10, &scsi->bus) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 10, &scsi->target) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 10, &scsi->lun) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse the SCSI address from filename: '%s'\"),\n                       filename);\n        return -1;\n    }\n\n    if (udev_device_get_sysattr_value(device, \"type\")) {\n        if (udevGetUintSysfsAttr(device, \"type\", &tmp, 0) < 0)\n            goto cleanup;\n\n        if (udevGetSCSIType(def, tmp, &scsi->type) < 0)\n            goto cleanup;\n    }\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (ret != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to process SCSI device with sysfs path '%s'\"),\n                       def->sysfs_path);\n    }\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessSCSIDevice(struct udev_device *device G_GNUC_UNUSED,\n                      virNodeDeviceDefPtr def)\n{\n    int ret = -1;\n    unsigned int tmp = 0;\n    virNodeDevCapSCSIPtr scsi = &def->caps->data.scsi;\n    g_autofree char *filename = NULL;\n    char *p = NULL;\n\n    filename = g_path_get_basename(def->sysfs_path);\n\n    if (virStrToLong_ui(filename, &p, 10, &scsi->host) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 10, &scsi->bus) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 10, &scsi->target) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 10, &scsi->lun) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse the SCSI address from filename: '%s'\"),\n                       filename);\n        return -1;\n    }\n\n    if (udev_device_get_sysattr_value(device, \"type\")) {\n        if (udevGetUintSysfsAttr(device, \"type\", &tmp, 0) < 0)\n            goto cleanup;\n\n        if (udevGetSCSIType(def, tmp, &scsi->type) < 0)\n            goto cleanup;\n    }\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (ret != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to process SCSI device with sysfs path '%s'\"),\n                       def->sysfs_path);\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevProcessSCSITarget",
          "args": [
            "device",
            "def"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessSCSITarget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "627-644",
          "snippet": "static int\nudevProcessSCSITarget(struct udev_device *device,\n                      virNodeDeviceDefPtr def)\n{\n    const char *sysname = NULL;\n    virNodeDevCapSCSITargetPtr scsi_target = &def->caps->data.scsi_target;\n\n    sysname = udev_device_get_sysname(device);\n\n    scsi_target->name = g_strdup(sysname);\n\n    virNodeDeviceGetSCSITargetCaps(def->sysfs_path, &def->caps->data.scsi_target);\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessSCSITarget(struct udev_device *device,\n                      virNodeDeviceDefPtr def)\n{\n    const char *sysname = NULL;\n    virNodeDevCapSCSITargetPtr scsi_target = &def->caps->data.scsi_target;\n\n    sysname = udev_device_get_sysname(device);\n\n    scsi_target->name = g_strdup(sysname);\n\n    virNodeDeviceGetSCSITargetCaps(def->sysfs_path, &def->caps->data.scsi_target);\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevProcessSCSIHost",
          "args": [
            "device",
            "def"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessSCSIHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "600-624",
          "snippet": "static int\nudevProcessSCSIHost(struct udev_device *device G_GNUC_UNUSED,\n                    virNodeDeviceDefPtr def)\n{\n    virNodeDevCapSCSIHostPtr scsi_host = &def->caps->data.scsi_host;\n    g_autofree char *filename = NULL;\n    char *str;\n\n    filename = g_path_get_basename(def->sysfs_path);\n\n    if (!(str = STRSKIP(filename, \"host\")) ||\n        virStrToLong_ui(str, NULL, 0, &scsi_host->host) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse SCSI host '%s'\"),\n                       filename);\n        return -1;\n    }\n\n    virNodeDeviceGetSCSIHostCaps(&def->caps->data.scsi_host);\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessSCSIHost(struct udev_device *device G_GNUC_UNUSED,\n                    virNodeDeviceDefPtr def)\n{\n    virNodeDevCapSCSIHostPtr scsi_host = &def->caps->data.scsi_host;\n    g_autofree char *filename = NULL;\n    char *str;\n\n    filename = g_path_get_basename(def->sysfs_path);\n\n    if (!(str = STRSKIP(filename, \"host\")) ||\n        virStrToLong_ui(str, NULL, 0, &scsi_host->host) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse SCSI host '%s'\"),\n                       filename);\n        return -1;\n    }\n\n    virNodeDeviceGetSCSIHostCaps(&def->caps->data.scsi_host);\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevProcessNetworkInterface",
          "args": [
            "device",
            "def"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessNetworkInterface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "562-597",
          "snippet": "static int\nudevProcessNetworkInterface(struct udev_device *device,\n                            virNodeDeviceDefPtr def)\n{\n    const char *devtype = udev_device_get_devtype(device);\n    virNodeDevCapNetPtr net = &def->caps->data.net;\n\n    if (devtype && STREQ(devtype, \"wlan\")) {\n        net->subtype = VIR_NODE_DEV_CAP_NET_80211;\n    } else {\n        net->subtype = VIR_NODE_DEV_CAP_NET_80203;\n    }\n\n    if (udevGetStringProperty(device,\n                              \"INTERFACE\",\n                              &net->ifname) < 0)\n        return -1;\n\n    if (udevGetStringSysfsAttr(device, \"address\",\n                               &net->address) < 0)\n        return -1;\n\n    if (udevGetUintSysfsAttr(device, \"addr_len\", &net->address_len, 0) < 0)\n        return -1;\n\n    if (udevGenerateDeviceName(device, def, net->address) != 0)\n        return -1;\n\n    if (virNetDevGetLinkInfo(net->ifname, &net->lnk) < 0)\n        return -1;\n\n    if (virNetDevGetFeatures(net->ifname, &net->features) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessNetworkInterface(struct udev_device *device,\n                            virNodeDeviceDefPtr def)\n{\n    const char *devtype = udev_device_get_devtype(device);\n    virNodeDevCapNetPtr net = &def->caps->data.net;\n\n    if (devtype && STREQ(devtype, \"wlan\")) {\n        net->subtype = VIR_NODE_DEV_CAP_NET_80211;\n    } else {\n        net->subtype = VIR_NODE_DEV_CAP_NET_80203;\n    }\n\n    if (udevGetStringProperty(device,\n                              \"INTERFACE\",\n                              &net->ifname) < 0)\n        return -1;\n\n    if (udevGetStringSysfsAttr(device, \"address\",\n                               &net->address) < 0)\n        return -1;\n\n    if (udevGetUintSysfsAttr(device, \"addr_len\", &net->address_len, 0) < 0)\n        return -1;\n\n    if (udevGenerateDeviceName(device, def, net->address) != 0)\n        return -1;\n\n    if (virNetDevGetLinkInfo(net->ifname, &net->lnk) < 0)\n        return -1;\n\n    if (virNetDevGetFeatures(net->ifname, &net->features) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevProcessUSBInterface",
          "args": [
            "device",
            "def"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessUSBInterface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "533-559",
          "snippet": "static int\nudevProcessUSBInterface(struct udev_device *device,\n                        virNodeDeviceDefPtr def)\n{\n    virNodeDevCapUSBIfPtr usb_if = &def->caps->data.usb_if;\n\n    if (udevGetUintSysfsAttr(device, \"bInterfaceNumber\",\n                             &usb_if->number, 16) < 0)\n        return -1;\n\n    if (udevGetUintSysfsAttr(device, \"bInterfaceClass\",\n                             &usb_if->klass, 16) < 0)\n        return -1;\n\n    if (udevGetUintSysfsAttr(device, \"bInterfaceSubClass\",\n                             &usb_if->subclass, 16) < 0)\n        return -1;\n\n    if (udevGetUintSysfsAttr(device, \"bInterfaceProtocol\",\n                             &usb_if->protocol, 16) < 0)\n        return -1;\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessUSBInterface(struct udev_device *device,\n                        virNodeDeviceDefPtr def)\n{\n    virNodeDevCapUSBIfPtr usb_if = &def->caps->data.usb_if;\n\n    if (udevGetUintSysfsAttr(device, \"bInterfaceNumber\",\n                             &usb_if->number, 16) < 0)\n        return -1;\n\n    if (udevGetUintSysfsAttr(device, \"bInterfaceClass\",\n                             &usb_if->klass, 16) < 0)\n        return -1;\n\n    if (udevGetUintSysfsAttr(device, \"bInterfaceSubClass\",\n                             &usb_if->subclass, 16) < 0)\n        return -1;\n\n    if (udevGetUintSysfsAttr(device, \"bInterfaceProtocol\",\n                             &usb_if->protocol, 16) < 0)\n        return -1;\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevProcessUSBDevice",
          "args": [
            "device",
            "def"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessUSBDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "490-530",
          "snippet": "static int\nudevProcessUSBDevice(struct udev_device *device,\n                     virNodeDeviceDefPtr def)\n{\n    virNodeDevCapUSBDevPtr usb_dev = &def->caps->data.usb_dev;\n\n    if (udevGetUintProperty(device, \"BUSNUM\", &usb_dev->bus, 10) < 0)\n        return -1;\n    if (udevGetUintProperty(device, \"DEVNUM\", &usb_dev->device, 10) < 0)\n        return -1;\n    if (udevGetUintProperty(device, \"ID_VENDOR_ID\", &usb_dev->vendor, 16) < 0)\n        return -1;\n\n    if (udevGetStringProperty(device,\n                              \"ID_VENDOR_FROM_DATABASE\",\n                              &usb_dev->vendor_name) < 0)\n        return -1;\n\n    if (!usb_dev->vendor_name &&\n        udevGetStringSysfsAttr(device, \"manufacturer\",\n                               &usb_dev->vendor_name) < 0)\n        return -1;\n\n    if (udevGetUintProperty(device, \"ID_MODEL_ID\", &usb_dev->product, 16) < 0)\n        return -1;\n\n    if (udevGetStringProperty(device,\n                              \"ID_MODEL_FROM_DATABASE\",\n                              &usb_dev->product_name) < 0)\n        return -1;\n\n    if (!usb_dev->product_name &&\n        udevGetStringSysfsAttr(device, \"product\",\n                               &usb_dev->product_name) < 0)\n        return -1;\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessUSBDevice(struct udev_device *device,\n                     virNodeDeviceDefPtr def)\n{\n    virNodeDevCapUSBDevPtr usb_dev = &def->caps->data.usb_dev;\n\n    if (udevGetUintProperty(device, \"BUSNUM\", &usb_dev->bus, 10) < 0)\n        return -1;\n    if (udevGetUintProperty(device, \"DEVNUM\", &usb_dev->device, 10) < 0)\n        return -1;\n    if (udevGetUintProperty(device, \"ID_VENDOR_ID\", &usb_dev->vendor, 16) < 0)\n        return -1;\n\n    if (udevGetStringProperty(device,\n                              \"ID_VENDOR_FROM_DATABASE\",\n                              &usb_dev->vendor_name) < 0)\n        return -1;\n\n    if (!usb_dev->vendor_name &&\n        udevGetStringSysfsAttr(device, \"manufacturer\",\n                               &usb_dev->vendor_name) < 0)\n        return -1;\n\n    if (udevGetUintProperty(device, \"ID_MODEL_ID\", &usb_dev->product, 16) < 0)\n        return -1;\n\n    if (udevGetStringProperty(device,\n                              \"ID_MODEL_FROM_DATABASE\",\n                              &usb_dev->product_name) < 0)\n        return -1;\n\n    if (!usb_dev->product_name &&\n        udevGetStringSysfsAttr(device, \"product\",\n                               &usb_dev->product_name) < 0)\n        return -1;\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevProcessPCI",
          "args": [
            "device",
            "def"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessPCI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "348-446",
          "snippet": "static int\nudevProcessPCI(struct udev_device *device,\n               virNodeDeviceDefPtr def)\n{\n    virNodeDevCapPCIDevPtr pci_dev = &def->caps->data.pci_dev;\n    virPCIEDeviceInfoPtr pci_express = NULL;\n    virPCIDevicePtr pciDev = NULL;\n    int ret = -1;\n    char *p;\n    bool privileged;\n\n    nodeDeviceLock();\n    privileged = driver->privileged;\n    nodeDeviceUnlock();\n\n    pci_dev->klass = -1;\n    if (udevGetIntProperty(device, \"PCI_CLASS\", &pci_dev->klass, 16) < 0)\n        goto cleanup;\n\n    if ((p = strrchr(def->sysfs_path, '/')) == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &pci_dev->domain) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &pci_dev->bus) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &pci_dev->slot) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &pci_dev->function) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse the PCI address from sysfs path: '%s'\"),\n                       def->sysfs_path);\n        goto cleanup;\n    }\n\n    if (udevGetUintSysfsAttr(device, \"vendor\", &pci_dev->vendor, 16) < 0)\n        goto cleanup;\n\n    if (udevGetUintSysfsAttr(device, \"device\", &pci_dev->product, 16) < 0)\n        goto cleanup;\n\n    if (udevTranslatePCIIds(pci_dev->vendor,\n                            pci_dev->product,\n                            &pci_dev->vendor_name,\n                            &pci_dev->product_name) != 0) {\n        goto cleanup;\n    }\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        goto cleanup;\n\n    /* The default value is -1, because it can't be 0\n     * as zero is valid node number. */\n    pci_dev->numa_node = -1;\n    if (udevGetIntSysfsAttr(device, \"numa_node\",\n                            &pci_dev->numa_node, 10) < 0)\n        goto cleanup;\n\n    if (virNodeDeviceGetPCIDynamicCaps(def->sysfs_path, pci_dev) < 0)\n        goto cleanup;\n\n    if (!(pciDev = virPCIDeviceNew(pci_dev->domain,\n                                   pci_dev->bus,\n                                   pci_dev->slot,\n                                   pci_dev->function)))\n        goto cleanup;\n\n    /* We need to be root to read PCI device configs */\n    if (privileged) {\n        if (virPCIGetHeaderType(pciDev, &pci_dev->hdrType) < 0)\n            goto cleanup;\n\n        if (virPCIDeviceIsPCIExpress(pciDev) > 0) {\n            if (VIR_ALLOC(pci_express) < 0)\n                goto cleanup;\n\n            if (virPCIDeviceHasPCIExpressLink(pciDev) > 0) {\n                if (VIR_ALLOC(pci_express->link_cap) < 0 ||\n                    VIR_ALLOC(pci_express->link_sta) < 0)\n                    goto cleanup;\n\n                if (virPCIDeviceGetLinkCapSta(pciDev,\n                                              &pci_express->link_cap->port,\n                                              &pci_express->link_cap->speed,\n                                              &pci_express->link_cap->width,\n                                              &pci_express->link_sta->speed,\n                                              &pci_express->link_sta->width) < 0)\n                    goto cleanup;\n\n                pci_express->link_sta->port = -1; /* PCIe can't negotiate port. Yet :) */\n            }\n            pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCIE;\n            pci_dev->pci_express = pci_express;\n            pci_express = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virPCIDeviceFree(pciDev);\n    virPCIEDeviceInfoFree(pci_express);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessPCI(struct udev_device *device,\n               virNodeDeviceDefPtr def)\n{\n    virNodeDevCapPCIDevPtr pci_dev = &def->caps->data.pci_dev;\n    virPCIEDeviceInfoPtr pci_express = NULL;\n    virPCIDevicePtr pciDev = NULL;\n    int ret = -1;\n    char *p;\n    bool privileged;\n\n    nodeDeviceLock();\n    privileged = driver->privileged;\n    nodeDeviceUnlock();\n\n    pci_dev->klass = -1;\n    if (udevGetIntProperty(device, \"PCI_CLASS\", &pci_dev->klass, 16) < 0)\n        goto cleanup;\n\n    if ((p = strrchr(def->sysfs_path, '/')) == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &pci_dev->domain) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &pci_dev->bus) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &pci_dev->slot) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &pci_dev->function) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse the PCI address from sysfs path: '%s'\"),\n                       def->sysfs_path);\n        goto cleanup;\n    }\n\n    if (udevGetUintSysfsAttr(device, \"vendor\", &pci_dev->vendor, 16) < 0)\n        goto cleanup;\n\n    if (udevGetUintSysfsAttr(device, \"device\", &pci_dev->product, 16) < 0)\n        goto cleanup;\n\n    if (udevTranslatePCIIds(pci_dev->vendor,\n                            pci_dev->product,\n                            &pci_dev->vendor_name,\n                            &pci_dev->product_name) != 0) {\n        goto cleanup;\n    }\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        goto cleanup;\n\n    /* The default value is -1, because it can't be 0\n     * as zero is valid node number. */\n    pci_dev->numa_node = -1;\n    if (udevGetIntSysfsAttr(device, \"numa_node\",\n                            &pci_dev->numa_node, 10) < 0)\n        goto cleanup;\n\n    if (virNodeDeviceGetPCIDynamicCaps(def->sysfs_path, pci_dev) < 0)\n        goto cleanup;\n\n    if (!(pciDev = virPCIDeviceNew(pci_dev->domain,\n                                   pci_dev->bus,\n                                   pci_dev->slot,\n                                   pci_dev->function)))\n        goto cleanup;\n\n    /* We need to be root to read PCI device configs */\n    if (privileged) {\n        if (virPCIGetHeaderType(pciDev, &pci_dev->hdrType) < 0)\n            goto cleanup;\n\n        if (virPCIDeviceIsPCIExpress(pciDev) > 0) {\n            if (VIR_ALLOC(pci_express) < 0)\n                goto cleanup;\n\n            if (virPCIDeviceHasPCIExpressLink(pciDev) > 0) {\n                if (VIR_ALLOC(pci_express->link_cap) < 0 ||\n                    VIR_ALLOC(pci_express->link_sta) < 0)\n                    goto cleanup;\n\n                if (virPCIDeviceGetLinkCapSta(pciDev,\n                                              &pci_express->link_cap->port,\n                                              &pci_express->link_cap->speed,\n                                              &pci_express->link_cap->width,\n                                              &pci_express->link_sta->speed,\n                                              &pci_express->link_sta->width) < 0)\n                    goto cleanup;\n\n                pci_express->link_sta->port = -1; /* PCIe can't negotiate port. Yet :) */\n            }\n            pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCIE;\n            pci_dev->pci_express = pci_express;\n            pci_express = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virPCIDeviceFree(pciDev);\n    virPCIEDeviceInfoFree(pci_express);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetDeviceDetails(struct udev_device *device,\n                     virNodeDeviceDefPtr def)\n{\n    switch (def->caps->data.type) {\n    case VIR_NODE_DEV_CAP_PCI_DEV:\n        return udevProcessPCI(device, def);\n    case VIR_NODE_DEV_CAP_USB_DEV:\n        return udevProcessUSBDevice(device, def);\n    case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        return udevProcessUSBInterface(device, def);\n    case VIR_NODE_DEV_CAP_NET:\n        return udevProcessNetworkInterface(device, def);\n    case VIR_NODE_DEV_CAP_SCSI_HOST:\n        return udevProcessSCSIHost(device, def);\n    case VIR_NODE_DEV_CAP_SCSI_TARGET:\n        return udevProcessSCSITarget(device, def);\n    case VIR_NODE_DEV_CAP_SCSI:\n        return udevProcessSCSIDevice(device, def);\n    case VIR_NODE_DEV_CAP_STORAGE:\n        return udevProcessStorage(device, def);\n    case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n        return udevProcessSCSIGeneric(device, def);\n    case VIR_NODE_DEV_CAP_DRM:\n        return udevProcessDRMDevice(device, def);\n    case VIR_NODE_DEV_CAP_MDEV:\n        return udevProcessMediatedDevice(device, def);\n    case VIR_NODE_DEV_CAP_CCW_DEV:\n        return udevProcessCCW(device, def);\n    case VIR_NODE_DEV_CAP_MDEV_TYPES:\n    case VIR_NODE_DEV_CAP_SYSTEM:\n    case VIR_NODE_DEV_CAP_FC_HOST:\n    case VIR_NODE_DEV_CAP_VPORTS:\n    case VIR_NODE_DEV_CAP_LAST:\n        break;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "udevGetDeviceType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1117-1180",
    "snippet": "static int\nudevGetDeviceType(struct udev_device *device,\n                  virNodeDevCapType *type)\n{\n    const char *devtype = NULL;\n    char *subsystem = NULL;\n    int ret = -1;\n\n    devtype = udev_device_get_devtype(device);\n    *type = 0;\n\n    if (devtype) {\n        if (STREQ(devtype, \"usb_device\"))\n            *type = VIR_NODE_DEV_CAP_USB_DEV;\n        else if (STREQ(devtype, \"usb_interface\"))\n            *type = VIR_NODE_DEV_CAP_USB_INTERFACE;\n        else if (STREQ(devtype, \"scsi_host\"))\n            *type = VIR_NODE_DEV_CAP_SCSI_HOST;\n        else if (STREQ(devtype, \"scsi_target\"))\n            *type = VIR_NODE_DEV_CAP_SCSI_TARGET;\n        else if (STREQ(devtype, \"scsi_device\"))\n            *type = VIR_NODE_DEV_CAP_SCSI;\n        else if (STREQ(devtype, \"disk\"))\n            *type = VIR_NODE_DEV_CAP_STORAGE;\n        else if (STREQ(devtype, \"wlan\"))\n            *type = VIR_NODE_DEV_CAP_NET;\n        else if (STREQ(devtype, \"drm_minor\"))\n            *type = VIR_NODE_DEV_CAP_DRM;\n    } else {\n        /* PCI devices don't set the DEVTYPE property. */\n        if (udevHasDeviceProperty(device, \"PCI_CLASS\"))\n            *type = VIR_NODE_DEV_CAP_PCI_DEV;\n\n        /* Wired network interfaces don't set the DEVTYPE property,\n         * USB devices also have an INTERFACE property, but they do\n         * set DEVTYPE, so if devtype is NULL and the INTERFACE\n         * property exists, we have a network device. */\n        if (udevHasDeviceProperty(device, \"INTERFACE\"))\n            *type = VIR_NODE_DEV_CAP_NET;\n\n        /* The following devices do not set the DEVTYPE property, therefore\n         * we need to rely on the SUBSYSTEM property */\n        if (udevGetStringProperty(device, \"SUBSYSTEM\", &subsystem) < 0)\n            return -1;\n\n        if (STREQ_NULLABLE(subsystem, \"scsi_generic\"))\n            *type = VIR_NODE_DEV_CAP_SCSI_GENERIC;\n        else if (STREQ_NULLABLE(subsystem, \"mdev\"))\n            *type = VIR_NODE_DEV_CAP_MDEV;\n        else if (STREQ_NULLABLE(subsystem, \"ccw\"))\n            *type = VIR_NODE_DEV_CAP_CCW_DEV;\n\n        VIR_FREE(subsystem);\n    }\n\n    if (!*type)\n        VIR_DEBUG(\"Could not determine device type for device \"\n                  \"with sysfs name '%s'\",\n                  udev_device_get_sysname(device));\n    else\n        ret = 0;\n\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Could not determine device type for device \"\n                  \"with sysfs name '%s'\"",
            "udev_device_get_sysname(device)"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysname",
          "args": [
            "device"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "subsystem"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "subsystem",
            "\"ccw\""
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "subsystem",
            "\"mdev\""
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "subsystem",
            "\"scsi_generic\""
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetStringProperty",
          "args": [
            "device",
            "\"SUBSYSTEM\"",
            "&subsystem"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetStringProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "151-159",
          "snippet": "static int\nudevGetStringProperty(struct udev_device *udev_device,\n                      const char *property_key,\n                      char **value)\n{\n    *value = g_strdup(udevGetDeviceProperty(udev_device, property_key));\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetStringProperty(struct udev_device *udev_device,\n                      const char *property_key,\n                      char **value)\n{\n    *value = g_strdup(udevGetDeviceProperty(udev_device, property_key));\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevHasDeviceProperty",
          "args": [
            "device",
            "\"INTERFACE\""
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "udevHasDeviceProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "125-133",
          "snippet": "static bool\nudevHasDeviceProperty(struct udev_device *dev,\n                      const char *key)\n{\n    if (udev_device_get_property_value(dev, key))\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic bool\nudevHasDeviceProperty(struct udev_device *dev,\n                      const char *key)\n{\n    if (udev_device_get_property_value(dev, key))\n        return true;\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "devtype",
            "\"drm_minor\""
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "devtype",
            "\"wlan\""
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "devtype",
            "\"disk\""
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "devtype",
            "\"scsi_device\""
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "devtype",
            "\"scsi_target\""
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "devtype",
            "\"scsi_host\""
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "devtype",
            "\"usb_interface\""
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "devtype",
            "\"usb_device\""
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_devtype",
          "args": [
            "device"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetDeviceType(struct udev_device *device,\n                  virNodeDevCapType *type)\n{\n    const char *devtype = NULL;\n    char *subsystem = NULL;\n    int ret = -1;\n\n    devtype = udev_device_get_devtype(device);\n    *type = 0;\n\n    if (devtype) {\n        if (STREQ(devtype, \"usb_device\"))\n            *type = VIR_NODE_DEV_CAP_USB_DEV;\n        else if (STREQ(devtype, \"usb_interface\"))\n            *type = VIR_NODE_DEV_CAP_USB_INTERFACE;\n        else if (STREQ(devtype, \"scsi_host\"))\n            *type = VIR_NODE_DEV_CAP_SCSI_HOST;\n        else if (STREQ(devtype, \"scsi_target\"))\n            *type = VIR_NODE_DEV_CAP_SCSI_TARGET;\n        else if (STREQ(devtype, \"scsi_device\"))\n            *type = VIR_NODE_DEV_CAP_SCSI;\n        else if (STREQ(devtype, \"disk\"))\n            *type = VIR_NODE_DEV_CAP_STORAGE;\n        else if (STREQ(devtype, \"wlan\"))\n            *type = VIR_NODE_DEV_CAP_NET;\n        else if (STREQ(devtype, \"drm_minor\"))\n            *type = VIR_NODE_DEV_CAP_DRM;\n    } else {\n        /* PCI devices don't set the DEVTYPE property. */\n        if (udevHasDeviceProperty(device, \"PCI_CLASS\"))\n            *type = VIR_NODE_DEV_CAP_PCI_DEV;\n\n        /* Wired network interfaces don't set the DEVTYPE property,\n         * USB devices also have an INTERFACE property, but they do\n         * set DEVTYPE, so if devtype is NULL and the INTERFACE\n         * property exists, we have a network device. */\n        if (udevHasDeviceProperty(device, \"INTERFACE\"))\n            *type = VIR_NODE_DEV_CAP_NET;\n\n        /* The following devices do not set the DEVTYPE property, therefore\n         * we need to rely on the SUBSYSTEM property */\n        if (udevGetStringProperty(device, \"SUBSYSTEM\", &subsystem) < 0)\n            return -1;\n\n        if (STREQ_NULLABLE(subsystem, \"scsi_generic\"))\n            *type = VIR_NODE_DEV_CAP_SCSI_GENERIC;\n        else if (STREQ_NULLABLE(subsystem, \"mdev\"))\n            *type = VIR_NODE_DEV_CAP_MDEV;\n        else if (STREQ_NULLABLE(subsystem, \"ccw\"))\n            *type = VIR_NODE_DEV_CAP_CCW_DEV;\n\n        VIR_FREE(subsystem);\n    }\n\n    if (!*type)\n        VIR_DEBUG(\"Could not determine device type for device \"\n                  \"with sysfs name '%s'\",\n                  udev_device_get_sysname(device));\n    else\n        ret = 0;\n\n    return ret;\n}"
  },
  {
    "function_name": "udevGetDeviceNodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1090-1114",
    "snippet": "static int\nudevGetDeviceNodes(struct udev_device *device,\n                   virNodeDeviceDefPtr def)\n{\n    const char *devnode = NULL;\n    struct udev_list_entry *list_entry = NULL;\n    int n = 0;\n\n    devnode = udev_device_get_devnode(device);\n\n    def->devnode = g_strdup(devnode);\n\n    udev_list_entry_foreach(list_entry, udev_device_get_devlinks_list_entry(device))\n        n++;\n\n    if (VIR_ALLOC_N(def->devlinks, n + 1) < 0)\n        return -1;\n\n    n = 0;\n    udev_list_entry_foreach(list_entry, udev_device_get_devlinks_list_entry(device)) {\n        def->devlinks[n++] = g_strdup(udev_list_entry_get_name(list_entry));\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "udev_list_entry_get_name(list_entry)"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_list_entry_get_name",
          "args": [
            "list_entry"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_list_entry_foreach",
          "args": [
            "list_entry",
            "udev_device_get_devlinks_list_entry(device)"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_devlinks_list_entry",
          "args": [
            "device"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->devlinks",
            "n + 1"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_list_entry_foreach",
          "args": [
            "list_entry",
            "udev_device_get_devlinks_list_entry(device)"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_devlinks_list_entry",
          "args": [
            "device"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_devnode",
          "args": [
            "device"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetDeviceNodes(struct udev_device *device,\n                   virNodeDeviceDefPtr def)\n{\n    const char *devnode = NULL;\n    struct udev_list_entry *list_entry = NULL;\n    int n = 0;\n\n    devnode = udev_device_get_devnode(device);\n\n    def->devnode = g_strdup(devnode);\n\n    udev_list_entry_foreach(list_entry, udev_device_get_devlinks_list_entry(device))\n        n++;\n\n    if (VIR_ALLOC_N(def->devlinks, n + 1) < 0)\n        return -1;\n\n    n = 0;\n    udev_list_entry_foreach(list_entry, udev_device_get_devlinks_list_entry(device)) {\n        def->devlinks[n++] = g_strdup(udev_list_entry_get_name(list_entry));\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "udevProcessCCW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1061-1087",
    "snippet": "static int\nudevProcessCCW(struct udev_device *device,\n               virNodeDeviceDefPtr def)\n{\n    int online;\n    char *p;\n    virNodeDevCapDataPtr data = &def->caps->data;\n\n    /* process only online devices to keep the list sane */\n    if (udevGetIntSysfsAttr(device, \"online\", &online, 0) < 0 || online != 1)\n        return -1;\n\n    if ((p = strrchr(def->sysfs_path, '/')) == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &data->ccw_dev.cssid) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &data->ccw_dev.ssid) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &data->ccw_dev.devno) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse the CCW address from sysfs path: '%s'\"),\n                       def->sysfs_path);\n        return -1;\n    }\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevGenerateDeviceName",
          "args": [
            "device",
            "def",
            "NULL"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "udevGenerateDeviceName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "291-314",
          "snippet": "static int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to parse the CCW address from sysfs path: '%s'\")",
            "def->sysfs_path"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to parse the CCW address from sysfs path: '%s'\""
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "p + 1",
            "&p",
            "16",
            "&data->ccw_dev.devno"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "def->sysfs_path",
            "'/'"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetIntSysfsAttr",
          "args": [
            "device",
            "\"online\"",
            "&online",
            "0"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetIntSysfsAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "232-249",
          "snippet": "static int\nudevGetIntSysfsAttr(struct udev_device *udev_device,\n                    const char *attr_name,\n                    int *value,\n                    int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetIntSysfsAttr(struct udev_device *udev_device,\n                    const char *attr_name,\n                    int *value,\n                    int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessCCW(struct udev_device *device,\n               virNodeDeviceDefPtr def)\n{\n    int online;\n    char *p;\n    virNodeDevCapDataPtr data = &def->caps->data;\n\n    /* process only online devices to keep the list sane */\n    if (udevGetIntSysfsAttr(device, \"online\", &online, 0) < 0 || online != 1)\n        return -1;\n\n    if ((p = strrchr(def->sysfs_path, '/')) == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &data->ccw_dev.cssid) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &data->ccw_dev.ssid) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &data->ccw_dev.devno) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse the CCW address from sysfs path: '%s'\"),\n                       def->sysfs_path);\n        return -1;\n    }\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "udevProcessMediatedDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "1011-1058",
    "snippet": "static int\nudevProcessMediatedDevice(struct udev_device *dev,\n                          virNodeDeviceDefPtr def)\n{\n    int ret = -1;\n    const char *uuidstr = NULL;\n    int iommugrp = -1;\n    char *linkpath = NULL;\n    char *canonicalpath = NULL;\n    virNodeDevCapMdevPtr data = &def->caps->data.mdev;\n\n    /* Because of a kernel uevent race, we might get the 'add' event prior to\n     * the sysfs tree being ready, so any attempt to access any sysfs attribute\n     * would result in ENOENT and us dropping the device, so let's work around\n     * it by waiting for the attributes to become available.\n     */\n\n    linkpath = g_strdup_printf(\"%s/mdev_type\", udev_device_get_syspath(dev));\n\n    if (virFileWaitForExists(linkpath, 1, 100) < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to wait for file '%s' to appear\"),\n                             linkpath);\n        goto cleanup;\n    }\n\n    if (virFileResolveLink(linkpath, &canonicalpath) < 0) {\n        virReportSystemError(errno, _(\"failed to resolve '%s'\"), linkpath);\n        goto cleanup;\n    }\n\n    data->type = g_path_get_basename(canonicalpath);\n\n    uuidstr = udev_device_get_sysname(dev);\n    if ((iommugrp = virMediatedDeviceGetIOMMUGroupNum(uuidstr)) < 0)\n        goto cleanup;\n\n    if (udevGenerateDeviceName(dev, def, NULL) != 0)\n        goto cleanup;\n\n    data->iommuGroupNumber = iommugrp;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(linkpath);\n    VIR_FREE(canonicalpath);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "canonicalpath"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "linkpath"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGenerateDeviceName",
          "args": [
            "dev",
            "def",
            "NULL"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "udevGenerateDeviceName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "291-314",
          "snippet": "static int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceGetIOMMUGroupNum",
          "args": [
            "uuidstr"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceGetIOMMUGroupNum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "237-251",
          "snippet": "int\nvirMediatedDeviceGetIOMMUGroupNum(const char *uuidstr)\n{\n    g_autofree char *vfio_path = NULL;\n    g_autofree char *group_num_str = NULL;\n    unsigned int group_num = -1;\n\n    if (!(vfio_path = virMediatedDeviceGetIOMMUGroupDev(uuidstr)))\n        return -1;\n\n    group_num_str = g_path_get_basename(vfio_path);\n    ignore_value(virStrToLong_ui(group_num_str, NULL, 10, &group_num));\n\n    return group_num;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nint\nvirMediatedDeviceGetIOMMUGroupNum(const char *uuidstr)\n{\n    g_autofree char *vfio_path = NULL;\n    g_autofree char *group_num_str = NULL;\n    unsigned int group_num = -1;\n\n    if (!(vfio_path = virMediatedDeviceGetIOMMUGroupDev(uuidstr)))\n        return -1;\n\n    group_num_str = g_path_get_basename(vfio_path);\n    ignore_value(virStrToLong_ui(group_num_str, NULL, 10, &group_num));\n\n    return group_num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysname",
          "args": [
            "dev"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_path_get_basename",
          "args": [
            "canonicalpath"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"failed to resolve '%s'\")",
            "linkpath"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to resolve '%s'\""
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileResolveLink",
          "args": [
            "linkpath",
            "&canonicalpath"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "virFileResolveLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1608-1612",
          "snippet": "int\nvirFileResolveLink(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, false, resultpath);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileResolveLink(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, false, resultpath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"failed to wait for file '%s' to appear\")",
            "linkpath"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileWaitForExists",
          "args": [
            "linkpath",
            "1",
            "100"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "virFileWaitForExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4314-4330",
          "snippet": "int\nvirFileWaitForExists(const char *path,\n                     size_t ms,\n                     size_t tries)\n{\n    errno = 0;\n\n    /* wait for @path to be accessible in @ms milliseconds, up to @tries */\n    while (tries-- > 0 && !virFileExists(path)) {\n        if (tries == 0 || errno != ENOENT)\n            return -1;\n\n        g_usleep(ms * 1000);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileWaitForExists(const char *path,\n                     size_t ms,\n                     size_t tries)\n{\n    errno = 0;\n\n    /* wait for @path to be accessible in @ms milliseconds, up to @tries */\n    while (tries-- > 0 && !virFileExists(path)) {\n        if (tries == 0 || errno != ENOENT)\n            return -1;\n\n        g_usleep(ms * 1000);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/mdev_type\"",
            "udev_device_get_syspath(dev)"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_get_syspath",
          "args": [
            "dev"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessMediatedDevice(struct udev_device *dev,\n                          virNodeDeviceDefPtr def)\n{\n    int ret = -1;\n    const char *uuidstr = NULL;\n    int iommugrp = -1;\n    char *linkpath = NULL;\n    char *canonicalpath = NULL;\n    virNodeDevCapMdevPtr data = &def->caps->data.mdev;\n\n    /* Because of a kernel uevent race, we might get the 'add' event prior to\n     * the sysfs tree being ready, so any attempt to access any sysfs attribute\n     * would result in ENOENT and us dropping the device, so let's work around\n     * it by waiting for the attributes to become available.\n     */\n\n    linkpath = g_strdup_printf(\"%s/mdev_type\", udev_device_get_syspath(dev));\n\n    if (virFileWaitForExists(linkpath, 1, 100) < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to wait for file '%s' to appear\"),\n                             linkpath);\n        goto cleanup;\n    }\n\n    if (virFileResolveLink(linkpath, &canonicalpath) < 0) {\n        virReportSystemError(errno, _(\"failed to resolve '%s'\"), linkpath);\n        goto cleanup;\n    }\n\n    data->type = g_path_get_basename(canonicalpath);\n\n    uuidstr = udev_device_get_sysname(dev);\n    if ((iommugrp = virMediatedDeviceGetIOMMUGroupNum(uuidstr)) < 0)\n        goto cleanup;\n\n    if (udevGenerateDeviceName(dev, def, NULL) != 0)\n        goto cleanup;\n\n    data->iommuGroupNumber = iommugrp;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(linkpath);\n    VIR_FREE(canonicalpath);\n    return ret;\n}"
  },
  {
    "function_name": "udevProcessSCSIGeneric",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "996-1008",
    "snippet": "static int\nudevProcessSCSIGeneric(struct udev_device *dev,\n                       virNodeDeviceDefPtr def)\n{\n    if (udevGetStringProperty(dev, \"DEVNAME\", &def->caps->data.sg.path) < 0 ||\n        !def->caps->data.sg.path)\n        return -1;\n\n    if (udevGenerateDeviceName(dev, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevGenerateDeviceName",
          "args": [
            "dev",
            "def",
            "NULL"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "udevGenerateDeviceName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "291-314",
          "snippet": "static int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetStringProperty",
          "args": [
            "dev",
            "\"DEVNAME\"",
            "&def->caps->data.sg.path"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetStringProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "151-159",
          "snippet": "static int\nudevGetStringProperty(struct udev_device *udev_device,\n                      const char *property_key,\n                      char **value)\n{\n    *value = g_strdup(udevGetDeviceProperty(udev_device, property_key));\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetStringProperty(struct udev_device *udev_device,\n                      const char *property_key,\n                      char **value)\n{\n    *value = g_strdup(udevGetDeviceProperty(udev_device, property_key));\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessSCSIGeneric(struct udev_device *dev,\n                       virNodeDeviceDefPtr def)\n{\n    if (udevGetStringProperty(dev, \"DEVNAME\", &def->caps->data.sg.path) < 0 ||\n        !def->caps->data.sg.path)\n        return -1;\n\n    if (udevGenerateDeviceName(dev, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "udevProcessStorage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "900-993",
    "snippet": "static int\nudevProcessStorage(struct udev_device *device,\n                   virNodeDeviceDefPtr def)\n{\n    virNodeDevCapStoragePtr storage = &def->caps->data.storage;\n    int ret = -1;\n    const char* devnode;\n\n    devnode = udev_device_get_devnode(device);\n    if (!devnode) {\n        VIR_DEBUG(\"No devnode for '%s'\", udev_device_get_devpath(device));\n        goto cleanup;\n    }\n\n    storage->block = g_strdup(devnode);\n\n    if (udevGetStringProperty(device, \"ID_BUS\", &storage->bus) < 0)\n        goto cleanup;\n    if (udevGetStringProperty(device, \"ID_SERIAL\", &storage->serial) < 0)\n        goto cleanup;\n\n    if (udevGetStringSysfsAttr(device, \"device/vendor\", &storage->vendor) < 0)\n        goto cleanup;\n    if (def->caps->data.storage.vendor)\n        virTrimSpaces(def->caps->data.storage.vendor, NULL);\n\n    if (udevGetStringSysfsAttr(device, \"device/model\", &storage->model) < 0)\n        goto cleanup;\n    if (def->caps->data.storage.model)\n        virTrimSpaces(def->caps->data.storage.model, NULL);\n    /* There is no equivalent of the hotpluggable property in libudev,\n     * but storage is going toward a world in which hotpluggable is\n     * expected, so I don't see a problem with not having a property\n     * for it. */\n\n    if (udevGetStringProperty(device, \"ID_TYPE\", &storage->drive_type) < 0)\n        goto cleanup;\n\n    if (!storage->drive_type ||\n        STREQ(def->caps->data.storage.drive_type, \"generic\")) {\n        int val = 0;\n        const char *str = NULL;\n\n        /* All floppy drives have the ID_DRIVE_FLOPPY prop. This is\n         * needed since legacy floppies don't have a drive_type */\n        if (udevGetIntProperty(device, \"ID_DRIVE_FLOPPY\", &val, 0) < 0)\n            goto cleanup;\n        else if (val == 1)\n            str = \"floppy\";\n\n        if (!str) {\n            if (udevGetIntProperty(device, \"ID_CDROM\", &val, 0) < 0)\n                goto cleanup;\n            else if (val == 1)\n                str = \"cd\";\n        }\n\n        if (!str) {\n            if (udevGetIntProperty(device, \"ID_DRIVE_FLASH_SD\", &val, 0) < 0)\n                goto cleanup;\n            if (val == 1)\n                str = \"sd\";\n        }\n\n        if (str) {\n            storage->drive_type = g_strdup(str);\n        } else {\n            /* If udev doesn't have it, perhaps we can guess it. */\n            if (udevKludgeStorageType(def) != 0)\n                goto cleanup;\n        }\n    }\n\n    if (STREQ(def->caps->data.storage.drive_type, \"cd\")) {\n        ret = udevProcessCDROM(device, def);\n    } else if (STREQ(def->caps->data.storage.drive_type, \"disk\")) {\n        ret = udevProcessDisk(device, def);\n    } else if (STREQ(def->caps->data.storage.drive_type, \"floppy\")) {\n        ret = udevProcessFloppy(device, def);\n    } else if (STREQ(def->caps->data.storage.drive_type, \"sd\")) {\n        ret = udevProcessSD(device, def);\n    } else {\n        VIR_DEBUG(\"Unsupported storage type '%s'\",\n                  def->caps->data.storage.drive_type);\n        goto cleanup;\n    }\n\n    if (udevGenerateDeviceName(device, def, storage->serial) != 0)\n        goto cleanup;\n\n cleanup:\n    VIR_DEBUG(\"Storage ret=%d\", ret);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storage ret=%d\"",
            "ret"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGenerateDeviceName",
          "args": [
            "device",
            "def",
            "storage->serial"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "udevGenerateDeviceName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "291-314",
          "snippet": "static int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Unsupported storage type '%s'\"",
            "def->caps->data.storage.drive_type"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevProcessSD",
          "args": [
            "device",
            "def"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessSD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "854-871",
          "snippet": "static int\nudevProcessSD(struct udev_device *device,\n              virNodeDeviceDefPtr def)\n{\n    virNodeDevCapStoragePtr storage = &def->caps->data.storage;\n\n    if (udevGetUint64SysfsAttr(device, \"size\",\n                               &storage->num_blocks) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"queue/logical_block_size\",\n                               &storage->logical_block_size) < 0)\n        return -1;\n\n    storage->size = storage->num_blocks * storage->logical_block_size;\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessSD(struct udev_device *device,\n              virNodeDeviceDefPtr def)\n{\n    virNodeDevCapStoragePtr storage = &def->caps->data.storage;\n\n    if (udevGetUint64SysfsAttr(device, \"size\",\n                               &storage->num_blocks) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"queue/logical_block_size\",\n                               &storage->logical_block_size) < 0)\n        return -1;\n\n    storage->size = storage->num_blocks * storage->logical_block_size;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->caps->data.storage.drive_type",
            "\"sd\""
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevProcessFloppy",
          "args": [
            "device",
            "def"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessFloppy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "835-851",
          "snippet": "static int\nudevProcessFloppy(struct udev_device *device,\n                  virNodeDeviceDefPtr def)\n{\n    int has_media = 0;\n\n    if (udevHasDeviceProperty(device, \"ID_CDROM_MEDIA\")) {\n        /* USB floppy */\n        if (udevGetIntProperty(device, \"DKD_MEDIA_AVAILABLE\", &has_media, 0) < 0)\n            return -1;\n    } else if (udevHasDeviceProperty(device, \"ID_FS_LABEL\")) {\n        /* Legacy floppy */\n        has_media = 1;\n    }\n\n    return udevProcessRemoveableMedia(device, def, has_media);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessFloppy(struct udev_device *device,\n                  virNodeDeviceDefPtr def)\n{\n    int has_media = 0;\n\n    if (udevHasDeviceProperty(device, \"ID_CDROM_MEDIA\")) {\n        /* USB floppy */\n        if (udevGetIntProperty(device, \"DKD_MEDIA_AVAILABLE\", &has_media, 0) < 0)\n            return -1;\n    } else if (udevHasDeviceProperty(device, \"ID_FS_LABEL\")) {\n        /* Legacy floppy */\n        has_media = 1;\n    }\n\n    return udevProcessRemoveableMedia(device, def, has_media);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->caps->data.storage.drive_type",
            "\"floppy\""
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevProcessDisk",
          "args": [
            "device",
            "def"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "752-768",
          "snippet": "static int\nudevProcessDisk(struct udev_device *device,\n                virNodeDeviceDefPtr def)\n{\n    virNodeDevCapStoragePtr storage = &def->caps->data.storage;\n\n    if (udevGetUint64SysfsAttr(device, \"size\", &storage->num_blocks) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"queue/logical_block_size\",\n                               &storage->logical_block_size) < 0)\n        return -1;\n\n    storage->size = storage->num_blocks * storage->logical_block_size;\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessDisk(struct udev_device *device,\n                virNodeDeviceDefPtr def)\n{\n    virNodeDevCapStoragePtr storage = &def->caps->data.storage;\n\n    if (udevGetUint64SysfsAttr(device, \"size\", &storage->num_blocks) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"queue/logical_block_size\",\n                               &storage->logical_block_size) < 0)\n        return -1;\n\n    storage->size = storage->num_blocks * storage->logical_block_size;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->caps->data.storage.drive_type",
            "\"disk\""
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevProcessCDROM",
          "args": [
            "device",
            "def"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessCDROM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "814-832",
          "snippet": "static int\nudevProcessCDROM(struct udev_device *device,\n                 virNodeDeviceDefPtr def)\n{\n    int has_media = 0;\n\n    /* NB: the drive_type string provided by udev is different from\n     * that provided by HAL; now it's \"cd\" instead of \"cdrom\" We\n     * change it to cdrom to preserve compatibility with earlier\n     * versions of libvirt.  */\n    VIR_FREE(def->caps->data.storage.drive_type);\n    def->caps->data.storage.drive_type = g_strdup(\"cdrom\");\n\n    if (udevHasDeviceProperty(device, \"ID_CDROM_MEDIA\") &&\n        udevGetIntProperty(device, \"ID_CDROM_MEDIA\", &has_media, 0) < 0)\n        return -1;\n\n    return udevProcessRemoveableMedia(device, def, has_media);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessCDROM(struct udev_device *device,\n                 virNodeDeviceDefPtr def)\n{\n    int has_media = 0;\n\n    /* NB: the drive_type string provided by udev is different from\n     * that provided by HAL; now it's \"cd\" instead of \"cdrom\" We\n     * change it to cdrom to preserve compatibility with earlier\n     * versions of libvirt.  */\n    VIR_FREE(def->caps->data.storage.drive_type);\n    def->caps->data.storage.drive_type = g_strdup(\"cdrom\");\n\n    if (udevHasDeviceProperty(device, \"ID_CDROM_MEDIA\") &&\n        udevGetIntProperty(device, \"ID_CDROM_MEDIA\", &has_media, 0) < 0)\n        return -1;\n\n    return udevProcessRemoveableMedia(device, def, has_media);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->caps->data.storage.drive_type",
            "\"cd\""
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevKludgeStorageType",
          "args": [
            "def"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "udevKludgeStorageType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "878-897",
          "snippet": "static int\nudevKludgeStorageType(virNodeDeviceDefPtr def)\n{\n    VIR_DEBUG(\"Could not find definitive storage type for device \"\n              \"with sysfs path '%s', trying to guess it\",\n              def->sysfs_path);\n\n    /* virtio disk */\n    if (STRPREFIX(def->caps->data.storage.block, \"/dev/vd\")) {\n        def->caps->data.storage.drive_type = g_strdup(\"disk\");\n        VIR_DEBUG(\"Found storage type '%s' for device \"\n                  \"with sysfs path '%s'\",\n                  def->caps->data.storage.drive_type,\n                  def->sysfs_path);\n        return 0;\n    }\n    VIR_DEBUG(\"Could not determine storage type \"\n              \"for device with sysfs path '%s'\", def->sysfs_path);\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevKludgeStorageType(virNodeDeviceDefPtr def)\n{\n    VIR_DEBUG(\"Could not find definitive storage type for device \"\n              \"with sysfs path '%s', trying to guess it\",\n              def->sysfs_path);\n\n    /* virtio disk */\n    if (STRPREFIX(def->caps->data.storage.block, \"/dev/vd\")) {\n        def->caps->data.storage.drive_type = g_strdup(\"disk\");\n        VIR_DEBUG(\"Found storage type '%s' for device \"\n                  \"with sysfs path '%s'\",\n                  def->caps->data.storage.drive_type,\n                  def->sysfs_path);\n        return 0;\n    }\n    VIR_DEBUG(\"Could not determine storage type \"\n              \"for device with sysfs path '%s'\", def->sysfs_path);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "str"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetIntProperty",
          "args": [
            "device",
            "\"ID_DRIVE_FLASH_SD\"",
            "&val",
            "0"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetIntProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "162-178",
          "snippet": "static int\nudevGetIntProperty(struct udev_device *udev_device,\n                   const char *property_key,\n                   int *value,\n                   int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceProperty(udev_device, property_key);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetIntProperty(struct udev_device *udev_device,\n                   const char *property_key,\n                   int *value,\n                   int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceProperty(udev_device, property_key);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->caps->data.storage.drive_type",
            "\"generic\""
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetStringProperty",
          "args": [
            "device",
            "\"ID_TYPE\"",
            "&storage->drive_type"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetStringProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "151-159",
          "snippet": "static int\nudevGetStringProperty(struct udev_device *udev_device,\n                      const char *property_key,\n                      char **value)\n{\n    *value = g_strdup(udevGetDeviceProperty(udev_device, property_key));\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetStringProperty(struct udev_device *udev_device,\n                      const char *property_key,\n                      char **value)\n{\n    *value = g_strdup(udevGetDeviceProperty(udev_device, property_key));\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTrimSpaces",
          "args": [
            "def->caps->data.storage.model",
            "NULL"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "virTrimSpaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "835-853",
          "snippet": "void\nvirTrimSpaces(char *str, char **endp)\n{\n    char *end;\n\n    if (!endp || !*endp)\n        end = str + strlen(str);\n    else\n        end = *endp;\n    while (end > str && g_ascii_isspace(end[-1]))\n        end--;\n    if (endp) {\n        if (!*endp)\n            *end = '\\0';\n        *endp = end;\n    } else {\n        *end = '\\0';\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid\nvirTrimSpaces(char *str, char **endp)\n{\n    char *end;\n\n    if (!endp || !*endp)\n        end = str + strlen(str);\n    else\n        end = *endp;\n    while (end > str && g_ascii_isspace(end[-1]))\n        end--;\n    if (endp) {\n        if (!*endp)\n            *end = '\\0';\n        *endp = end;\n    } else {\n        *end = '\\0';\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetStringSysfsAttr",
          "args": [
            "device",
            "\"device/model\"",
            "&storage->model"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetStringSysfsAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "216-229",
          "snippet": "static int\nudevGetStringSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name,\n                       char **value)\n{\n    *value = g_strdup(udevGetDeviceSysfsAttr(udev_device, attr_name));\n\n    virStringStripControlChars(*value);\n\n    if (*value != NULL && (STREQ(*value, \"\")))\n        VIR_FREE(*value);\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetStringSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name,\n                       char **value)\n{\n    *value = g_strdup(udevGetDeviceSysfsAttr(udev_device, attr_name));\n\n    virStringStripControlChars(*value);\n\n    if (*value != NULL && (STREQ(*value, \"\")))\n        VIR_FREE(*value);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"No devnode for '%s'\"",
            "udev_device_get_devpath(device)"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_devpath",
          "args": [
            "device"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_devnode",
          "args": [
            "device"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessStorage(struct udev_device *device,\n                   virNodeDeviceDefPtr def)\n{\n    virNodeDevCapStoragePtr storage = &def->caps->data.storage;\n    int ret = -1;\n    const char* devnode;\n\n    devnode = udev_device_get_devnode(device);\n    if (!devnode) {\n        VIR_DEBUG(\"No devnode for '%s'\", udev_device_get_devpath(device));\n        goto cleanup;\n    }\n\n    storage->block = g_strdup(devnode);\n\n    if (udevGetStringProperty(device, \"ID_BUS\", &storage->bus) < 0)\n        goto cleanup;\n    if (udevGetStringProperty(device, \"ID_SERIAL\", &storage->serial) < 0)\n        goto cleanup;\n\n    if (udevGetStringSysfsAttr(device, \"device/vendor\", &storage->vendor) < 0)\n        goto cleanup;\n    if (def->caps->data.storage.vendor)\n        virTrimSpaces(def->caps->data.storage.vendor, NULL);\n\n    if (udevGetStringSysfsAttr(device, \"device/model\", &storage->model) < 0)\n        goto cleanup;\n    if (def->caps->data.storage.model)\n        virTrimSpaces(def->caps->data.storage.model, NULL);\n    /* There is no equivalent of the hotpluggable property in libudev,\n     * but storage is going toward a world in which hotpluggable is\n     * expected, so I don't see a problem with not having a property\n     * for it. */\n\n    if (udevGetStringProperty(device, \"ID_TYPE\", &storage->drive_type) < 0)\n        goto cleanup;\n\n    if (!storage->drive_type ||\n        STREQ(def->caps->data.storage.drive_type, \"generic\")) {\n        int val = 0;\n        const char *str = NULL;\n\n        /* All floppy drives have the ID_DRIVE_FLOPPY prop. This is\n         * needed since legacy floppies don't have a drive_type */\n        if (udevGetIntProperty(device, \"ID_DRIVE_FLOPPY\", &val, 0) < 0)\n            goto cleanup;\n        else if (val == 1)\n            str = \"floppy\";\n\n        if (!str) {\n            if (udevGetIntProperty(device, \"ID_CDROM\", &val, 0) < 0)\n                goto cleanup;\n            else if (val == 1)\n                str = \"cd\";\n        }\n\n        if (!str) {\n            if (udevGetIntProperty(device, \"ID_DRIVE_FLASH_SD\", &val, 0) < 0)\n                goto cleanup;\n            if (val == 1)\n                str = \"sd\";\n        }\n\n        if (str) {\n            storage->drive_type = g_strdup(str);\n        } else {\n            /* If udev doesn't have it, perhaps we can guess it. */\n            if (udevKludgeStorageType(def) != 0)\n                goto cleanup;\n        }\n    }\n\n    if (STREQ(def->caps->data.storage.drive_type, \"cd\")) {\n        ret = udevProcessCDROM(device, def);\n    } else if (STREQ(def->caps->data.storage.drive_type, \"disk\")) {\n        ret = udevProcessDisk(device, def);\n    } else if (STREQ(def->caps->data.storage.drive_type, \"floppy\")) {\n        ret = udevProcessFloppy(device, def);\n    } else if (STREQ(def->caps->data.storage.drive_type, \"sd\")) {\n        ret = udevProcessSD(device, def);\n    } else {\n        VIR_DEBUG(\"Unsupported storage type '%s'\",\n                  def->caps->data.storage.drive_type);\n        goto cleanup;\n    }\n\n    if (udevGenerateDeviceName(device, def, storage->serial) != 0)\n        goto cleanup;\n\n cleanup:\n    VIR_DEBUG(\"Storage ret=%d\", ret);\n    return ret;\n}"
  },
  {
    "function_name": "udevKludgeStorageType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "878-897",
    "snippet": "static int\nudevKludgeStorageType(virNodeDeviceDefPtr def)\n{\n    VIR_DEBUG(\"Could not find definitive storage type for device \"\n              \"with sysfs path '%s', trying to guess it\",\n              def->sysfs_path);\n\n    /* virtio disk */\n    if (STRPREFIX(def->caps->data.storage.block, \"/dev/vd\")) {\n        def->caps->data.storage.drive_type = g_strdup(\"disk\");\n        VIR_DEBUG(\"Found storage type '%s' for device \"\n                  \"with sysfs path '%s'\",\n                  def->caps->data.storage.drive_type,\n                  def->sysfs_path);\n        return 0;\n    }\n    VIR_DEBUG(\"Could not determine storage type \"\n              \"for device with sysfs path '%s'\", def->sysfs_path);\n    return -1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Could not determine storage type \"\n              \"for device with sysfs path '%s'\"",
            "def->sysfs_path"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Found storage type '%s' for device \"\n                  \"with sysfs path '%s'\"",
            "def->caps->data.storage.drive_type",
            "def->sysfs_path"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"disk\""
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "def->caps->data.storage.block",
            "\"/dev/vd\""
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Could not find definitive storage type for device \"\n              \"with sysfs path '%s', trying to guess it\"",
            "def->sysfs_path"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevKludgeStorageType(virNodeDeviceDefPtr def)\n{\n    VIR_DEBUG(\"Could not find definitive storage type for device \"\n              \"with sysfs path '%s', trying to guess it\",\n              def->sysfs_path);\n\n    /* virtio disk */\n    if (STRPREFIX(def->caps->data.storage.block, \"/dev/vd\")) {\n        def->caps->data.storage.drive_type = g_strdup(\"disk\");\n        VIR_DEBUG(\"Found storage type '%s' for device \"\n                  \"with sysfs path '%s'\",\n                  def->caps->data.storage.drive_type,\n                  def->sysfs_path);\n        return 0;\n    }\n    VIR_DEBUG(\"Could not determine storage type \"\n              \"for device with sysfs path '%s'\", def->sysfs_path);\n    return -1;\n}"
  },
  {
    "function_name": "udevProcessSD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "854-871",
    "snippet": "static int\nudevProcessSD(struct udev_device *device,\n              virNodeDeviceDefPtr def)\n{\n    virNodeDevCapStoragePtr storage = &def->caps->data.storage;\n\n    if (udevGetUint64SysfsAttr(device, \"size\",\n                               &storage->num_blocks) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"queue/logical_block_size\",\n                               &storage->logical_block_size) < 0)\n        return -1;\n\n    storage->size = storage->num_blocks * storage->logical_block_size;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevGetUint64SysfsAttr",
          "args": [
            "device",
            "\"queue/logical_block_size\"",
            "&storage->logical_block_size"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetUint64SysfsAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "272-288",
          "snippet": "static int\nudevGetUint64SysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name,\n                       unsigned long long *value)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_ull(str, NULL, 0, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to unsigned long long\"), str);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetUint64SysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name,\n                       unsigned long long *value)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_ull(str, NULL, 0, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to unsigned long long\"), str);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessSD(struct udev_device *device,\n              virNodeDeviceDefPtr def)\n{\n    virNodeDevCapStoragePtr storage = &def->caps->data.storage;\n\n    if (udevGetUint64SysfsAttr(device, \"size\",\n                               &storage->num_blocks) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"queue/logical_block_size\",\n                               &storage->logical_block_size) < 0)\n        return -1;\n\n    storage->size = storage->num_blocks * storage->logical_block_size;\n\n    return 0;\n}"
  },
  {
    "function_name": "udevProcessFloppy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "835-851",
    "snippet": "static int\nudevProcessFloppy(struct udev_device *device,\n                  virNodeDeviceDefPtr def)\n{\n    int has_media = 0;\n\n    if (udevHasDeviceProperty(device, \"ID_CDROM_MEDIA\")) {\n        /* USB floppy */\n        if (udevGetIntProperty(device, \"DKD_MEDIA_AVAILABLE\", &has_media, 0) < 0)\n            return -1;\n    } else if (udevHasDeviceProperty(device, \"ID_FS_LABEL\")) {\n        /* Legacy floppy */\n        has_media = 1;\n    }\n\n    return udevProcessRemoveableMedia(device, def, has_media);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevProcessRemoveableMedia",
          "args": [
            "device",
            "def",
            "has_media"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessRemoveableMedia",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "771-811",
          "snippet": "static int\nudevProcessRemoveableMedia(struct udev_device *device,\n                           virNodeDeviceDefPtr def,\n                           int has_media)\n{\n    virNodeDevCapStoragePtr storage = &def->caps->data.storage;\n    int is_removable = 0;\n\n    if (udevGetIntSysfsAttr(device, \"removable\", &is_removable, 0) < 0)\n        return -1;\n    if (is_removable == 1)\n        def->caps->data.storage.flags |= VIR_NODE_DEV_CAP_STORAGE_REMOVABLE;\n\n    if (!has_media)\n        return 0;\n\n    def->caps->data.storage.flags |=\n        VIR_NODE_DEV_CAP_STORAGE_REMOVABLE_MEDIA_AVAILABLE;\n\n    if (udevGetStringProperty(device, \"ID_FS_LABEL\",\n                              &storage->media_label) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"size\",\n                               &storage->num_blocks) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"queue/logical_block_size\",\n                               &storage->logical_block_size) < 0)\n        return -1;\n\n    /* XXX This calculation is wrong for the qemu virtual cdrom\n     * which reports the size in 512 byte blocks, but the logical\n     * block size as 2048.  I don't have a physical cdrom on a\n     * devel system to see how they behave. */\n    def->caps->data.storage.removable_media_size =\n        def->caps->data.storage.num_blocks *\n        def->caps->data.storage.logical_block_size;\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessRemoveableMedia(struct udev_device *device,\n                           virNodeDeviceDefPtr def,\n                           int has_media)\n{\n    virNodeDevCapStoragePtr storage = &def->caps->data.storage;\n    int is_removable = 0;\n\n    if (udevGetIntSysfsAttr(device, \"removable\", &is_removable, 0) < 0)\n        return -1;\n    if (is_removable == 1)\n        def->caps->data.storage.flags |= VIR_NODE_DEV_CAP_STORAGE_REMOVABLE;\n\n    if (!has_media)\n        return 0;\n\n    def->caps->data.storage.flags |=\n        VIR_NODE_DEV_CAP_STORAGE_REMOVABLE_MEDIA_AVAILABLE;\n\n    if (udevGetStringProperty(device, \"ID_FS_LABEL\",\n                              &storage->media_label) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"size\",\n                               &storage->num_blocks) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"queue/logical_block_size\",\n                               &storage->logical_block_size) < 0)\n        return -1;\n\n    /* XXX This calculation is wrong for the qemu virtual cdrom\n     * which reports the size in 512 byte blocks, but the logical\n     * block size as 2048.  I don't have a physical cdrom on a\n     * devel system to see how they behave. */\n    def->caps->data.storage.removable_media_size =\n        def->caps->data.storage.num_blocks *\n        def->caps->data.storage.logical_block_size;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevHasDeviceProperty",
          "args": [
            "device",
            "\"ID_FS_LABEL\""
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "udevHasDeviceProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "125-133",
          "snippet": "static bool\nudevHasDeviceProperty(struct udev_device *dev,\n                      const char *key)\n{\n    if (udev_device_get_property_value(dev, key))\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic bool\nudevHasDeviceProperty(struct udev_device *dev,\n                      const char *key)\n{\n    if (udev_device_get_property_value(dev, key))\n        return true;\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetIntProperty",
          "args": [
            "device",
            "\"DKD_MEDIA_AVAILABLE\"",
            "&has_media",
            "0"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetIntProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "162-178",
          "snippet": "static int\nudevGetIntProperty(struct udev_device *udev_device,\n                   const char *property_key,\n                   int *value,\n                   int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceProperty(udev_device, property_key);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetIntProperty(struct udev_device *udev_device,\n                   const char *property_key,\n                   int *value,\n                   int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceProperty(udev_device, property_key);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessFloppy(struct udev_device *device,\n                  virNodeDeviceDefPtr def)\n{\n    int has_media = 0;\n\n    if (udevHasDeviceProperty(device, \"ID_CDROM_MEDIA\")) {\n        /* USB floppy */\n        if (udevGetIntProperty(device, \"DKD_MEDIA_AVAILABLE\", &has_media, 0) < 0)\n            return -1;\n    } else if (udevHasDeviceProperty(device, \"ID_FS_LABEL\")) {\n        /* Legacy floppy */\n        has_media = 1;\n    }\n\n    return udevProcessRemoveableMedia(device, def, has_media);\n}"
  },
  {
    "function_name": "udevProcessCDROM",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "814-832",
    "snippet": "static int\nudevProcessCDROM(struct udev_device *device,\n                 virNodeDeviceDefPtr def)\n{\n    int has_media = 0;\n\n    /* NB: the drive_type string provided by udev is different from\n     * that provided by HAL; now it's \"cd\" instead of \"cdrom\" We\n     * change it to cdrom to preserve compatibility with earlier\n     * versions of libvirt.  */\n    VIR_FREE(def->caps->data.storage.drive_type);\n    def->caps->data.storage.drive_type = g_strdup(\"cdrom\");\n\n    if (udevHasDeviceProperty(device, \"ID_CDROM_MEDIA\") &&\n        udevGetIntProperty(device, \"ID_CDROM_MEDIA\", &has_media, 0) < 0)\n        return -1;\n\n    return udevProcessRemoveableMedia(device, def, has_media);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevProcessRemoveableMedia",
          "args": [
            "device",
            "def",
            "has_media"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "udevProcessRemoveableMedia",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "771-811",
          "snippet": "static int\nudevProcessRemoveableMedia(struct udev_device *device,\n                           virNodeDeviceDefPtr def,\n                           int has_media)\n{\n    virNodeDevCapStoragePtr storage = &def->caps->data.storage;\n    int is_removable = 0;\n\n    if (udevGetIntSysfsAttr(device, \"removable\", &is_removable, 0) < 0)\n        return -1;\n    if (is_removable == 1)\n        def->caps->data.storage.flags |= VIR_NODE_DEV_CAP_STORAGE_REMOVABLE;\n\n    if (!has_media)\n        return 0;\n\n    def->caps->data.storage.flags |=\n        VIR_NODE_DEV_CAP_STORAGE_REMOVABLE_MEDIA_AVAILABLE;\n\n    if (udevGetStringProperty(device, \"ID_FS_LABEL\",\n                              &storage->media_label) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"size\",\n                               &storage->num_blocks) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"queue/logical_block_size\",\n                               &storage->logical_block_size) < 0)\n        return -1;\n\n    /* XXX This calculation is wrong for the qemu virtual cdrom\n     * which reports the size in 512 byte blocks, but the logical\n     * block size as 2048.  I don't have a physical cdrom on a\n     * devel system to see how they behave. */\n    def->caps->data.storage.removable_media_size =\n        def->caps->data.storage.num_blocks *\n        def->caps->data.storage.logical_block_size;\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessRemoveableMedia(struct udev_device *device,\n                           virNodeDeviceDefPtr def,\n                           int has_media)\n{\n    virNodeDevCapStoragePtr storage = &def->caps->data.storage;\n    int is_removable = 0;\n\n    if (udevGetIntSysfsAttr(device, \"removable\", &is_removable, 0) < 0)\n        return -1;\n    if (is_removable == 1)\n        def->caps->data.storage.flags |= VIR_NODE_DEV_CAP_STORAGE_REMOVABLE;\n\n    if (!has_media)\n        return 0;\n\n    def->caps->data.storage.flags |=\n        VIR_NODE_DEV_CAP_STORAGE_REMOVABLE_MEDIA_AVAILABLE;\n\n    if (udevGetStringProperty(device, \"ID_FS_LABEL\",\n                              &storage->media_label) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"size\",\n                               &storage->num_blocks) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"queue/logical_block_size\",\n                               &storage->logical_block_size) < 0)\n        return -1;\n\n    /* XXX This calculation is wrong for the qemu virtual cdrom\n     * which reports the size in 512 byte blocks, but the logical\n     * block size as 2048.  I don't have a physical cdrom on a\n     * devel system to see how they behave. */\n    def->caps->data.storage.removable_media_size =\n        def->caps->data.storage.num_blocks *\n        def->caps->data.storage.logical_block_size;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetIntProperty",
          "args": [
            "device",
            "\"ID_CDROM_MEDIA\"",
            "&has_media",
            "0"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetIntProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "162-178",
          "snippet": "static int\nudevGetIntProperty(struct udev_device *udev_device,\n                   const char *property_key,\n                   int *value,\n                   int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceProperty(udev_device, property_key);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetIntProperty(struct udev_device *udev_device,\n                   const char *property_key,\n                   int *value,\n                   int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceProperty(udev_device, property_key);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevHasDeviceProperty",
          "args": [
            "device",
            "\"ID_CDROM_MEDIA\""
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "udevHasDeviceProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "125-133",
          "snippet": "static bool\nudevHasDeviceProperty(struct udev_device *dev,\n                      const char *key)\n{\n    if (udev_device_get_property_value(dev, key))\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic bool\nudevHasDeviceProperty(struct udev_device *dev,\n                      const char *key)\n{\n    if (udev_device_get_property_value(dev, key))\n        return true;\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"cdrom\""
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->caps->data.storage.drive_type"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessCDROM(struct udev_device *device,\n                 virNodeDeviceDefPtr def)\n{\n    int has_media = 0;\n\n    /* NB: the drive_type string provided by udev is different from\n     * that provided by HAL; now it's \"cd\" instead of \"cdrom\" We\n     * change it to cdrom to preserve compatibility with earlier\n     * versions of libvirt.  */\n    VIR_FREE(def->caps->data.storage.drive_type);\n    def->caps->data.storage.drive_type = g_strdup(\"cdrom\");\n\n    if (udevHasDeviceProperty(device, \"ID_CDROM_MEDIA\") &&\n        udevGetIntProperty(device, \"ID_CDROM_MEDIA\", &has_media, 0) < 0)\n        return -1;\n\n    return udevProcessRemoveableMedia(device, def, has_media);\n}"
  },
  {
    "function_name": "udevProcessRemoveableMedia",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "771-811",
    "snippet": "static int\nudevProcessRemoveableMedia(struct udev_device *device,\n                           virNodeDeviceDefPtr def,\n                           int has_media)\n{\n    virNodeDevCapStoragePtr storage = &def->caps->data.storage;\n    int is_removable = 0;\n\n    if (udevGetIntSysfsAttr(device, \"removable\", &is_removable, 0) < 0)\n        return -1;\n    if (is_removable == 1)\n        def->caps->data.storage.flags |= VIR_NODE_DEV_CAP_STORAGE_REMOVABLE;\n\n    if (!has_media)\n        return 0;\n\n    def->caps->data.storage.flags |=\n        VIR_NODE_DEV_CAP_STORAGE_REMOVABLE_MEDIA_AVAILABLE;\n\n    if (udevGetStringProperty(device, \"ID_FS_LABEL\",\n                              &storage->media_label) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"size\",\n                               &storage->num_blocks) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"queue/logical_block_size\",\n                               &storage->logical_block_size) < 0)\n        return -1;\n\n    /* XXX This calculation is wrong for the qemu virtual cdrom\n     * which reports the size in 512 byte blocks, but the logical\n     * block size as 2048.  I don't have a physical cdrom on a\n     * devel system to see how they behave. */\n    def->caps->data.storage.removable_media_size =\n        def->caps->data.storage.num_blocks *\n        def->caps->data.storage.logical_block_size;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevGetUint64SysfsAttr",
          "args": [
            "device",
            "\"queue/logical_block_size\"",
            "&storage->logical_block_size"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetUint64SysfsAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "272-288",
          "snippet": "static int\nudevGetUint64SysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name,\n                       unsigned long long *value)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_ull(str, NULL, 0, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to unsigned long long\"), str);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetUint64SysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name,\n                       unsigned long long *value)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_ull(str, NULL, 0, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to unsigned long long\"), str);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetStringProperty",
          "args": [
            "device",
            "\"ID_FS_LABEL\"",
            "&storage->media_label"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetStringProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "151-159",
          "snippet": "static int\nudevGetStringProperty(struct udev_device *udev_device,\n                      const char *property_key,\n                      char **value)\n{\n    *value = g_strdup(udevGetDeviceProperty(udev_device, property_key));\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetStringProperty(struct udev_device *udev_device,\n                      const char *property_key,\n                      char **value)\n{\n    *value = g_strdup(udevGetDeviceProperty(udev_device, property_key));\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetIntSysfsAttr",
          "args": [
            "device",
            "\"removable\"",
            "&is_removable",
            "0"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetIntSysfsAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "232-249",
          "snippet": "static int\nudevGetIntSysfsAttr(struct udev_device *udev_device,\n                    const char *attr_name,\n                    int *value,\n                    int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetIntSysfsAttr(struct udev_device *udev_device,\n                    const char *attr_name,\n                    int *value,\n                    int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessRemoveableMedia(struct udev_device *device,\n                           virNodeDeviceDefPtr def,\n                           int has_media)\n{\n    virNodeDevCapStoragePtr storage = &def->caps->data.storage;\n    int is_removable = 0;\n\n    if (udevGetIntSysfsAttr(device, \"removable\", &is_removable, 0) < 0)\n        return -1;\n    if (is_removable == 1)\n        def->caps->data.storage.flags |= VIR_NODE_DEV_CAP_STORAGE_REMOVABLE;\n\n    if (!has_media)\n        return 0;\n\n    def->caps->data.storage.flags |=\n        VIR_NODE_DEV_CAP_STORAGE_REMOVABLE_MEDIA_AVAILABLE;\n\n    if (udevGetStringProperty(device, \"ID_FS_LABEL\",\n                              &storage->media_label) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"size\",\n                               &storage->num_blocks) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"queue/logical_block_size\",\n                               &storage->logical_block_size) < 0)\n        return -1;\n\n    /* XXX This calculation is wrong for the qemu virtual cdrom\n     * which reports the size in 512 byte blocks, but the logical\n     * block size as 2048.  I don't have a physical cdrom on a\n     * devel system to see how they behave. */\n    def->caps->data.storage.removable_media_size =\n        def->caps->data.storage.num_blocks *\n        def->caps->data.storage.logical_block_size;\n\n    return 0;\n}"
  },
  {
    "function_name": "udevProcessDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "752-768",
    "snippet": "static int\nudevProcessDisk(struct udev_device *device,\n                virNodeDeviceDefPtr def)\n{\n    virNodeDevCapStoragePtr storage = &def->caps->data.storage;\n\n    if (udevGetUint64SysfsAttr(device, \"size\", &storage->num_blocks) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"queue/logical_block_size\",\n                               &storage->logical_block_size) < 0)\n        return -1;\n\n    storage->size = storage->num_blocks * storage->logical_block_size;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevGetUint64SysfsAttr",
          "args": [
            "device",
            "\"queue/logical_block_size\"",
            "&storage->logical_block_size"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetUint64SysfsAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "272-288",
          "snippet": "static int\nudevGetUint64SysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name,\n                       unsigned long long *value)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_ull(str, NULL, 0, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to unsigned long long\"), str);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetUint64SysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name,\n                       unsigned long long *value)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_ull(str, NULL, 0, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to unsigned long long\"), str);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessDisk(struct udev_device *device,\n                virNodeDeviceDefPtr def)\n{\n    virNodeDevCapStoragePtr storage = &def->caps->data.storage;\n\n    if (udevGetUint64SysfsAttr(device, \"size\", &storage->num_blocks) < 0)\n        return -1;\n\n    if (udevGetUint64SysfsAttr(device, \"queue/logical_block_size\",\n                               &storage->logical_block_size) < 0)\n        return -1;\n\n    storage->size = storage->num_blocks * storage->logical_block_size;\n\n    return 0;\n}"
  },
  {
    "function_name": "udevProcessSCSIDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "707-749",
    "snippet": "static int\nudevProcessSCSIDevice(struct udev_device *device G_GNUC_UNUSED,\n                      virNodeDeviceDefPtr def)\n{\n    int ret = -1;\n    unsigned int tmp = 0;\n    virNodeDevCapSCSIPtr scsi = &def->caps->data.scsi;\n    g_autofree char *filename = NULL;\n    char *p = NULL;\n\n    filename = g_path_get_basename(def->sysfs_path);\n\n    if (virStrToLong_ui(filename, &p, 10, &scsi->host) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 10, &scsi->bus) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 10, &scsi->target) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 10, &scsi->lun) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse the SCSI address from filename: '%s'\"),\n                       filename);\n        return -1;\n    }\n\n    if (udev_device_get_sysattr_value(device, \"type\")) {\n        if (udevGetUintSysfsAttr(device, \"type\", &tmp, 0) < 0)\n            goto cleanup;\n\n        if (udevGetSCSIType(def, tmp, &scsi->type) < 0)\n            goto cleanup;\n    }\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (ret != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to process SCSI device with sysfs path '%s'\"),\n                       def->sysfs_path);\n    }\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to process SCSI device with sysfs path '%s'\")",
            "def->sysfs_path"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to process SCSI device with sysfs path '%s'\""
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGenerateDeviceName",
          "args": [
            "device",
            "def",
            "NULL"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "udevGenerateDeviceName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "291-314",
          "snippet": "static int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetSCSIType",
          "args": [
            "def",
            "tmp",
            "&scsi->type"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetSCSIType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "647-704",
          "snippet": "static int\nudevGetSCSIType(virNodeDeviceDefPtr def G_GNUC_UNUSED,\n                unsigned int type,\n                char **typestring)\n{\n    int ret = 0;\n    int foundtype = 1;\n\n    *typestring = NULL;\n\n    switch (type) {\n    case TYPE_DISK:\n        *typestring = g_strdup(\"disk\");\n        break;\n    case TYPE_TAPE:\n        *typestring = g_strdup(\"tape\");\n        break;\n    case TYPE_PROCESSOR:\n        *typestring = g_strdup(\"processor\");\n        break;\n    case TYPE_WORM:\n        *typestring = g_strdup(\"worm\");\n        break;\n    case TYPE_ROM:\n        *typestring = g_strdup(\"cdrom\");\n        break;\n    case TYPE_SCANNER:\n        *typestring = g_strdup(\"scanner\");\n        break;\n    case TYPE_MOD:\n        *typestring = g_strdup(\"mod\");\n        break;\n    case TYPE_MEDIUM_CHANGER:\n        *typestring = g_strdup(\"changer\");\n        break;\n    case TYPE_ENCLOSURE:\n        *typestring = g_strdup(\"enclosure\");\n        break;\n    case TYPE_RAID:\n        *typestring = g_strdup(\"raid\");\n        break;\n    case TYPE_NO_LUN:\n    default:\n        foundtype = 0;\n        break;\n    }\n\n    if (*typestring == NULL) {\n        if (foundtype == 1) {\n            ret = -1;\n        } else {\n            VIR_DEBUG(\"Failed to find SCSI device type %d for %s\",\n                      type, def->sysfs_path);\n        }\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetSCSIType(virNodeDeviceDefPtr def G_GNUC_UNUSED,\n                unsigned int type,\n                char **typestring)\n{\n    int ret = 0;\n    int foundtype = 1;\n\n    *typestring = NULL;\n\n    switch (type) {\n    case TYPE_DISK:\n        *typestring = g_strdup(\"disk\");\n        break;\n    case TYPE_TAPE:\n        *typestring = g_strdup(\"tape\");\n        break;\n    case TYPE_PROCESSOR:\n        *typestring = g_strdup(\"processor\");\n        break;\n    case TYPE_WORM:\n        *typestring = g_strdup(\"worm\");\n        break;\n    case TYPE_ROM:\n        *typestring = g_strdup(\"cdrom\");\n        break;\n    case TYPE_SCANNER:\n        *typestring = g_strdup(\"scanner\");\n        break;\n    case TYPE_MOD:\n        *typestring = g_strdup(\"mod\");\n        break;\n    case TYPE_MEDIUM_CHANGER:\n        *typestring = g_strdup(\"changer\");\n        break;\n    case TYPE_ENCLOSURE:\n        *typestring = g_strdup(\"enclosure\");\n        break;\n    case TYPE_RAID:\n        *typestring = g_strdup(\"raid\");\n        break;\n    case TYPE_NO_LUN:\n    default:\n        foundtype = 0;\n        break;\n    }\n\n    if (*typestring == NULL) {\n        if (foundtype == 1) {\n            ret = -1;\n        } else {\n            VIR_DEBUG(\"Failed to find SCSI device type %d for %s\",\n                      type, def->sysfs_path);\n        }\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetUintSysfsAttr",
          "args": [
            "device",
            "\"type\"",
            "&tmp",
            "0"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetUintSysfsAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "252-269",
          "snippet": "static int\nudevGetUintSysfsAttr(struct udev_device *udev_device,\n                     const char *attr_name,\n                     unsigned int *value,\n                     int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_ui(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to unsigned int\"), str);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetUintSysfsAttr(struct udev_device *udev_device,\n                     const char *attr_name,\n                     unsigned int *value,\n                     int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_ui(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to unsigned int\"), str);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "device",
            "\"type\""
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to parse the SCSI address from filename: '%s'\")",
            "filename"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "p + 1",
            "&p",
            "10",
            "&scsi->lun"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_path_get_basename",
          "args": [
            "def->sysfs_path"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessSCSIDevice(struct udev_device *device G_GNUC_UNUSED,\n                      virNodeDeviceDefPtr def)\n{\n    int ret = -1;\n    unsigned int tmp = 0;\n    virNodeDevCapSCSIPtr scsi = &def->caps->data.scsi;\n    g_autofree char *filename = NULL;\n    char *p = NULL;\n\n    filename = g_path_get_basename(def->sysfs_path);\n\n    if (virStrToLong_ui(filename, &p, 10, &scsi->host) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 10, &scsi->bus) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 10, &scsi->target) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 10, &scsi->lun) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse the SCSI address from filename: '%s'\"),\n                       filename);\n        return -1;\n    }\n\n    if (udev_device_get_sysattr_value(device, \"type\")) {\n        if (udevGetUintSysfsAttr(device, \"type\", &tmp, 0) < 0)\n            goto cleanup;\n\n        if (udevGetSCSIType(def, tmp, &scsi->type) < 0)\n            goto cleanup;\n    }\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (ret != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to process SCSI device with sysfs path '%s'\"),\n                       def->sysfs_path);\n    }\n    return ret;\n}"
  },
  {
    "function_name": "udevGetSCSIType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "647-704",
    "snippet": "static int\nudevGetSCSIType(virNodeDeviceDefPtr def G_GNUC_UNUSED,\n                unsigned int type,\n                char **typestring)\n{\n    int ret = 0;\n    int foundtype = 1;\n\n    *typestring = NULL;\n\n    switch (type) {\n    case TYPE_DISK:\n        *typestring = g_strdup(\"disk\");\n        break;\n    case TYPE_TAPE:\n        *typestring = g_strdup(\"tape\");\n        break;\n    case TYPE_PROCESSOR:\n        *typestring = g_strdup(\"processor\");\n        break;\n    case TYPE_WORM:\n        *typestring = g_strdup(\"worm\");\n        break;\n    case TYPE_ROM:\n        *typestring = g_strdup(\"cdrom\");\n        break;\n    case TYPE_SCANNER:\n        *typestring = g_strdup(\"scanner\");\n        break;\n    case TYPE_MOD:\n        *typestring = g_strdup(\"mod\");\n        break;\n    case TYPE_MEDIUM_CHANGER:\n        *typestring = g_strdup(\"changer\");\n        break;\n    case TYPE_ENCLOSURE:\n        *typestring = g_strdup(\"enclosure\");\n        break;\n    case TYPE_RAID:\n        *typestring = g_strdup(\"raid\");\n        break;\n    case TYPE_NO_LUN:\n    default:\n        foundtype = 0;\n        break;\n    }\n\n    if (*typestring == NULL) {\n        if (foundtype == 1) {\n            ret = -1;\n        } else {\n            VIR_DEBUG(\"Failed to find SCSI device type %d for %s\",\n                      type, def->sysfs_path);\n        }\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed to find SCSI device type %d for %s\"",
            "type",
            "def->sysfs_path"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"raid\""
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetSCSIType(virNodeDeviceDefPtr def G_GNUC_UNUSED,\n                unsigned int type,\n                char **typestring)\n{\n    int ret = 0;\n    int foundtype = 1;\n\n    *typestring = NULL;\n\n    switch (type) {\n    case TYPE_DISK:\n        *typestring = g_strdup(\"disk\");\n        break;\n    case TYPE_TAPE:\n        *typestring = g_strdup(\"tape\");\n        break;\n    case TYPE_PROCESSOR:\n        *typestring = g_strdup(\"processor\");\n        break;\n    case TYPE_WORM:\n        *typestring = g_strdup(\"worm\");\n        break;\n    case TYPE_ROM:\n        *typestring = g_strdup(\"cdrom\");\n        break;\n    case TYPE_SCANNER:\n        *typestring = g_strdup(\"scanner\");\n        break;\n    case TYPE_MOD:\n        *typestring = g_strdup(\"mod\");\n        break;\n    case TYPE_MEDIUM_CHANGER:\n        *typestring = g_strdup(\"changer\");\n        break;\n    case TYPE_ENCLOSURE:\n        *typestring = g_strdup(\"enclosure\");\n        break;\n    case TYPE_RAID:\n        *typestring = g_strdup(\"raid\");\n        break;\n    case TYPE_NO_LUN:\n    default:\n        foundtype = 0;\n        break;\n    }\n\n    if (*typestring == NULL) {\n        if (foundtype == 1) {\n            ret = -1;\n        } else {\n            VIR_DEBUG(\"Failed to find SCSI device type %d for %s\",\n                      type, def->sysfs_path);\n        }\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "udevProcessSCSITarget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "627-644",
    "snippet": "static int\nudevProcessSCSITarget(struct udev_device *device,\n                      virNodeDeviceDefPtr def)\n{\n    const char *sysname = NULL;\n    virNodeDevCapSCSITargetPtr scsi_target = &def->caps->data.scsi_target;\n\n    sysname = udev_device_get_sysname(device);\n\n    scsi_target->name = g_strdup(sysname);\n\n    virNodeDeviceGetSCSITargetCaps(def->sysfs_path, &def->caps->data.scsi_target);\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevGenerateDeviceName",
          "args": [
            "device",
            "def",
            "NULL"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "udevGenerateDeviceName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "291-314",
          "snippet": "static int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceGetSCSITargetCaps",
          "args": [
            "def->sysfs_path",
            "&def->caps->data.scsi_target"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceGetSCSITargetCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2616-2620",
          "snippet": "int virNodeDeviceGetSCSITargetCaps(const char *sysfsPath G_GNUC_UNUSED,\n                                   virNodeDevCapSCSITargetPtr scsi_target G_GNUC_UNUSED)\n{\n    return -1;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNodeDeviceGetSCSITargetCaps(const char *sysfsPath G_GNUC_UNUSED,\n                                   virNodeDevCapSCSITargetPtr scsi_target G_GNUC_UNUSED)\n{\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "sysname"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysname",
          "args": [
            "device"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessSCSITarget(struct udev_device *device,\n                      virNodeDeviceDefPtr def)\n{\n    const char *sysname = NULL;\n    virNodeDevCapSCSITargetPtr scsi_target = &def->caps->data.scsi_target;\n\n    sysname = udev_device_get_sysname(device);\n\n    scsi_target->name = g_strdup(sysname);\n\n    virNodeDeviceGetSCSITargetCaps(def->sysfs_path, &def->caps->data.scsi_target);\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "udevProcessSCSIHost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "600-624",
    "snippet": "static int\nudevProcessSCSIHost(struct udev_device *device G_GNUC_UNUSED,\n                    virNodeDeviceDefPtr def)\n{\n    virNodeDevCapSCSIHostPtr scsi_host = &def->caps->data.scsi_host;\n    g_autofree char *filename = NULL;\n    char *str;\n\n    filename = g_path_get_basename(def->sysfs_path);\n\n    if (!(str = STRSKIP(filename, \"host\")) ||\n        virStrToLong_ui(str, NULL, 0, &scsi_host->host) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse SCSI host '%s'\"),\n                       filename);\n        return -1;\n    }\n\n    virNodeDeviceGetSCSIHostCaps(&def->caps->data.scsi_host);\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevGenerateDeviceName",
          "args": [
            "device",
            "def",
            "NULL"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "udevGenerateDeviceName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "291-314",
          "snippet": "static int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceGetSCSIHostCaps",
          "args": [
            "&def->caps->data.scsi_host"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceGetSCSIHostCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2602-2606",
          "snippet": "int\nvirNodeDeviceGetSCSIHostCaps(virNodeDevCapSCSIHostPtr scsi_host G_GNUC_UNUSED)\n{\n    return -1;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNodeDeviceGetSCSIHostCaps(virNodeDevCapSCSIHostPtr scsi_host G_GNUC_UNUSED)\n{\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to parse SCSI host '%s'\")",
            "filename"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to parse SCSI host '%s'\""
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "str",
            "NULL",
            "0",
            "&scsi_host->host"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRSKIP",
          "args": [
            "filename",
            "\"host\""
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_path_get_basename",
          "args": [
            "def->sysfs_path"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessSCSIHost(struct udev_device *device G_GNUC_UNUSED,\n                    virNodeDeviceDefPtr def)\n{\n    virNodeDevCapSCSIHostPtr scsi_host = &def->caps->data.scsi_host;\n    g_autofree char *filename = NULL;\n    char *str;\n\n    filename = g_path_get_basename(def->sysfs_path);\n\n    if (!(str = STRSKIP(filename, \"host\")) ||\n        virStrToLong_ui(str, NULL, 0, &scsi_host->host) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse SCSI host '%s'\"),\n                       filename);\n        return -1;\n    }\n\n    virNodeDeviceGetSCSIHostCaps(&def->caps->data.scsi_host);\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "udevProcessNetworkInterface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "562-597",
    "snippet": "static int\nudevProcessNetworkInterface(struct udev_device *device,\n                            virNodeDeviceDefPtr def)\n{\n    const char *devtype = udev_device_get_devtype(device);\n    virNodeDevCapNetPtr net = &def->caps->data.net;\n\n    if (devtype && STREQ(devtype, \"wlan\")) {\n        net->subtype = VIR_NODE_DEV_CAP_NET_80211;\n    } else {\n        net->subtype = VIR_NODE_DEV_CAP_NET_80203;\n    }\n\n    if (udevGetStringProperty(device,\n                              \"INTERFACE\",\n                              &net->ifname) < 0)\n        return -1;\n\n    if (udevGetStringSysfsAttr(device, \"address\",\n                               &net->address) < 0)\n        return -1;\n\n    if (udevGetUintSysfsAttr(device, \"addr_len\", &net->address_len, 0) < 0)\n        return -1;\n\n    if (udevGenerateDeviceName(device, def, net->address) != 0)\n        return -1;\n\n    if (virNetDevGetLinkInfo(net->ifname, &net->lnk) < 0)\n        return -1;\n\n    if (virNetDevGetFeatures(net->ifname, &net->features) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDevGetFeatures",
          "args": [
            "net->ifname",
            "&net->features"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetFeatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "3416-3423",
          "snippet": "int\nvirNetDevGetFeatures(const char *ifname G_GNUC_UNUSED,\n                     virBitmapPtr *out G_GNUC_UNUSED)\n{\n    VIR_DEBUG(\"Getting network device features on %s is not implemented on this platform\",\n              ifname);\n    return 0;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevGetFeatures(const char *ifname G_GNUC_UNUSED,\n                     virBitmapPtr *out G_GNUC_UNUSED)\n{\n    VIR_DEBUG(\"Getting network device features on %s is not implemented on this platform\",\n              ifname);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevGetLinkInfo",
          "args": [
            "net->ifname",
            "&net->lnk"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetLinkInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "2515-2524",
          "snippet": "int\nvirNetDevGetLinkInfo(const char *ifname,\n                     virNetDevIfLinkPtr lnk)\n{\n    /* Port me */\n    VIR_DEBUG(\"Getting link info on %s is not implemented on this platform\",\n              ifname);\n    lnk->speed = lnk->state = 0;\n    return 0;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevGetLinkInfo(const char *ifname,\n                     virNetDevIfLinkPtr lnk)\n{\n    /* Port me */\n    VIR_DEBUG(\"Getting link info on %s is not implemented on this platform\",\n              ifname);\n    lnk->speed = lnk->state = 0;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGenerateDeviceName",
          "args": [
            "device",
            "def",
            "net->address"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "udevGenerateDeviceName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "291-314",
          "snippet": "static int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetUintSysfsAttr",
          "args": [
            "device",
            "\"addr_len\"",
            "&net->address_len",
            "0"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetUintSysfsAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "252-269",
          "snippet": "static int\nudevGetUintSysfsAttr(struct udev_device *udev_device,\n                     const char *attr_name,\n                     unsigned int *value,\n                     int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_ui(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to unsigned int\"), str);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetUintSysfsAttr(struct udev_device *udev_device,\n                     const char *attr_name,\n                     unsigned int *value,\n                     int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_ui(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to unsigned int\"), str);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetStringSysfsAttr",
          "args": [
            "device",
            "\"address\"",
            "&net->address"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetStringSysfsAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "216-229",
          "snippet": "static int\nudevGetStringSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name,\n                       char **value)\n{\n    *value = g_strdup(udevGetDeviceSysfsAttr(udev_device, attr_name));\n\n    virStringStripControlChars(*value);\n\n    if (*value != NULL && (STREQ(*value, \"\")))\n        VIR_FREE(*value);\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetStringSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name,\n                       char **value)\n{\n    *value = g_strdup(udevGetDeviceSysfsAttr(udev_device, attr_name));\n\n    virStringStripControlChars(*value);\n\n    if (*value != NULL && (STREQ(*value, \"\")))\n        VIR_FREE(*value);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetStringProperty",
          "args": [
            "device",
            "\"INTERFACE\"",
            "&net->ifname"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetStringProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "151-159",
          "snippet": "static int\nudevGetStringProperty(struct udev_device *udev_device,\n                      const char *property_key,\n                      char **value)\n{\n    *value = g_strdup(udevGetDeviceProperty(udev_device, property_key));\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetStringProperty(struct udev_device *udev_device,\n                      const char *property_key,\n                      char **value)\n{\n    *value = g_strdup(udevGetDeviceProperty(udev_device, property_key));\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "devtype",
            "\"wlan\""
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_devtype",
          "args": [
            "device"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessNetworkInterface(struct udev_device *device,\n                            virNodeDeviceDefPtr def)\n{\n    const char *devtype = udev_device_get_devtype(device);\n    virNodeDevCapNetPtr net = &def->caps->data.net;\n\n    if (devtype && STREQ(devtype, \"wlan\")) {\n        net->subtype = VIR_NODE_DEV_CAP_NET_80211;\n    } else {\n        net->subtype = VIR_NODE_DEV_CAP_NET_80203;\n    }\n\n    if (udevGetStringProperty(device,\n                              \"INTERFACE\",\n                              &net->ifname) < 0)\n        return -1;\n\n    if (udevGetStringSysfsAttr(device, \"address\",\n                               &net->address) < 0)\n        return -1;\n\n    if (udevGetUintSysfsAttr(device, \"addr_len\", &net->address_len, 0) < 0)\n        return -1;\n\n    if (udevGenerateDeviceName(device, def, net->address) != 0)\n        return -1;\n\n    if (virNetDevGetLinkInfo(net->ifname, &net->lnk) < 0)\n        return -1;\n\n    if (virNetDevGetFeatures(net->ifname, &net->features) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "udevProcessUSBInterface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "533-559",
    "snippet": "static int\nudevProcessUSBInterface(struct udev_device *device,\n                        virNodeDeviceDefPtr def)\n{\n    virNodeDevCapUSBIfPtr usb_if = &def->caps->data.usb_if;\n\n    if (udevGetUintSysfsAttr(device, \"bInterfaceNumber\",\n                             &usb_if->number, 16) < 0)\n        return -1;\n\n    if (udevGetUintSysfsAttr(device, \"bInterfaceClass\",\n                             &usb_if->klass, 16) < 0)\n        return -1;\n\n    if (udevGetUintSysfsAttr(device, \"bInterfaceSubClass\",\n                             &usb_if->subclass, 16) < 0)\n        return -1;\n\n    if (udevGetUintSysfsAttr(device, \"bInterfaceProtocol\",\n                             &usb_if->protocol, 16) < 0)\n        return -1;\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevGenerateDeviceName",
          "args": [
            "device",
            "def",
            "NULL"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "udevGenerateDeviceName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "291-314",
          "snippet": "static int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetUintSysfsAttr",
          "args": [
            "device",
            "\"bInterfaceProtocol\"",
            "&usb_if->protocol",
            "16"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetUintSysfsAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "252-269",
          "snippet": "static int\nudevGetUintSysfsAttr(struct udev_device *udev_device,\n                     const char *attr_name,\n                     unsigned int *value,\n                     int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_ui(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to unsigned int\"), str);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetUintSysfsAttr(struct udev_device *udev_device,\n                     const char *attr_name,\n                     unsigned int *value,\n                     int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_ui(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to unsigned int\"), str);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessUSBInterface(struct udev_device *device,\n                        virNodeDeviceDefPtr def)\n{\n    virNodeDevCapUSBIfPtr usb_if = &def->caps->data.usb_if;\n\n    if (udevGetUintSysfsAttr(device, \"bInterfaceNumber\",\n                             &usb_if->number, 16) < 0)\n        return -1;\n\n    if (udevGetUintSysfsAttr(device, \"bInterfaceClass\",\n                             &usb_if->klass, 16) < 0)\n        return -1;\n\n    if (udevGetUintSysfsAttr(device, \"bInterfaceSubClass\",\n                             &usb_if->subclass, 16) < 0)\n        return -1;\n\n    if (udevGetUintSysfsAttr(device, \"bInterfaceProtocol\",\n                             &usb_if->protocol, 16) < 0)\n        return -1;\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "udevProcessUSBDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "490-530",
    "snippet": "static int\nudevProcessUSBDevice(struct udev_device *device,\n                     virNodeDeviceDefPtr def)\n{\n    virNodeDevCapUSBDevPtr usb_dev = &def->caps->data.usb_dev;\n\n    if (udevGetUintProperty(device, \"BUSNUM\", &usb_dev->bus, 10) < 0)\n        return -1;\n    if (udevGetUintProperty(device, \"DEVNUM\", &usb_dev->device, 10) < 0)\n        return -1;\n    if (udevGetUintProperty(device, \"ID_VENDOR_ID\", &usb_dev->vendor, 16) < 0)\n        return -1;\n\n    if (udevGetStringProperty(device,\n                              \"ID_VENDOR_FROM_DATABASE\",\n                              &usb_dev->vendor_name) < 0)\n        return -1;\n\n    if (!usb_dev->vendor_name &&\n        udevGetStringSysfsAttr(device, \"manufacturer\",\n                               &usb_dev->vendor_name) < 0)\n        return -1;\n\n    if (udevGetUintProperty(device, \"ID_MODEL_ID\", &usb_dev->product, 16) < 0)\n        return -1;\n\n    if (udevGetStringProperty(device,\n                              \"ID_MODEL_FROM_DATABASE\",\n                              &usb_dev->product_name) < 0)\n        return -1;\n\n    if (!usb_dev->product_name &&\n        udevGetStringSysfsAttr(device, \"product\",\n                               &usb_dev->product_name) < 0)\n        return -1;\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udevGenerateDeviceName",
          "args": [
            "device",
            "def",
            "NULL"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "udevGenerateDeviceName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "291-314",
          "snippet": "static int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetStringSysfsAttr",
          "args": [
            "device",
            "\"product\"",
            "&usb_dev->product_name"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetStringSysfsAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "216-229",
          "snippet": "static int\nudevGetStringSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name,\n                       char **value)\n{\n    *value = g_strdup(udevGetDeviceSysfsAttr(udev_device, attr_name));\n\n    virStringStripControlChars(*value);\n\n    if (*value != NULL && (STREQ(*value, \"\")))\n        VIR_FREE(*value);\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetStringSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name,\n                       char **value)\n{\n    *value = g_strdup(udevGetDeviceSysfsAttr(udev_device, attr_name));\n\n    virStringStripControlChars(*value);\n\n    if (*value != NULL && (STREQ(*value, \"\")))\n        VIR_FREE(*value);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetStringProperty",
          "args": [
            "device",
            "\"ID_MODEL_FROM_DATABASE\"",
            "&usb_dev->product_name"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetStringProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "151-159",
          "snippet": "static int\nudevGetStringProperty(struct udev_device *udev_device,\n                      const char *property_key,\n                      char **value)\n{\n    *value = g_strdup(udevGetDeviceProperty(udev_device, property_key));\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetStringProperty(struct udev_device *udev_device,\n                      const char *property_key,\n                      char **value)\n{\n    *value = g_strdup(udevGetDeviceProperty(udev_device, property_key));\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetUintProperty",
          "args": [
            "device",
            "\"ID_MODEL_ID\"",
            "&usb_dev->product",
            "16"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetUintProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "181-197",
          "snippet": "static int\nudevGetUintProperty(struct udev_device *udev_device,\n                    const char *property_key,\n                    unsigned int *value,\n                    int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceProperty(udev_device, property_key);\n\n    if (str && virStrToLong_ui(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetUintProperty(struct udev_device *udev_device,\n                    const char *property_key,\n                    unsigned int *value,\n                    int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceProperty(udev_device, property_key);\n\n    if (str && virStrToLong_ui(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessUSBDevice(struct udev_device *device,\n                     virNodeDeviceDefPtr def)\n{\n    virNodeDevCapUSBDevPtr usb_dev = &def->caps->data.usb_dev;\n\n    if (udevGetUintProperty(device, \"BUSNUM\", &usb_dev->bus, 10) < 0)\n        return -1;\n    if (udevGetUintProperty(device, \"DEVNUM\", &usb_dev->device, 10) < 0)\n        return -1;\n    if (udevGetUintProperty(device, \"ID_VENDOR_ID\", &usb_dev->vendor, 16) < 0)\n        return -1;\n\n    if (udevGetStringProperty(device,\n                              \"ID_VENDOR_FROM_DATABASE\",\n                              &usb_dev->vendor_name) < 0)\n        return -1;\n\n    if (!usb_dev->vendor_name &&\n        udevGetStringSysfsAttr(device, \"manufacturer\",\n                               &usb_dev->vendor_name) < 0)\n        return -1;\n\n    if (udevGetUintProperty(device, \"ID_MODEL_ID\", &usb_dev->product, 16) < 0)\n        return -1;\n\n    if (udevGetStringProperty(device,\n                              \"ID_MODEL_FROM_DATABASE\",\n                              &usb_dev->product_name) < 0)\n        return -1;\n\n    if (!usb_dev->product_name &&\n        udevGetStringSysfsAttr(device, \"product\",\n                               &usb_dev->product_name) < 0)\n        return -1;\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "udevProcessDRMDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "468-487",
    "snippet": "static int\nudevProcessDRMDevice(struct udev_device *device,\n                     virNodeDeviceDefPtr def)\n{\n    virNodeDevCapDRMPtr drm = &def->caps->data.drm;\n    int minor;\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    if (udevGetIntProperty(device, \"MINOR\", &minor, 10) < 0)\n        return -1;\n\n    if ((minor = drmGetMinorType(minor)) == -1)\n        return -1;\n\n    drm->type = minor;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "drmGetMinorType",
          "args": [
            "minor"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "drmGetMinorType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "449-465",
          "snippet": "static int\ndrmGetMinorType(int minor)\n{\n    int type = minor >> 6;\n\n    if (minor < 0)\n        return -1;\n\n    switch (type) {\n    case VIR_NODE_DEV_DRM_PRIMARY:\n    case VIR_NODE_DEV_DRM_CONTROL:\n    case VIR_NODE_DEV_DRM_RENDER:\n        return type;\n    default:\n        return -1;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\ndrmGetMinorType(int minor)\n{\n    int type = minor >> 6;\n\n    if (minor < 0)\n        return -1;\n\n    switch (type) {\n    case VIR_NODE_DEV_DRM_PRIMARY:\n    case VIR_NODE_DEV_DRM_CONTROL:\n    case VIR_NODE_DEV_DRM_RENDER:\n        return type;\n    default:\n        return -1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetIntProperty",
          "args": [
            "device",
            "\"MINOR\"",
            "&minor",
            "10"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetIntProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "162-178",
          "snippet": "static int\nudevGetIntProperty(struct udev_device *udev_device,\n                   const char *property_key,\n                   int *value,\n                   int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceProperty(udev_device, property_key);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetIntProperty(struct udev_device *udev_device,\n                   const char *property_key,\n                   int *value,\n                   int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceProperty(udev_device, property_key);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGenerateDeviceName",
          "args": [
            "device",
            "def",
            "NULL"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "udevGenerateDeviceName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "291-314",
          "snippet": "static int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessDRMDevice(struct udev_device *device,\n                     virNodeDeviceDefPtr def)\n{\n    virNodeDevCapDRMPtr drm = &def->caps->data.drm;\n    int minor;\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        return -1;\n\n    if (udevGetIntProperty(device, \"MINOR\", &minor, 10) < 0)\n        return -1;\n\n    if ((minor = drmGetMinorType(minor)) == -1)\n        return -1;\n\n    drm->type = minor;\n\n    return 0;\n}"
  },
  {
    "function_name": "drmGetMinorType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "449-465",
    "snippet": "static int\ndrmGetMinorType(int minor)\n{\n    int type = minor >> 6;\n\n    if (minor < 0)\n        return -1;\n\n    switch (type) {\n    case VIR_NODE_DEV_DRM_PRIMARY:\n    case VIR_NODE_DEV_DRM_CONTROL:\n    case VIR_NODE_DEV_DRM_RENDER:\n        return type;\n    default:\n        return -1;\n    }\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\ndrmGetMinorType(int minor)\n{\n    int type = minor >> 6;\n\n    if (minor < 0)\n        return -1;\n\n    switch (type) {\n    case VIR_NODE_DEV_DRM_PRIMARY:\n    case VIR_NODE_DEV_DRM_CONTROL:\n    case VIR_NODE_DEV_DRM_RENDER:\n        return type;\n    default:\n        return -1;\n    }\n}"
  },
  {
    "function_name": "udevProcessPCI",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "348-446",
    "snippet": "static int\nudevProcessPCI(struct udev_device *device,\n               virNodeDeviceDefPtr def)\n{\n    virNodeDevCapPCIDevPtr pci_dev = &def->caps->data.pci_dev;\n    virPCIEDeviceInfoPtr pci_express = NULL;\n    virPCIDevicePtr pciDev = NULL;\n    int ret = -1;\n    char *p;\n    bool privileged;\n\n    nodeDeviceLock();\n    privileged = driver->privileged;\n    nodeDeviceUnlock();\n\n    pci_dev->klass = -1;\n    if (udevGetIntProperty(device, \"PCI_CLASS\", &pci_dev->klass, 16) < 0)\n        goto cleanup;\n\n    if ((p = strrchr(def->sysfs_path, '/')) == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &pci_dev->domain) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &pci_dev->bus) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &pci_dev->slot) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &pci_dev->function) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse the PCI address from sysfs path: '%s'\"),\n                       def->sysfs_path);\n        goto cleanup;\n    }\n\n    if (udevGetUintSysfsAttr(device, \"vendor\", &pci_dev->vendor, 16) < 0)\n        goto cleanup;\n\n    if (udevGetUintSysfsAttr(device, \"device\", &pci_dev->product, 16) < 0)\n        goto cleanup;\n\n    if (udevTranslatePCIIds(pci_dev->vendor,\n                            pci_dev->product,\n                            &pci_dev->vendor_name,\n                            &pci_dev->product_name) != 0) {\n        goto cleanup;\n    }\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        goto cleanup;\n\n    /* The default value is -1, because it can't be 0\n     * as zero is valid node number. */\n    pci_dev->numa_node = -1;\n    if (udevGetIntSysfsAttr(device, \"numa_node\",\n                            &pci_dev->numa_node, 10) < 0)\n        goto cleanup;\n\n    if (virNodeDeviceGetPCIDynamicCaps(def->sysfs_path, pci_dev) < 0)\n        goto cleanup;\n\n    if (!(pciDev = virPCIDeviceNew(pci_dev->domain,\n                                   pci_dev->bus,\n                                   pci_dev->slot,\n                                   pci_dev->function)))\n        goto cleanup;\n\n    /* We need to be root to read PCI device configs */\n    if (privileged) {\n        if (virPCIGetHeaderType(pciDev, &pci_dev->hdrType) < 0)\n            goto cleanup;\n\n        if (virPCIDeviceIsPCIExpress(pciDev) > 0) {\n            if (VIR_ALLOC(pci_express) < 0)\n                goto cleanup;\n\n            if (virPCIDeviceHasPCIExpressLink(pciDev) > 0) {\n                if (VIR_ALLOC(pci_express->link_cap) < 0 ||\n                    VIR_ALLOC(pci_express->link_sta) < 0)\n                    goto cleanup;\n\n                if (virPCIDeviceGetLinkCapSta(pciDev,\n                                              &pci_express->link_cap->port,\n                                              &pci_express->link_cap->speed,\n                                              &pci_express->link_cap->width,\n                                              &pci_express->link_sta->speed,\n                                              &pci_express->link_sta->width) < 0)\n                    goto cleanup;\n\n                pci_express->link_sta->port = -1; /* PCIe can't negotiate port. Yet :) */\n            }\n            pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCIE;\n            pci_dev->pci_express = pci_express;\n            pci_express = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virPCIDeviceFree(pciDev);\n    virPCIEDeviceInfoFree(pci_express);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIEDeviceInfoFree",
          "args": [
            "pci_express"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIEDeviceInfoFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2840-2849",
          "snippet": "void\nvirPCIEDeviceInfoFree(virPCIEDeviceInfoPtr dev)\n{\n    if (!dev)\n        return;\n\n    VIR_FREE(dev->link_cap);\n    VIR_FREE(dev->link_sta);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIEDeviceInfoFree(virPCIEDeviceInfoPtr dev)\n{\n    if (!dev)\n        return;\n\n    VIR_FREE(dev->link_cap);\n    VIR_FREE(dev->link_sta);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceFree",
          "args": [
            "pciDev"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1439-1450",
          "snippet": "void\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetLinkCapSta",
          "args": [
            "pciDev",
            "&pci_express->link_cap->port",
            "&pci_express->link_cap->speed",
            "&pci_express->link_cap->width",
            "&pci_express->link_sta->speed",
            "&pci_express->link_sta->width"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetLinkCapSta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2769-2809",
          "snippet": "int\nvirPCIDeviceGetLinkCapSta(virPCIDevicePtr dev,\n                          int *cap_port,\n                          unsigned int *cap_speed,\n                          unsigned int *cap_width,\n                          unsigned int *sta_speed,\n                          unsigned int *sta_width)\n{\n    uint32_t t;\n    int fd;\n    int ret = -1;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return ret;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    if (!dev->pcie_cap_pos) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"pci device %s is not a PCI-Express device\"),\n                       dev->name);\n        goto cleanup;\n    }\n\n    t = virPCIDeviceRead32(dev, fd, dev->pcie_cap_pos + PCI_EXP_LNKCAP);\n\n    *cap_port = t >> 24;\n    *cap_speed = t & PCI_EXP_LNKCAP_SPEED;\n    *cap_width = (t & PCI_EXP_LNKCAP_WIDTH) >> 4;\n\n    t = virPCIDeviceRead16(dev, fd, dev->pcie_cap_pos + PCI_EXP_LNKSTA);\n\n    *sta_speed = t & PCI_EXP_LNKSTA_SPEED;\n    *sta_width = (t & PCI_EXP_LNKSTA_WIDTH) >> 4;\n    ret = 0;\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_EXP_LNKSTA_WIDTH    0x03f0  /* Negotiated Link Width */",
            "#define PCI_EXP_LNKSTA_SPEED    0x000f  /* Negotiated Link Speed */",
            "#define PCI_EXP_LNKSTA          0x12    /* Link Status */",
            "#define PCI_EXP_LNKCAP_WIDTH    0x003f0 /* Maximum Link Width */",
            "#define PCI_EXP_LNKCAP_SPEED    0x0000f /* Maximum Link Speed */",
            "#define PCI_EXP_LNKCAP          0xc     /* Link Capabilities */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_EXP_LNKSTA_WIDTH    0x03f0  /* Negotiated Link Width */\n#define PCI_EXP_LNKSTA_SPEED    0x000f  /* Negotiated Link Speed */\n#define PCI_EXP_LNKSTA          0x12    /* Link Status */\n#define PCI_EXP_LNKCAP_WIDTH    0x003f0 /* Maximum Link Width */\n#define PCI_EXP_LNKCAP_SPEED    0x0000f /* Maximum Link Speed */\n#define PCI_EXP_LNKCAP          0xc     /* Link Capabilities */\n\nint\nvirPCIDeviceGetLinkCapSta(virPCIDevicePtr dev,\n                          int *cap_port,\n                          unsigned int *cap_speed,\n                          unsigned int *cap_width,\n                          unsigned int *sta_speed,\n                          unsigned int *sta_width)\n{\n    uint32_t t;\n    int fd;\n    int ret = -1;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return ret;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    if (!dev->pcie_cap_pos) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"pci device %s is not a PCI-Express device\"),\n                       dev->name);\n        goto cleanup;\n    }\n\n    t = virPCIDeviceRead32(dev, fd, dev->pcie_cap_pos + PCI_EXP_LNKCAP);\n\n    *cap_port = t >> 24;\n    *cap_speed = t & PCI_EXP_LNKCAP_SPEED;\n    *cap_width = (t & PCI_EXP_LNKCAP_WIDTH) >> 4;\n\n    t = virPCIDeviceRead16(dev, fd, dev->pcie_cap_pos + PCI_EXP_LNKSTA);\n\n    *sta_speed = t & PCI_EXP_LNKSTA_SPEED;\n    *sta_width = (t & PCI_EXP_LNKSTA_WIDTH) >> 4;\n    ret = 0;\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "pci_express->link_sta"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "pci_express->link_cap"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceHasPCIExpressLink",
          "args": [
            "pciDev"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceHasPCIExpressLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2746-2767",
          "snippet": "int\nvirPCIDeviceHasPCIExpressLink(virPCIDevicePtr dev)\n{\n    int fd;\n    int ret = -1;\n    uint16_t cap, type;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return ret;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    cap = virPCIDeviceRead16(dev, fd, dev->pcie_cap_pos + PCI_CAP_FLAGS);\n    type = (cap & PCI_EXP_FLAGS_TYPE) >> 4;\n\n    ret = type != PCI_EXP_TYPE_ROOT_INT_EP && type != PCI_EXP_TYPE_ROOT_EC;\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_EXP_TYPE_ROOT_EC 0xa        /* Root Complex Event Collector */",
            "#define PCI_EXP_TYPE_ROOT_INT_EP 0x9    /* Root Complex Integrated Endpoint */",
            "#define PCI_EXP_FLAGS_TYPE      0x00f0",
            "#define PCI_CAP_FLAGS           2       /* Capability defined flags (16 bits) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_EXP_TYPE_ROOT_EC 0xa        /* Root Complex Event Collector */\n#define PCI_EXP_TYPE_ROOT_INT_EP 0x9    /* Root Complex Integrated Endpoint */\n#define PCI_EXP_FLAGS_TYPE      0x00f0\n#define PCI_CAP_FLAGS           2       /* Capability defined flags (16 bits) */\n\nint\nvirPCIDeviceHasPCIExpressLink(virPCIDevicePtr dev)\n{\n    int fd;\n    int ret = -1;\n    uint16_t cap, type;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return ret;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    cap = virPCIDeviceRead16(dev, fd, dev->pcie_cap_pos + PCI_CAP_FLAGS);\n    type = (cap & PCI_EXP_FLAGS_TYPE) >> 4;\n\n    ret = type != PCI_EXP_TYPE_ROOT_INT_EP && type != PCI_EXP_TYPE_ROOT_EC;\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "pci_express"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceIsPCIExpress",
          "args": [
            "pciDev"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceIsPCIExpress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2727-2744",
          "snippet": "int\nvirPCIDeviceIsPCIExpress(virPCIDevicePtr dev)\n{\n    int fd;\n    int ret = -1;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return ret;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    ret = dev->pcie_cap_pos != 0;\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceIsPCIExpress(virPCIDevicePtr dev)\n{\n    int fd;\n    int ret = -1;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return ret;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    ret = dev->pcie_cap_pos != 0;\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIGetHeaderType",
          "args": [
            "pciDev",
            "&pci_dev->hdrType"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIGetHeaderType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2812-2837",
          "snippet": "int virPCIGetHeaderType(virPCIDevicePtr dev, int *hdrType)\n{\n    int fd;\n    uint8_t type;\n\n    *hdrType = -1;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return -1;\n\n    type = virPCIDeviceRead8(dev, fd, PCI_HEADER_TYPE);\n\n    virPCIDeviceConfigClose(dev, fd);\n\n    type &= PCI_HEADER_TYPE_MASK;\n    if (type >= VIR_PCI_HEADER_LAST) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown PCI header type '%d' for device '%s'\"),\n                       type, dev->name);\n        return -1;\n    }\n\n    *hdrType = type;\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_HEADER_TYPE_MASK   0x7f",
            "#define PCI_HEADER_TYPE         0x0e    /* Header type */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_HEADER_TYPE_MASK   0x7f\n#define PCI_HEADER_TYPE         0x0e    /* Header type */\n\nint virPCIGetHeaderType(virPCIDevicePtr dev, int *hdrType)\n{\n    int fd;\n    uint8_t type;\n\n    *hdrType = -1;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return -1;\n\n    type = virPCIDeviceRead8(dev, fd, PCI_HEADER_TYPE);\n\n    virPCIDeviceConfigClose(dev, fd);\n\n    type &= PCI_HEADER_TYPE_MASK;\n    if (type >= VIR_PCI_HEADER_LAST) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown PCI header type '%d' for device '%s'\"),\n                       type, dev->name);\n        return -1;\n    }\n\n    *hdrType = type;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceNew",
          "args": [
            "pci_dev->domain",
            "pci_dev->bus",
            "pci_dev->slot",
            "pci_dev->function"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1364-1416",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nvirPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceGetPCIDynamicCaps",
          "args": [
            "def->sysfs_path",
            "pci_dev"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceGetPCIDynamicCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2608-2613",
          "snippet": "int\nvirNodeDeviceGetPCIDynamicCaps(const char *sysfsPath G_GNUC_UNUSED,\n                               virNodeDevCapPCIDevPtr pci_dev G_GNUC_UNUSED)\n{\n    return -1;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNodeDeviceGetPCIDynamicCaps(const char *sysfsPath G_GNUC_UNUSED,\n                               virNodeDevCapPCIDevPtr pci_dev G_GNUC_UNUSED)\n{\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetIntSysfsAttr",
          "args": [
            "device",
            "\"numa_node\"",
            "&pci_dev->numa_node",
            "10"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetIntSysfsAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "232-249",
          "snippet": "static int\nudevGetIntSysfsAttr(struct udev_device *udev_device,\n                    const char *attr_name,\n                    int *value,\n                    int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetIntSysfsAttr(struct udev_device *udev_device,\n                    const char *attr_name,\n                    int *value,\n                    int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGenerateDeviceName",
          "args": [
            "device",
            "def",
            "NULL"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "udevGenerateDeviceName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "291-314",
          "snippet": "static int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevTranslatePCIIds",
          "args": [
            "pci_dev->vendor",
            "pci_dev->product",
            "&pci_dev->vendor_name",
            "&pci_dev->product_name"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "udevTranslatePCIIds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "317-345",
          "snippet": "static int\nudevTranslatePCIIds(unsigned int vendor,\n                    unsigned int product,\n                    char **vendor_string,\n                    char **product_string)\n{\n    struct pci_id_match m;\n    const char *vendor_name = NULL, *device_name = NULL;\n\n    m.vendor_id = vendor;\n    m.device_id = product;\n    m.subvendor_id = PCI_MATCH_ANY;\n    m.subdevice_id = PCI_MATCH_ANY;\n    m.device_class = 0;\n    m.device_class_mask = 0;\n    m.match_data = 0;\n\n    /* pci_get_strings returns void */\n    pci_get_strings(&m,\n                    &device_name,\n                    &vendor_name,\n                    NULL,\n                    NULL);\n\n    *vendor_string = g_strdup(vendor_name);\n    *product_string = g_strdup(device_name);\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevTranslatePCIIds(unsigned int vendor,\n                    unsigned int product,\n                    char **vendor_string,\n                    char **product_string)\n{\n    struct pci_id_match m;\n    const char *vendor_name = NULL, *device_name = NULL;\n\n    m.vendor_id = vendor;\n    m.device_id = product;\n    m.subvendor_id = PCI_MATCH_ANY;\n    m.subdevice_id = PCI_MATCH_ANY;\n    m.device_class = 0;\n    m.device_class_mask = 0;\n    m.match_data = 0;\n\n    /* pci_get_strings returns void */\n    pci_get_strings(&m,\n                    &device_name,\n                    &vendor_name,\n                    NULL,\n                    NULL);\n\n    *vendor_string = g_strdup(vendor_name);\n    *product_string = g_strdup(device_name);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetUintSysfsAttr",
          "args": [
            "device",
            "\"device\"",
            "&pci_dev->product",
            "16"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetUintSysfsAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "252-269",
          "snippet": "static int\nudevGetUintSysfsAttr(struct udev_device *udev_device,\n                     const char *attr_name,\n                     unsigned int *value,\n                     int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_ui(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to unsigned int\"), str);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetUintSysfsAttr(struct udev_device *udev_device,\n                     const char *attr_name,\n                     unsigned int *value,\n                     int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_ui(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to unsigned int\"), str);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to parse the PCI address from sysfs path: '%s'\")",
            "def->sysfs_path"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to parse the PCI address from sysfs path: '%s'\""
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "p + 1",
            "&p",
            "16",
            "&pci_dev->function"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "def->sysfs_path",
            "'/'"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udevGetIntProperty",
          "args": [
            "device",
            "\"PCI_CLASS\"",
            "&pci_dev->klass",
            "16"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetIntProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "162-178",
          "snippet": "static int\nudevGetIntProperty(struct udev_device *udev_device,\n                   const char *property_key,\n                   int *value,\n                   int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceProperty(udev_device, property_key);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetIntProperty(struct udev_device *udev_device,\n                   const char *property_key,\n                   int *value,\n                   int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceProperty(udev_device, property_key);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodeDeviceUnlock",
          "args": [],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "nodeDeviceUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_driver.c",
          "lines": "152-156",
          "snippet": "void\nnodeDeviceUnlock(void)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virvhba.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virNodeDeviceDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"viraccessapicheck.h\"\n#include \"virvhba.h\"\n#include \"node_device_util.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <time.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNodeDeviceDriverStatePtr driver;\n\nvoid\nnodeDeviceUnlock(void)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodeDeviceLock",
          "args": [],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "nodeDeviceLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_driver.c",
          "lines": "145-149",
          "snippet": "void\nnodeDeviceLock(void)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virvhba.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virNodeDeviceDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"viraccessapicheck.h\"\n#include \"virvhba.h\"\n#include \"node_device_util.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <time.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNodeDeviceDriverStatePtr driver;\n\nvoid\nnodeDeviceLock(void)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevProcessPCI(struct udev_device *device,\n               virNodeDeviceDefPtr def)\n{\n    virNodeDevCapPCIDevPtr pci_dev = &def->caps->data.pci_dev;\n    virPCIEDeviceInfoPtr pci_express = NULL;\n    virPCIDevicePtr pciDev = NULL;\n    int ret = -1;\n    char *p;\n    bool privileged;\n\n    nodeDeviceLock();\n    privileged = driver->privileged;\n    nodeDeviceUnlock();\n\n    pci_dev->klass = -1;\n    if (udevGetIntProperty(device, \"PCI_CLASS\", &pci_dev->klass, 16) < 0)\n        goto cleanup;\n\n    if ((p = strrchr(def->sysfs_path, '/')) == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &pci_dev->domain) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &pci_dev->bus) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &pci_dev->slot) < 0 || p == NULL ||\n        virStrToLong_ui(p + 1, &p, 16, &pci_dev->function) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse the PCI address from sysfs path: '%s'\"),\n                       def->sysfs_path);\n        goto cleanup;\n    }\n\n    if (udevGetUintSysfsAttr(device, \"vendor\", &pci_dev->vendor, 16) < 0)\n        goto cleanup;\n\n    if (udevGetUintSysfsAttr(device, \"device\", &pci_dev->product, 16) < 0)\n        goto cleanup;\n\n    if (udevTranslatePCIIds(pci_dev->vendor,\n                            pci_dev->product,\n                            &pci_dev->vendor_name,\n                            &pci_dev->product_name) != 0) {\n        goto cleanup;\n    }\n\n    if (udevGenerateDeviceName(device, def, NULL) != 0)\n        goto cleanup;\n\n    /* The default value is -1, because it can't be 0\n     * as zero is valid node number. */\n    pci_dev->numa_node = -1;\n    if (udevGetIntSysfsAttr(device, \"numa_node\",\n                            &pci_dev->numa_node, 10) < 0)\n        goto cleanup;\n\n    if (virNodeDeviceGetPCIDynamicCaps(def->sysfs_path, pci_dev) < 0)\n        goto cleanup;\n\n    if (!(pciDev = virPCIDeviceNew(pci_dev->domain,\n                                   pci_dev->bus,\n                                   pci_dev->slot,\n                                   pci_dev->function)))\n        goto cleanup;\n\n    /* We need to be root to read PCI device configs */\n    if (privileged) {\n        if (virPCIGetHeaderType(pciDev, &pci_dev->hdrType) < 0)\n            goto cleanup;\n\n        if (virPCIDeviceIsPCIExpress(pciDev) > 0) {\n            if (VIR_ALLOC(pci_express) < 0)\n                goto cleanup;\n\n            if (virPCIDeviceHasPCIExpressLink(pciDev) > 0) {\n                if (VIR_ALLOC(pci_express->link_cap) < 0 ||\n                    VIR_ALLOC(pci_express->link_sta) < 0)\n                    goto cleanup;\n\n                if (virPCIDeviceGetLinkCapSta(pciDev,\n                                              &pci_express->link_cap->port,\n                                              &pci_express->link_cap->speed,\n                                              &pci_express->link_cap->width,\n                                              &pci_express->link_sta->speed,\n                                              &pci_express->link_sta->width) < 0)\n                    goto cleanup;\n\n                pci_express->link_sta->port = -1; /* PCIe can't negotiate port. Yet :) */\n            }\n            pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCIE;\n            pci_dev->pci_express = pci_express;\n            pci_express = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virPCIDeviceFree(pciDev);\n    virPCIEDeviceInfoFree(pci_express);\n    return ret;\n}"
  },
  {
    "function_name": "udevTranslatePCIIds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "317-345",
    "snippet": "static int\nudevTranslatePCIIds(unsigned int vendor,\n                    unsigned int product,\n                    char **vendor_string,\n                    char **product_string)\n{\n    struct pci_id_match m;\n    const char *vendor_name = NULL, *device_name = NULL;\n\n    m.vendor_id = vendor;\n    m.device_id = product;\n    m.subvendor_id = PCI_MATCH_ANY;\n    m.subdevice_id = PCI_MATCH_ANY;\n    m.device_class = 0;\n    m.device_class_mask = 0;\n    m.match_data = 0;\n\n    /* pci_get_strings returns void */\n    pci_get_strings(&m,\n                    &device_name,\n                    &vendor_name,\n                    NULL,\n                    NULL);\n\n    *vendor_string = g_strdup(vendor_name);\n    *product_string = g_strdup(device_name);\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "device_name"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_get_strings",
          "args": [
            "&m",
            "&device_name",
            "&vendor_name",
            "NULL",
            "NULL"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevTranslatePCIIds(unsigned int vendor,\n                    unsigned int product,\n                    char **vendor_string,\n                    char **product_string)\n{\n    struct pci_id_match m;\n    const char *vendor_name = NULL, *device_name = NULL;\n\n    m.vendor_id = vendor;\n    m.device_id = product;\n    m.subvendor_id = PCI_MATCH_ANY;\n    m.subdevice_id = PCI_MATCH_ANY;\n    m.device_class = 0;\n    m.device_class_mask = 0;\n    m.match_data = 0;\n\n    /* pci_get_strings returns void */\n    pci_get_strings(&m,\n                    &device_name,\n                    &vendor_name,\n                    NULL,\n                    NULL);\n\n    *vendor_string = g_strdup(vendor_name);\n    *product_string = g_strdup(device_name);\n\n    return 0;\n}"
  },
  {
    "function_name": "udevGenerateDeviceName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "291-314",
    "snippet": "static int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_ascii_isalnum",
          "args": [
            "*(def->name + i)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "def->name"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"_%s\"",
            "s"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysname",
          "args": [
            "device"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_subsystem",
          "args": [
            "device"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGenerateDeviceName(struct udev_device *device,\n                       virNodeDeviceDefPtr def,\n                       const char *s)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s_%s\",\n                      udev_device_get_subsystem(device),\n                      udev_device_get_sysname(device));\n\n    if (s != NULL)\n        virBufferAsprintf(&buf, \"_%s\", s);\n\n    def->name = virBufferContentAndReset(&buf);\n\n    for (i = 0; i < strlen(def->name); i++) {\n        if (!(g_ascii_isalnum(*(def->name + i))))\n            *(def->name + i) = '_';\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "udevGetUint64SysfsAttr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "272-288",
    "snippet": "static int\nudevGetUint64SysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name,\n                       unsigned long long *value)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_ull(str, NULL, 0, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to unsigned long long\"), str);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to convert '%s' to unsigned long long\")",
            "str"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to convert '%s' to unsigned long long\""
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ull",
          "args": [
            "str",
            "NULL",
            "0",
            "value"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ullp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "568-586",
          "snippet": "int\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetDeviceSysfsAttr",
          "args": [
            "udev_device",
            "attr_name"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetDeviceSysfsAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "200-213",
          "snippet": "static const char *\nudevGetDeviceSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name)\n{\n    const char *ret = NULL;\n\n    ret = udev_device_get_sysattr_value(udev_device, attr_name);\n\n    VIR_DEBUG(\"Found sysfs attribute '%s' value '%s' \"\n              \"for device with sysname '%s'\",\n              attr_name, NULLSTR(ret),\n              udev_device_get_sysname(udev_device));\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic const char *\nudevGetDeviceSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name)\n{\n    const char *ret = NULL;\n\n    ret = udev_device_get_sysattr_value(udev_device, attr_name);\n\n    VIR_DEBUG(\"Found sysfs attribute '%s' value '%s' \"\n              \"for device with sysname '%s'\",\n              attr_name, NULLSTR(ret),\n              udev_device_get_sysname(udev_device));\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetUint64SysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name,\n                       unsigned long long *value)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_ull(str, NULL, 0, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to unsigned long long\"), str);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "udevGetUintSysfsAttr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "252-269",
    "snippet": "static int\nudevGetUintSysfsAttr(struct udev_device *udev_device,\n                     const char *attr_name,\n                     unsigned int *value,\n                     int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_ui(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to unsigned int\"), str);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to convert '%s' to unsigned int\")",
            "str"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to convert '%s' to unsigned int\""
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "str",
            "NULL",
            "base",
            "value"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetDeviceSysfsAttr",
          "args": [
            "udev_device",
            "attr_name"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetDeviceSysfsAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "200-213",
          "snippet": "static const char *\nudevGetDeviceSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name)\n{\n    const char *ret = NULL;\n\n    ret = udev_device_get_sysattr_value(udev_device, attr_name);\n\n    VIR_DEBUG(\"Found sysfs attribute '%s' value '%s' \"\n              \"for device with sysname '%s'\",\n              attr_name, NULLSTR(ret),\n              udev_device_get_sysname(udev_device));\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic const char *\nudevGetDeviceSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name)\n{\n    const char *ret = NULL;\n\n    ret = udev_device_get_sysattr_value(udev_device, attr_name);\n\n    VIR_DEBUG(\"Found sysfs attribute '%s' value '%s' \"\n              \"for device with sysname '%s'\",\n              attr_name, NULLSTR(ret),\n              udev_device_get_sysname(udev_device));\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetUintSysfsAttr(struct udev_device *udev_device,\n                     const char *attr_name,\n                     unsigned int *value,\n                     int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_ui(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to unsigned int\"), str);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "udevGetIntSysfsAttr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "232-249",
    "snippet": "static int\nudevGetIntSysfsAttr(struct udev_device *udev_device,\n                    const char *attr_name,\n                    int *value,\n                    int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to convert '%s' to int\")",
            "str"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to convert '%s' to int\""
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "str",
            "NULL",
            "base",
            "value"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetDeviceSysfsAttr",
          "args": [
            "udev_device",
            "attr_name"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetDeviceSysfsAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "200-213",
          "snippet": "static const char *\nudevGetDeviceSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name)\n{\n    const char *ret = NULL;\n\n    ret = udev_device_get_sysattr_value(udev_device, attr_name);\n\n    VIR_DEBUG(\"Found sysfs attribute '%s' value '%s' \"\n              \"for device with sysname '%s'\",\n              attr_name, NULLSTR(ret),\n              udev_device_get_sysname(udev_device));\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic const char *\nudevGetDeviceSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name)\n{\n    const char *ret = NULL;\n\n    ret = udev_device_get_sysattr_value(udev_device, attr_name);\n\n    VIR_DEBUG(\"Found sysfs attribute '%s' value '%s' \"\n              \"for device with sysname '%s'\",\n              attr_name, NULLSTR(ret),\n              udev_device_get_sysname(udev_device));\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetIntSysfsAttr(struct udev_device *udev_device,\n                    const char *attr_name,\n                    int *value,\n                    int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceSysfsAttr(udev_device, attr_name);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "udevGetStringSysfsAttr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "216-229",
    "snippet": "static int\nudevGetStringSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name,\n                       char **value)\n{\n    *value = g_strdup(udevGetDeviceSysfsAttr(udev_device, attr_name));\n\n    virStringStripControlChars(*value);\n\n    if (*value != NULL && (STREQ(*value, \"\")))\n        VIR_FREE(*value);\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*value"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "*value",
            "\"\""
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringStripControlChars",
          "args": [
            "*value"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "virStringStripControlChars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1219-1235",
          "snippet": "void\nvirStringStripControlChars(char *str)\n{\n    size_t len, i, j;\n\n    if (!str)\n        return;\n\n    len = strlen(str);\n    for (i = 0, j = 0; i < len; i++) {\n        if (strchr(control_chars, str[i]))\n            continue;\n\n        str[j++] = str[i];\n    }\n    str[j] = '\\0';\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char control_chars[] =\n    \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\"\n    \"\\x08\" /* \\t \\n */ \"\\x0B\\x0C\" /* \\r */ \"\\x0E\\x0F\"\n    \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\"\n    \"\\x18\\x19\\x1A\\x1B\\x1C\\x1D\\x1E\\x1F\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nstatic const char control_chars[] =\n    \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\"\n    \"\\x08\" /* \\t \\n */ \"\\x0B\\x0C\" /* \\r */ \"\\x0E\\x0F\"\n    \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\"\n    \"\\x18\\x19\\x1A\\x1B\\x1C\\x1D\\x1E\\x1F\";\n\nvoid\nvirStringStripControlChars(char *str)\n{\n    size_t len, i, j;\n\n    if (!str)\n        return;\n\n    len = strlen(str);\n    for (i = 0, j = 0; i < len; i++) {\n        if (strchr(control_chars, str[i]))\n            continue;\n\n        str[j++] = str[i];\n    }\n    str[j] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "udevGetDeviceSysfsAttr(udev_device, attr_name)"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetDeviceSysfsAttr",
          "args": [
            "udev_device",
            "attr_name"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetDeviceSysfsAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "200-213",
          "snippet": "static const char *\nudevGetDeviceSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name)\n{\n    const char *ret = NULL;\n\n    ret = udev_device_get_sysattr_value(udev_device, attr_name);\n\n    VIR_DEBUG(\"Found sysfs attribute '%s' value '%s' \"\n              \"for device with sysname '%s'\",\n              attr_name, NULLSTR(ret),\n              udev_device_get_sysname(udev_device));\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic const char *\nudevGetDeviceSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name)\n{\n    const char *ret = NULL;\n\n    ret = udev_device_get_sysattr_value(udev_device, attr_name);\n\n    VIR_DEBUG(\"Found sysfs attribute '%s' value '%s' \"\n              \"for device with sysname '%s'\",\n              attr_name, NULLSTR(ret),\n              udev_device_get_sysname(udev_device));\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetStringSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name,\n                       char **value)\n{\n    *value = g_strdup(udevGetDeviceSysfsAttr(udev_device, attr_name));\n\n    virStringStripControlChars(*value);\n\n    if (*value != NULL && (STREQ(*value, \"\")))\n        VIR_FREE(*value);\n\n    return 0;\n}"
  },
  {
    "function_name": "udevGetDeviceSysfsAttr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "200-213",
    "snippet": "static const char *\nudevGetDeviceSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name)\n{\n    const char *ret = NULL;\n\n    ret = udev_device_get_sysattr_value(udev_device, attr_name);\n\n    VIR_DEBUG(\"Found sysfs attribute '%s' value '%s' \"\n              \"for device with sysname '%s'\",\n              attr_name, NULLSTR(ret),\n              udev_device_get_sysname(udev_device));\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Found sysfs attribute '%s' value '%s' \"\n              \"for device with sysname '%s'\"",
            "attr_name",
            "NULLSTR(ret)",
            "udev_device_get_sysname(udev_device)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysname",
          "args": [
            "udev_device"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "ret"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysattr_value",
          "args": [
            "udev_device",
            "attr_name"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic const char *\nudevGetDeviceSysfsAttr(struct udev_device *udev_device,\n                       const char *attr_name)\n{\n    const char *ret = NULL;\n\n    ret = udev_device_get_sysattr_value(udev_device, attr_name);\n\n    VIR_DEBUG(\"Found sysfs attribute '%s' value '%s' \"\n              \"for device with sysname '%s'\",\n              attr_name, NULLSTR(ret),\n              udev_device_get_sysname(udev_device));\n    return ret;\n}"
  },
  {
    "function_name": "udevGetUintProperty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "181-197",
    "snippet": "static int\nudevGetUintProperty(struct udev_device *udev_device,\n                    const char *property_key,\n                    unsigned int *value,\n                    int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceProperty(udev_device, property_key);\n\n    if (str && virStrToLong_ui(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to convert '%s' to int\")",
            "str"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to convert '%s' to int\""
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "str",
            "NULL",
            "base",
            "value"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetDeviceProperty",
          "args": [
            "udev_device",
            "property_key"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetDeviceProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "136-148",
          "snippet": "static const char *\nudevGetDeviceProperty(struct udev_device *udev_device,\n                      const char *property_key)\n{\n    const char *ret = NULL;\n\n    ret = udev_device_get_property_value(udev_device, property_key);\n\n    VIR_DEBUG(\"Found property key '%s' value '%s' for device with sysname '%s'\",\n              property_key, NULLSTR(ret), udev_device_get_sysname(udev_device));\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic const char *\nudevGetDeviceProperty(struct udev_device *udev_device,\n                      const char *property_key)\n{\n    const char *ret = NULL;\n\n    ret = udev_device_get_property_value(udev_device, property_key);\n\n    VIR_DEBUG(\"Found property key '%s' value '%s' for device with sysname '%s'\",\n              property_key, NULLSTR(ret), udev_device_get_sysname(udev_device));\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetUintProperty(struct udev_device *udev_device,\n                    const char *property_key,\n                    unsigned int *value,\n                    int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceProperty(udev_device, property_key);\n\n    if (str && virStrToLong_ui(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "udevGetIntProperty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "162-178",
    "snippet": "static int\nudevGetIntProperty(struct udev_device *udev_device,\n                   const char *property_key,\n                   int *value,\n                   int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceProperty(udev_device, property_key);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to convert '%s' to int\")",
            "str"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to convert '%s' to int\""
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "str",
            "NULL",
            "base",
            "value"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetDeviceProperty",
          "args": [
            "udev_device",
            "property_key"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetDeviceProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "136-148",
          "snippet": "static const char *\nudevGetDeviceProperty(struct udev_device *udev_device,\n                      const char *property_key)\n{\n    const char *ret = NULL;\n\n    ret = udev_device_get_property_value(udev_device, property_key);\n\n    VIR_DEBUG(\"Found property key '%s' value '%s' for device with sysname '%s'\",\n              property_key, NULLSTR(ret), udev_device_get_sysname(udev_device));\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic const char *\nudevGetDeviceProperty(struct udev_device *udev_device,\n                      const char *property_key)\n{\n    const char *ret = NULL;\n\n    ret = udev_device_get_property_value(udev_device, property_key);\n\n    VIR_DEBUG(\"Found property key '%s' value '%s' for device with sysname '%s'\",\n              property_key, NULLSTR(ret), udev_device_get_sysname(udev_device));\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetIntProperty(struct udev_device *udev_device,\n                   const char *property_key,\n                   int *value,\n                   int base)\n{\n    const char *str = NULL;\n\n    str = udevGetDeviceProperty(udev_device, property_key);\n\n    if (str && virStrToLong_i(str, NULL, base, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to convert '%s' to int\"), str);\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "udevGetStringProperty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "151-159",
    "snippet": "static int\nudevGetStringProperty(struct udev_device *udev_device,\n                      const char *property_key,\n                      char **value)\n{\n    *value = g_strdup(udevGetDeviceProperty(udev_device, property_key));\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "udevGetDeviceProperty(udev_device, property_key)"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevGetDeviceProperty",
          "args": [
            "udev_device",
            "property_key"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "udevGetDeviceProperty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
          "lines": "136-148",
          "snippet": "static const char *\nudevGetDeviceProperty(struct udev_device *udev_device,\n                      const char *property_key)\n{\n    const char *ret = NULL;\n\n    ret = udev_device_get_property_value(udev_device, property_key);\n\n    VIR_DEBUG(\"Found property key '%s' value '%s' for device with sysname '%s'\",\n              property_key, NULLSTR(ret), udev_device_get_sysname(udev_device));\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virmdev.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_udev.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include <scsi/scsi.h>",
            "#include <pciaccess.h>",
            "#include <libudev.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic const char *\nudevGetDeviceProperty(struct udev_device *udev_device,\n                      const char *property_key)\n{\n    const char *ret = NULL;\n\n    ret = udev_device_get_property_value(udev_device, property_key);\n\n    VIR_DEBUG(\"Found property key '%s' value '%s' for device with sysname '%s'\",\n              property_key, NULLSTR(ret), udev_device_get_sysname(udev_device));\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevGetStringProperty(struct udev_device *udev_device,\n                      const char *property_key,\n                      char **value)\n{\n    *value = g_strdup(udevGetDeviceProperty(udev_device, property_key));\n\n    return 0;\n}"
  },
  {
    "function_name": "udevGetDeviceProperty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "136-148",
    "snippet": "static const char *\nudevGetDeviceProperty(struct udev_device *udev_device,\n                      const char *property_key)\n{\n    const char *ret = NULL;\n\n    ret = udev_device_get_property_value(udev_device, property_key);\n\n    VIR_DEBUG(\"Found property key '%s' value '%s' for device with sysname '%s'\",\n              property_key, NULLSTR(ret), udev_device_get_sysname(udev_device));\n\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Found property key '%s' value '%s' for device with sysname '%s'\"",
            "property_key",
            "NULLSTR(ret)",
            "udev_device_get_sysname(udev_device)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_sysname",
          "args": [
            "udev_device"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "ret"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_device_get_property_value",
          "args": [
            "udev_device",
            "property_key"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic const char *\nudevGetDeviceProperty(struct udev_device *udev_device,\n                      const char *property_key)\n{\n    const char *ret = NULL;\n\n    ret = udev_device_get_property_value(udev_device, property_key);\n\n    VIR_DEBUG(\"Found property key '%s' value '%s' for device with sysname '%s'\",\n              property_key, NULLSTR(ret), udev_device_get_sysname(udev_device));\n\n    return ret;\n}"
  },
  {
    "function_name": "udevHasDeviceProperty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "125-133",
    "snippet": "static bool\nudevHasDeviceProperty(struct udev_device *dev,\n                      const char *key)\n{\n    if (udev_device_get_property_value(dev, key))\n        return true;\n\n    return false;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udev_device_get_property_value",
          "args": [
            "dev",
            "key"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic bool\nudevHasDeviceProperty(struct udev_device *dev,\n                      const char *key)\n{\n    if (udev_device_get_property_value(dev, key))\n        return true;\n\n    return false;\n}"
  },
  {
    "function_name": "udevEventDataNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "104-122",
    "snippet": "static udevEventDataPtr\nudevEventDataNew(void)\n{\n    udevEventDataPtr ret = NULL;\n\n    if (udevEventDataInitialize() < 0)\n        return NULL;\n\n    if (!(ret = virObjectLockableNew(udevEventDataClass)))\n        return NULL;\n\n    if (virCondInit(&ret->threadCond) < 0) {\n        virObjectUnref(ret);\n        return NULL;\n    }\n\n    ret->watch = -1;\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr udevEventDataClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "ret"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondInit",
          "args": [
            "&ret->threadCond"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "virCondInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "125-133",
          "snippet": "int virCondInit(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_init(&c->cond, NULL)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondInit(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_init(&c->cond, NULL)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "udevEventDataClass"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udevEventDataInitialize",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic virClassPtr udevEventDataClass;\n\nstatic udevEventDataPtr\nudevEventDataNew(void)\n{\n    udevEventDataPtr ret = NULL;\n\n    if (udevEventDataInitialize() < 0)\n        return NULL;\n\n    if (!(ret = virObjectLockableNew(udevEventDataClass)))\n        return NULL;\n\n    if (virCondInit(&ret->threadCond) < 0) {\n        virObjectUnref(ret);\n        return NULL;\n    }\n\n    ret->watch = -1;\n    return ret;\n}"
  },
  {
    "function_name": "udevEventDataOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "93-100",
    "snippet": "static int\nudevEventDataOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(udevEventData, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "udevEventData",
            "virClassForObjectLockable()"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObjectLockable",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "116-123",
          "snippet": "virClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectLockableClass;\n\nvirClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic int\nudevEventDataOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(udevEventData, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "udevEventDataDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_udev.c",
    "lines": "73-90",
    "snippet": "static void\nudevEventDataDispose(void *obj)\n{\n    struct udev *udev = NULL;\n    udevEventDataPtr priv = obj;\n\n    if (priv->watch != -1)\n        virEventRemoveHandle(priv->watch);\n\n    if (!priv->udev_monitor)\n        return;\n\n    udev = udev_monitor_get_udev(priv->udev_monitor);\n    udev_monitor_unref(priv->udev_monitor);\n    udev_unref(udev);\n\n    virCondDestroy(&priv->threadCond);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virmdev.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_udev.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_event.h\"",
      "#include \"node_device_conf.h\"",
      "#include <scsi/scsi.h>",
      "#include <pciaccess.h>",
      "#include <libudev.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCondDestroy",
          "args": [
            "&priv->threadCond"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "virCondDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "135-143",
          "snippet": "int virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udev_unref",
          "args": [
            "udev"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_monitor_unref",
          "args": [
            "priv->udev_monitor"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udev_monitor_get_udev",
          "args": [
            "priv->udev_monitor"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventRemoveHandle",
          "args": [
            "priv->watch"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "virEventRemoveHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "116-123",
          "snippet": "int\nvirEventRemoveHandle(int watch)\n{\n    if (!removeHandleImpl)\n        return -1;\n\n    return removeHandleImpl(watch);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventRemoveHandleFunc removeHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventRemoveHandleFunc removeHandleImpl;\n\nint\nvirEventRemoveHandle(int watch)\n{\n    if (!removeHandleImpl)\n        return -1;\n\n    return removeHandleImpl(watch);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virmdev.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_udev.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include <scsi/scsi.h>\n#include <pciaccess.h>\n#include <libudev.h>\n#include <config.h>\n\nstatic void\nudevEventDataDispose(void *obj)\n{\n    struct udev *udev = NULL;\n    udevEventDataPtr priv = obj;\n\n    if (priv->watch != -1)\n        virEventRemoveHandle(priv->watch);\n\n    if (!priv->udev_monitor)\n        return;\n\n    udev = udev_monitor_get_udev(priv->udev_monitor);\n    udev_monitor_unref(priv->udev_monitor);\n    udev_unref(udev);\n\n    virCondDestroy(&priv->threadCond);\n}"
  }
]